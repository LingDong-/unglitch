var DISK={"examples/blink.t412.asm":";***************************************************\n;*\n;* blink.t412.asm\n;*\n;* blink LED on any pin of PORTA\n;*\n;* (c) lingdong huang 2023, MIT License\n;*\n;***************************************************\n\n\n.include \"./inc/tn412def.inc\"\n\n\tser\tr27\n\tser\tr16\n\tsts\tPORTA_DIRSET,r16\nloop:\n\tsts\tPORTA_OUT,r16\n\tcom\tr16\n\trcall\tdelay\n\trcall\tdelay\n\trjmp\tloop\ndelay:\n\tnop\n\tnop\n\tnop\n\tnop\n\tsbiw\tr26, 1\n\tbrne\tdelay\n\tret\n","examples/echo.t412.asm":";***************************************************\n;*\n;* echo.t412.asm\n;*\n;* echo via serial, buffer by line (0xA)\n;*\n;*..................................................\n;* \n;*       .--    +---+        +---------+        \n;* +-----|      |RTS|  +-VCC-|o        |-GND--+\n;* | []  |      | RX|--|--TX-| ATtiny- |-     |\n;* |~--~-|  ... | TX|--|--RX-| 202/402 |-UPDI |\n;* | []  |      |VCC|--+    -| 212/412 |-     |\n;* +-----|      |CTS|        +---------+      |\n;*       '--    |GND|-------------------------+\n;*  USB -> UART +---+ \n;*..................................................\n;*\n;* (c) lingdong huang 2023, MIT License\n;*\n;***************************************************\n\n.include \"./inc/tn412def.inc\"\n\n.equ BAUD      = 1389 ;20M/6*4/9600\n.equ TX_bm     = (1<<6)\n.equ RX_bm     = (1<<7)\n.equ UART_DIRSET = PORTA_DIRSET\n.equ UART_DIRCLR = PORTA_DIRCLR\n.equ UART_OUTSET = PORTA_OUTSET\n\n.dseg\nbuf: .byte 128\n.cseg\n\n\tldi\tr16, LOW(ramend)\n\tout\tCPU_SPL, r16\n\tldi\tr16, HIGH(ramend)\n\tout\tCPU_SPH, r16\n\n\tldi\tr16, TX_bm \n\tsts\tUART_DIRSET,r16\n\tsts\tUART_OUTSET,r16\n\n\tldi\tr16, RX_bm \n\tsts\tUART_DIRCLR,r16\n\n\tldi\tr16, LOW(BAUD)\n\tsts\tUSART0_BAUDL, r16\n\tldi\tr16, HIGH(BAUD)\n\tsts\tUSART0_BAUDH, r16\n\n\tldi\tr16, (USART_RXEN_bm | USART_TXEN_bm)\n\tsts\tUSART0_CTRLB, r16\n\n\tser\tr26\n\tser\tr27\n\trcall\tdelay\n\trcall\tdelay\n\n\tldi\tr19, 'r'\n\trcall\tuart_sendchar\n\tldi\tr19, 'e'\n\trcall\tuart_sendchar\n\tldi\tr19, 'a'\n\trcall\tuart_sendchar\n\tldi\tr19, 'd'\n\trcall\tuart_sendchar\n\tldi\tr19, 'y'\n\trcall\tuart_sendchar\n\tldi\tr19, 0x0a\n\trcall\tuart_sendchar\n\n\tldi\tXL, LOW(buf)\n\tldi\tXH, HIGH(buf)\n\n\tldi\tr21, 0\n\nloop:  \n\trcall\tuart_readchar\n\n\tst\tX+, r19\n\tinc\tr21\n\n\tcpi\tr19, 0x0a\n\tbrne\tloop\n\n\n\tldi\tr19, 'e'\n\trcall\tuart_sendchar\n\tldi\tr19, 'c'\n\trcall\tuart_sendchar\n\tldi\tr19, 'h'\n\trcall\tuart_sendchar\n\tldi\tr19, 'o'\n\trcall\tuart_sendchar\n\tldi\tr19, ':'\n\trcall\tuart_sendchar\n\n\tldi\tXL, LOW(buf)\n\tldi\tXH, HIGH(buf)\n\n\tldi\tr22, 0\n\nloopp:\n\n\tld\tr19, X+\n\trcall\tuart_sendchar\n\n\tinc\tr22\n\tcp\tr22, r21\n\tbrlo\tloopp\n\n\tldi\tXL, LOW(buf)\n\tldi\tXH, HIGH(buf)\n\tldi\tr21, 0\n\n\trjmp\tloop\n\nuart_sendchar:\n\tlds\tr16, USART0_STATUS\n\tsbrs\tr16, USART_DREIF_bp\n\trjmp\tuart_sendchar\n\tsts\tUSART0_TXDATAL, r19\n\tret\n\nuart_readchar:\n\tlds\tr16, USART0_STATUS\n\tsbrs\tr16, USART_RXCIF_bp\n\trjmp\tuart_readchar\n\tlds\tr19, USART0_RXDATAL\n\tret\n  \ndelay:\n\tnop\n\tnop\n\tnop\n\tnop\n\tsbiw\tr26, 1\n\tbrne\tdelay\n\tret\n","examples/l0print.oled.t412.asm":";***************************************************\n;*\n;* l0print.oled.t412.asm\n;*\n;* recreation of the '10 PRINT' maze generator\n;*\n;*..................................................\n;* \n;*     +---------+          +------------+  \n;* VCC-|o        |-GND  +---|SDA OLED    |\n;*    -| ATtiny- |-     | +-|SCL SSD1306 | \n;*    -| 202/402 |-UPDI | | |VCC 128X64  |\n;*   +-| 212/412 |--------+ |GND         |\n;*   | +---------+      |   +------------+\n;*   +------------------+                     \n;* \n;*..................................................\n;*\n;* (c) lingdong huang 2023, MIT License\n;*\n;***************************************************\n\n.include \"./inc/tn412def.inc\"\n\n.equ SDA_bm     = (1<<1)\n.equ SCL_bm     = (1<<2)\n.equ I2C_ADDR   = 0x78\n.equ I2C_DIRSET = PORTA_DIRSET\n\n\tldi\tr30, 0x30\n\n\tldi\tr16, 0\n\tsts\tCLKCTRL_MCLKCTRLB, r16\n\n\tldi\tr16, LOW(ramend)\n\tout\tCPU_SPL, r16\n\tldi\tr16, HIGH(ramend)\n\tout\tCPU_SPH, r16\n\n\tldi\tr16, SCL_bm \n\tsts\tI2C_DIRSET,r16\n\n\tldi\tr16, SDA_bm \n\tsts\tI2C_DIRSET,r16\n\n\tclr\tr26\n\tldi\tr27, 128\nwait0:\n\tnop\n\tsbiw\tr26, 1\n\tbrne\twait0\n\n\tldi\tr16, 17     \n\tsts\tTWI0_MBAUD,r16\n\n\tldi\tr16, TWI_ENABLE_bm\n\tsts\tTWI0_MCTRLA,r16\n\n\tldi\tr16, TWI_BUSSTATE_IDLE_gc\n\tsts\tTWI0_MSTATUS,r16\n\n\tldi\tr17, 0xae\n\trcall\toled_cmd1\n\n\tldi\tr17, 0xa8\n\tldi\tr18, 0x3f\n\trcall\toled_cmd2\n\n\tldi\tr17, 0xd3\n\tldi\tr18, 0x00\n\trcall\toled_cmd2\n\n\tldi\tr17, 0x40\n\trcall\toled_cmd1\n\n\tldi\tr17, 0xa0\n\trcall\toled_cmd1\n\n\tldi\tr17, 0xc8\n\trcall\toled_cmd1\n\n\tldi\tr17, 0xda\n\tldi\tr18, 0x12\n\trcall\toled_cmd2\n\n\tldi\tr17, 0x81\n\tldi\tr18, 0xff\n\trcall\toled_cmd2\n\n\tldi\tr17, 0xa4\n\trcall\toled_cmd1\n\n\tldi\tr17, 0xa6\n\trcall\toled_cmd1\n\n\tldi\tr17, 0xd5\n\tldi\tr18, 0x80\n\trcall\toled_cmd2\n\n\tldi\tr17, 0x8d\n\tldi\tr18, 0x14\n\trcall\toled_cmd2\n\n\tldi\tr17, 0x20\n\tldi\tr18, 0x02\n\trcall\toled_cmd2\n\n\tldi\tr17, 0xaf\n\trcall\toled_cmd1\n\n  \nloop: \n\trcall\tl0print\n\n\trjmp\tloop\n\n\ni2c_write:\n\tldi\tr16, TWI_MCMD_RECVTRANS_gc\n\tsts\tTWI0_MCTRLB, r16\n\n\tsts\tTWI0_MDATA, r19\n\nwait2:\n\tlds\tr16, TWI0_MSTATUS\n\tsbrs\tr16, TWI_WIF_bp\n\trjmp\twait2\n\n\tret\n\ni2c_start:\n\tldi\tr16, I2C_ADDR\n\tsts\tTWI0_MADDR, r16\n\nwait1:\n\tlds\tr16, TWI0_MSTATUS\n\tandi\tr16, (TWI_WIF_bm|TWI_RIF_bm)\n\tbreq\twait1\n\n\tret\n\ni2c_stop:\n\tlds\tr16, TWI0_MCTRLB\n\tori\tr16, TWI_MCMD_STOP_gc\n\nwait3:\n\tlds\tr16, TWI0_MSTATUS\n\tsbrs\tr16, TWI_BUSSTATE_IDLE_gc\n\trjmp\twait3\n\n\tret\n\noled_cmd1:\n\trcall\ti2c_start\n\n\tldi\tr19, 0\n\trcall\ti2c_write\n\n\tmov\tr19, r17\n\trcall\ti2c_write\n\n\trcall\ti2c_stop\n\n\tret\n\noled_cmd2:\n\trcall\ti2c_start\n\n\tldi\tr19, 0\n\trcall\ti2c_write\n\n\tmov\tr19, r17\n\trcall\ti2c_write\n\n\tmov\tr19, r18\n\trcall\ti2c_write\n\n\trcall\ti2c_stop\n  \n\tret\n\noled_goto:\n\tmov\tr17, r19\n\tmov\tr18, r19\n\n\tandi\tr17, 0xf\n\tswap\tr18\n\tandi\tr18, 0xf\n\tori\tr18, 0x10\n\n\trcall\toled_cmd2\n\n\tmov\tr17, r20\n\tori\tr17, 0xb0\n\n\trcall\toled_cmd1\n\n\tret\n\nshr3:\n\tldi\tr17, 0\n\tldi\tr31, 0\n\n\tmov\tr16, r30\n\n\tlsl\tr16\n\trol\tr17\n\tlsl\tr16\n\trol\tr17\n\tlsl\tr16\n\trol\tr17\n\n\teor\tr30, r16\n\teor\tr31, r17\n\n\tmovw\tr16, r30\n\n\tlsr\tr17\n\tror\tr16\n\tlsr\tr17\n\tror\tr16\n\n\teor\tr30, r16\n\teor\tr31, r17\n\n\tmovw\tr16, r30\n\n\tlsl\tr16\n\teor\tr30, r16\n\tmov\tr16, r30\n\tret\n\n\nl0print:\n\tldi\tr21, 7\n\nloopy:\n\tldi\tr19, 0\n\tmov\tr20, r21\n\trcall\toled_goto\n\n\trcall\ti2c_start\n\tldi\tr19, 0x40\n\trcall\ti2c_write\n\n\tldi\tr22, 15\nloopx:\n\trcall\tshr3\n\tmov\tr16, r30\n\tandi\tr16, 2\n\n\tbreq\telse1\n\tldi\tr19, 1\n\trcall\ti2c_write\n\tldi\tr19, 2\n\trcall\ti2c_write\n\tldi\tr19, 4\n\trcall\ti2c_write\n\tldi\tr19, 8\n\trcall\ti2c_write\n\tldi\tr19, 16\n\trcall\ti2c_write\n\tldi\tr19, 32\n\trcall\ti2c_write\n\tldi\tr19, 64\n\trcall\ti2c_write\n\tldi\tr19, 128\n\trcall\ti2c_write\n\trjmp\tendif1\nelse1:\n\tldi\tr19, 128\n\trcall\ti2c_write\n\tldi\tr19, 64\n\trcall\ti2c_write\n\tldi\tr19, 32\n\trcall\ti2c_write\n\tldi\tr19, 16\n\trcall\ti2c_write\n\tldi\tr19, 8\n\trcall\ti2c_write\n\tldi\tr19, 4\n\trcall\ti2c_write\n\tldi\tr19, 2\n\trcall\ti2c_write\n\tldi\tr19, 1\n\trcall\ti2c_write\nendif1:\n\n\tdec\tr22\n\tsbrs\tr22, 7\n\trjmp\tloopx\n\n\trcall\ti2c_stop\n\n\tdec\tr21\n\tsbrs\tr21, 7\n\trjmp\tloopy\n\tret\n  ","examples/mbrot.oled.t412.asm":";***************************************************\n;*\n;* mbrot.oled.t412.asm\n;*\n;* mandelbrot set with dithering\n;*\n;*..................................................\n;* \n;*     +---------+          +------------+  \n;* VCC-|o        |-GND  +---|SDA OLED    |\n;*    -| ATtiny- |-     | +-|SCL SSD1306 | \n;*    -| 202/402 |-UPDI | | |VCC 128X64  |\n;*   +-| 212/412 |--------+ |GND         |\n;*   | +---------+      |   +------------+\n;*   +------------------+                     \n;* \n;*..................................................\n;*\n;* (c) lingdong huang 2023, MIT License\n;*\n;***************************************************\n\n.include \"./inc/tn412def.inc\"\n\n.equ SDA_bm     = (1<<1)\n.equ SCL_bm     = (1<<2)\n.equ I2C_ADDR   = 0x78\n.equ I2C_DIRSET = PORTA_DIRSET\n\n\tldi\tr16, 0\n\tsts\tCLKCTRL_MCLKCTRLB, r16\n\n\tldi\tr16, LOW(ramend)\n\tout\tCPU_SPL, r16\n\tldi\tr16, HIGH(ramend)\n\tout\tCPU_SPH, r16\n\n\tldi\tr16, SCL_bm \n\tsts\tI2C_DIRSET,r16\n\n\tldi\tr16, SDA_bm \n\tsts\tI2C_DIRSET,r16\n\n\tclr\tr26\n\tldi\tr27, 128\nwait0:\n\tnop\n\tsbiw\tr26, 1\n\tbrne\twait0\n\n\tldi\tr16, 17     \n\tsts\tTWI0_MBAUD,r16\n\n\tldi\tr16, TWI_ENABLE_bm\n\tsts\tTWI0_MCTRLA,r16\n\n\tldi\tr16, TWI_BUSSTATE_IDLE_gc\n\tsts\tTWI0_MSTATUS,r16\n\n\tldi\tr17, 0xae\n\trcall\toled_cmd1\n\n\tldi\tr17, 0xa8\n\tldi\tr18, 0x3f\n\trcall\toled_cmd2\n\n\tldi\tr17, 0xd3\n\tldi\tr18, 0x00\n\trcall\toled_cmd2\n\n\tldi\tr17, 0x40\n\trcall\toled_cmd1\n\n\tldi\tr17, 0xa0\n\trcall\toled_cmd1\n\n\tldi\tr17, 0xc8\n\trcall\toled_cmd1\n\n\tldi\tr17, 0xda\n\tldi\tr18, 0x12\n\trcall\toled_cmd2\n\n\tldi\tr17, 0x81\n\tldi\tr18, 0xff\n\trcall\toled_cmd2\n\n\tldi\tr17, 0xa4\n\trcall\toled_cmd1\n\n\tldi\tr17, 0xa6\n\trcall\toled_cmd1\n\n\tldi\tr17, 0xd5\n\tldi\tr18, 0x80\n\trcall\toled_cmd2\n\n\tldi\tr17, 0x8d\n\tldi\tr18, 0x14\n\trcall\toled_cmd2\n\n\tldi\tr17, 0x20\n\tldi\tr18, 0x02\n\trcall\toled_cmd2\n\n\tldi\tr17, 0xaf\n\trcall\toled_cmd1\n\n\trcall\tmbrot\nloop: rjmp loop\n\n\ni2c_write:\n\tldi\tr16, TWI_MCMD_RECVTRANS_gc\n\tsts\tTWI0_MCTRLB, r16\n\n\tsts\tTWI0_MDATA, r19\n\nwait2:\n\tlds\tr16, TWI0_MSTATUS\n\tsbrs\tr16, TWI_WIF_bp\n\trjmp\twait2\n\n\tret\n\ni2c_start:\n\tldi\tr16, I2C_ADDR\n\tsts\tTWI0_MADDR, r16\n\nwait1:\n\tlds\tr16, TWI0_MSTATUS\n\tandi\tr16, (TWI_WIF_bm|TWI_RIF_bm)\n\tbreq\twait1\n\n\tret\n\ni2c_stop:\n\tlds\tr16, TWI0_MCTRLB\n\tori\tr16, TWI_MCMD_STOP_gc\n\nwait3:\n\tlds\tr16, TWI0_MSTATUS\n\tsbrs\tr16, TWI_BUSSTATE_IDLE_gc\n\trjmp\twait3\n\n\tret\n\noled_cmd1:\n\trcall\ti2c_start\n\n\tldi\tr19, 0\n\trcall\ti2c_write\n\n\tmov\tr19, r17\n\trcall\ti2c_write\n\n\trcall\ti2c_stop\n\n\tret\n\noled_cmd2:\n\trcall\ti2c_start\n\n\tldi\tr19, 0\n\trcall\ti2c_write\n\n\tmov\tr19, r17\n\trcall\ti2c_write\n\n\tmov\tr19, r18\n\trcall\ti2c_write\n\n\trcall\ti2c_stop\n  \n\tret\n\noled_goto:\n\tmov\tr17, r19\n\tmov\tr18, r19\n\n\tandi\tr17, 0xf\n\tswap\tr18\n\tandi\tr18, 0xf\n\tori\tr18, 0x10\n\n\trcall\toled_cmd2\n\n\tmov\tr17, r20\n\tori\tr17, 0xb0\n\n\trcall\toled_cmd1\n\n\tret\n\n\nmuls16:\n\tmuls\tr23, r21\n\tmul\tr22, r20\n\tmovw\tr16, r0\n\tmulsu\tr23, r20\n\tadd\tr17, r0\n\tmulsu\tr21, r22\n\tadd\tr17, r0\n\tret\n\nmbrot:\n\tldi\tr16, 7\n\tmov\tr3, r16\n\tclr\tr2\n\nloopy:\n\tclr\tr6\n\n\tclr\tr19\n\tmov\tr20, r3\n\trcall\toled_goto\n\trcall\ti2c_start\n\tldi\tr19, 0x40\n\trcall\ti2c_write\n\n\tmov\tr4, r3\n\tlsl\tr4\n\tlsl\tr4\n\tlsl\tr4\n\nloopx:\n\n\tldi\tr24, 7\n\tclr\tr5\n\nloopc:\n        \n\tmov\tr7, r4\n\tadd\tr7, r24\n\n\tclr\tr26\n\tclr\tr27\n\tclr\tr28\n\tclr\tr29\n\tldi\tr25, 16\n\nloopz:\n\tmovw\tr20, r26\n\tmovw\tr22, r26\n\trcall\tmuls16\n\tmovw\tr18, r16\n\n\tmovw\tr20, r28\n\tmovw\tr22, r28\n\trcall\tmuls16\n\n\tmovw\tr20, r16\n\tadd\tr20, r18\n\tadc\tr21, r19\n\tcpi\tr21, 17\n\tbrge\tendloopz\n\n\tmovw\tr20, r18\n\tsub\tr20, r16\n\tsbc\tr21, r17\n\n\tasr\tr21\n\tror\tr20\n\tasr\tr21\n\tror\tr20\n\tasr\tr21\n\tror\tr20\n\tasr\tr21\n\tror\tr20\n\tasr\tr21\n\tror\tr20\n\n\tsubi\tr20, 80\n\tsbci\tr21, 0\n\tadd\tr20, r6\n\tadc\tr21, r2\n\tmovw\tr14, r20\n\n\tmovw\tr20, r26\n\tmovw\tr22, r28\n\trcall\tmuls16\n\n\tmovw\tr20, r16\n\tasr\tr21\n\tror\tr20\n\tasr\tr21\n\tror\tr20\n\tasr\tr21\n\tror\tr20\n\tasr\tr21\n\tror\tr20\n          \n\tsubi\tr20, 32\n\tsbci\tr21, 0\n\tadd\tr20, r7\n\tadc\tr21, r2\n\n\tmovw\tr26, r14\n\tmovw\tr28, r20\n\n\tdec\tr25\n\tbrne\tloopz\nendloopz:\n\n\t; andi r25, 1\n\n\n\tmov\tr16, r7\n\tandi\tr16, 3\n\tlsl\tr16\n\tlsl\tr16\n\tmov\tr17, r6\n\tandi\tr17, 3\n\tadd\tr16, r17\n\n\tldi\tZL, LOW (dithord*2)\n\tldi\tZH, HIGH(dithord*2)\n\tadd\tZL, r16\n\tadc\tZH, r2\n\tlpm\n\n\tldi\tr16, 1\n\tsub\tr25, r0\n\tsbrs\tr25, 7\n\tclr\tr16\n\n\tlsl\tr5\n\tor\tr5, r16\n\n\tdec\tr24\n\tsbrs\tr24, 7\n\trjmp\tloopc\n      \n\tmov\tr19, r5\n\trcall\ti2c_write\n      \n\tinc\tr6\n\tsbrs\tr6, 7\n\trjmp\tloopx\n \n\trcall\ti2c_stop\n\n\tdec\tr3\n\tsbrs\tr3, 7\n\trjmp\tloopy\n\n\tret\n  \n\n\ndithord: .db 0,8,2,10,12,4,14,6,3,11,1,9,15,7,13,5\n","examples/tetris.t202.asm":";***************************************************\n;*\n;* tetris.v2.t202.asm\n;*\n;* tetris game in AVR assembly\n;*\n;*..................................................\n;* \n;*  VCC-[10KO]-+     +---------+      +-[10KO]-VCC\n;*             | VCC-|o        |-GND  |\n;*  GND--_/ _--+-----| ATtiny- |------+--_/ _--GND\n;*  GND--_/ _---+----| 202/402 |-UPDI\n;*              |  +-| 212/412 |-+\n;*  VCC-[10KO]--+  | +---------+ |\n;*                 |        +----+\n;*                 +--------|---+  \n;*                          |   |\n;*                +---------------+\n;*                |GND VCC SCL SDA|\n;*                |               |\n;*                | OLED(SSD1306) |\n;*                |   128 X 64    |\n;*                +---------------+\n;* \n;*..................................................\n;*\n;* (c) lingdong huang 2023, MIT License\n;*\n;***************************************************\n\n.include \"./inc/tn202def.inc\"\n\n.equ I2C_ADDR   = 0x78\n.equ I2C_bm     = ((1<<1)|(1<<2))\n.equ I2C_DIRSET = PORTA_DIRSET\n.equ KEY_L_bp   = 7\n.equ KEY_U_bp   = 6\n.equ KEY_R_bp   = 3\n.equ KEY_bm     = ((1<<KEY_L_bp)|(1<<KEY_R_bp)|(1<<KEY_U_bp))\n.equ KEY_DIRCLR = PORTA_DIRCLR\n.equ KEY_IN     = PORTA_IN\n\n.eseg\nhisc: .db 0\n\n.dseg\nbrd: .byte 16\n\n.cseg\n\n\tlds\tr16, PORTA_OUT\n\n\tclr\tr16\n\tsts\tCLKCTRL_MCLKCTRLB, r16\n\tmov\tr2, r16\n  \n\tlds\tr16, (EEPROM_START+hisc)\n\tcpi\tr16, 0xFF\n\tbrne\tno_erase_hisc\n\tclr\tr16\n\trcall\teewrite_hisc\nno_erase_hisc:\n\n\tldi\tr16, 0x42\n\tmov\tr3, r16\n\n\tclr\tr10\n\tclr\tr11\n\n\tldi\tr16, LOW(ramend)\n\tout\tCPU_SPL, r16\n\tldi\tr16, HIGH(ramend)\n\tout\tCPU_SPH, r16\n\n\tldi\tr16, I2C_bm \n\tsts\tI2C_DIRSET,r16\n\n\tldi\tr16, KEY_bm\n\tsts\tKEY_DIRCLR, r16\n\n\tclr\tr26\n\tldi\tr27, 0xFF\n\trcall\tdelay\n\n\n\tldi\tr16, 17     \n\tsts\tTWI0_MBAUD,r16\n\n\tldi\tr16, TWI_ENABLE_bm\n\tsts\tTWI0_MCTRLA,r16\n\n\tldi\tr16, TWI_BUSSTATE_IDLE_gc\n\tsts\tTWI0_MSTATUS,r16\n\n\tldi\tr17, 0xae\n\trcall\toled_cmd1\n\n\tldi\tr17, 0xa8\n\tldi\tr18, 0x3f\n\trcall\toled_cmd2\n\n\tldi\tr17, 0xd3\n\tldi\tr18, 0x00\n\trcall\toled_cmd2\n\n\tldi\tr17, 0x40\n\trcall\toled_cmd1\n\n\tldi\tr17, 0xa0\n\trcall\toled_cmd1\n\n\tldi\tr17, 0xc8\n\trcall\toled_cmd1\n\n\tldi\tr17, 0xda\n\tldi\tr18, 0x12\n\trcall\toled_cmd2\n\n\tldi\tr17, 0x81\n\tldi\tr18, 0xff\n\trcall\toled_cmd2\n\n\tldi\tr17, 0xa4\n\trcall\toled_cmd1\n\n\tldi\tr17, 0xa6\n\trcall\toled_cmd1\n\n\tldi\tr17, 0xd5\n\tldi\tr18, 0x80\n\trcall\toled_cmd2\n\n\tldi\tr17, 0x8d\n\tldi\tr18, 0x14\n\trcall\toled_cmd2\n\n\tldi\tr17, 0x20\n\tldi\tr18, 0x02\n\trcall\toled_cmd2\n\n\tldi\tr17, 0xaf\n\trcall\toled_cmd1\n\n\n\trcall\toled_clr\n\n\tldi\tr19, 52\n\tldi\tr20, 4\n\trcall\toled_goto\n\n\trcall\ti2c_start\n\tldi\tr19, 0x40\n\trcall\ti2c_write\n\tldi\tr16, 'T'\n\trcall\toled_printchar\n\tldi\tr16, 'E'\n\trcall\toled_printchar\n\tldi\tr16, 'T'\n\trcall\toled_printchar\n\tldi\tr16, 'R'\n\trcall\toled_printchar\n\tldi\tr16, 'I'\n\trcall\toled_printchar\n\tldi\tr16, 'S'\n\trcall\toled_printchar\n\trcall\ti2c_stop\n\n\tldi\tr28, 16\n\trcall\tlong_delay\n\n\n\nrestart:\n\n\trcall\toled_clr\n\n\tclr\tr12\n\n\tclr\tr16\n\tldi\tXL, LOW(brd)\n\tldi\tXH, HIGH(brd)\nbrd_clr:\n\tst\tX, r2\n\tinc\tr16\n\tadiw\tX, 1\n\tsbrs\tr16, 5\n\trjmp\tbrd_clr\n\n\trcall\tnext_piece\n\nloop: \n\trcall\ttetris_update\n\trjmp\tloop\n\n\nnext_piece:\n\tclr\tr4\n\tldi\tr16, 2\n\tmov\tr5, r16\n\n\trcall\treroll\n\tlsl\tr16\n\t; clr r16\n\tldi\tZL, LOW (pcs<<1)\n\tldi\tZH, HIGH(pcs<<1)\n\tadd\tZL, r16\n\tadc\tZH, r2\n\n\tlpm\tr6, Z+\n\tlpm\tr7, Z\n\n\tmov\tr21, r6\n\tmov\tr22, r7\n\trcall\trot_piece\n\tmov\tr6, r21\n\tmov\tr7, r22\n\n\tmov\tr19, r4\n\tmov\tr20, r5\n\n\trcall\tcheck_collide\n\n\tsbrs\tr16, 0\n\tret\n\n\tlds\tr16, (EEPROM_START+hisc)\n\n\tcp\tr12, r16\n\n\tbrlo\tnohi\n\n\tmov\tr16, r12\n\trcall\teewrite_hisc\n\nnohi:\n\n\trcall\toled_clr\n\n\tldi\tr19, 46\n\tldi\tr20, 5\n\trcall\toled_goto\n\n\trcall\ti2c_start\n\tldi\tr19, 0x40\n\trcall\ti2c_write\n\tldi\tr16, 'G'\n\trcall\toled_printchar\n\tldi\tr16, 'A'\n\trcall\toled_printchar\n\tldi\tr16, 'M'\n\trcall\toled_printchar\n\tldi\tr16, 'E'\n\trcall\toled_printchar\n\tclr\tr19\n\trcall\ti2c_write\n\trcall\ti2c_write\n\trcall\ti2c_write\n\trcall\ti2c_write\n\tldi\tr16, 'O'\n\trcall\toled_printchar\n\tldi\tr16, 'V'\n\trcall\toled_printchar\n\tldi\tr16, 'E'\n\trcall\toled_printchar\n\tldi\tr16, 'R'\n\trcall\toled_printchar\n\trcall\ti2c_stop\n\n\tldi\tr19, 44\n\tldi\tr20, 3\n\trcall\toled_goto\n\trcall\ti2c_start\n\tldi\tr19, 0x40\n\trcall\ti2c_write\n\tldi\tr16, 'S'\n\trcall\toled_printchar\n\tldi\tr16, 'C'\n\trcall\toled_printchar\n\tldi\tr16, 'O'\n\trcall\toled_printchar\n\tldi\tr16, 'R'\n\trcall\toled_printchar\n\tldi\tr16, 'E'\n\trcall\toled_printchar\n\tldi\tr16, ':'\n\trcall\toled_printchar\n\tclr\tr19\n\trcall\ti2c_write\n\trcall\ti2c_write\n\trcall\ti2c_write\n\trcall\ti2c_write\n\n\tmov\tr16, r12\n\trcall\tbyte_to_dec\n\n\tpush\tr16\n\tmov\tr16, r18\n\tsubi\tr16, -48\n\trcall\toled_printchar\n\tmov\tr16, r17\n\tsubi\tr16, -48\n\trcall\toled_printchar\n\tpop\tr16\n\tsubi\tr16, -48\n\trcall\toled_printchar\n\n\trcall\ti2c_stop\n\n\n\tldi\tr19, 44\n\tldi\tr20, 2\n\trcall\toled_goto\n\trcall\ti2c_start\n\tldi\tr19, 0x40\n\trcall\ti2c_write\n\tldi\tr16, 'H'\n\trcall\toled_printchar\n\tldi\tr16, 'I'\n\trcall\toled_printchar\n\tldi\tr16, 'G'\n\trcall\toled_printchar\n\tldi\tr16, 'H'\n\trcall\toled_printchar\n\tclr\tr19\n\trcall\ti2c_write\n\trcall\ti2c_write\n\trcall\ti2c_write\n\trcall\ti2c_write\n\tldi\tr16, ':'\n\trcall\toled_printchar\n\tclr\tr19\n\trcall\ti2c_write\n\trcall\ti2c_write\n\trcall\ti2c_write\n\trcall\ti2c_write\n\n\tlds\tr16, (EEPROM_START+hisc)\n  \n\trcall\tbyte_to_dec\n\tpush\tr16\n\tmov\tr16, r18\n\tsubi\tr16, -48\n\trcall\toled_printchar\n\tmov\tr16, r17\n\tsubi\tr16, -48\n\trcall\toled_printchar\n\tpop\tr16\n\tsubi\tr16, -48\n\trcall\toled_printchar\n\n\trcall\ti2c_stop\n\n\n\n\tldi\tr28, 32\n\trcall\tlong_delay\n\n\trjmp\trestart\n\nlong_delay:\n\tldi\tr26, 0xFF\n\tldi\tr27, 0xFF\n\trcall\tdelay\n\tdec\tr28\n\tbrne\tlong_delay\n\tret\n\ndelay:\n\tnop\n\tsbiw\tr26, 1\n\tbrne\tdelay\n\tret\n\ndelay_poll0:\n\tclr\tr26\n\tldi\tr27, 0x2A\n\trcall\tdelay\n\n\tmov\tr10, r11\n\n\tlds\tr16, KEY_IN\n\tcom\tr16\n\tmov\tr11, r16\n\n\teor\tr10, r11\n\tand\tr10, r11\n\n\tclr\tr26\n\tldi\tr27, 0x2A\n\trcall\tdelay\n\n\tret\n\n\ndelay_poll:\n\tclr\tr17\n\tclr\tr18\n\trcall\tdelay_poll0\n\tor\tr17, r10\n\tor\tr18, r11\n\t; sbrc r11, KEY_D_bp\n\t; ret\n\n\tldi\tr19, 6\ndp_ll:\n\n\trcall\tdelay_poll0\n\tor\tr17, r10\n\tor\tr18, r11\n\n\tdec\tr19\n\tbrne\tdp_ll\n\n\tmov\tr10, r17\n\tmov\tr11, r18\n\tret\n\nreroll:\n\trcall\tshr3\n\tmov\tr16, r3\n\tandi\tr16, 7\n\tcpi\tr16, 7\n\tbreq\treroll\n\tret\n\ni2c_write:\n\tldi\tr16, TWI_MCMD_RECVTRANS_gc\n\tsts\tTWI0_MCTRLB, r16\n\n\tsts\tTWI0_MDATA, r19\n\nwait2:\n\tlds\tr16, TWI0_MSTATUS\n\tsbrs\tr16, TWI_WIF_bp\n\trjmp\twait2\n\n\tret\n\ni2c_start:\n\tldi\tr16, I2C_ADDR\n\tsts\tTWI0_MADDR, r16\n\nwait1:\n\tlds\tr16, TWI0_MSTATUS\n\tandi\tr16, (TWI_WIF_bm|TWI_RIF_bm)\n\tbreq\twait1\n\n\tret\n\ni2c_stop:\n\tlds\tr16, TWI0_MCTRLB\n\tori\tr16, TWI_MCMD_STOP_gc\n\nwait3:\n\tlds\tr16, TWI0_MSTATUS\n\tsbrs\tr16, TWI_BUSSTATE_IDLE_gc\n\trjmp\twait3\n\n\tret\n\noled_cmd1:\n\trcall\ti2c_start\n\n\tclr\tr19\n\trcall\ti2c_write\n\n\tmov\tr19, r17\n\trcall\ti2c_write\n\n\trcall\ti2c_stop\n\n\tret\n\noled_cmd2:\n\trcall\ti2c_start\n\n\tclr\tr19\n\trcall\ti2c_write\n\n\tmov\tr19, r17\n\trcall\ti2c_write\n\n\tmov\tr19, r18\n\trcall\ti2c_write\n\n\trcall\ti2c_stop\n  \n\tret\n\noled_goto:\n\tmov\tr17, r19\n\tmov\tr18, r19\n\n\tandi\tr17, 0xf\n\tswap\tr18\n\tandi\tr18, 0xf\n\tori\tr18, 0x10\n\n\trcall\toled_cmd2\n\n\tmov\tr17, r20\n\tori\tr17, 0xb0\n\n\trcall\toled_cmd1\n\n\tret\n\noled_printchar:\n\tsubi\tr16, 33\n\tldi\tr19, 3\n\tmul\tr16, r19\n\tldi\tZL, LOW (font<<1)\n\tldi\tZH, HIGH(font<<1)\n\tadd\tZL, r0\n\tadc\tZH, r1\n\tlpm\tr19, Z+\n\trcall\ti2c_write\n\tlpm\tr19, Z+\n\trcall\ti2c_write\n\tlpm\tr19, Z\n\trcall\ti2c_write\n\tclr\tr19\n\trcall\ti2c_write\n\tret\n\n\ndiv10_8:\n\tmov\tr18, r16\n\tmov\tr17, r18\n\tlsr\tr18\n\tclr\tr0\n\tadd\tr18, r17\n\tadc\tr0, r0\n\tlsr\tr0\n\tror\tr18\n\tmov\tr17, r18\n\tswap\tr18\n\tandi\tr18, 0xF\n\tadd\tr18, r17\n\tlsr\tr18\n\tlsr\tr18\n\tlsr\tr18\n\tmov\tr17, r18\n\tlsl\tr17\n\tlsl\tr17\n\tadd\tr17, r18\n\tlsl\tr17\n\tsub\tr17, r16\n\tneg\tr17\n\tcpi\tr17, 10\n\tbrlo\td108_noof\n\tsubi\tr17, 10\n\tinc\tr18\nd108_noof:\n\tret\n\nbyte_to_dec:\n\trcall\tdiv10_8\n\tpush\tr17\n\tmov\tr16, r18\n\trcall\tdiv10_8\n\tpop\tr16\n\tret\n\n\n\noled_clr:\n\tldi\tr21, 7\n\nloopy:\n\tclr\tr19\n\tmov\tr20, r21\n\trcall\toled_goto\n\n\trcall\ti2c_start\n\tldi\tr19, 0x40\n\trcall\ti2c_write\n\n\tclr\tr22\nloopx:\n\tclr\tr19\n\trcall\ti2c_write\n\n\tinc\tr22\n\tsbrs\tr22, 7\n\trjmp\tloopx\n\n\trcall\ti2c_stop\n\n\tdec\tr21\n\tsbrs\tr21, 7\n\trjmp\tloopy\n\tret\n\n\ndraw_block:\n\trcall\ti2c_start\n\tldi\tr19, 0x40\n\trcall\ti2c_write\n\tmov\tr19, r24\n\trcall\ti2c_write\n\trcall\ti2c_write\n\tandi\tr19, 0b11000011\n\trcall\ti2c_write\n\trcall\ti2c_write\n\trcall\ti2c_write\n\trcall\ti2c_write\n\tmov\tr19, r24\n\trcall\ti2c_write\n\trcall\ti2c_write\n\trcall\ti2c_stop\n\tret\n  \ndraw_piece:\n\tlsl\tr19\n\tlsl\tr19\n\tlsl\tr19\n\tclr\tr26\n\ndraw_row:\n  \n\tclr\tr25\n\ndraw_pix:\n\tpush\tr19\n\t; push r20\n\trcall\toled_goto\n\t; ldi r24, 0xFF\n\tsbrs\tr21, 0\n\trjmp\tdraw_pix_skipped\n\n\trcall\tdraw_block\n  \ndraw_pix_skipped:\n\n\t; pop r20\n\tpop\tr19\n\tlsr\tr22\n\tror\tr21\n\tinc\tr20\n\tinc\tr25\n\n\tsbrs\tr25, 2\n\trjmp\tdraw_pix\n\n\tsubi\tr19, -8\n\tsubi\tr20, 4\n\n\tinc\tr26\n\tsbrs\tr26, 2\n\trjmp\tdraw_row\n\n\tret\n\n\nrot_piece:\n\tclr\tr23\n\tclr\tr24\n\n\tsbrc\tr22, 4\n\tori\tr23, 1\n\tsbrc\tr22, 0\n\tori\tr23, 2\n\tsbrc\tr21, 4\n\tori\tr23, 4\n\tsbrc\tr21, 0\n\tori\tr23, 8\n\n\tsbrc\tr22, 5\n\tori\tr23, 16\n\tsbrc\tr22, 1\n\tori\tr23, 32\n\tsbrc\tr21, 5\n\tori\tr23, 64\n\tsbrc\tr21, 1\n\tori\tr23, 128\n\n\tsbrc\tr22, 6\n\tori\tr24, 1\n\tsbrc\tr22, 2\n\tori\tr24, 2\n\tsbrc\tr21, 6\n\tori\tr24, 4\n\tsbrc\tr21, 2\n\tori\tr24, 8\n\n\tsbrc\tr22, 7\n\tori\tr24, 16\n\tsbrc\tr22, 3\n\tori\tr24, 32\n\tsbrc\tr21, 7\n\tori\tr24, 64\n\tsbrc\tr21, 3\n\tori\tr24, 128\n\n\tmov\tr21, r23\n\tmov\tr22, r24\n\n\tret\n\n\n\n\nget_board:\n\tldi\tYL, LOW(brd)\n\tldi\tYH, HIGH(brd)\n\tadd\tYL, r19\n\tadc\tYH, r2\n\tld\tr16, Y\n\tcpse\tr20, r2\n\trjmp\tgbshr\ngbr:\n\tandi\tr16, 1\n\tret\ngbshr:\n\tlsr\tr16\n\tdec\tr20\n\tbrne\tgbshr\n\trjmp\tgbr\n\nflip_board:\n\tldi\tYL, LOW(brd)\n\tldi\tYH, HIGH(brd)\n\tadd\tYL, r19\n\tadc\tYH, r2\n\tld\tr16, y\n\tldi\tr17, 1\n\tcpse\tr20, r2\n\trjmp\tfbshl\nfbr:\n\teor\tr16, r17\n\tst\tY, r16\n\tret\nfbshl:\n\tlsl\tr17\n\tdec\tr20\n\tbrne\tfbshl\n\trjmp\tfbr\n\n\ndraw_board:\n\tclr\tr30\ndb_l0:\n\n\tldi\tYL, LOW(brd)\n\tldi\tYH, HIGH(brd)\n\tadd\tYL, r30\n\tadc\tYH, r2\n\tld\tr0, Y\n  \n\tclr\tr31\ndb_l1:\n\n\tmov\tr19, r30\n\tlsl\tr19\n\tlsl\tr19\n\tlsl\tr19\n\tmov\tr20, r31\n\trcall\toled_goto\n\n\tclr\tr24\n\tsbrc\tr0, 0\n\tldi\tr24, 0xFF\n\trcall\tdraw_block\n\n\tlsr\tr0\n\tinc\tr31\n\tsbrs\tr31, 3\n\trjmp\tdb_l1\n\n\tinc\tr30\n\tsbrs\tr30, 4\n\trjmp\tdb_l0\n\n\tret\n  \n\ncheck_collide:\n\n\tclr\tr26\nckc_l0:\n\tclr\tr25\nckc_l1:\n\n\tsbrs\tr21, 0\n\trjmp\tckc_skp\n\n\tcpi\tr19, 16\n\tbreq\tckc_brdr\n\tcpi\tr20, -1\n\tbreq\tckc_brdr\n\tcpi\tr20, 8\n\tbreq\tckc_brdr\n\n\tpush\tr20\n\trcall\tget_board\n\tpop\tr20\n\n\tsbrc\tr16, 0\n\tret\n\nckc_skp:\n\n\tlsr\tr22\n\tror\tr21\n\tinc\tr20\n\tinc\tr25\n\n\tsbrs\tr25, 2\n\trjmp\tckc_l1\n\n\tinc\tr19\n\tsubi\tr20, 4\n\n\tinc\tr26\n\tsbrs\tr26, 2\n\trjmp\tckc_l0\n\tret\n\nckc_brdr:\n\tldi\tr16, 1\n\tret\n\n\ntetris_update:\n\tmov\tr19, r4\n\tmov\tr20, r5\n\tmov\tr21, r6\n\tmov\tr22, r7\n\tclr\tr24\n\trcall\tdraw_piece\n\n\tmov\tr19, r4\n\tinc\tr19\n\tmov\tr4, r19\n\tmov\tr20, r5\n\tmov\tr21, r6\n\tmov\tr22, r7\n\n\n\tsbrc\tr11, KEY_L_bp\n\tdec\tr20\n\tsbrc\tr11, KEY_R_bp\n\tinc\tr20\n\tsbrc\tr10, KEY_U_bp\n\trcall\trot_piece\n\n\tpush\tr19\n\tpush\tr20\n\tpush\tr21\n\tpush\tr22\n\n\trcall\tcheck_collide\n\n\tpop\tr22\n\tpop\tr21\n\tpop\tr20\n\tpop\tr19\n\n\tsbrs\tr16, 0\n\trjmp\tnoconflict\n\n\tmov\tr19, r4\n\tmov\tr20, r5\n\tmov\tr21, r6\n\tmov\tr22, r7\n\nnoconflict:\n\n\tmov\tr4, r19\n\tmov\tr5, r20\n\tmov\tr6, r21\n\tmov\tr7, r22\n\tldi\tr24, 0xFF\n\trcall\tdraw_piece\n\n\tmov\tr19, r4\n\tmov\tr20, r5\n\tmov\tr21, r6\n\tmov\tr22, r7\n\n\n\tinc\tr19\n\trcall\tcheck_collide\n\tsbrs\tr16, 0\n\trjmp\tnocollide\n  \n\tmov\tr19, r4\n\tmov\tr20, r5\n\tmov\tr21, r6\n\tmov\tr22, r7\n\n\tclr\tr26\ntucm0:\n\tclr\tr25\ntucm1:\n\n\tsbrs\tr21, 0\n\trjmp\ttucms\n\n\tpush\tr20\n\trcall\tflip_board\n\tpop\tr20\n\ntucms:\n\n\tlsr\tr22\n\tror\tr21\n\tinc\tr20\n\tinc\tr25\n\n\tsbrs\tr25, 2\n\trjmp\ttucm1\n\n\tinc\tr19\n\tsubi\tr20, 4\n\n\tinc\tr26\n\tsbrs\tr26, 2\n\trjmp\ttucm0\n\n\trcall\tnext_piece\n\n\trcall\ttetris_check\n\nnocollide:\n\n\trcall\tdelay_poll\n\n\tret\n\ntetris_check:\n\tclr\tr17\n\tldi\tr19, 1\ntc_l0:\n\n\tldi\tYL, LOW(brd)\n\tldi\tYH, HIGH(brd)\n\tadd\tYL, r17\n\tadc\tYH, r2\n\tld\tr16, Y\n\tcpi\tr16, 0xFF\n\tbrne\ttc_skp\n\n\tmov\tr18, r17\n\tdec\tr18\n\ntc_l1:\n\n\tsbrc\tr18, 7\n\trjmp\ttc_shifted\n\n\tldi\tYL, LOW(brd)\n\tldi\tYH, HIGH(brd)\n\tadd\tYL, r18\n\tadc\tYH, r2\n\tld\tr16, Y\n\tadiw\tYL, 1\n\tst\tY, r16\n\n\tdec\tr18\n\trjmp\ttc_l1\n\ntc_shifted:\n\tldi\tYL, LOW(brd)\n\tldi\tYH, HIGH(brd)\n\tst\tY, r2\n\tlsl\tr19\n  \ntc_skp:\n\tinc\tr17\n\tsbrs\tr17, 5\n\trjmp\ttc_l0\n\n\tadd\tr12, r19\n\n\tsbrs\tr19, 0\n\trcall\tdraw_board\n\n\tret\n  \n\n\nshr3:\n\tclr\tr17\n\tclr\tr18\n\n\tmov\tr16, r3\n\n\tlsl\tr16\n\trol\tr17\n\tlsl\tr16\n\trol\tr17\n\tlsl\tr16\n\trol\tr17\n\n\teor\tr3, r16\n\teor\tr18, r17\n\n\tmov\tr16, r3\n\tmov\tr17, r18\n\n\tlsr\tr17\n\tror\tr16\n\tlsr\tr17\n\tror\tr16\n\n\teor\tr3, r16\n\teor\tr18, r17\n\n\tmov\tr16, r3\n\tmov\tr17, r18\n\n\tlsl\tr16\n\teor\tr3, r16\n\tret\n\neewrite_hisc:\n\tldi\tZL, LOW(NVMCTRL_STATUS)\n\tldi\tZH, HIGH(NVMCTRL_STATUS)\n\tin\tr0, CPU_SREG\n\tld\tr18, Z\n\tandi\tr18, 3\n\tbrne\teewrite_hisc\n\tcli\n\tsts\t(EEPROM_START+hisc), r16\n\tldi\tr16, CPU_CCP_SPM_gc\n\tout\tCPU_CCP, r16\n\tldi\tr16, NVMCTRL_CMD_PAGEERASEWRITE_gc\n\tldi\tZL, LOW(NVMCTRL_CTRLA)\n\tldi\tZH, HIGH(NVMCTRL_CTRLA)\n\tst\tZ, r16\n\tout\tCPU_SREG, r0\n\tret\n\npcs: .db \\\n  0b11110000, 0b00000000,\\\n  0b00010000, 0b00000111,\\\n  0b01000000, 0b00000111,\\\n  0b01100000, 0b00000110,\\\n  0b01100000, 0b00000011,\\\n  0b00100000, 0b00000111,\\\n  0b00110000, 0b00000110\n\nfont: .db \\\n  0x00,0x7d,0x00,0x60,0x00,0x60,0x7f,0x14,0x7f,0x32,0x6b,0x26,\\\n  0x27,0x08,0x73,0x3e,0x6b,0x2a,0x00,0x60,0x00,0x1c,0x22,0x41,\\\n  0x41,0x22,0x1c,0x6b,0x3e,0x6b,0x08,0x3e,0x08,0x02,0x03,0x00,\\\n  0x08,0x08,0x08,0x03,0x03,0x00,0x03,0x1c,0x60,0x3e,0x41,0x3e,\\\n  0x21,0x7f,0x01,0x23,0x45,0x39,0x22,0x49,0x36,0x3c,0x04,0x7f,\\\n  0x7a,0x49,0x4e,0x3e,0x49,0x26,0x40,0x4f,0x70,0x36,0x49,0x36,\\\n  0x32,0x49,0x3e,0x00,0x14,0x00,0x02,0x14,0x00,0x08,0x14,0x22,\\\n  0x14,0x14,0x14,0x22,0x14,0x08,0x20,0x4d,0x30,0x3f,0x41,0x7d,\\\n  0x7f,0x50,0x7f,0x7f,0x49,0x36,0x3e,0x41,0x22,0x7f,0x41,0x3e,\\\n  0x7f,0x49,0x41,0x7f,0x48,0x48,0x3e,0x41,0x2e,0x7f,0x08,0x7f,\\\n  0x41,0x7f,0x41,0x02,0x01,0x7e,0x7f,0x08,0x77,0x7f,0x01,0x01,\\\n  0x7f,0x3e,0x7f,0x7f,0x40,0x7f,0x7f,0x41,0x7f,0x7f,0x48,0x30,\\\n  0x3e,0x45,0x3f,0x7f,0x48,0x37,0x32,0x49,0x26,0x40,0x7f,0x40,\\\n  0x7f,0x01,0x7f,0x7c,0x03,0x7c,0x7f,0x0e,0x7f,0x77,0x08,0x77,\\\n  0x70,0x0f,0x70,0x47,0x49,0x71,0x7f,0x41,0x41,0x60,0x1c,0x03,\\\n  0x41,0x41,0x7f,0x20,0x40,0x20,0x01,0x01,0x01,0x40,0x20,0x00\n\n\n","examples/invaders.t202.asm":";***************************************************\n;*\n;* invaders.t202.asm\n;*\n;* space invaders game in AVR assembly\n;*\n;*..................................................\n;* \n;*  VCC-[10KO]-+     +---------+      +-[10KO]-VCC\n;*             | VCC-|o        |-GND  |\n;*  GND--_/ _--+-----| ATtiny- |------+--_/ _--GND\n;*  GND--_/ _---+----| 202/402 |-UPDI\n;*              |  +-| 212/412 |-+\n;*  VCC-[10KO]--+  | +---------+ |\n;*                 |        +----+\n;*                 +--------|---+  \n;*                          |   |\n;*                +---------------+\n;*                |GND VCC SCL SDA|\n;*                |               |\n;*                | OLED(SSD1306) |\n;*                |   128 X 64    |\n;*                +---------------+\n;* \n;*..................................................\n;*\n;* (c) lingdong huang 2023, MIT License\n;*\n;***************************************************\n\n.include \"./inc/tn202def.inc\"\n\n.equ I2C_ADDR   = 0x78\n.equ I2C_bm     = ((1<<1)|(1<<2))\n.equ I2C_DIRSET = PORTA_DIRSET\n.equ KEY_L_bp   = 7\n.equ KEY_R_bp   = 6\n.equ KEY_U_bp   = 3\n.equ KEY_bm     = ((1<<KEY_L_bp)|(1<<KEY_R_bp)|(1<<KEY_U_bp))\n.equ KEY_DIRCLR = PORTA_DIRCLR\n.equ KEY_IN     = PORTA_IN\n\n.eseg\nhisc: .db 0\n\n.dseg\nfleet: .byte 3\nwalls: .byte 6\n\n.cseg\n\n\tclr\tr2\n\n\tldi\tr16, 0x42\n\tmov\tr3, r16\n\n\tldi\tr16, 0\n\tsts\tCLKCTRL_MCLKCTRLB, r16\n\n\tlds\tr16, (EEPROM_START+hisc)\n\tcpi\tr16, 0xFF\n\tbrne\tno_erase_hisc\n\tclr\tr16\n\trcall\teewrite_hisc\nno_erase_hisc:\n\n\n\tldi\tr16, LOW(ramend)\n\tout\tCPU_SPL, r16\n\tldi\tr16, HIGH(ramend)\n\tout\tCPU_SPH, r16\n\n\tldi\tr16, I2C_bm \n\tsts\tI2C_DIRSET,r16\n\n\tldi\tr16, KEY_bm\n\tsts\tKEY_DIRCLR, r16\n\n\n\tclr\tr26\n\tldi\tr27, 128\n\trcall\tdelay\n\n\tldi\tr16, 17     \n\tsts\tTWI0_MBAUD,r16\n\n\tldi\tr16, TWI_ENABLE_bm\n\tsts\tTWI0_MCTRLA,r16\n\n\tldi\tr16, TWI_BUSSTATE_IDLE_gc\n\tsts\tTWI0_MSTATUS,r16\n\n\tldi\tr17, 0xae\n\trcall\toled_cmd1\n\n\tldi\tr17, 0xa8\n\tldi\tr18, 0x3f\n\trcall\toled_cmd2\n\n\tldi\tr17, 0xd3\n\tldi\tr18, 0x00\n\trcall\toled_cmd2\n\n\tldi\tr17, 0x40\n\trcall\toled_cmd1\n\n\tldi\tr17, 0xa0\n\trcall\toled_cmd1\n\n\tldi\tr17, 0xc8\n\trcall\toled_cmd1\n\n\tldi\tr17, 0xda\n\tldi\tr18, 0x12\n\trcall\toled_cmd2\n\n\tldi\tr17, 0x81\n\tldi\tr18, 0xff\n\trcall\toled_cmd2\n\n\tldi\tr17, 0xa4\n\trcall\toled_cmd1\n\n\tldi\tr17, 0xa6\n\trcall\toled_cmd1\n\n\tldi\tr17, 0xd5\n\tldi\tr18, 0x80\n\trcall\toled_cmd2\n\n\tldi\tr17, 0x8d\n\tldi\tr18, 0x14\n\trcall\toled_cmd2\n\n\tldi\tr17, 0x20\n\tldi\tr18, 0x02\n\trcall\toled_cmd2\n\n\tldi\tr17, 0xaf\n\trcall\toled_cmd1\n\n\nrestart:\n\n\tldi\tr16, LOW(ramend)\n\tout\tCPU_SPL, r16\n\tldi\tr16, HIGH(ramend)\n\tout\tCPU_SPH, r16\n\n\trcall\toled_clr\n\n\tclr\tr8\n\tclr\tr9\n\tcom\tr9\n\tldi\tr16, 60\n\tmov\tr14, r16\n\tclr\tr10\n\tclr\tr11\n\tcom\tr11\n\tclr\tr12\n\tldi\tr16, 3\n\tmov\tr15, r16\n\n\trcall\tfleet_make\n\n\t; ldi r16, 0b10100101\n\tldi\tr16, 15\n\tsts\twalls, r16\n\tsts\t(walls+1), r16\n\tsts\t(walls+2), r16\n\tsts\t(walls+3), r16\n\tsts\t(walls+4), r16\n\tsts\t(walls+5), r16\n\tsts\t(walls+6), r16\n\n\trcall\tgui_draw\n\trcall\twall_draw_all\n\n\nloop: \n\n\trcall\tpoll\n\trcall\tplayer_draw\n\trcall\tbullet_update\n\t; rcall bomb_update\n\tldi\tr23, 0\n\trcall\tfleet_draw_row\n\n\trcall\tpoll\n\trcall\tplayer_draw\n\trcall\tbullet_update\n\trcall\tbomb_update\n\tldi\tr23, 1\n\trcall\tfleet_draw_row\n\n\trcall\tpoll\n\trcall\tplayer_draw\n\trcall\tbullet_update\n\trcall\tbomb_update\n\tldi\tr23, 2\n\trcall\tfleet_draw_row\n\n\trcall\tfleet_move\n\n\trcall\tbomb_emit\n  \n\t; ldi r26, 0xFF\n\t; ldi r27, 0xFF\n\t; rcall delay\n\n\trjmp\tloop\n\ngame_over:\n\t; ldi r23, 0\n\t; rcall fleet_draw_row\n\t; ldi r23, 1\n\t; rcall fleet_draw_row\n\t; ldi r23, 2\n\t; rcall fleet_draw_row\n\n\tlds\tr16, (EEPROM_START+hisc)\n\tcp\tr12, r16\n\tbrlo\tnohi\n\tmov\tr16, r12\n\trcall\teewrite_hisc\nnohi:\n\n\tldi\tr23, 0b00001000\n\tldi\tr21, 5\n\trcall\toled_clr_row\n\tldi\tr21, 4\n\tclr\tr23\n\trcall\toled_clr_row\n\tldi\tr21, 3\n\tldi\tr23, 0b00100000\n\trcall\toled_clr_row\n\n\tldi\tr19, 46\n\tldi\tr20, 4\n\trcall\toled_godata\n\n\tldi\tr16, 13\n\trcall\toled_printchar\n\tldi\tr16, 10\n\trcall\toled_printchar\n\tldi\tr16, 16\n\trcall\toled_printchar\n\tldi\tr16, 12\n\trcall\toled_printchar\n\tclr\tr19\n\trcall\ti2c_write\n\trcall\ti2c_write\n\trcall\ti2c_write\n\trcall\ti2c_write\n\tldi\tr16, 0\n\trcall\toled_printchar\n\tldi\tr16, 19\n\trcall\toled_printchar\n\tldi\tr16, 12\n\trcall\toled_printchar\n\tldi\tr16, 17\n\trcall\toled_printchar\n\trcall\ti2c_stop\n\n\n\tldi\tr28, 32\n\trcall\tlong_delay\n\n\trjmp\trestart\n\n\nfleet_make:\n\tclr\tr6\n\tldi\tr16, 55\n\tmov\tr7, r16\n\tclr\tr5\n\tinc\tr5\n\tldi\tr16, 0b01111110\n\t; ldi r16, 0b00001000\n\tsts\tfleet, r16\n\tsts\t(fleet+1), r16\n\tsts\t(fleet+2), r16\n\tret\n\nnum1_draw:\n\trcall\toled_godata\n\tmov\tr16, r22\n\trcall\toled_printchar\n\trcall\ti2c_stop\n\tret\n\nnum3_draw:\n\trcall\toled_godata\n\n\tmov\tr16, r22\n\trcall\tbyte_to_dec\n\n\tpush\tr16\n\tmov\tr16, r18\n\trcall\toled_printchar\n\tmov\tr16, r17\n\trcall\toled_printchar\n\tpop\tr16\n\trcall\toled_printchar\n\n\trcall\ti2c_stop\n\tret\n\nscore_draw:\n\tldi\tr19, 57\n\tldi\tr20, 7\n\tmov\tr22, r12\n\trcall\tnum3_draw\n\tret\n\nlives_draw:\n\tldi\tr19, 18\n\tldi\tr20, 7\n\tmov\tr22, r15\n\trcall\tnum1_draw\n\tret\n\ngui_draw:\n\tldi\tr19, 116\n\tldi\tr20, 7\n\tlds\tr22, (EEPROM_START+hisc)\n\trcall\tnum3_draw\n\n\trcall\tscore_draw\n\trcall\tlives_draw\n\n\tldi\tr19, 0\n\tldi\tr20, 7\n\trcall\tplayer_img_draw\n\n\tldi\tr19, 11\n\tldi\tr20, 7\n\trcall\toled_godata\n\n\tldi\tr19, 0b00100010\n\trcall\ti2c_write\n\tldi\tr19, 0b00010100\n\trcall\ti2c_write\n\tldi\tr19, 0b00001000\n\trcall\ti2c_write\n\tldi\tr19, 0b00010100\n\trcall\ti2c_write\n\tldi\tr19, 0b00100010\n\trcall\ti2c_write\n\trcall\ti2c_stop\n\n\tldi\tr19, 78\n\tldi\tr20, 7\n\trcall\toled_godata\n\n\tldi\tr16, 14\n\trcall\toled_printchar\n\tldi\tr16, 15\n\trcall\toled_printchar\n\tldi\tr16, 21\n\trcall\toled_printchar\n\trcall\ti2c_stop\n\n\tldi\tr19, 90\n\tclr\tr23\n\ngdds:\n\n\tldi\tr20, 7\n\trcall\toled_godata\n  \n\tldi\tr16, 18\n\trcall\toled_printchar\n\tldi\tr16, 11\n\trcall\toled_printchar\n\tldi\tr16, 0\n\trcall\toled_printchar\n\tldi\tr16, 17\n\trcall\toled_printchar\n\tldi\tr16, 12\n\trcall\toled_printchar\n\tldi\tr16, 20\n\trcall\toled_printchar\n\trcall\ti2c_stop\n\n\tsbrc\tr23, 0\n\tret\n\n\tldi\tr19, 31\n\tinc\tr23\n\trjmp\tgdds\n\n\tret\n\n\n\nlong_delay:\n\tldi\tr26, 0xFF\n\tldi\tr27, 0xFF\n\trcall\tdelay\n\tdec\tr28\n\tbrne\tlong_delay\n\tret\n\n\npoll:\n\tlds\tr16, KEY_IN\n\tcom\tr16\n\tsbrc\tr16, KEY_L_bp\n\tdec\tr14\n\tsbrc\tr16, KEY_R_bp\n\tinc\tr14\n\tsbrc\tr16, KEY_U_bp\n\trcall\tbullet_emit\n\n\tldi\tr16, 0x7f\n\tand\tr14, r16\n\tret\n\ndelay:\n\tnop\n\tsbiw\tr26, 1\n\tbrne\tdelay\n\tret\n\ni2c_write:\n\tldi\tr16, TWI_MCMD_RECVTRANS_gc\n\tsts\tTWI0_MCTRLB, r16\n\n\tsts\tTWI0_MDATA, r19\n\nwait2:\n\tlds\tr16, TWI0_MSTATUS\n\tsbrs\tr16, TWI_WIF_bp\n\trjmp\twait2\n\n\tret\n\ni2c_start:\n\tldi\tr16, I2C_ADDR\n\tsts\tTWI0_MADDR, r16\n\nwait1:\n\tlds\tr16, TWI0_MSTATUS\n\tandi\tr16, (TWI_WIF_bm|TWI_RIF_bm)\n\tbreq\twait1\n\n\tret\n\ni2c_stop:\n\tlds\tr16, TWI0_MCTRLB\n\tori\tr16, TWI_MCMD_STOP_gc\n\nwait3:\n\tlds\tr16, TWI0_MSTATUS\n\tsbrs\tr16, TWI_BUSSTATE_IDLE_gc\n\trjmp\twait3\n\n\tret\n\noled_cmd1:\n\trcall\ti2c_start\n\n\tldi\tr19, 0\n\trcall\ti2c_write\n\n\tmov\tr19, r17\n\trcall\ti2c_write\n\n\trcall\ti2c_stop\n\n\tret\n\noled_cmd2:\n\trcall\ti2c_start\n\n\tldi\tr19, 0\n\trcall\ti2c_write\n\n\tmov\tr19, r17\n\trcall\ti2c_write\n\n\tmov\tr19, r18\n\trcall\ti2c_write\n\n\trcall\ti2c_stop\n  \n\tret\n\noled_goto:\n\tmov\tr17, r19\n\tmov\tr18, r19\n\n\tandi\tr17, 0xf\n\tswap\tr18\n\tandi\tr18, 0xf\n\tori\tr18, 0x10\n\n\trcall\toled_cmd2\n\n\tmov\tr17, r20\n\tori\tr17, 0xb0\n\n\trcall\toled_cmd1\n\n\tret\n\noled_godata:\n\trcall\toled_goto\n\trcall\ti2c_start\n\tldi\tr19, 0x40\n\trcall\ti2c_write\n\tret\n\noled_printchar:\n\tldi\tr19, 3\n\tmul\tr16, r19\n\tldi\tZL, LOW (font<<1)\n\tldi\tZH, HIGH(font<<1)\n\tadd\tZL, r0\n\tadc\tZH, r1\n\tlpm\tr19, Z+\n\trcall\ti2c_write\n\tlpm\tr19, Z+\n\trcall\ti2c_write\n\tlpm\tr19, Z\n\trcall\ti2c_write\n\tclr\tr19\n\trcall\ti2c_write\n\tret\n\n\ndiv10_8:\n\tmov\tr18, r16\n\tmov\tr17, r18\n\tlsr\tr18\n\tclr\tr0\n\tadd\tr18, r17\n\tadc\tr0, r0\n\tlsr\tr0\n\tror\tr18\n\tmov\tr17, r18\n\tswap\tr18\n\tandi\tr18, 0xF\n\tadd\tr18, r17\n\tlsr\tr18\n\tlsr\tr18\n\tlsr\tr18\n\tmov\tr17, r18\n\tlsl\tr17\n\tlsl\tr17\n\tadd\tr17, r18\n\tlsl\tr17\n\tsub\tr17, r16\n\tneg\tr17\n\tcpi\tr17, 10\n\tbrlo\td108_noof\n\tsubi\tr17, 10\n\tinc\tr18\nd108_noof:\n\tret\n\nbyte_to_dec:\n\trcall\tdiv10_8\n\tpush\tr17\n\tmov\tr16, r18\n\trcall\tdiv10_8\n\tpop\tr16\n\tret\n\n\noled_clr_row:\n\tclr\tr19\n\tmov\tr20, r21\n\trcall\toled_godata\n\n\tclr\tr22\noclx:\n\t; clr r19\n\tmov\tr19, r23\n\trcall\ti2c_write\n\n\tinc\tr22\n\tsbrs\tr22, 7\n\trjmp\toclx\n\n\trcall\ti2c_stop\n\tret\n\noled_clr:\n\tclr\tr21\n\tclr\tr23\nocly:\n\trcall\toled_clr_row\n\tinc\tr21\n\tsbrs\tr21, 3\n\trcall\tocly\n\tret\n\n\nplayer_img_draw:\n\trcall\toled_godata\n\tclr\tr19\n\trcall\ti2c_write\n\tldi\tr19, 0b00000111\n\trcall\ti2c_write\n\tldi\tr19, 0b00001111\n\trcall\ti2c_write\n\trcall\ti2c_write\n\tldi\tr19, 0b01111111\n\trcall\ti2c_write\n\trcall\ti2c_write\n\tldi\tr19, 0b00001111\n\trcall\ti2c_write\n\trcall\ti2c_write\n\tldi\tr19, 0b00000111\n\trcall\ti2c_write\n\tclr\tr19\n\trcall\ti2c_write\n\trcall\ti2c_stop\n\tret\n\nplayer_draw:\n\tmov\tr19, r14\n\tldi\tr20, 0\n\trcall\tplayer_img_draw\n\tret\n\nalien_draw:\n\tldi\tr21, 0b00001110\n\tsbrc\tr19, 1\n\trjmp\taspa\n\tlsl\tr21\n\tlsl\tr21\n\tlsl\tr21\n\naspa:\n\n\trcall\toled_godata\n\n\tclr\tr19\n\trcall\ti2c_write\n\tmov\tr19, r21\n\trcall\ti2c_write\n\tldi\tr19, 0b00011000\n\trcall\ti2c_write\n\tldi\tr19, 0b10111110\n\trcall\ti2c_write\n\tldi\tr19, 0b01101101\n\trcall\ti2c_write\n\tldi\tr19, 0b00111101\n\trcall\ti2c_write\n\tldi\tr19, 0b00111100\n\trcall\ti2c_write\n\n\tldi\tr19, 0b00111100\n\trcall\ti2c_write\n\tldi\tr19, 0b00111101\n\trcall\ti2c_write\n\tldi\tr19, 0b01101101\n\trcall\ti2c_write\n\tldi\tr19, 0b10111110\n\trcall\ti2c_write\n\tldi\tr19, 0b00011000\n\trcall\ti2c_write\n\tmov\tr19, r21\n\trcall\ti2c_write\n\tclr\tr19\n\trcall\ti2c_write\n\n\trcall\ti2c_stop\n\tret\n\n\nfleet_draw_row:\n\n\tclr\tr22\n\n\tldi\tXL, LOW(fleet)\n\tldi\tXH, HIGH(fleet)\n\tadd\tXL, r23\n\tadc\tXH, r2\n\tld\tr0, X\n\nfulx:\n\n\tsbrs\tr0, 0\n\trjmp\tnoship\n\n\tmov\tr19, r22\n\tswap\tr19\n\tandi\tr19, 0xFF\n\tadd\tr19, r6\n\n\tmov\tr20, r7\n\tlsr\tr20\n\tlsr\tr20\n\tlsr\tr20\n\tsub\tr20, r23\n\n\trcall\talien_draw\n\nnoship:\n\tlsr\tr0\n\n\tinc\tr22\n\tsbrs\tr22, 3  \n\trjmp\tfulx\n\n\tret\n\n\nfleet_move:\n\tlds\tr16, fleet\n\tlds\tr17, (fleet+1)\n\tor\tr16, r17\n\tlds\tr17, (fleet+2)\n\tor\tr16, r17\n\n\tclr\tr18\n\tldi\tr19, 4\n\n\tmov\tr20, r16\nfmlsb:\n\tlsr\tr20\n\tsubi\tr18, 16\n\tsbrs\tr20, 0\n\trjmp\tfmlsb\n\n\tmov\tr20, r16\nfmmsb:\n\tlsl\tr20\n\tsubi\tr19, -16\n\tsbrs\tr20, 7\n\trjmp\tfmmsb\n\nfmm:\n\tadd\tr6, r5\n\tcp\tr6, r18\n\tbrlt\tfmcd\n\tcp\tr6, r19\n\tbrge\tfmcd\n\n\tret\nfmcd:\n\tsub\tr6, r5\n\tneg\tr5\n\tmov\tr21, r7\n\n\tandi\tr21, 7\n\tbrne\tfmne\n\n\tmov\tr21, r7\n\tlsr\tr21\n\tlsr\tr21\n\tlsr\tr21\n\n\tpush\tr18\n\tpush\tr19\n\tldi\tr23, 0\n\trcall\toled_clr_row\n\tdec\tr21\n\trcall\toled_clr_row\n\tdec\tr21\n\trcall\toled_clr_row\n\tpop\tr19\n\tpop\tr18\n\nfmne:\n\n\tdec\tr7\n\n\trcall\tfleet_invade\n\n\trjmp\tfmm\n\tret\n\n\nfleet_invade:\n\n\tldi\tr17, 31\n\tcp\tr7, r17\n\tbrsh\tfiok\n\tlds\tr16, fleet\n\tcpse\tr16, r2\n\trjmp\tgame_over\n\n\tsubi\tr17, 8\n\tcp\tr7, r17\n\tbrsh\tfiok\n\tlds\tr16, (fleet+1)\n\tcpse\tr16, r2\n\trjmp\tgame_over\n  \n\tsubi\tr17, 8\n\tcp\tr7, r17\n\tbrsh\tfiok\n\tlds\tr16, (fleet+2)\n\tcpse\tr16, r2\n\trjmp\tgame_over\n\nfiok:\n\tret\n\n\n\n\nbullet_emit:\n\tsbrs\tr9, 6\n\tret\n  \n\tmov\tr8, r14\n\tldi\tr16, 8\n\tmov\tr9, r16\n\tldi\tr16, 4\n\tadd\tr8, r16\n\tret\n\nbullet_update:\n\tsbrc\tr9, 6\n\tret\n\n\tmov\tr20, r9\n\tinc\tr20\n\tandi\tr20, 7\n\tbrne\tbune\n\n\tmov\tr20, r9\n\tlsr\tr20\n\tlsr\tr20\n\tlsr\tr20\n\tmov\tr19, r8\n\trcall\toled_godata\n\tclr\tr19\n\trcall\ti2c_write\n\trcall\ti2c_stop\n\nbune:\n\n\tinc\tr9\n\tldi\tr16, 56\n\tcpse\tr9, r16\n\tsbrc\tr2, 0\n\tcom\tr9\n\n\tsbrc\tr9, 6\n\tret\n\n\tmov\tr20, r9\n\tlsr\tr20\n\tlsr\tr20\n\tlsr\tr20\n\tmov\tr19, r8\n  \n\trcall\toled_godata\n\n\tldi\tr19, 1\n\tmov\tr16, r9\n\tandi\tr16, 7\n\tbreq\tnobpshl\n\nbpshl:\n\tlsl\tr19\n\tdec\tr16\n\tbrne\tbpshl\n\nnobpshl:\n  \n\trcall\ti2c_write\n\trcall\ti2c_stop\n\n\trcall\tbullet_hit_alien\n\n\tpush\tr10\n\tpush\tr11\n\tmov\tr10, r8\n\tmov\tr11, r9\n\trcall\tbomb_hit_wall\n\tmov\tr9, r11\n\tpop\tr11\n\tpop\tr10\n\n\tret\n\nbullet_hit_alien:\n\tmov\tr19, r8\n\tsub\tr19, r6\n\tmov\tr21, r19\n\tandi\tr21, 0xF\n\n\tcpi\tr21, 12\n\tbrge\tbnohit\n\n\tswap\tr19\n\tandi\tr19, 0xF\n\n\tmov\tr20, r7\n\tlsr\tr20\n\tlsr\tr20\n\tlsr\tr20\n\tmov\tr21, r9\n\tlsr\tr21\n\tlsr\tr21\n\tlsr\tr21\n\tsub\tr20, r21\n\n\tcpi\tr20, 0\n\tbrlt\tbnohit\n\tcpi\tr20, 3\n\tbrge\tbnohit\n\n\tldi\tXL, LOW(fleet)\n\tldi\tXH, HIGH(fleet)\n\tadd\tXL, r20\n\tadc\tXH, r2\n\tld\tr0, X\n\tmov\tr1, r0\n\n\tldi\tr22, 1\n\n\tmov\tr21, r19\nbhlx:\n\tlsr\tr0\n\tlsl\tr22\n\tdec\tr21\n\tbrne\tbhlx\n\n\tsbrs\tr0, 0\n\trjmp\tbnohit\n\n\tcom\tr22\n\tand\tr1, r22\n\tst\tX, r1\n\n\tswap\tr19\n\tadd\tr19, r6\n\n\tmov\tr21, r7\n\tlsr\tr21\n\tlsr\tr21\n\tlsr\tr21\n\tsub\tr20, r21\n\tneg\tr20\n\trcall\tbang_draw\n\n\tcom\tr9\n\n\tinc\tr12\n\trcall\tscore_draw\n\trcall\tcheck_win\n\n\nbnohit:\n\tret\n\n\nbang_draw:\n\tpush\tr19\n\tpush\tr20\n\trcall\toled_godata\n\tclr\tr19\n\trcall\ti2c_write\n\tldi\tr19, 0b00001000\n\trcall\ti2c_write\n\tldi\tr19, 0b01001001\n\trcall\ti2c_write\n\tldi\tr19, 0b00100010\n\trcall\ti2c_write\n\tldi\tr19, 0b00010100\n\trcall\ti2c_write\n\tclr\tr19\n\trcall\ti2c_write\n\tldi\tr19, 0b11000011\n\trcall\ti2c_write\n\tclr\tr19\n\trcall\ti2c_write\n\tldi\tr19, 0b00010100\n\trcall\ti2c_write\n\tldi\tr19, 0b00100010\n\trcall\ti2c_write\n\tldi\tr19, 0b01001001\n\trcall\ti2c_write\n\tldi\tr19, 0b00001000\n\trcall\ti2c_write\n\tclr\tr19\n\trcall\ti2c_write\n\trcall\ti2c_stop\n\n\tldi\tr26, 0xFF\n\tldi\tr27, 0xFF\n\trcall\tdelay\n\n\tpop\tr20\n\tpop\tr19\n\trcall\toled_godata\n\tclr\tr19\n\n\tldi\tr17, 14\nbdc:\n\trcall\ti2c_write\n\tdec\tr17\n\tbrne\tbdc\n\n\trcall\ti2c_stop\n\n\tret\n\n\ncheck_win:\n\tlds\tr22, fleet\n\tlds\tr23, (fleet+1)\n\tor\tr22, r23\n\tlds\tr23, (fleet+2)\n\tor\tr22, r23\n\tbreq\tcwy\n\tret\ncwy:\n\tsbrs\tr15, 3\n\tinc\tr15\n\trcall\tlives_draw\n\trcall\tfleet_make\n\tret\n\nbomb_emit:\n\tsbrs\tr11, 6\n\tret\n\n\tlds\tr22, fleet\n\tlds\tr23, (fleet+1)\n\tlds\tr24, (fleet+2)\n\n\trcall\tshr3\n  \n\tmov\tr21, r3\n\tandi\tr21, 7\n\tmov\tr20, r21\n\n\tbreq\tbomb_emit\n\nbelx:\n\tlsr\tr22\n\tlsr\tr23\n\tlsr\tr24\n\tdec\tr21\n\tbrne\tbelx\n\n\tor\tr22, r23\n\tor\tr22, r24\n\n\tsbrs\tr22, 0\n\trjmp\tbomb_emit\n\n\tmov\tr10, r20\n\tswap\tr10\n\tadd\tr10, r6\n\tldi\tr21, 7\n\tadd\tr10, r21\n\n\tmov\tr11, r7\n\tlsr\tr11\n\tlsr\tr11\n\tlsr\tr11\n\tdec\tr11\n\tdec\tr11\n\tsbrc\tr24, 0\n\trjmp\tbeok\n\tinc\tr11\n\tsbrc\tr23, 0\n\trjmp\tbeok\n\tinc\tr11\n\nbeok:\n\tlsl\tr11\n\tlsl\tr11\n\tlsl\tr11\n\tdec\tr11\n\n\tret\n\n\nbomb_update:\n \n\tsbrc\tr11, 6\n\tret\n\n\tmov\tr20, r11\n\tandi\tr20, 7\n\tbrne\tbmune\n\n\tmov\tr20, r11\n\tlsr\tr20\n\tlsr\tr20\n\tlsr\tr20\n\tmov\tr19, r10\n\trcall\toled_godata\n\tclr\tr19\n\trcall\ti2c_write\n\trcall\ti2c_stop\n\nbmune:\n\n\tdec\tr11\n\n\tsbrc\tr11, 6\n\tret\n\n\tmov\tr20, r11\n\tlsr\tr20\n\tlsr\tr20\n\tlsr\tr20\n\tmov\tr19, r10\n  \n\trcall\toled_godata\n\n\tldi\tr19, 1\n\tmov\tr16, r11\n\tandi\tr16, 7\n\tbreq\tnobmshl\n\nbmshl:\n\tlsl\tr19\n\tdec\tr16\n\tbrne\tbmshl\n\nnobmshl:\n  \n\trcall\ti2c_write\n\trcall\ti2c_stop\n\n\tmov\tr16, r11\n\tcpi\tr16, 8\n\tbrge\tbmnohit\n  \n\tmov\tr16, r10\n\tdec\tr16\n\tcp\tr16, r14\n\tbrlt\tbmnohit\n\n\tsubi\tr16, 8\n\tcp\tr16, r14\n\tbrge\tbmnohit\n\n\tmov\tr19, r14\n\tsubi\tr19, 2\n\tldi\tr20, 0\n\trcall\tbang_draw\n\n\tsbrs\tr11, 7\n\tcom\tr11\n\n\trjmp\tlives_lost\n\nbmnohit:\n\n\trcall\tbomb_hit_wall\n\n\tret\n\nlives_lost:\n\tdec\tr15\n\trcall\tlives_draw\n\tcpse\tr15, r2\n\tsbrc\tr2, 0\n\trjmp\tgame_over\n\n\tldi\tr28, 4\n\trcall\tlong_delay\n\tldi\tr16, 60\n\tmov\tr14, r16\n\n\nbomb_hit_wall:\n\n\tmov\tr16, r11\n\tcpi\tr16, 16\n\tbrge\tbmnowall\n  \n\tclr\tr23\n\n\tldi\tXL, LOW(walls)\n\tldi\tXH, HIGH(walls)\n\nbmll:\n\n\tldi\tZL, LOW(wallpos<<1)\n\tldi\tZH, HIGH(wallpos<<1)\n\tadd\tZL, r23\n\tadc\tZH, r2\n\tlpm\n\n\tmov\tr16, r0\n\tandi\tr16, 0x7f\n\tcp\tr10, r16\n\tbrlt\tbmln\n\n\tsubi\tr16, -8\n\tcp\tr10, r16\n\tbrge\tbmln\n\n\tld\tr25, X\n\n\tcpse\tr25, r2\n\tsbrc\tr2, 0\n\trjmp\tbmln\n\n\tmov\tr19, r0\n\tdec\tr25\n\tst\tX, r25\n\n\tcom\tr11\n\trcall\twall_draw\n\trjmp\tbmnowall\n\nbmln:\n\tadiw\tXL, 1\n\tinc\tr23\n\tcpi\tr23, 6\n\tbrne\tbmll\n\nbmnowall:\n\n\tret\n\n\nwall_draw:\n\tmov\tr28, r19\n\tandi\tr19, 0x7f\n  \n\tldi\tr20, 1\n\trcall\toled_godata\n\n\tclr\tr21\nwdlx:\n\n\tldi\tZL, LOW(wallpat<<1)\n\tldi\tZH, HIGH(wallpat<<1)\n\n\tmov\tr16, r21\n\tsbrc\tr28, 7\n\tneg\tr16\n\tsbrc\tr28, 7\n\tsubi\tr16, -7\n\n\tadd\tZL, r16\n\tadc\tZH, r2\n\n\tlpm\n\n\tclr\tr19\n\tclr\tr22\nwdly:\n\n\tmov\tr16, r22\n\tandi\tr16, 3\n\tmov\tr17, r21\n\tandi\tr17, 3\n\tlsl\tr17\n\tlsl\tr17\n\tadd\tr16, r17\n\n\tldi\tZL, LOW(dithord<<1)\n\tldi\tZH, HIGH(dithord<<1)\n\tadd\tZL, r16\n\tadc\tZH, r2\n\tlpm\tr24, Z\n\t; dec r24\n\tsub\tr24, r25\n\n\tlsl\tr19\n\n\tsbrc\tr24, 7\n\tori\tr19, 1\n\n\tinc\tr22\n\tsbrs\tr22, 3\n\trjmp\twdly\n\n\tand\tr19, r0\n\t; ldi r19, 0xFF\n\t; mov r19, r25\n\trcall\ti2c_write\n\n\tinc\tr21\n\tsbrs\tr21, 3\n\trjmp\twdlx\n\n\trcall\ti2c_stop\n\tret\n\nwall_draw_all:\n\tldi\tr23, 6\n\n\tldi\tXL, LOW(walls)\n\tldi\tXH, HIGH(walls)\n\nwdll:\n\n\tldi\tZL, LOW(wallpos<<1)\n\tldi\tZH, HIGH(wallpos<<1)\n\tadiw\tZL, 6\n\tsub\tZL, r23\n\tsbc\tZH, r2\n\tlpm\n\n\tmov\tr19, r0\n\tld\tr25, X+\n\n\trcall\twall_draw\n\n\tdec\tr23\n\tbrne\twdll\n\tret\n\n\nshr3:\n\tclr\tr17\n\tclr\tr18\n\n\tmov\tr16, r3\n\n\tlsl\tr16\n\trol\tr17\n\tlsl\tr16\n\trol\tr17\n\tlsl\tr16\n\trol\tr17\n\n\teor\tr3, r16\n\teor\tr18, r17\n\n\tmov\tr16, r3\n\tmov\tr17, r18\n\n\tlsr\tr17\n\tror\tr16\n\tlsr\tr17\n\tror\tr16\n\n\teor\tr3, r16\n\teor\tr18, r17\n\n\tmov\tr16, r3\n\tmov\tr17, r18\n\n\tlsl\tr16\n\teor\tr3, r16\n\tret\n\n\neewrite_hisc:\n\tldi\tZL, LOW(NVMCTRL_STATUS)\n\tldi\tZH, HIGH(NVMCTRL_STATUS)\n\tin\tr0, CPU_SREG\n\tld\tr18, Z\n\tandi\tr18, 3\n\tbrne\teewrite_hisc\n\tcli\n\tsts\t(EEPROM_START+hisc), r16\n\tldi\tr16, CPU_CCP_SPM_gc\n\tout\tCPU_CCP, r16\n\tldi\tr16, NVMCTRL_CMD_PAGEERASEWRITE_gc\n\tldi\tZL, LOW(NVMCTRL_CTRLA)\n\tldi\tZH, HIGH(NVMCTRL_CTRLA)\n\tst\tZ, r16\n\tout\tCPU_SREG, r0\n\tret\n\nfont: .db \\\n0x7c,0x82,0x7c,0x42,0xfe,0x02,0x46,0x8a,0x72,0x44,0x92,\\\n0x6c,0x78,0x08,0xfe,0xf4,0x92,0x9c,0x7c,0x92,0x4c,0x80,\\\n0x9e,0xe0,0x6c,0x92,0x6c,0x64,0x92,0x7c,0xfe,0xa0,0xfe,\\\n0x7c,0x82,0x44,0xfe,0x92,0x82,0x7c,0x82,0x5c,0xfe,0x10,\\\n0xfe,0x82,0xfe,0x82,0xfe,0x7c,0xfe,0xfe,0x90,0x6e,0x64,\\\n0x92,0x4c,0xf8,0x06,0xf8,0x00,0x28,0x00,0x10,0x10,0x10\n\ndithord: .db 0,8,2,10,12,4,14,6,3,11,1,9,15,7,13,5\n\nwallpos: .db 20,-28,  56,-64,  92,-100\n\nwallpat: .db 0b00111111, 0b01111111, 0b11111111, 0b11111111,\\\n             0b11111111, 0b11111110, 0b11111100, 0b11111100\n","examples/quine.t412.asm":";***************************************************\n;*\n;* quine.t412.asm\n;*\n;* a program that prints itself (ihex) via serial\n;*\n;*..................................................\n;* \n;*       .--    +---+        +---------+        \n;* +-----|      |RTS|  +-VCC-|o        |-GND--+\n;* | []  |      | RX|--|--TX-| ATtiny- |-     |\n;* |~--~-|  ... | TX|--|--RX-| 202/402 |-UPDI |\n;* | []  |      |VCC|--+    -| 212/412 |-     |\n;* +-----|      |CTS|        +---------+      |\n;*       '--    |GND|-------------------------+\n;*  USB -> UART +---+ \n;*..................................................\n;*\n;* (c) lingdong huang 2023, MIT License\n;*\n;***************************************************\n\n.include \"./inc/tn412def.inc\"\n\n.equ BAUD\t= 1389\n.equ TX_bm\t= (1<<6)\n.equ UART_DIRSET = PORTA_DIRSET\n.equ UART_OUTSET = PORTA_OUTSET\n\n\tldi\tr16, LOW(ramend)\n\tout\tCPU_SPL, r16\n\tldi\tr16, HIGH(ramend)\n\tout\tCPU_SPH, r16\n\t\n\tldi \tr16, TX_bm \n\tsts \tUART_DIRSET,r16\n\tsts \tUART_OUTSET,r16\n\n\tldi\tr16, LOW(BAUD)\n\tsts\tUSART0_BAUDL, r16\n\tldi\tr16, HIGH(BAUD)\n\tsts\tUSART0_BAUDH, r16\n\n\tldi\tr16, (USART_TXEN_bm)\n\tsts\tUSART0_CTRLB, r16\n\n\tser\tr26\n\tser\tr27\n\trcall\tdelay\n\trcall\tdelay\n  \n\tclr\tr30\n\tclr\tr31\n\t\n\tclr\tr21\n\t\n\tldi\tr19, ':'\n\trcall\tuart_sendchar\n\tldi\tr19, '0'\n\trcall\tuart_sendchar\n\tldi\tr19, '2'\n\trcall\tuart_sendchar\n\tldi\tr19, '0'\n\trcall\tuart_sendchar\n\trcall\tuart_sendchar\n\trcall\tuart_sendchar\n\trcall\tuart_sendchar\n\trcall\tuart_sendchar\n\tldi\tr19, '2'\n\trcall\tuart_sendchar\n\tldi\tr19, '0'\n\trcall\tuart_sendchar\n\trcall\tuart_sendchar\n\trcall\tuart_sendchar\n\trcall\tuart_sendchar\n\tldi\tr19, 'F'\n\trcall\tuart_sendchar\n\tldi\tr19, 'C'\n\trcall\tuart_sendchar\n\tldi\tr19, 0xA\n\trcall\tuart_sendchar\n\t\nloopl:\n\tclr\tr20\n\tldi\tr19, ':'\n\trcall\tuart_sendchar\n\tldi\tr19, '1'\n\trcall\tuart_sendchar\n\tldi\tr19, '0'\n\trcall\tuart_sendchar\n\trcall\tuart_sendchar\n\trcall\tuart_sendchar\n\tmov\tr19, r30\n\trcall\tputhex\n\tldi\tr19, '0'\n\trcall\tuart_sendchar\n\trcall\tuart_sendchar\n\t\n\tldi\tr22, 0x10\n\tadd\tr22, r30\n\t\nloopb:\n\tlpm\tr19,Z+\n\tadd\tr22,r19\n\trcall\tputhex\n\t\n\tinc\tr20\n\tsbrs\tr20,4\n\trjmp\tloopb\n\t\n\tcom\tr22\n\tinc\tr22\n\tmov\tr19,r22\n\trcall\tputhex\n\t\n\tldi\tr19,0xA\n\trcall\tuart_sendchar\n\t\n\tinc\tr21\n\tsbrs\tr21,4\n\trjmp\tloopl\n\t\n\tldi\tr19, ':'\n\trcall\tuart_sendchar\n\tldi\tr19, '0'\n\trcall\tuart_sendchar\n\trcall\tuart_sendchar\n\trcall\tuart_sendchar\n\trcall\tuart_sendchar\n\trcall\tuart_sendchar\n\trcall\tuart_sendchar\n\trcall\tuart_sendchar\n\tldi\tr19, '1'\n\trcall\tuart_sendchar\n\tldi\tr19, 'F'\n\trcall\tuart_sendchar\n\tldi\tr19, 'F'\n\trcall\tuart_sendchar\n\tldi\tr19, 0xA\n\trcall\tuart_sendchar\n\t\n\t\ndone:\trjmp done\n\n\nputhex:\n\tmov\tr18,r19\n\tswap\tr19\n\tandi\tr19,0xf\n\tandi\tr18,0xf\n\t\n\tsubi\tr19,-6\n\tsbrc\tr19,4\n\tsubi\tr19,-7\n\tsubi\tr19,-42\n\trcall\tuart_sendchar\n\t\n\tmov\tr19,r18\n\t\n\tsubi\tr19,-6\n\tsbrc\tr19,4\n\tsubi\tr19,-7\n\tsubi\tr19,-42\n\trcall\tuart_sendchar\n\tret\n\t\n\nuart_sendchar:\n\tlds\tr16, USART0_STATUS\n\tsbrs\tr16, USART_DREIF_bp\n\trjmp\tuart_sendchar\n\tsts\tUSART0_TXDATAL, r19\n\tret\n\n\t\ndelay:\n\tnop\n\tnop\n\tsbiw\tr26, 1\n\tbrne\tdelay\n\tret\n","inc/tn202def.inc":";***** THIS IS A MACHINE GENERATED FILE - DO NOT EDIT ********************\n\n;*************************************************************************\n;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y\n;*\n;* Number            : AVR000\n;* File Name         : tn202def.inc\n;* Title             : Register/Bit Definitions for the ATtiny202\n;* Created           : 2021-07-13 10:42\n;* Version           : 1.00\n;* Support e-mail    : avr@atmel.com\n;* Target MCU        : ATtiny202\n;*\n;* DESCRIPTION\n;* When including this file in the assembly program file, all I/O register\n;* names and I/O register bit names appearing in the data book can be used.\n;* In addition, the six registers forming the three data pointers X, Y and\n;* Z have been assigned names XL - ZH. Highest RAM address for Internal\n;* SRAM is also defined\n;*\n;*************************************************************************\n\n#ifndef _TN202DEF_INC_\n#define _TN202DEF_INC_\n\n\n#pragma partinc 0\n\n; ***** SPECIFY DEVICE ***************************************************\n.device\tATtiny202\n\n#pragma AVRPART ADMIN PART_NAME ATtiny202\n\n.equ\tSIGNATURE_000\t= 0x1E\n.equ\tSIGNATURE_001\t= 0x91\n.equ\tSIGNATURE_002\t= 0x23\n\n#pragma AVRPART CORE CORE_VERSION V4\n\n\n; ***** ABSOLUTE I/O REGISTER LOCATIONS **********************************\n\n\n;*************************************************************************\n;** AC0 - Analog Comparator\n;*************************************************************************\n\n.equ AC0_CTRLA = 0x0670                  ; Control A\n.equ AC0_MUXCTRLA = 0x0672               ; Mux Control A\n.equ AC0_INTCTRL = 0x0676                ; Interrupt Control\n.equ AC0_STATUS = 0x0677                 ; Status\n\n;*************************************************************************\n;** ADC0 - Analog to Digital Converter\n;*************************************************************************\n\n.equ ADC0_CTRLA = 0x0600                 ; Control A\n.equ ADC0_CTRLB = 0x0601                 ; Control B\n.equ ADC0_CTRLC = 0x0602                 ; Control C\n.equ ADC0_CTRLD = 0x0603                 ; Control D\n.equ ADC0_CTRLE = 0x0604                 ; Control E\n.equ ADC0_SAMPCTRL = 0x0605              ; Sample Control\n.equ ADC0_MUXPOS = 0x0606                ; Positive mux input\n.equ ADC0_COMMAND = 0x0608               ; Command\n.equ ADC0_EVCTRL = 0x0609                ; Event Control\n.equ ADC0_INTCTRL = 0x060A               ; Interrupt Control\n.equ ADC0_INTFLAGS = 0x060B              ; Interrupt Flags\n.equ ADC0_DBGCTRL = 0x060C               ; Debug Control\n.equ ADC0_TEMP = 0x060D                  ; Temporary Data\n.equ ADC0_RES = 0x0610                   ; ADC Accumulator Result\n.equ ADC0_RESL = 0x0610                  ; ADC Accumulator Result low byte\n.equ ADC0_RESH = 0x0611                  ; ADC Accumulator Result hi byte\n.equ ADC0_WINLT = 0x0612                 ; Window comparator low threshold\n.equ ADC0_WINLTL = 0x0612                ; Window comparator low threshold low byte\n.equ ADC0_WINLTH = 0x0613                ; Window comparator low threshold hi byte\n.equ ADC0_WINHT = 0x0614                 ; Window comparator high threshold\n.equ ADC0_WINHTL = 0x0614                ; Window comparator high threshold low byte\n.equ ADC0_WINHTH = 0x0615                ; Window comparator high threshold hi byte\n.equ ADC0_CALIB = 0x0616                 ; Calibration\n\n;*************************************************************************\n;** BOD - Bod interface\n;*************************************************************************\n\n.equ BOD_CTRLA = 0x0080                  ; Control A\n.equ BOD_CTRLB = 0x0081                  ; Control B\n.equ BOD_VLMCTRLA = 0x0088               ; Voltage level monitor Control\n.equ BOD_INTCTRL = 0x0089                ; Voltage level monitor interrupt Control\n.equ BOD_INTFLAGS = 0x008A               ; Voltage level monitor interrupt Flags\n.equ BOD_STATUS = 0x008B                 ; Voltage level monitor status\n\n;*************************************************************************\n;** CCL - Configurable Custom Logic\n;*************************************************************************\n\n.equ CCL_CTRLA = 0x01C0                  ; Control Register A\n.equ CCL_SEQCTRL0 = 0x01C1               ; Sequential Control 0\n.equ CCL_LUT0CTRLA = 0x01C5              ; LUT Control 0 A\n.equ CCL_LUT0CTRLB = 0x01C6              ; LUT Control 0 B\n.equ CCL_LUT0CTRLC = 0x01C7              ; LUT Control 0 C\n.equ CCL_TRUTH0 = 0x01C8                 ; Truth 0\n.equ CCL_LUT1CTRLA = 0x01C9              ; LUT Control 1 A\n.equ CCL_LUT1CTRLB = 0x01CA              ; LUT Control 1 B\n.equ CCL_LUT1CTRLC = 0x01CB              ; LUT Control 1 C\n.equ CCL_TRUTH1 = 0x01CC                 ; Truth 1\n\n;*************************************************************************\n;** CLKCTRL - Clock controller\n;*************************************************************************\n\n.equ CLKCTRL_MCLKCTRLA = 0x0060          ; MCLK Control A\n.equ CLKCTRL_MCLKCTRLB = 0x0061          ; MCLK Control B\n.equ CLKCTRL_MCLKLOCK = 0x0062           ; MCLK Lock\n.equ CLKCTRL_MCLKSTATUS = 0x0063         ; MCLK Status\n.equ CLKCTRL_OSC20MCTRLA = 0x0070        ; OSC20M Control A\n.equ CLKCTRL_OSC20MCALIBA = 0x0071       ; OSC20M Calibration A\n.equ CLKCTRL_OSC20MCALIBB = 0x0072       ; OSC20M Calibration B\n.equ CLKCTRL_OSC32KCTRLA = 0x0078        ; OSC32K Control A\n\n;*************************************************************************\n;** CPU - CPU\n;*************************************************************************\n\n.equ CPU_CCP = 0x0034                    ; Configuration Change Protection\n.equ CPU_SPL = 0x003D                    ; Stack Pointer Low\n.equ CPU_SPH = 0x003E                    ; Stack Pointer High\n.equ CPU_SREG = 0x003F                   ; Status Register\n\n;*************************************************************************\n;** CPUINT - Interrupt Controller\n;*************************************************************************\n\n.equ CPUINT_CTRLA = 0x0110               ; Control A\n.equ CPUINT_STATUS = 0x0111              ; Status\n.equ CPUINT_LVL0PRI = 0x0112             ; Interrupt Level 0 Priority\n.equ CPUINT_LVL1VEC = 0x0113             ; Interrupt Level 1 Priority Vector\n\n;*************************************************************************\n;** CRCSCAN - CRCSCAN\n;*************************************************************************\n\n.equ CRCSCAN_CTRLA = 0x0120              ; Control A\n.equ CRCSCAN_CTRLB = 0x0121              ; Control B\n.equ CRCSCAN_STATUS = 0x0122             ; Status\n\n;*************************************************************************\n;** EVSYS - Event System\n;*************************************************************************\n\n.equ EVSYS_ASYNCSTROBE = 0x0180          ; Asynchronous Channel Strobe\n.equ EVSYS_SYNCSTROBE = 0x0181           ; Synchronous Channel Strobe\n.equ EVSYS_ASYNCCH0 = 0x0182             ; Asynchronous Channel 0 Generator Selection\n.equ EVSYS_ASYNCCH1 = 0x0183             ; Asynchronous Channel 1 Generator Selection\n.equ EVSYS_SYNCCH0 = 0x018A              ; Synchronous Channel 0 Generator Selection\n.equ EVSYS_SYNCCH1 = 0x018B              ; Synchronous Channel 1 Generator Selection\n.equ EVSYS_ASYNCUSER0 = 0x0192           ; Asynchronous User Ch 0 Input Selection - TCB0\n.equ EVSYS_ASYNCUSER1 = 0x0193           ; Asynchronous User Ch 1 Input Selection - ADC0\n.equ EVSYS_ASYNCUSER2 = 0x0194           ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0\n.equ EVSYS_ASYNCUSER3 = 0x0195           ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0\n.equ EVSYS_ASYNCUSER4 = 0x0196           ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1\n.equ EVSYS_ASYNCUSER5 = 0x0197           ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1\n.equ EVSYS_ASYNCUSER6 = 0x0198           ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0\n.equ EVSYS_ASYNCUSER7 = 0x0199           ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1\n.equ EVSYS_ASYNCUSER8 = 0x019A           ; Asynchronous User Ch 8 Input Selection - Event Out 0\n.equ EVSYS_ASYNCUSER9 = 0x019B           ; Asynchronous User Ch 9 Input Selection - Event Out 1\n.equ EVSYS_ASYNCUSER10 = 0x019C          ; Asynchronous User Ch 10 Input Selection - Event Out 2\n.equ EVSYS_SYNCUSER0 = 0x01A2            ; Synchronous User Ch 0 Input Selection - TCA0\n\n;*************************************************************************\n;** FUSE - Fuses\n;*************************************************************************\n\n.equ FUSE_WDTCFG = 0x1280                ; Watchdog Configuration\n.equ FUSE_BODCFG = 0x1281                ; BOD Configuration\n.equ FUSE_OSCCFG = 0x1282                ; Oscillator Configuration\n.equ FUSE_TCD0CFG = 0x1284               ; TCD0 Configuration\n.equ FUSE_SYSCFG0 = 0x1285               ; System Configuration 0\n.equ FUSE_SYSCFG1 = 0x1286               ; System Configuration 1\n.equ FUSE_APPEND = 0x1287                ; Application Code Section End\n.equ FUSE_BOOTEND = 0x1288               ; Boot Section End\n\n;*************************************************************************\n;** GPIO - General Purpose IO\n;*************************************************************************\n\n.equ GPIO_GPIOR0 = 0x001C                ; General Purpose IO Register 0\n.equ GPIO_GPIOR1 = 0x001D                ; General Purpose IO Register 1\n.equ GPIO_GPIOR2 = 0x001E                ; General Purpose IO Register 2\n.equ GPIO_GPIOR3 = 0x001F                ; General Purpose IO Register 3\n\n;*************************************************************************\n;** LOCKBIT - Lockbit\n;*************************************************************************\n\n.equ LOCKBIT_LOCKBIT = 0x128A            ; Lock bits\n\n;*************************************************************************\n;** NVMCTRL - Non-volatile Memory Controller\n;*************************************************************************\n\n.equ NVMCTRL_CTRLA = 0x1000              ; Control A\n.equ NVMCTRL_CTRLB = 0x1001              ; Control B\n.equ NVMCTRL_STATUS = 0x1002             ; Status\n.equ NVMCTRL_INTCTRL = 0x1003            ; Interrupt Control\n.equ NVMCTRL_INTFLAGS = 0x1004           ; Interrupt Flags\n.equ NVMCTRL_DATA = 0x1006               ; Data\n.equ NVMCTRL_DATAL = 0x1006              ; Data low byte\n.equ NVMCTRL_DATAH = 0x1007              ; Data hi byte\n.equ NVMCTRL_ADDR = 0x1008               ; Address\n.equ NVMCTRL_ADDRL = 0x1008              ; Address low byte\n.equ NVMCTRL_ADDRH = 0x1009              ; Address hi byte\n\n;*************************************************************************\n;** PORTA - I/O Ports\n;*************************************************************************\n\n.equ PORTA_DIR = 0x0400                  ; Data Direction\n.equ PORTA_DIRSET = 0x0401               ; Data Direction Set\n.equ PORTA_DIRCLR = 0x0402               ; Data Direction Clear\n.equ PORTA_DIRTGL = 0x0403               ; Data Direction Toggle\n.equ PORTA_OUT = 0x0404                  ; Output Value\n.equ PORTA_OUTSET = 0x0405               ; Output Value Set\n.equ PORTA_OUTCLR = 0x0406               ; Output Value Clear\n.equ PORTA_OUTTGL = 0x0407               ; Output Value Toggle\n.equ PORTA_IN = 0x0408                   ; Input Value\n.equ PORTA_INTFLAGS = 0x0409             ; Interrupt Flags\n.equ PORTA_PIN0CTRL = 0x0410             ; Pin 0 Control\n.equ PORTA_PIN1CTRL = 0x0411             ; Pin 1 Control\n.equ PORTA_PIN2CTRL = 0x0412             ; Pin 2 Control\n.equ PORTA_PIN3CTRL = 0x0413             ; Pin 3 Control\n.equ PORTA_PIN4CTRL = 0x0414             ; Pin 4 Control\n.equ PORTA_PIN5CTRL = 0x0415             ; Pin 5 Control\n.equ PORTA_PIN6CTRL = 0x0416             ; Pin 6 Control\n.equ PORTA_PIN7CTRL = 0x0417             ; Pin 7 Control\n\n;*************************************************************************\n;** PORTMUX - Port Multiplexer\n;*************************************************************************\n\n.equ PORTMUX_CTRLA = 0x0200              ; Port Multiplexer Control A\n.equ PORTMUX_CTRLB = 0x0201              ; Port Multiplexer Control B\n.equ PORTMUX_CTRLC = 0x0202              ; Port Multiplexer Control C\n.equ PORTMUX_CTRLD = 0x0203              ; Port Multiplexer Control D\n\n;*************************************************************************\n;** RSTCTRL - Reset controller\n;*************************************************************************\n\n.equ RSTCTRL_RSTFR = 0x0040              ; Reset Flags\n.equ RSTCTRL_SWRR = 0x0041               ; Software Reset\n\n;*************************************************************************\n;** RTC - Real-Time Counter\n;*************************************************************************\n\n.equ RTC_CTRLA = 0x0140                  ; Control A\n.equ RTC_STATUS = 0x0141                 ; Status\n.equ RTC_INTCTRL = 0x0142                ; Interrupt Control\n.equ RTC_INTFLAGS = 0x0143               ; Interrupt Flags\n.equ RTC_TEMP = 0x0144                   ; Temporary\n.equ RTC_DBGCTRL = 0x0145                ; Debug control\n.equ RTC_CLKSEL = 0x0147                 ; Clock Select\n.equ RTC_CNT = 0x0148                    ; Counter\n.equ RTC_CNTL = 0x0148                   ; Counter low byte\n.equ RTC_CNTH = 0x0149                   ; Counter hi byte\n.equ RTC_PER = 0x014A                    ; Period\n.equ RTC_PERL = 0x014A                   ; Period low byte\n.equ RTC_PERH = 0x014B                   ; Period hi byte\n.equ RTC_CMP = 0x014C                    ; Compare\n.equ RTC_CMPL = 0x014C                   ; Compare low byte\n.equ RTC_CMPH = 0x014D                   ; Compare hi byte\n.equ RTC_PITCTRLA = 0x0150               ; PIT Control A\n.equ RTC_PITSTATUS = 0x0151              ; PIT Status\n.equ RTC_PITINTCTRL = 0x0152             ; PIT Interrupt Control\n.equ RTC_PITINTFLAGS = 0x0153            ; PIT Interrupt Flags\n.equ RTC_PITDBGCTRL = 0x0155             ; PIT Debug control\n\n;*************************************************************************\n;** SIGROW - Signature row\n;*************************************************************************\n\n.equ SIGROW_DEVICEID0 = 0x1100           ; Device ID Byte 0\n.equ SIGROW_DEVICEID1 = 0x1101           ; Device ID Byte 1\n.equ SIGROW_DEVICEID2 = 0x1102           ; Device ID Byte 2\n.equ SIGROW_SERNUM0 = 0x1103             ; Serial Number Byte 0\n.equ SIGROW_SERNUM1 = 0x1104             ; Serial Number Byte 1\n.equ SIGROW_SERNUM2 = 0x1105             ; Serial Number Byte 2\n.equ SIGROW_SERNUM3 = 0x1106             ; Serial Number Byte 3\n.equ SIGROW_SERNUM4 = 0x1107             ; Serial Number Byte 4\n.equ SIGROW_SERNUM5 = 0x1108             ; Serial Number Byte 5\n.equ SIGROW_SERNUM6 = 0x1109             ; Serial Number Byte 6\n.equ SIGROW_SERNUM7 = 0x110A             ; Serial Number Byte 7\n.equ SIGROW_SERNUM8 = 0x110B             ; Serial Number Byte 8\n.equ SIGROW_SERNUM9 = 0x110C             ; Serial Number Byte 9\n.equ SIGROW_TEMPSENSE0 = 0x1120          ; Temperature Sensor Calibration Byte 0\n.equ SIGROW_TEMPSENSE1 = 0x1121          ; Temperature Sensor Calibration Byte 1\n.equ SIGROW_OSC16ERR3V = 0x1122          ; OSC16 error at 3V\n.equ SIGROW_OSC16ERR5V = 0x1123          ; OSC16 error at 5V\n.equ SIGROW_OSC20ERR3V = 0x1124          ; OSC20 error at 3V\n.equ SIGROW_OSC20ERR5V = 0x1125          ; OSC20 error at 5V\n\n;*************************************************************************\n;** SLPCTRL - Sleep Controller\n;*************************************************************************\n\n.equ SLPCTRL_CTRLA = 0x0050              ; Control\n\n;*************************************************************************\n;** SPI0 - Serial Peripheral Interface\n;*************************************************************************\n\n.equ SPI0_CTRLA = 0x0820                 ; Control A\n.equ SPI0_CTRLB = 0x0821                 ; Control B\n.equ SPI0_INTCTRL = 0x0822               ; Interrupt Control\n.equ SPI0_INTFLAGS = 0x0823              ; Interrupt Flags\n.equ SPI0_DATA = 0x0824                  ; Data\n\n;*************************************************************************\n;** SYSCFG - System Configuration Registers\n;*************************************************************************\n\n.equ SYSCFG_REVID = 0x0F01               ; Revision ID\n.equ SYSCFG_EXTBRK = 0x0F02              ; External Break\n\n;*************************************************************************\n;** TCA0 - 16-bit Timer/Counter Type A\n;*************************************************************************\n\n.equ TCA0_SINGLE_CTRLA = 0x0A00          ; SINGLE Control A\n.equ TCA0_SINGLE_CTRLB = 0x0A01          ; SINGLE Control B\n.equ TCA0_SINGLE_CTRLC = 0x0A02          ; SINGLE Control C\n.equ TCA0_SINGLE_CTRLD = 0x0A03          ; SINGLE Control D\n.equ TCA0_SINGLE_CTRLECLR = 0x0A04       ; SINGLE Control E Clear\n.equ TCA0_SINGLE_CTRLESET = 0x0A05       ; SINGLE Control E Set\n.equ TCA0_SINGLE_CTRLFCLR = 0x0A06       ; SINGLE Control F Clear\n.equ TCA0_SINGLE_CTRLFSET = 0x0A07       ; SINGLE Control F Set\n.equ TCA0_SINGLE_EVCTRL = 0x0A09         ; SINGLE Event Control\n.equ TCA0_SINGLE_INTCTRL = 0x0A0A        ; SINGLE Interrupt Control\n.equ TCA0_SINGLE_INTFLAGS = 0x0A0B       ; SINGLE Interrupt Flags\n.equ TCA0_SINGLE_DBGCTRL = 0x0A0E        ; SINGLE Degbug Control\n.equ TCA0_SINGLE_TEMP = 0x0A0F           ; SINGLE Temporary data for 16-bit Access\n.equ TCA0_SINGLE_CNT = 0x0A20            ; SINGLE Count\n.equ TCA0_SINGLE_PER = 0x0A26            ; SINGLE Period\n.equ TCA0_SINGLE_CMP0 = 0x0A28           ; SINGLE Compare 0\n.equ TCA0_SINGLE_CMP1 = 0x0A2A           ; SINGLE Compare 1\n.equ TCA0_SINGLE_CMP2 = 0x0A2C           ; SINGLE Compare 2\n.equ TCA0_SINGLE_PERBUF = 0x0A36         ; SINGLE Period Buffer\n.equ TCA0_SINGLE_CMP0BUF = 0x0A38        ; SINGLE Compare 0 Buffer\n.equ TCA0_SINGLE_CMP1BUF = 0x0A3A        ; SINGLE Compare 1 Buffer\n.equ TCA0_SINGLE_CMP2BUF = 0x0A3C        ; SINGLE Compare 2 Buffer\n.equ TCA0_SPLIT_CTRLA = 0x0A00           ; SPLIT Control A\n.equ TCA0_SPLIT_CTRLB = 0x0A01           ; SPLIT Control B\n.equ TCA0_SPLIT_CTRLC = 0x0A02           ; SPLIT Control C\n.equ TCA0_SPLIT_CTRLD = 0x0A03           ; SPLIT Control D\n.equ TCA0_SPLIT_CTRLECLR = 0x0A04        ; SPLIT Control E Clear\n.equ TCA0_SPLIT_CTRLESET = 0x0A05        ; SPLIT Control E Set\n.equ TCA0_SPLIT_INTCTRL = 0x0A0A         ; SPLIT Interrupt Control\n.equ TCA0_SPLIT_INTFLAGS = 0x0A0B        ; SPLIT Interrupt Flags\n.equ TCA0_SPLIT_DBGCTRL = 0x0A0E         ; SPLIT Degbug Control\n.equ TCA0_SPLIT_LCNT = 0x0A20            ; SPLIT Low Count\n.equ TCA0_SPLIT_HCNT = 0x0A21            ; SPLIT High Count\n.equ TCA0_SPLIT_LPER = 0x0A26            ; SPLIT Low Period\n.equ TCA0_SPLIT_HPER = 0x0A27            ; SPLIT High Period\n.equ TCA0_SPLIT_LCMP0 = 0x0A28           ; SPLIT Low Compare\n.equ TCA0_SPLIT_HCMP0 = 0x0A29           ; SPLIT High Compare\n.equ TCA0_SPLIT_LCMP1 = 0x0A2A           ; SPLIT Low Compare\n.equ TCA0_SPLIT_HCMP1 = 0x0A2B           ; SPLIT High Compare\n.equ TCA0_SPLIT_LCMP2 = 0x0A2C           ; SPLIT Low Compare\n.equ TCA0_SPLIT_HCMP2 = 0x0A2D           ; SPLIT High Compare\n\n;*************************************************************************\n;** TCB0 - 16-bit Timer Type B\n;*************************************************************************\n\n.equ TCB0_CTRLA = 0x0A40                 ; Control A\n.equ TCB0_CTRLB = 0x0A41                 ; Control Register B\n.equ TCB0_EVCTRL = 0x0A44                ; Event Control\n.equ TCB0_INTCTRL = 0x0A45               ; Interrupt Control\n.equ TCB0_INTFLAGS = 0x0A46              ; Interrupt Flags\n.equ TCB0_STATUS = 0x0A47                ; Status\n.equ TCB0_DBGCTRL = 0x0A48               ; Debug Control\n.equ TCB0_TEMP = 0x0A49                  ; Temporary Value\n.equ TCB0_CNT = 0x0A4A                   ; Count\n.equ TCB0_CNTL = 0x0A4A                  ; Count low byte\n.equ TCB0_CNTH = 0x0A4B                  ; Count hi byte\n.equ TCB0_CCMP = 0x0A4C                  ; Compare or Capture\n.equ TCB0_CCMPL = 0x0A4C                 ; Compare or Capture low byte\n.equ TCB0_CCMPH = 0x0A4D                 ; Compare or Capture hi byte\n\n;*************************************************************************\n;** TWI0 - Two-Wire Interface\n;*************************************************************************\n\n.equ TWI0_CTRLA = 0x0810                 ; Control A\n.equ TWI0_DBGCTRL = 0x0812               ; Debug Control Register\n.equ TWI0_MCTRLA = 0x0813                ; Master Control A\n.equ TWI0_MCTRLB = 0x0814                ; Master Control B\n.equ TWI0_MSTATUS = 0x0815               ; Master Status\n.equ TWI0_MBAUD = 0x0816                 ; Master Baurd Rate Control\n.equ TWI0_MADDR = 0x0817                 ; Master Address\n.equ TWI0_MDATA = 0x0818                 ; Master Data\n.equ TWI0_SCTRLA = 0x0819                ; Slave Control A\n.equ TWI0_SCTRLB = 0x081A                ; Slave Control B\n.equ TWI0_SSTATUS = 0x081B               ; Slave Status\n.equ TWI0_SADDR = 0x081C                 ; Slave Address\n.equ TWI0_SDATA = 0x081D                 ; Slave Data\n.equ TWI0_SADDRMASK = 0x081E             ; Slave Address Mask\n\n;*************************************************************************\n;** USART0 - Universal Synchronous and Asynchronous Receiver and Transmitter\n;*************************************************************************\n\n.equ USART0_RXDATAL = 0x0800             ; Receive Data Low Byte\n.equ USART0_RXDATAH = 0x0801             ; Receive Data High Byte\n.equ USART0_TXDATAL = 0x0802             ; Transmit Data Low Byte\n.equ USART0_TXDATAH = 0x0803             ; Transmit Data High Byte\n.equ USART0_STATUS = 0x0804              ; Status\n.equ USART0_CTRLA = 0x0805               ; Control A\n.equ USART0_CTRLB = 0x0806               ; Control B\n.equ USART0_CTRLC = 0x0807               ; Control C\n.equ USART0_BAUD = 0x0808                ; Baud Rate\n.equ USART0_BAUDL = 0x0808               ; Baud Rate low byte\n.equ USART0_BAUDH = 0x0809               ; Baud Rate hi byte\n.equ USART0_DBGCTRL = 0x080B             ; Debug Control\n.equ USART0_EVCTRL = 0x080C              ; Event Control\n.equ USART0_TXPLCTRL = 0x080D            ; IRCOM Transmitter Pulse Length Control\n.equ USART0_RXPLCTRL = 0x080E            ; IRCOM Receiver Pulse Length Control\n\n;*************************************************************************\n;** USERROW - User Row\n;*************************************************************************\n\n.equ USERROW_USERROW0 = 0x1300           ; User Row Byte 0\n.equ USERROW_USERROW1 = 0x1301           ; User Row Byte 1\n.equ USERROW_USERROW2 = 0x1302           ; User Row Byte 2\n.equ USERROW_USERROW3 = 0x1303           ; User Row Byte 3\n.equ USERROW_USERROW4 = 0x1304           ; User Row Byte 4\n.equ USERROW_USERROW5 = 0x1305           ; User Row Byte 5\n.equ USERROW_USERROW6 = 0x1306           ; User Row Byte 6\n.equ USERROW_USERROW7 = 0x1307           ; User Row Byte 7\n.equ USERROW_USERROW8 = 0x1308           ; User Row Byte 8\n.equ USERROW_USERROW9 = 0x1309           ; User Row Byte 9\n.equ USERROW_USERROW10 = 0x130A          ; User Row Byte 10\n.equ USERROW_USERROW11 = 0x130B          ; User Row Byte 11\n.equ USERROW_USERROW12 = 0x130C          ; User Row Byte 12\n.equ USERROW_USERROW13 = 0x130D          ; User Row Byte 13\n.equ USERROW_USERROW14 = 0x130E          ; User Row Byte 14\n.equ USERROW_USERROW15 = 0x130F          ; User Row Byte 15\n.equ USERROW_USERROW16 = 0x1310          ; User Row Byte 16\n.equ USERROW_USERROW17 = 0x1311          ; User Row Byte 17\n.equ USERROW_USERROW18 = 0x1312          ; User Row Byte 18\n.equ USERROW_USERROW19 = 0x1313          ; User Row Byte 19\n.equ USERROW_USERROW20 = 0x1314          ; User Row Byte 20\n.equ USERROW_USERROW21 = 0x1315          ; User Row Byte 21\n.equ USERROW_USERROW22 = 0x1316          ; User Row Byte 22\n.equ USERROW_USERROW23 = 0x1317          ; User Row Byte 23\n.equ USERROW_USERROW24 = 0x1318          ; User Row Byte 24\n.equ USERROW_USERROW25 = 0x1319          ; User Row Byte 25\n.equ USERROW_USERROW26 = 0x131A          ; User Row Byte 26\n.equ USERROW_USERROW27 = 0x131B          ; User Row Byte 27\n.equ USERROW_USERROW28 = 0x131C          ; User Row Byte 28\n.equ USERROW_USERROW29 = 0x131D          ; User Row Byte 29\n.equ USERROW_USERROW30 = 0x131E          ; User Row Byte 30\n.equ USERROW_USERROW31 = 0x131F          ; User Row Byte 31\n\n;*************************************************************************\n;** VPORTA - Virtual Ports\n;*************************************************************************\n\n.equ VPORTA_DIR = 0x0000                 ; Data Direction\n.equ VPORTA_OUT = 0x0001                 ; Output Value\n.equ VPORTA_IN = 0x0002                  ; Input Value\n.equ VPORTA_INTFLAGS = 0x0003            ; Interrupt Flags\n\n;*************************************************************************\n;** VPORTB - Virtual Ports\n;*************************************************************************\n\n.equ VPORTB_DIR = 0x0004                 ; Data Direction\n.equ VPORTB_OUT = 0x0005                 ; Output Value\n.equ VPORTB_IN = 0x0006                  ; Input Value\n.equ VPORTB_INTFLAGS = 0x0007            ; Interrupt Flags\n\n;*************************************************************************\n;** VPORTC - Virtual Ports\n;*************************************************************************\n\n.equ VPORTC_DIR = 0x0008                 ; Data Direction\n.equ VPORTC_OUT = 0x0009                 ; Output Value\n.equ VPORTC_IN = 0x000A                  ; Input Value\n.equ VPORTC_INTFLAGS = 0x000B            ; Interrupt Flags\n\n;*************************************************************************\n;** VREF - Voltage reference\n;*************************************************************************\n\n.equ VREF_CTRLA = 0x00A0                 ; Control A\n.equ VREF_CTRLB = 0x00A1                 ; Control B\n\n;*************************************************************************\n;** WDT - Watch-Dog Timer\n;*************************************************************************\n\n.equ WDT_CTRLA = 0x0100                  ; Control A\n.equ WDT_STATUS = 0x0101                 ; Status\n\n\n; ***** ALL MODULE BASE ADRESSES *****************************************\n\n.equ AC0_base = 0x0670                   ; Analog Comparator\n.equ ADC0_base = 0x0600                  ; Analog to Digital Converter\n.equ BOD_base = 0x0080                   ; Bod interface\n.equ CCL_base = 0x01C0                   ; Configurable Custom Logic\n.equ CLKCTRL_base = 0x0060               ; Clock controller\n.equ CPU_base = 0x0030                   ; CPU\n.equ CPUINT_base = 0x0110                ; Interrupt Controller\n.equ CRCSCAN_base = 0x0120               ; CRCSCAN\n.equ EVSYS_base = 0x0180                 ; Event System\n.equ FUSE_base = 0x1280                  ; Fuses\n.equ GPIO_base = 0x001C                  ; General Purpose IO\n.equ LOCKBIT_base = 0x128A               ; Lockbit\n.equ NVMCTRL_base = 0x1000               ; Non-volatile Memory Controller\n.equ PORTA_base = 0x0400                 ; I/O Ports\n.equ PORTMUX_base = 0x0200               ; Port Multiplexer\n.equ RSTCTRL_base = 0x0040               ; Reset controller\n.equ RTC_base = 0x0140                   ; Real-Time Counter\n.equ SIGROW_base = 0x1100                ; Signature row\n.equ SLPCTRL_base = 0x0050               ; Sleep Controller\n.equ SPI0_base = 0x0820                  ; Serial Peripheral Interface\n.equ SYSCFG_base = 0x0F00                ; System Configuration Registers\n.equ TCA0_base = 0x0A00                  ; 16-bit Timer/Counter Type A\n.equ TCB0_base = 0x0A40                  ; 16-bit Timer Type B\n.equ TWI0_base = 0x0810                  ; Two-Wire Interface\n.equ USART0_base = 0x0800                ; Universal Synchronous and Asynchronous Receiver and Transmitter\n.equ USERROW_base = 0x1300               ; User Row\n.equ VPORTA_base = 0x0000                ; Virtual Ports\n.equ VPORTB_base = 0x0004                ; Virtual Ports\n.equ VPORTC_base = 0x0008                ; Virtual Ports\n.equ VREF_base = 0x00A0                  ; Voltage reference\n.equ WDT_base = 0x0100                   ; Watch-Dog Timer\n\n\n; ***** IO REGISTER OFFSETS **********************************************\n\n\n;*************************************************************************\n;** AC - Analog Comparator\n;*************************************************************************\n.equ AC_CTRLA_offset = 0x00              ; Control A\n.equ AC_MUXCTRLA_offset = 0x02           ; Mux Control A\n.equ AC_INTCTRL_offset = 0x06            ; Interrupt Control\n.equ AC_STATUS_offset = 0x07             ; Status\n\n;*************************************************************************\n;** ADC - Analog to Digital Converter\n;*************************************************************************\n.equ ADC_CTRLA_offset = 0x00             ; Control A\n.equ ADC_CTRLB_offset = 0x01             ; Control B\n.equ ADC_CTRLC_offset = 0x02             ; Control C\n.equ ADC_CTRLD_offset = 0x03             ; Control D\n.equ ADC_CTRLE_offset = 0x04             ; Control E\n.equ ADC_SAMPCTRL_offset = 0x05          ; Sample Control\n.equ ADC_MUXPOS_offset = 0x06            ; Positive mux input\n.equ ADC_COMMAND_offset = 0x08           ; Command\n.equ ADC_EVCTRL_offset = 0x09            ; Event Control\n.equ ADC_INTCTRL_offset = 0x0A           ; Interrupt Control\n.equ ADC_INTFLAGS_offset = 0x0B          ; Interrupt Flags\n.equ ADC_DBGCTRL_offset = 0x0C           ; Debug Control\n.equ ADC_TEMP_offset = 0x0D              ; Temporary Data\n.equ ADC_RES_offset = 0x10               ; ADC Accumulator Result\n.equ ADC_WINLT_offset = 0x12             ; Window comparator low threshold\n.equ ADC_WINHT_offset = 0x14             ; Window comparator high threshold\n.equ ADC_CALIB_offset = 0x16             ; Calibration\n\n;*************************************************************************\n;** BOD - Bod interface\n;*************************************************************************\n.equ BOD_CTRLA_offset = 0x00             ; Control A\n.equ BOD_CTRLB_offset = 0x01             ; Control B\n.equ BOD_VLMCTRLA_offset = 0x08          ; Voltage level monitor Control\n.equ BOD_INTCTRL_offset = 0x09           ; Voltage level monitor interrupt Control\n.equ BOD_INTFLAGS_offset = 0x0A          ; Voltage level monitor interrupt Flags\n.equ BOD_STATUS_offset = 0x0B            ; Voltage level monitor status\n\n;*************************************************************************\n;** CCL - Configurable Custom Logic\n;*************************************************************************\n.equ CCL_CTRLA_offset = 0x00             ; Control Register A\n.equ CCL_SEQCTRL0_offset = 0x01          ; Sequential Control 0\n.equ CCL_LUT0CTRLA_offset = 0x05         ; LUT Control 0 A\n.equ CCL_LUT0CTRLB_offset = 0x06         ; LUT Control 0 B\n.equ CCL_LUT0CTRLC_offset = 0x07         ; LUT Control 0 C\n.equ CCL_TRUTH0_offset = 0x08            ; Truth 0\n.equ CCL_LUT1CTRLA_offset = 0x09         ; LUT Control 1 A\n.equ CCL_LUT1CTRLB_offset = 0x0A         ; LUT Control 1 B\n.equ CCL_LUT1CTRLC_offset = 0x0B         ; LUT Control 1 C\n.equ CCL_TRUTH1_offset = 0x0C            ; Truth 1\n\n;*************************************************************************\n;** CLKCTRL - Clock controller\n;*************************************************************************\n.equ CLKCTRL_MCLKCTRLA_offset = 0x00     ; MCLK Control A\n.equ CLKCTRL_MCLKCTRLB_offset = 0x01     ; MCLK Control B\n.equ CLKCTRL_MCLKLOCK_offset = 0x02      ; MCLK Lock\n.equ CLKCTRL_MCLKSTATUS_offset = 0x03    ; MCLK Status\n.equ CLKCTRL_OSC20MCTRLA_offset = 0x10   ; OSC20M Control A\n.equ CLKCTRL_OSC20MCALIBA_offset = 0x11  ; OSC20M Calibration A\n.equ CLKCTRL_OSC20MCALIBB_offset = 0x12  ; OSC20M Calibration B\n.equ CLKCTRL_OSC32KCTRLA_offset = 0x18   ; OSC32K Control A\n\n;*************************************************************************\n;** CPU - CPU\n;*************************************************************************\n.equ CPU_CCP_offset = 0x04               ; Configuration Change Protection\n.equ CPU_SPL_offset = 0x0D               ; Stack Pointer Low\n.equ CPU_SPH_offset = 0x0E               ; Stack Pointer High\n.equ CPU_SREG_offset = 0x0F              ; Status Register\n\n;*************************************************************************\n;** CPUINT - Interrupt Controller\n;*************************************************************************\n.equ CPUINT_CTRLA_offset = 0x00          ; Control A\n.equ CPUINT_STATUS_offset = 0x01         ; Status\n.equ CPUINT_LVL0PRI_offset = 0x02        ; Interrupt Level 0 Priority\n.equ CPUINT_LVL1VEC_offset = 0x03        ; Interrupt Level 1 Priority Vector\n\n;*************************************************************************\n;** CRCSCAN - CRCSCAN\n;*************************************************************************\n.equ CRCSCAN_CTRLA_offset = 0x00         ; Control A\n.equ CRCSCAN_CTRLB_offset = 0x01         ; Control B\n.equ CRCSCAN_STATUS_offset = 0x02        ; Status\n\n;*************************************************************************\n;** EVSYS - Event System\n;*************************************************************************\n.equ EVSYS_ASYNCSTROBE_offset = 0x00     ; Asynchronous Channel Strobe\n.equ EVSYS_SYNCSTROBE_offset = 0x01      ; Synchronous Channel Strobe\n.equ EVSYS_ASYNCCH0_offset = 0x02        ; Asynchronous Channel 0 Generator Selection\n.equ EVSYS_ASYNCCH1_offset = 0x03        ; Asynchronous Channel 1 Generator Selection\n.equ EVSYS_SYNCCH0_offset = 0x0A         ; Synchronous Channel 0 Generator Selection\n.equ EVSYS_SYNCCH1_offset = 0x0B         ; Synchronous Channel 1 Generator Selection\n.equ EVSYS_ASYNCUSER0_offset = 0x12      ; Asynchronous User Ch 0 Input Selection - TCB0\n.equ EVSYS_ASYNCUSER1_offset = 0x13      ; Asynchronous User Ch 1 Input Selection - ADC0\n.equ EVSYS_ASYNCUSER2_offset = 0x14      ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0\n.equ EVSYS_ASYNCUSER3_offset = 0x15      ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0\n.equ EVSYS_ASYNCUSER4_offset = 0x16      ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1\n.equ EVSYS_ASYNCUSER5_offset = 0x17      ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1\n.equ EVSYS_ASYNCUSER6_offset = 0x18      ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0\n.equ EVSYS_ASYNCUSER7_offset = 0x19      ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1\n.equ EVSYS_ASYNCUSER8_offset = 0x1A      ; Asynchronous User Ch 8 Input Selection - Event Out 0\n.equ EVSYS_ASYNCUSER9_offset = 0x1B      ; Asynchronous User Ch 9 Input Selection - Event Out 1\n.equ EVSYS_ASYNCUSER10_offset = 0x1C     ; Asynchronous User Ch 10 Input Selection - Event Out 2\n.equ EVSYS_SYNCUSER0_offset = 0x22       ; Synchronous User Ch 0 Input Selection - TCA0\n\n;*************************************************************************\n;** FUSE - Fuses\n;*************************************************************************\n.equ FUSE_WDTCFG_offset = 0x00           ; Watchdog Configuration\n.equ FUSE_BODCFG_offset = 0x01           ; BOD Configuration\n.equ FUSE_OSCCFG_offset = 0x02           ; Oscillator Configuration\n.equ FUSE_TCD0CFG_offset = 0x04          ; TCD0 Configuration\n.equ FUSE_SYSCFG0_offset = 0x05          ; System Configuration 0\n.equ FUSE_SYSCFG1_offset = 0x06          ; System Configuration 1\n.equ FUSE_APPEND_offset = 0x07           ; Application Code Section End\n.equ FUSE_BOOTEND_offset = 0x08          ; Boot Section End\n\n;*************************************************************************\n;** GPIO - General Purpose IO\n;*************************************************************************\n.equ GPIO_GPIOR0_offset = 0x00           ; General Purpose IO Register 0\n.equ GPIO_GPIOR1_offset = 0x01           ; General Purpose IO Register 1\n.equ GPIO_GPIOR2_offset = 0x02           ; General Purpose IO Register 2\n.equ GPIO_GPIOR3_offset = 0x03           ; General Purpose IO Register 3\n\n;*************************************************************************\n;** LOCKBIT - Lockbit\n;*************************************************************************\n.equ LOCKBIT_LOCKBIT_offset = 0x00       ; Lock bits\n\n;*************************************************************************\n;** NVMCTRL - Non-volatile Memory Controller\n;*************************************************************************\n.equ NVMCTRL_CTRLA_offset = 0x00         ; Control A\n.equ NVMCTRL_CTRLB_offset = 0x01         ; Control B\n.equ NVMCTRL_STATUS_offset = 0x02        ; Status\n.equ NVMCTRL_INTCTRL_offset = 0x03       ; Interrupt Control\n.equ NVMCTRL_INTFLAGS_offset = 0x04      ; Interrupt Flags\n.equ NVMCTRL_DATA_offset = 0x06          ; Data\n.equ NVMCTRL_ADDR_offset = 0x08          ; Address\n\n;*************************************************************************\n;** PORT - I/O Ports\n;*************************************************************************\n.equ PORT_DIR_offset = 0x00              ; Data Direction\n.equ PORT_DIRSET_offset = 0x01           ; Data Direction Set\n.equ PORT_DIRCLR_offset = 0x02           ; Data Direction Clear\n.equ PORT_DIRTGL_offset = 0x03           ; Data Direction Toggle\n.equ PORT_OUT_offset = 0x04              ; Output Value\n.equ PORT_OUTSET_offset = 0x05           ; Output Value Set\n.equ PORT_OUTCLR_offset = 0x06           ; Output Value Clear\n.equ PORT_OUTTGL_offset = 0x07           ; Output Value Toggle\n.equ PORT_IN_offset = 0x08               ; Input Value\n.equ PORT_INTFLAGS_offset = 0x09         ; Interrupt Flags\n.equ PORT_PIN0CTRL_offset = 0x10         ; Pin 0 Control\n.equ PORT_PIN1CTRL_offset = 0x11         ; Pin 1 Control\n.equ PORT_PIN2CTRL_offset = 0x12         ; Pin 2 Control\n.equ PORT_PIN3CTRL_offset = 0x13         ; Pin 3 Control\n.equ PORT_PIN4CTRL_offset = 0x14         ; Pin 4 Control\n.equ PORT_PIN5CTRL_offset = 0x15         ; Pin 5 Control\n.equ PORT_PIN6CTRL_offset = 0x16         ; Pin 6 Control\n.equ PORT_PIN7CTRL_offset = 0x17         ; Pin 7 Control\n\n;*************************************************************************\n;** PORTMUX - Port Multiplexer\n;*************************************************************************\n.equ PORTMUX_CTRLA_offset = 0x00         ; Port Multiplexer Control A\n.equ PORTMUX_CTRLB_offset = 0x01         ; Port Multiplexer Control B\n.equ PORTMUX_CTRLC_offset = 0x02         ; Port Multiplexer Control C\n.equ PORTMUX_CTRLD_offset = 0x03         ; Port Multiplexer Control D\n\n;*************************************************************************\n;** RSTCTRL - Reset controller\n;*************************************************************************\n.equ RSTCTRL_RSTFR_offset = 0x00         ; Reset Flags\n.equ RSTCTRL_SWRR_offset = 0x01          ; Software Reset\n\n;*************************************************************************\n;** RTC - Real-Time Counter\n;*************************************************************************\n.equ RTC_CTRLA_offset = 0x00             ; Control A\n.equ RTC_STATUS_offset = 0x01            ; Status\n.equ RTC_INTCTRL_offset = 0x02           ; Interrupt Control\n.equ RTC_INTFLAGS_offset = 0x03          ; Interrupt Flags\n.equ RTC_TEMP_offset = 0x04              ; Temporary\n.equ RTC_DBGCTRL_offset = 0x05           ; Debug control\n.equ RTC_CLKSEL_offset = 0x07            ; Clock Select\n.equ RTC_CNT_offset = 0x08               ; Counter\n.equ RTC_PER_offset = 0x0A               ; Period\n.equ RTC_CMP_offset = 0x0C               ; Compare\n.equ RTC_PITCTRLA_offset = 0x10          ; PIT Control A\n.equ RTC_PITSTATUS_offset = 0x11         ; PIT Status\n.equ RTC_PITINTCTRL_offset = 0x12        ; PIT Interrupt Control\n.equ RTC_PITINTFLAGS_offset = 0x13       ; PIT Interrupt Flags\n.equ RTC_PITDBGCTRL_offset = 0x15        ; PIT Debug control\n\n;*************************************************************************\n;** SIGROW - Signature row\n;*************************************************************************\n.equ SIGROW_DEVICEID0_offset = 0x00      ; Device ID Byte 0\n.equ SIGROW_DEVICEID1_offset = 0x01      ; Device ID Byte 1\n.equ SIGROW_DEVICEID2_offset = 0x02      ; Device ID Byte 2\n.equ SIGROW_SERNUM0_offset = 0x03        ; Serial Number Byte 0\n.equ SIGROW_SERNUM1_offset = 0x04        ; Serial Number Byte 1\n.equ SIGROW_SERNUM2_offset = 0x05        ; Serial Number Byte 2\n.equ SIGROW_SERNUM3_offset = 0x06        ; Serial Number Byte 3\n.equ SIGROW_SERNUM4_offset = 0x07        ; Serial Number Byte 4\n.equ SIGROW_SERNUM5_offset = 0x08        ; Serial Number Byte 5\n.equ SIGROW_SERNUM6_offset = 0x09        ; Serial Number Byte 6\n.equ SIGROW_SERNUM7_offset = 0x0A        ; Serial Number Byte 7\n.equ SIGROW_SERNUM8_offset = 0x0B        ; Serial Number Byte 8\n.equ SIGROW_SERNUM9_offset = 0x0C        ; Serial Number Byte 9\n.equ SIGROW_TEMPSENSE0_offset = 0x20     ; Temperature Sensor Calibration Byte 0\n.equ SIGROW_TEMPSENSE1_offset = 0x21     ; Temperature Sensor Calibration Byte 1\n.equ SIGROW_OSC16ERR3V_offset = 0x22     ; OSC16 error at 3V\n.equ SIGROW_OSC16ERR5V_offset = 0x23     ; OSC16 error at 5V\n.equ SIGROW_OSC20ERR3V_offset = 0x24     ; OSC20 error at 3V\n.equ SIGROW_OSC20ERR5V_offset = 0x25     ; OSC20 error at 5V\n\n;*************************************************************************\n;** SLPCTRL - Sleep Controller\n;*************************************************************************\n.equ SLPCTRL_CTRLA_offset = 0x00         ; Control\n\n;*************************************************************************\n;** SPI - Serial Peripheral Interface\n;*************************************************************************\n.equ SPI_CTRLA_offset = 0x00             ; Control A\n.equ SPI_CTRLB_offset = 0x01             ; Control B\n.equ SPI_INTCTRL_offset = 0x02           ; Interrupt Control\n.equ SPI_INTFLAGS_offset = 0x03          ; Interrupt Flags\n.equ SPI_DATA_offset = 0x04              ; Data\n\n;*************************************************************************\n;** SYSCFG - System Configuration Registers\n;*************************************************************************\n.equ SYSCFG_REVID_offset = 0x01          ; Revision ID\n.equ SYSCFG_EXTBRK_offset = 0x02         ; External Break\n\n;*************************************************************************\n;** TCA - 16-bit Timer/Counter Type A\n;*************************************************************************\n.equ TCA_SINGLE_CTRLA_offset = 0x00      ; Control A\n.equ TCA_SINGLE_CTRLB_offset = 0x01      ; Control B\n.equ TCA_SINGLE_CTRLC_offset = 0x02      ; Control C\n.equ TCA_SINGLE_CTRLD_offset = 0x03      ; Control D\n.equ TCA_SINGLE_CTRLECLR_offset = 0x04   ; Control E Clear\n.equ TCA_SINGLE_CTRLESET_offset = 0x05   ; Control E Set\n.equ TCA_SINGLE_CTRLFCLR_offset = 0x06   ; Control F Clear\n.equ TCA_SINGLE_CTRLFSET_offset = 0x07   ; Control F Set\n.equ TCA_SINGLE_EVCTRL_offset = 0x09     ; Event Control\n.equ TCA_SINGLE_INTCTRL_offset = 0x0A    ; Interrupt Control\n.equ TCA_SINGLE_INTFLAGS_offset = 0x0B   ; Interrupt Flags\n.equ TCA_SINGLE_DBGCTRL_offset = 0x0E    ; Degbug Control\n.equ TCA_SINGLE_TEMP_offset = 0x0F       ; Temporary data for 16-bit Access\n.equ TCA_SINGLE_CNT_offset = 0x20        ; Count\n.equ TCA_SINGLE_PER_offset = 0x26        ; Period\n.equ TCA_SINGLE_CMP0_offset = 0x28       ; Compare 0\n.equ TCA_SINGLE_CMP1_offset = 0x2A       ; Compare 1\n.equ TCA_SINGLE_CMP2_offset = 0x2C       ; Compare 2\n.equ TCA_SINGLE_PERBUF_offset = 0x36     ; Period Buffer\n.equ TCA_SINGLE_CMP0BUF_offset = 0x38    ; Compare 0 Buffer\n.equ TCA_SINGLE_CMP1BUF_offset = 0x3A    ; Compare 1 Buffer\n.equ TCA_SINGLE_CMP2BUF_offset = 0x3C    ; Compare 2 Buffer\n.equ TCA_SPLIT_CTRLA_offset = 0x00       ; Control A\n.equ TCA_SPLIT_CTRLB_offset = 0x01       ; Control B\n.equ TCA_SPLIT_CTRLC_offset = 0x02       ; Control C\n.equ TCA_SPLIT_CTRLD_offset = 0x03       ; Control D\n.equ TCA_SPLIT_CTRLECLR_offset = 0x04    ; Control E Clear\n.equ TCA_SPLIT_CTRLESET_offset = 0x05    ; Control E Set\n.equ TCA_SPLIT_INTCTRL_offset = 0x0A     ; Interrupt Control\n.equ TCA_SPLIT_INTFLAGS_offset = 0x0B    ; Interrupt Flags\n.equ TCA_SPLIT_DBGCTRL_offset = 0x0E     ; Degbug Control\n.equ TCA_SPLIT_LCNT_offset = 0x20        ; Low Count\n.equ TCA_SPLIT_HCNT_offset = 0x21        ; High Count\n.equ TCA_SPLIT_LPER_offset = 0x26        ; Low Period\n.equ TCA_SPLIT_HPER_offset = 0x27        ; High Period\n.equ TCA_SPLIT_LCMP0_offset = 0x28       ; Low Compare\n.equ TCA_SPLIT_HCMP0_offset = 0x29       ; High Compare\n.equ TCA_SPLIT_LCMP1_offset = 0x2A       ; Low Compare\n.equ TCA_SPLIT_HCMP1_offset = 0x2B       ; High Compare\n.equ TCA_SPLIT_LCMP2_offset = 0x2C       ; Low Compare\n.equ TCA_SPLIT_HCMP2_offset = 0x2D       ; High Compare\n.equ TCA_SINGLE_offset = 0x00            ; \n.equ TCA_SPLIT_offset = 0x00             ; \n\n;*************************************************************************\n;** TCB - 16-bit Timer Type B\n;*************************************************************************\n.equ TCB_CTRLA_offset = 0x00             ; Control A\n.equ TCB_CTRLB_offset = 0x01             ; Control Register B\n.equ TCB_EVCTRL_offset = 0x04            ; Event Control\n.equ TCB_INTCTRL_offset = 0x05           ; Interrupt Control\n.equ TCB_INTFLAGS_offset = 0x06          ; Interrupt Flags\n.equ TCB_STATUS_offset = 0x07            ; Status\n.equ TCB_DBGCTRL_offset = 0x08           ; Debug Control\n.equ TCB_TEMP_offset = 0x09              ; Temporary Value\n.equ TCB_CNT_offset = 0x0A               ; Count\n.equ TCB_CCMP_offset = 0x0C              ; Compare or Capture\n\n;*************************************************************************\n;** TWI - Two-Wire Interface\n;*************************************************************************\n.equ TWI_CTRLA_offset = 0x00             ; Control A\n.equ TWI_DBGCTRL_offset = 0x02           ; Debug Control Register\n.equ TWI_MCTRLA_offset = 0x03            ; Master Control A\n.equ TWI_MCTRLB_offset = 0x04            ; Master Control B\n.equ TWI_MSTATUS_offset = 0x05           ; Master Status\n.equ TWI_MBAUD_offset = 0x06             ; Master Baurd Rate Control\n.equ TWI_MADDR_offset = 0x07             ; Master Address\n.equ TWI_MDATA_offset = 0x08             ; Master Data\n.equ TWI_SCTRLA_offset = 0x09            ; Slave Control A\n.equ TWI_SCTRLB_offset = 0x0A            ; Slave Control B\n.equ TWI_SSTATUS_offset = 0x0B           ; Slave Status\n.equ TWI_SADDR_offset = 0x0C             ; Slave Address\n.equ TWI_SDATA_offset = 0x0D             ; Slave Data\n.equ TWI_SADDRMASK_offset = 0x0E         ; Slave Address Mask\n\n;*************************************************************************\n;** USART - Universal Synchronous and Asynchronous Receiver and Transmitter\n;*************************************************************************\n.equ USART_RXDATAL_offset = 0x00         ; Receive Data Low Byte\n.equ USART_RXDATAH_offset = 0x01         ; Receive Data High Byte\n.equ USART_TXDATAL_offset = 0x02         ; Transmit Data Low Byte\n.equ USART_TXDATAH_offset = 0x03         ; Transmit Data High Byte\n.equ USART_STATUS_offset = 0x04          ; Status\n.equ USART_CTRLA_offset = 0x05           ; Control A\n.equ USART_CTRLB_offset = 0x06           ; Control B\n.equ USART_CTRLC_offset = 0x07           ; Control C\n.equ USART_BAUD_offset = 0x08            ; Baud Rate\n.equ USART_DBGCTRL_offset = 0x0B         ; Debug Control\n.equ USART_EVCTRL_offset = 0x0C          ; Event Control\n.equ USART_TXPLCTRL_offset = 0x0D        ; IRCOM Transmitter Pulse Length Control\n.equ USART_RXPLCTRL_offset = 0x0E        ; IRCOM Receiver Pulse Length Control\n\n;*************************************************************************\n;** USERROW - User Row\n;*************************************************************************\n.equ USERROW_USERROW0_offset = 0x00      ; User Row Byte 0\n.equ USERROW_USERROW1_offset = 0x01      ; User Row Byte 1\n.equ USERROW_USERROW2_offset = 0x02      ; User Row Byte 2\n.equ USERROW_USERROW3_offset = 0x03      ; User Row Byte 3\n.equ USERROW_USERROW4_offset = 0x04      ; User Row Byte 4\n.equ USERROW_USERROW5_offset = 0x05      ; User Row Byte 5\n.equ USERROW_USERROW6_offset = 0x06      ; User Row Byte 6\n.equ USERROW_USERROW7_offset = 0x07      ; User Row Byte 7\n.equ USERROW_USERROW8_offset = 0x08      ; User Row Byte 8\n.equ USERROW_USERROW9_offset = 0x09      ; User Row Byte 9\n.equ USERROW_USERROW10_offset = 0x0A     ; User Row Byte 10\n.equ USERROW_USERROW11_offset = 0x0B     ; User Row Byte 11\n.equ USERROW_USERROW12_offset = 0x0C     ; User Row Byte 12\n.equ USERROW_USERROW13_offset = 0x0D     ; User Row Byte 13\n.equ USERROW_USERROW14_offset = 0x0E     ; User Row Byte 14\n.equ USERROW_USERROW15_offset = 0x0F     ; User Row Byte 15\n.equ USERROW_USERROW16_offset = 0x10     ; User Row Byte 16\n.equ USERROW_USERROW17_offset = 0x11     ; User Row Byte 17\n.equ USERROW_USERROW18_offset = 0x12     ; User Row Byte 18\n.equ USERROW_USERROW19_offset = 0x13     ; User Row Byte 19\n.equ USERROW_USERROW20_offset = 0x14     ; User Row Byte 20\n.equ USERROW_USERROW21_offset = 0x15     ; User Row Byte 21\n.equ USERROW_USERROW22_offset = 0x16     ; User Row Byte 22\n.equ USERROW_USERROW23_offset = 0x17     ; User Row Byte 23\n.equ USERROW_USERROW24_offset = 0x18     ; User Row Byte 24\n.equ USERROW_USERROW25_offset = 0x19     ; User Row Byte 25\n.equ USERROW_USERROW26_offset = 0x1A     ; User Row Byte 26\n.equ USERROW_USERROW27_offset = 0x1B     ; User Row Byte 27\n.equ USERROW_USERROW28_offset = 0x1C     ; User Row Byte 28\n.equ USERROW_USERROW29_offset = 0x1D     ; User Row Byte 29\n.equ USERROW_USERROW30_offset = 0x1E     ; User Row Byte 30\n.equ USERROW_USERROW31_offset = 0x1F     ; User Row Byte 31\n\n;*************************************************************************\n;** VPORT - Virtual Ports\n;*************************************************************************\n.equ VPORT_DIR_offset = 0x00             ; Data Direction\n.equ VPORT_OUT_offset = 0x01             ; Output Value\n.equ VPORT_IN_offset = 0x02              ; Input Value\n.equ VPORT_INTFLAGS_offset = 0x03        ; Interrupt Flags\n\n;*************************************************************************\n;** VREF - Voltage reference\n;*************************************************************************\n.equ VREF_CTRLA_offset = 0x00            ; Control A\n.equ VREF_CTRLB_offset = 0x01            ; Control B\n\n;*************************************************************************\n;** WDT - Watch-Dog Timer\n;*************************************************************************\n.equ WDT_CTRLA_offset = 0x00             ; Control A\n.equ WDT_STATUS_offset = 0x01            ; Status\n\n\n; ***** LOCKBIT REGISTER LOCATIONS ***************************************\n\n\n\n\n; ***** FUSE REGISTER LOCATIONS ******************************************\n\n\n\n\n; ***** BIT AND VALUE DEFINITIONS ****************************************\n\n\n;*************************************************************************\n;** AC - Analog Comparator\n;*************************************************************************\n\n; AC_CTRLA masks\n.equ AC_ENABLE_bm = 0x01                 ; Enable bit mask\n.equ AC_ENABLE_bp = 0                    ; Enable bit position\n.equ AC_HYSMODE_gm = 0x06                ; Hysteresis Mode group mask\n.equ AC_HYSMODE_gp = 1                   ; Hysteresis Mode group position\n.equ AC_HYSMODE0_bm = (1<<1)             ; Hysteresis Mode bit 0 mask\n.equ AC_HYSMODE0_bp = 1                  ; Hysteresis Mode bit 0 position\n.equ AC_HYSMODE1_bm = (1<<2)             ; Hysteresis Mode bit 1 mask\n.equ AC_HYSMODE1_bp = 2                  ; Hysteresis Mode bit 1 position\n.equ AC_INTMODE_gm = 0x30                ; Interrupt Mode group mask\n.equ AC_INTMODE_gp = 4                   ; Interrupt Mode group position\n.equ AC_INTMODE0_bm = (1<<4)             ; Interrupt Mode bit 0 mask\n.equ AC_INTMODE0_bp = 4                  ; Interrupt Mode bit 0 position\n.equ AC_INTMODE1_bm = (1<<5)             ; Interrupt Mode bit 1 mask\n.equ AC_INTMODE1_bp = 5                  ; Interrupt Mode bit 1 position\n.equ AC_OUTEN_bm = 0x40                  ; Output Buffer Enable bit mask\n.equ AC_OUTEN_bp = 6                     ; Output Buffer Enable bit position\n.equ AC_RUNSTDBY_bm = 0x80               ; Run in Standby Mode bit mask\n.equ AC_RUNSTDBY_bp = 7                  ; Run in Standby Mode bit position\n\n; AC_INTCTRL masks\n.equ AC_CMP_bm = 0x01                    ; Analog Comparator 0 Interrupt Enable bit mask\n.equ AC_CMP_bp = 0                       ; Analog Comparator 0 Interrupt Enable bit position\n\n; AC_MUXCTRLA masks\n.equ AC_INVERT_bm = 0x80                 ; Invert AC Output bit mask\n.equ AC_INVERT_bp = 7                    ; Invert AC Output bit position\n.equ AC_MUXNEG_gm = 0x03                 ; Negative Input MUX Selection group mask\n.equ AC_MUXNEG_gp = 0                    ; Negative Input MUX Selection group position\n.equ AC_MUXNEG0_bm = (1<<0)              ; Negative Input MUX Selection bit 0 mask\n.equ AC_MUXNEG0_bp = 0                   ; Negative Input MUX Selection bit 0 position\n.equ AC_MUXNEG1_bm = (1<<1)              ; Negative Input MUX Selection bit 1 mask\n.equ AC_MUXNEG1_bp = 1                   ; Negative Input MUX Selection bit 1 position\n.equ AC_MUXPOS_gm = 0x18                 ; Positive Input MUX Selection group mask\n.equ AC_MUXPOS_gp = 3                    ; Positive Input MUX Selection group position\n.equ AC_MUXPOS0_bm = (1<<3)              ; Positive Input MUX Selection bit 0 mask\n.equ AC_MUXPOS0_bp = 3                   ; Positive Input MUX Selection bit 0 position\n.equ AC_MUXPOS1_bm = (1<<4)              ; Positive Input MUX Selection bit 1 mask\n.equ AC_MUXPOS1_bp = 4                   ; Positive Input MUX Selection bit 1 position\n\n; AC_STATUS masks\n; Masks for AC_CMP already defined\n.equ AC_STATE_bm = 0x10                  ; Analog Comparator State bit mask\n.equ AC_STATE_bp = 4                     ; Analog Comparator State bit position\n\n; Hysteresis Mode select\n.equ AC_HYSMODE_OFF_gc = (0x00<<1)       ; No hysteresis\n.equ AC_HYSMODE_10mV_gc = (0x01<<1)      ; 10mV hysteresis\n.equ AC_HYSMODE_25mV_gc = (0x02<<1)      ; 25mV hysteresis\n.equ AC_HYSMODE_50mV_gc = (0x03<<1)      ; 50mV hysteresis\n\n; Interrupt Mode select\n.equ AC_INTMODE_BOTHEDGE_gc = (0x00<<4)  ; Any Edge\n.equ AC_INTMODE_NEGEDGE_gc = (0x02<<4)   ; Negative Edge\n.equ AC_INTMODE_POSEDGE_gc = (0x03<<4)   ; Positive Edge\n\n; Negative Input MUX Selection select\n.equ AC_MUXNEG_PIN0_gc = (0x00<<0)       ; Negative Pin 0\n.equ AC_MUXNEG_VREF_gc = (0x02<<0)       ; Voltage Reference\n\n; Positive Input MUX Selection select\n.equ AC_MUXPOS_PIN0_gc = (0x00<<3)       ; Positive Pin 0\n\n\n;*************************************************************************\n;** ADC - Analog to Digital Converter\n;*************************************************************************\n\n; ADC_CALIB masks\n.equ ADC_DUTYCYC_bm = 0x01               ; Duty Cycle bit mask\n.equ ADC_DUTYCYC_bp = 0                  ; Duty Cycle bit position\n\n; ADC_COMMAND masks\n.equ ADC_STCONV_bm = 0x01                ; Start Conversion Operation bit mask\n.equ ADC_STCONV_bp = 0                   ; Start Conversion Operation bit position\n\n; ADC_CTRLA masks\n.equ ADC_ENABLE_bm = 0x01                ; ADC Enable bit mask\n.equ ADC_ENABLE_bp = 0                   ; ADC Enable bit position\n.equ ADC_FREERUN_bm = 0x02               ; ADC Freerun mode bit mask\n.equ ADC_FREERUN_bp = 1                  ; ADC Freerun mode bit position\n.equ ADC_RESSEL_bm = 0x04                ; ADC Resolution bit mask\n.equ ADC_RESSEL_bp = 2                   ; ADC Resolution bit position\n.equ ADC_RUNSTBY_bm = 0x80               ; Run standby mode bit mask\n.equ ADC_RUNSTBY_bp = 7                  ; Run standby mode bit position\n\n; ADC_CTRLB masks\n.equ ADC_SAMPNUM_gm = 0x07               ; Accumulation Samples group mask\n.equ ADC_SAMPNUM_gp = 0                  ; Accumulation Samples group position\n.equ ADC_SAMPNUM0_bm = (1<<0)            ; Accumulation Samples bit 0 mask\n.equ ADC_SAMPNUM0_bp = 0                 ; Accumulation Samples bit 0 position\n.equ ADC_SAMPNUM1_bm = (1<<1)            ; Accumulation Samples bit 1 mask\n.equ ADC_SAMPNUM1_bp = 1                 ; Accumulation Samples bit 1 position\n.equ ADC_SAMPNUM2_bm = (1<<2)            ; Accumulation Samples bit 2 mask\n.equ ADC_SAMPNUM2_bp = 2                 ; Accumulation Samples bit 2 position\n\n; ADC_CTRLC masks\n.equ ADC_PRESC_gm = 0x07                 ; Clock Pre-scaler group mask\n.equ ADC_PRESC_gp = 0                    ; Clock Pre-scaler group position\n.equ ADC_PRESC0_bm = (1<<0)              ; Clock Pre-scaler bit 0 mask\n.equ ADC_PRESC0_bp = 0                   ; Clock Pre-scaler bit 0 position\n.equ ADC_PRESC1_bm = (1<<1)              ; Clock Pre-scaler bit 1 mask\n.equ ADC_PRESC1_bp = 1                   ; Clock Pre-scaler bit 1 position\n.equ ADC_PRESC2_bm = (1<<2)              ; Clock Pre-scaler bit 2 mask\n.equ ADC_PRESC2_bp = 2                   ; Clock Pre-scaler bit 2 position\n.equ ADC_REFSEL_gm = 0x30                ; Reference Selection group mask\n.equ ADC_REFSEL_gp = 4                   ; Reference Selection group position\n.equ ADC_REFSEL0_bm = (1<<4)             ; Reference Selection bit 0 mask\n.equ ADC_REFSEL0_bp = 4                  ; Reference Selection bit 0 position\n.equ ADC_REFSEL1_bm = (1<<5)             ; Reference Selection bit 1 mask\n.equ ADC_REFSEL1_bp = 5                  ; Reference Selection bit 1 position\n.equ ADC_SAMPCAP_bm = 0x40               ; Sample Capacitance Selection bit mask\n.equ ADC_SAMPCAP_bp = 6                  ; Sample Capacitance Selection bit position\n\n; ADC_CTRLD masks\n.equ ADC_ASDV_bm = 0x10                  ; Automatic Sampling Delay Variation bit mask\n.equ ADC_ASDV_bp = 4                     ; Automatic Sampling Delay Variation bit position\n.equ ADC_INITDLY_gm = 0xE0               ; Initial Delay Selection group mask\n.equ ADC_INITDLY_gp = 5                  ; Initial Delay Selection group position\n.equ ADC_INITDLY0_bm = (1<<5)            ; Initial Delay Selection bit 0 mask\n.equ ADC_INITDLY0_bp = 5                 ; Initial Delay Selection bit 0 position\n.equ ADC_INITDLY1_bm = (1<<6)            ; Initial Delay Selection bit 1 mask\n.equ ADC_INITDLY1_bp = 6                 ; Initial Delay Selection bit 1 position\n.equ ADC_INITDLY2_bm = (1<<7)            ; Initial Delay Selection bit 2 mask\n.equ ADC_INITDLY2_bp = 7                 ; Initial Delay Selection bit 2 position\n.equ ADC_SAMPDLY_gm = 0x0F               ; Sampling Delay Selection group mask\n.equ ADC_SAMPDLY_gp = 0                  ; Sampling Delay Selection group position\n.equ ADC_SAMPDLY0_bm = (1<<0)            ; Sampling Delay Selection bit 0 mask\n.equ ADC_SAMPDLY0_bp = 0                 ; Sampling Delay Selection bit 0 position\n.equ ADC_SAMPDLY1_bm = (1<<1)            ; Sampling Delay Selection bit 1 mask\n.equ ADC_SAMPDLY1_bp = 1                 ; Sampling Delay Selection bit 1 position\n.equ ADC_SAMPDLY2_bm = (1<<2)            ; Sampling Delay Selection bit 2 mask\n.equ ADC_SAMPDLY2_bp = 2                 ; Sampling Delay Selection bit 2 position\n.equ ADC_SAMPDLY3_bm = (1<<3)            ; Sampling Delay Selection bit 3 mask\n.equ ADC_SAMPDLY3_bp = 3                 ; Sampling Delay Selection bit 3 position\n\n; ADC_CTRLE masks\n.equ ADC_WINCM_gm = 0x07                 ; Window Comparator Mode group mask\n.equ ADC_WINCM_gp = 0                    ; Window Comparator Mode group position\n.equ ADC_WINCM0_bm = (1<<0)              ; Window Comparator Mode bit 0 mask\n.equ ADC_WINCM0_bp = 0                   ; Window Comparator Mode bit 0 position\n.equ ADC_WINCM1_bm = (1<<1)              ; Window Comparator Mode bit 1 mask\n.equ ADC_WINCM1_bp = 1                   ; Window Comparator Mode bit 1 position\n.equ ADC_WINCM2_bm = (1<<2)              ; Window Comparator Mode bit 2 mask\n.equ ADC_WINCM2_bp = 2                   ; Window Comparator Mode bit 2 position\n\n; ADC_DBGCTRL masks\n.equ ADC_DBGRUN_bm = 0x01                ; Debug run bit mask\n.equ ADC_DBGRUN_bp = 0                   ; Debug run bit position\n\n; ADC_EVCTRL masks\n.equ ADC_STARTEI_bm = 0x01               ; Start Event Input Enable bit mask\n.equ ADC_STARTEI_bp = 0                  ; Start Event Input Enable bit position\n\n; ADC_INTCTRL masks\n.equ ADC_RESRDY_bm = 0x01                ; Result Ready Interrupt Enable bit mask\n.equ ADC_RESRDY_bp = 0                   ; Result Ready Interrupt Enable bit position\n.equ ADC_WCMP_bm = 0x02                  ; Window Comparator Interrupt Enable bit mask\n.equ ADC_WCMP_bp = 1                     ; Window Comparator Interrupt Enable bit position\n\n; ADC_INTFLAGS masks\n; Masks for ADC_RESRDY already defined\n; Masks for ADC_WCMP already defined\n\n; ADC_MUXPOS masks\n.equ ADC_MUXPOS_gm = 0x1F                ; Analog Channel Selection Bits group mask\n.equ ADC_MUXPOS_gp = 0                   ; Analog Channel Selection Bits group position\n.equ ADC_MUXPOS0_bm = (1<<0)             ; Analog Channel Selection Bits bit 0 mask\n.equ ADC_MUXPOS0_bp = 0                  ; Analog Channel Selection Bits bit 0 position\n.equ ADC_MUXPOS1_bm = (1<<1)             ; Analog Channel Selection Bits bit 1 mask\n.equ ADC_MUXPOS1_bp = 1                  ; Analog Channel Selection Bits bit 1 position\n.equ ADC_MUXPOS2_bm = (1<<2)             ; Analog Channel Selection Bits bit 2 mask\n.equ ADC_MUXPOS2_bp = 2                  ; Analog Channel Selection Bits bit 2 position\n.equ ADC_MUXPOS3_bm = (1<<3)             ; Analog Channel Selection Bits bit 3 mask\n.equ ADC_MUXPOS3_bp = 3                  ; Analog Channel Selection Bits bit 3 position\n.equ ADC_MUXPOS4_bm = (1<<4)             ; Analog Channel Selection Bits bit 4 mask\n.equ ADC_MUXPOS4_bp = 4                  ; Analog Channel Selection Bits bit 4 position\n\n; ADC_SAMPCTRL masks\n.equ ADC_SAMPLEN_gm = 0x1F               ; Sample lenght group mask\n.equ ADC_SAMPLEN_gp = 0                  ; Sample lenght group position\n.equ ADC_SAMPLEN0_bm = (1<<0)            ; Sample lenght bit 0 mask\n.equ ADC_SAMPLEN0_bp = 0                 ; Sample lenght bit 0 position\n.equ ADC_SAMPLEN1_bm = (1<<1)            ; Sample lenght bit 1 mask\n.equ ADC_SAMPLEN1_bp = 1                 ; Sample lenght bit 1 position\n.equ ADC_SAMPLEN2_bm = (1<<2)            ; Sample lenght bit 2 mask\n.equ ADC_SAMPLEN2_bp = 2                 ; Sample lenght bit 2 position\n.equ ADC_SAMPLEN3_bm = (1<<3)            ; Sample lenght bit 3 mask\n.equ ADC_SAMPLEN3_bp = 3                 ; Sample lenght bit 3 position\n.equ ADC_SAMPLEN4_bm = (1<<4)            ; Sample lenght bit 4 mask\n.equ ADC_SAMPLEN4_bp = 4                 ; Sample lenght bit 4 position\n\n; ADC_TEMP masks\n.equ ADC_TEMP_gm = 0xFF                  ; Temporary group mask\n.equ ADC_TEMP_gp = 0                     ; Temporary group position\n.equ ADC_TEMP0_bm = (1<<0)               ; Temporary bit 0 mask\n.equ ADC_TEMP0_bp = 0                    ; Temporary bit 0 position\n.equ ADC_TEMP1_bm = (1<<1)               ; Temporary bit 1 mask\n.equ ADC_TEMP1_bp = 1                    ; Temporary bit 1 position\n.equ ADC_TEMP2_bm = (1<<2)               ; Temporary bit 2 mask\n.equ ADC_TEMP2_bp = 2                    ; Temporary bit 2 position\n.equ ADC_TEMP3_bm = (1<<3)               ; Temporary bit 3 mask\n.equ ADC_TEMP3_bp = 3                    ; Temporary bit 3 position\n.equ ADC_TEMP4_bm = (1<<4)               ; Temporary bit 4 mask\n.equ ADC_TEMP4_bp = 4                    ; Temporary bit 4 position\n.equ ADC_TEMP5_bm = (1<<5)               ; Temporary bit 5 mask\n.equ ADC_TEMP5_bp = 5                    ; Temporary bit 5 position\n.equ ADC_TEMP6_bm = (1<<6)               ; Temporary bit 6 mask\n.equ ADC_TEMP6_bp = 6                    ; Temporary bit 6 position\n.equ ADC_TEMP7_bm = (1<<7)               ; Temporary bit 7 mask\n.equ ADC_TEMP7_bp = 7                    ; Temporary bit 7 position\n\n; Duty Cycle select\n.equ ADC_DUTYCYC_DUTY50_gc = (0x00<<0)   ; 50% Duty cycle\n.equ ADC_DUTYCYC_DUTY25_gc = (0x01<<0)   ; 25% Duty cycle\n\n; ADC Resolution select\n.equ ADC_RESSEL_10BIT_gc = (0x00<<2)     ; 10-bit mode\n.equ ADC_RESSEL_8BIT_gc = (0x01<<2)      ; 8-bit mode\n\n; Accumulation Samples select\n.equ ADC_SAMPNUM_ACC1_gc = (0x00<<0)     ; 1 ADC sample\n.equ ADC_SAMPNUM_ACC2_gc = (0x01<<0)     ; Accumulate 2 samples\n.equ ADC_SAMPNUM_ACC4_gc = (0x02<<0)     ; Accumulate 4 samples\n.equ ADC_SAMPNUM_ACC8_gc = (0x03<<0)     ; Accumulate 8 samples\n.equ ADC_SAMPNUM_ACC16_gc = (0x04<<0)    ; Accumulate 16 samples\n.equ ADC_SAMPNUM_ACC32_gc = (0x05<<0)    ; Accumulate 32 samples\n.equ ADC_SAMPNUM_ACC64_gc = (0x06<<0)    ; Accumulate 64 samples\n\n; Clock Pre-scaler select\n.equ ADC_PRESC_DIV2_gc = (0x00<<0)       ; CLK_PER divided by 2\n.equ ADC_PRESC_DIV4_gc = (0x01<<0)       ; CLK_PER divided by 4\n.equ ADC_PRESC_DIV8_gc = (0x02<<0)       ; CLK_PER divided by 8\n.equ ADC_PRESC_DIV16_gc = (0x03<<0)      ; CLK_PER divided by 16\n.equ ADC_PRESC_DIV32_gc = (0x04<<0)      ; CLK_PER divided by 32\n.equ ADC_PRESC_DIV64_gc = (0x05<<0)      ; CLK_PER divided by 64\n.equ ADC_PRESC_DIV128_gc = (0x06<<0)     ; CLK_PER divided by 128\n.equ ADC_PRESC_DIV256_gc = (0x07<<0)     ; CLK_PER divided by 256\n\n; Reference Selection select\n.equ ADC_REFSEL_INTREF_gc = (0x00<<4)    ; Internal reference\n.equ ADC_REFSEL_VDDREF_gc = (0x01<<4)    ; VDD\n\n; Automatic Sampling Delay Variation select\n.equ ADC_ASDV_ASVOFF_gc = (0x00<<4)      ; The Automatic Sampling Delay Variation is disabled\n.equ ADC_ASDV_ASVON_gc = (0x01<<4)       ; The Automatic Sampling Delay Variation is enabled\n\n; Initial Delay Selection select\n.equ ADC_INITDLY_DLY0_gc = (0x00<<5)     ; Delay 0 CLK_ADC cycles\n.equ ADC_INITDLY_DLY16_gc = (0x01<<5)    ; Delay 16 CLK_ADC cycles\n.equ ADC_INITDLY_DLY32_gc = (0x02<<5)    ; Delay 32 CLK_ADC cycles\n.equ ADC_INITDLY_DLY64_gc = (0x03<<5)    ; Delay 64 CLK_ADC cycles\n.equ ADC_INITDLY_DLY128_gc = (0x04<<5)   ; Delay 128 CLK_ADC cycles\n.equ ADC_INITDLY_DLY256_gc = (0x05<<5)   ; Delay 256 CLK_ADC cycles\n\n; Window Comparator Mode select\n.equ ADC_WINCM_NONE_gc = (0x00<<0)       ; No Window Comparison\n.equ ADC_WINCM_BELOW_gc = (0x01<<0)      ; Below Window\n.equ ADC_WINCM_ABOVE_gc = (0x02<<0)      ; Above Window\n.equ ADC_WINCM_INSIDE_gc = (0x03<<0)     ; Inside Window\n.equ ADC_WINCM_OUTSIDE_gc = (0x04<<0)    ; Outside Window\n\n; Analog Channel Selection Bits select\n.equ ADC_MUXPOS_AIN0_gc = (0x00<<0)      ; ADC input pin 0\n.equ ADC_MUXPOS_AIN1_gc = (0x01<<0)      ; ADC input pin 1\n.equ ADC_MUXPOS_AIN2_gc = (0x02<<0)      ; ADC input pin 2\n.equ ADC_MUXPOS_AIN3_gc = (0x03<<0)      ; ADC input pin 3\n.equ ADC_MUXPOS_AIN4_gc = (0x04<<0)      ; ADC input pin 4\n.equ ADC_MUXPOS_AIN5_gc = (0x05<<0)      ; ADC input pin 5\n.equ ADC_MUXPOS_AIN6_gc = (0x06<<0)      ; ADC input pin 6\n.equ ADC_MUXPOS_AIN7_gc = (0x07<<0)      ; ADC input pin 7\n.equ ADC_MUXPOS_AIN8_gc = (0x08<<0)      ; ADC input pin 8\n.equ ADC_MUXPOS_AIN9_gc = (0x09<<0)      ; ADC input pin 9\n.equ ADC_MUXPOS_AIN10_gc = (0x0A<<0)     ; ADC input pin 10\n.equ ADC_MUXPOS_AIN11_gc = (0x0B<<0)     ; ADC input pin 11\n.equ ADC_MUXPOS_DAC0_gc = (0x1C<<0)      ; DAC0\n.equ ADC_MUXPOS_INTREF_gc = (0x1D<<0)    ; Internal Ref\n.equ ADC_MUXPOS_TEMPSENSE_gc = (0x1E<<0) ; Temp sensor\n.equ ADC_MUXPOS_GND_gc = (0x1F<<0)       ; GND\n\n\n;*************************************************************************\n;** BOD - Bod interface\n;*************************************************************************\n\n; BOD_CTRLA masks\n.equ BOD_ACTIVE_gm = 0x0C                ; Operation in active mode group mask\n.equ BOD_ACTIVE_gp = 2                   ; Operation in active mode group position\n.equ BOD_ACTIVE0_bm = (1<<2)             ; Operation in active mode bit 0 mask\n.equ BOD_ACTIVE0_bp = 2                  ; Operation in active mode bit 0 position\n.equ BOD_ACTIVE1_bm = (1<<3)             ; Operation in active mode bit 1 mask\n.equ BOD_ACTIVE1_bp = 3                  ; Operation in active mode bit 1 position\n.equ BOD_SAMPFREQ_bm = 0x10              ; Sample frequency bit mask\n.equ BOD_SAMPFREQ_bp = 4                 ; Sample frequency bit position\n.equ BOD_SLEEP_gm = 0x03                 ; Operation in sleep mode group mask\n.equ BOD_SLEEP_gp = 0                    ; Operation in sleep mode group position\n.equ BOD_SLEEP0_bm = (1<<0)              ; Operation in sleep mode bit 0 mask\n.equ BOD_SLEEP0_bp = 0                   ; Operation in sleep mode bit 0 position\n.equ BOD_SLEEP1_bm = (1<<1)              ; Operation in sleep mode bit 1 mask\n.equ BOD_SLEEP1_bp = 1                   ; Operation in sleep mode bit 1 position\n\n; BOD_CTRLB masks\n.equ BOD_LVL_gm = 0x07                   ; Bod level group mask\n.equ BOD_LVL_gp = 0                      ; Bod level group position\n.equ BOD_LVL0_bm = (1<<0)                ; Bod level bit 0 mask\n.equ BOD_LVL0_bp = 0                     ; Bod level bit 0 position\n.equ BOD_LVL1_bm = (1<<1)                ; Bod level bit 1 mask\n.equ BOD_LVL1_bp = 1                     ; Bod level bit 1 position\n.equ BOD_LVL2_bm = (1<<2)                ; Bod level bit 2 mask\n.equ BOD_LVL2_bp = 2                     ; Bod level bit 2 position\n\n; BOD_INTCTRL masks\n.equ BOD_VLMCFG_gm = 0x06                ; Configuration group mask\n.equ BOD_VLMCFG_gp = 1                   ; Configuration group position\n.equ BOD_VLMCFG0_bm = (1<<1)             ; Configuration bit 0 mask\n.equ BOD_VLMCFG0_bp = 1                  ; Configuration bit 0 position\n.equ BOD_VLMCFG1_bm = (1<<2)             ; Configuration bit 1 mask\n.equ BOD_VLMCFG1_bp = 2                  ; Configuration bit 1 position\n.equ BOD_VLMIE_bm = 0x01                 ; voltage level monitor interrrupt enable bit mask\n.equ BOD_VLMIE_bp = 0                    ; voltage level monitor interrrupt enable bit position\n\n; BOD_INTFLAGS masks\n.equ BOD_VLMIF_bm = 0x01                 ; Voltage level monitor interrupt flag bit mask\n.equ BOD_VLMIF_bp = 0                    ; Voltage level monitor interrupt flag bit position\n\n; BOD_STATUS masks\n.equ BOD_VLMS_bm = 0x01                  ; Voltage level monitor status bit mask\n.equ BOD_VLMS_bp = 0                     ; Voltage level monitor status bit position\n\n; BOD_VLMCTRLA masks\n.equ BOD_VLMLVL_gm = 0x03                ; voltage level monitor level group mask\n.equ BOD_VLMLVL_gp = 0                   ; voltage level monitor level group position\n.equ BOD_VLMLVL0_bm = (1<<0)             ; voltage level monitor level bit 0 mask\n.equ BOD_VLMLVL0_bp = 0                  ; voltage level monitor level bit 0 position\n.equ BOD_VLMLVL1_bm = (1<<1)             ; voltage level monitor level bit 1 mask\n.equ BOD_VLMLVL1_bp = 1                  ; voltage level monitor level bit 1 position\n\n; Operation in active mode select\n.equ BOD_ACTIVE_DIS_gc = (0x00<<2)       ; Disabled\n.equ BOD_ACTIVE_ENABLED_gc = (0x01<<2)   ; Enabled\n.equ BOD_ACTIVE_SAMPLED_gc = (0x02<<2)   ; Sampled\n.equ BOD_ACTIVE_ENWAKE_gc = (0x03<<2)    ; Enabled with wakeup halt\n\n; Sample frequency select\n.equ BOD_SAMPFREQ_1KHZ_gc = (0x00<<4)    ; 1kHz sampling\n.equ BOD_SAMPFREQ_125Hz_gc = (0x01<<4)   ; 125Hz sampling\n\n; Operation in sleep mode select\n.equ BOD_SLEEP_DIS_gc = (0x00<<0)        ; Disabled\n.equ BOD_SLEEP_ENABLED_gc = (0x01<<0)    ; Enabled\n.equ BOD_SLEEP_SAMPLED_gc = (0x02<<0)    ; Sampled\n\n; Bod level select\n.equ BOD_LVL_BODLEVEL0_gc = (0x00<<0)    ; 1.8 V\n.equ BOD_LVL_BODLEVEL2_gc = (0x02<<0)    ; 2.6 V\n.equ BOD_LVL_BODLEVEL7_gc = (0x07<<0)    ; 4.2 V\n\n; Configuration select\n.equ BOD_VLMCFG_BELOW_gc = (0x00<<1)     ; Interrupt when supply goes below VLM level\n.equ BOD_VLMCFG_ABOVE_gc = (0x01<<1)     ; Interrupt when supply goes above VLM level\n.equ BOD_VLMCFG_CROSS_gc = (0x02<<1)     ; Interrupt when supply crosses VLM level\n\n; voltage level monitor level select\n.equ BOD_VLMLVL_5ABOVE_gc = (0x00<<0)    ; VLM threshold 5% above BOD level\n.equ BOD_VLMLVL_15ABOVE_gc = (0x01<<0)   ; VLM threshold 15% above BOD level\n.equ BOD_VLMLVL_25ABOVE_gc = (0x02<<0)   ; VLM threshold 25% above BOD level\n\n\n;*************************************************************************\n;** CCL - Configurable Custom Logic\n;*************************************************************************\n\n; CCL_CTRLA masks\n.equ CCL_ENABLE_bm = 0x01                ; Enable bit mask\n.equ CCL_ENABLE_bp = 0                   ; Enable bit position\n.equ CCL_RUNSTDBY_bm = 0x40              ; Run in Standby bit mask\n.equ CCL_RUNSTDBY_bp = 6                 ; Run in Standby bit position\n\n; CCL_LUT0CTRLA masks\n.equ CCL_CLKSRC_bm = 0x40                ; Clock Source Selection bit mask\n.equ CCL_CLKSRC_bp = 6                   ; Clock Source Selection bit position\n.equ CCL_EDGEDET_bm = 0x80               ; Edge Detection Enable bit mask\n.equ CCL_EDGEDET_bp = 7                  ; Edge Detection Enable bit position\n; Masks for CCL_ENABLE already defined\n.equ CCL_FILTSEL_gm = 0x30               ; Filter Selection group mask\n.equ CCL_FILTSEL_gp = 4                  ; Filter Selection group position\n.equ CCL_FILTSEL0_bm = (1<<4)            ; Filter Selection bit 0 mask\n.equ CCL_FILTSEL0_bp = 4                 ; Filter Selection bit 0 position\n.equ CCL_FILTSEL1_bm = (1<<5)            ; Filter Selection bit 1 mask\n.equ CCL_FILTSEL1_bp = 5                 ; Filter Selection bit 1 position\n.equ CCL_OUTEN_bm = 0x08                 ; Output Enable bit mask\n.equ CCL_OUTEN_bp = 3                    ; Output Enable bit position\n\n; CCL_LUT0CTRLB masks\n.equ CCL_INSEL0_gm = 0x0F                ; LUT Input 0 Source Selection group mask\n.equ CCL_INSEL0_gp = 0                   ; LUT Input 0 Source Selection group position\n.equ CCL_INSEL00_bm = (1<<0)             ; LUT Input 0 Source Selection bit 0 mask\n.equ CCL_INSEL00_bp = 0                  ; LUT Input 0 Source Selection bit 0 position\n.equ CCL_INSEL01_bm = (1<<1)             ; LUT Input 0 Source Selection bit 1 mask\n.equ CCL_INSEL01_bp = 1                  ; LUT Input 0 Source Selection bit 1 position\n.equ CCL_INSEL02_bm = (1<<2)             ; LUT Input 0 Source Selection bit 2 mask\n.equ CCL_INSEL02_bp = 2                  ; LUT Input 0 Source Selection bit 2 position\n.equ CCL_INSEL03_bm = (1<<3)             ; LUT Input 0 Source Selection bit 3 mask\n.equ CCL_INSEL03_bp = 3                  ; LUT Input 0 Source Selection bit 3 position\n.equ CCL_INSEL1_gm = 0xF0                ; LUT Input 1 Source Selection group mask\n.equ CCL_INSEL1_gp = 4                   ; LUT Input 1 Source Selection group position\n.equ CCL_INSEL10_bm = (1<<4)             ; LUT Input 1 Source Selection bit 0 mask\n.equ CCL_INSEL10_bp = 4                  ; LUT Input 1 Source Selection bit 0 position\n.equ CCL_INSEL11_bm = (1<<5)             ; LUT Input 1 Source Selection bit 1 mask\n.equ CCL_INSEL11_bp = 5                  ; LUT Input 1 Source Selection bit 1 position\n.equ CCL_INSEL12_bm = (1<<6)             ; LUT Input 1 Source Selection bit 2 mask\n.equ CCL_INSEL12_bp = 6                  ; LUT Input 1 Source Selection bit 2 position\n.equ CCL_INSEL13_bm = (1<<7)             ; LUT Input 1 Source Selection bit 3 mask\n.equ CCL_INSEL13_bp = 7                  ; LUT Input 1 Source Selection bit 3 position\n\n; CCL_LUT0CTRLC masks\n.equ CCL_INSEL2_gm = 0x0F                ; LUT Input 2 Source Selection group mask\n.equ CCL_INSEL2_gp = 0                   ; LUT Input 2 Source Selection group position\n.equ CCL_INSEL20_bm = (1<<0)             ; LUT Input 2 Source Selection bit 0 mask\n.equ CCL_INSEL20_bp = 0                  ; LUT Input 2 Source Selection bit 0 position\n.equ CCL_INSEL21_bm = (1<<1)             ; LUT Input 2 Source Selection bit 1 mask\n.equ CCL_INSEL21_bp = 1                  ; LUT Input 2 Source Selection bit 1 position\n.equ CCL_INSEL22_bm = (1<<2)             ; LUT Input 2 Source Selection bit 2 mask\n.equ CCL_INSEL22_bp = 2                  ; LUT Input 2 Source Selection bit 2 position\n.equ CCL_INSEL23_bm = (1<<3)             ; LUT Input 2 Source Selection bit 3 mask\n.equ CCL_INSEL23_bp = 3                  ; LUT Input 2 Source Selection bit 3 position\n\n; CCL_LUT1CTRLA masks\n; Masks for CCL_CLKSRC already defined\n; Masks for CCL_EDGEDET already defined\n; Masks for CCL_ENABLE already defined\n; Masks for CCL_FILTSEL already defined\n; Masks for CCL_OUTEN already defined\n\n; CCL_LUT1CTRLB masks\n; Masks for CCL_INSEL0 already defined\n; Masks for CCL_INSEL1 already defined\n\n; CCL_LUT1CTRLC masks\n; Masks for CCL_INSEL2 already defined\n\n; CCL_SEQCTRL0 masks\n.equ CCL_SEQSEL_gm = 0x07                ; Sequential Selection group mask\n.equ CCL_SEQSEL_gp = 0                   ; Sequential Selection group position\n.equ CCL_SEQSEL0_bm = (1<<0)             ; Sequential Selection bit 0 mask\n.equ CCL_SEQSEL0_bp = 0                  ; Sequential Selection bit 0 position\n.equ CCL_SEQSEL1_bm = (1<<1)             ; Sequential Selection bit 1 mask\n.equ CCL_SEQSEL1_bp = 1                  ; Sequential Selection bit 1 position\n.equ CCL_SEQSEL2_bm = (1<<2)             ; Sequential Selection bit 2 mask\n.equ CCL_SEQSEL2_bp = 2                  ; Sequential Selection bit 2 position\n\n; CCL_TRUTH0 masks\n.equ CCL_TRUTH_gm = 0xFF                 ; Truth Table group mask\n.equ CCL_TRUTH_gp = 0                    ; Truth Table group position\n.equ CCL_TRUTH0_bm = (1<<0)              ; Truth Table bit 0 mask\n.equ CCL_TRUTH0_bp = 0                   ; Truth Table bit 0 position\n.equ CCL_TRUTH1_bm = (1<<1)              ; Truth Table bit 1 mask\n.equ CCL_TRUTH1_bp = 1                   ; Truth Table bit 1 position\n.equ CCL_TRUTH2_bm = (1<<2)              ; Truth Table bit 2 mask\n.equ CCL_TRUTH2_bp = 2                   ; Truth Table bit 2 position\n.equ CCL_TRUTH3_bm = (1<<3)              ; Truth Table bit 3 mask\n.equ CCL_TRUTH3_bp = 3                   ; Truth Table bit 3 position\n.equ CCL_TRUTH4_bm = (1<<4)              ; Truth Table bit 4 mask\n.equ CCL_TRUTH4_bp = 4                   ; Truth Table bit 4 position\n.equ CCL_TRUTH5_bm = (1<<5)              ; Truth Table bit 5 mask\n.equ CCL_TRUTH5_bp = 5                   ; Truth Table bit 5 position\n.equ CCL_TRUTH6_bm = (1<<6)              ; Truth Table bit 6 mask\n.equ CCL_TRUTH6_bp = 6                   ; Truth Table bit 6 position\n.equ CCL_TRUTH7_bm = (1<<7)              ; Truth Table bit 7 mask\n.equ CCL_TRUTH7_bp = 7                   ; Truth Table bit 7 position\n\n; CCL_TRUTH1 masks\n; Masks for CCL_TRUTH already defined\n\n; Edge Detection Enable select\n.equ CCL_EDGEDET_DIS_gc = (0x00<<7)      ; Edge detector is disabled\n.equ CCL_EDGEDET_EN_gc = (0x01<<7)       ; Edge detector is enabled\n\n; Filter Selection select\n.equ CCL_FILTSEL_DISABLE_gc = (0x00<<4)  ; Filter disabled\n.equ CCL_FILTSEL_SYNCH_gc = (0x01<<4)    ; Synchronizer enabled\n.equ CCL_FILTSEL_FILTER_gc = (0x02<<4)   ; Filter enabled\n\n; LUT Input 0 Source Selection select\n.equ CCL_INSEL0_MASK_gc = (0x00<<0)      ; Masked input\n.equ CCL_INSEL0_FEEDBACK_gc = (0x01<<0)  ; Feedback input source\n.equ CCL_INSEL0_LINK_gc = (0x02<<0)      ; Linked LUT input source\n.equ CCL_INSEL0_EVENT0_gc = (0x03<<0)    ; Event input source 0\n.equ CCL_INSEL0_EVENT1_gc = (0x04<<0)    ; Event input source 1\n.equ CCL_INSEL0_IO_gc = (0x05<<0)        ; IO pin LUTn-IN0 input source\n.equ CCL_INSEL0_AC0_gc = (0x06<<0)       ; AC0 OUT input source\n.equ CCL_INSEL0_TCB0_gc = (0x07<<0)      ; TCB0 WO input source\n.equ CCL_INSEL0_TCA0_gc = (0x08<<0)      ; TCA0 WO0 input source\n.equ CCL_INSEL0_TCD0_gc = (0x09<<0)      ; TCD0 WOA input source\n.equ CCL_INSEL0_USART0_gc = (0x0A<<0)    ; USART0 XCK input source\n.equ CCL_INSEL0_SPI0_gc = (0x0B<<0)      ; SPI0 SCK source\n\n; LUT Input 1 Source Selection select\n.equ CCL_INSEL1_MASK_gc = (0x00<<4)      ; Masked input\n.equ CCL_INSEL1_FEEDBACK_gc = (0x01<<4)  ; Feedback input source\n.equ CCL_INSEL1_LINK_gc = (0x02<<4)      ; Linked LUT input source\n.equ CCL_INSEL1_EVENT0_gc = (0x03<<4)    ; Event input source 0\n.equ CCL_INSEL1_EVENT1_gc = (0x04<<4)    ; Event input source 1\n.equ CCL_INSEL1_IO_gc = (0x05<<4)        ; IO pin LUTn-N1 input source\n.equ CCL_INSEL1_AC0_gc = (0x06<<4)       ; AC0 OUT input source\n.equ CCL_INSEL1_TCB0_gc = (0x07<<4)      ; TCB0 WO input source\n.equ CCL_INSEL1_TCA0_gc = (0x08<<4)      ; TCA0 WO1 input source\n.equ CCL_INSEL1_TCD0_gc = (0x09<<4)      ; TCD0 WOB input source\n.equ CCL_INSEL1_USART0_gc = (0x0A<<4)    ; USART0 TXD input source\n.equ CCL_INSEL1_SPI0_gc = (0x0B<<4)      ; SPI0 MOSI input source\n\n; LUT Input 2 Source Selection select\n.equ CCL_INSEL2_MASK_gc = (0x00<<0)      ; Masked input\n.equ CCL_INSEL2_FEEDBACK_gc = (0x01<<0)  ; Feedback input source\n.equ CCL_INSEL2_LINK_gc = (0x02<<0)      ; Linked LUT input source\n.equ CCL_INSEL2_EVENT0_gc = (0x03<<0)    ; Event input source 0\n.equ CCL_INSEL2_EVENT1_gc = (0x04<<0)    ; Event input source 1\n.equ CCL_INSEL2_IO_gc = (0x05<<0)        ; IO pin LUTn-IN2 input source\n.equ CCL_INSEL2_AC0_gc = (0x06<<0)       ; AC0 OUT input source\n.equ CCL_INSEL2_TCB0_gc = (0x07<<0)      ; TCB0 WO input source\n.equ CCL_INSEL2_TCA0_gc = (0x08<<0)      ; TCA0 WO2 input source\n.equ CCL_INSEL2_TCD0_gc = (0x09<<0)      ; TCD0 WOA input source\n.equ CCL_INSEL2_SPI0_gc = (0x0B<<0)      ; SPI0 MISO source\n\n; Sequential Selection select\n.equ CCL_SEQSEL_DISABLE_gc = (0x00<<0)   ; Sequential logic disabled\n.equ CCL_SEQSEL_DFF_gc = (0x01<<0)       ; D FlipFlop\n.equ CCL_SEQSEL_JK_gc = (0x02<<0)        ; JK FlipFlop\n.equ CCL_SEQSEL_LATCH_gc = (0x03<<0)     ; D Latch\n.equ CCL_SEQSEL_RS_gc = (0x04<<0)        ; RS Latch\n\n\n;*************************************************************************\n;** CLKCTRL - Clock controller\n;*************************************************************************\n\n; CLKCTRL_MCLKCTRLA masks\n.equ CLKCTRL_CLKOUT_bm = 0x80            ; System clock out bit mask\n.equ CLKCTRL_CLKOUT_bp = 7               ; System clock out bit position\n.equ CLKCTRL_CLKSEL_gm = 0x03            ; clock select group mask\n.equ CLKCTRL_CLKSEL_gp = 0               ; clock select group position\n.equ CLKCTRL_CLKSEL0_bm = (1<<0)         ; clock select bit 0 mask\n.equ CLKCTRL_CLKSEL0_bp = 0              ; clock select bit 0 position\n.equ CLKCTRL_CLKSEL1_bm = (1<<1)         ; clock select bit 1 mask\n.equ CLKCTRL_CLKSEL1_bp = 1              ; clock select bit 1 position\n\n; CLKCTRL_MCLKCTRLB masks\n.equ CLKCTRL_PDIV_gm = 0x1E              ; Prescaler division group mask\n.equ CLKCTRL_PDIV_gp = 1                 ; Prescaler division group position\n.equ CLKCTRL_PDIV0_bm = (1<<1)           ; Prescaler division bit 0 mask\n.equ CLKCTRL_PDIV0_bp = 1                ; Prescaler division bit 0 position\n.equ CLKCTRL_PDIV1_bm = (1<<2)           ; Prescaler division bit 1 mask\n.equ CLKCTRL_PDIV1_bp = 2                ; Prescaler division bit 1 position\n.equ CLKCTRL_PDIV2_bm = (1<<3)           ; Prescaler division bit 2 mask\n.equ CLKCTRL_PDIV2_bp = 3                ; Prescaler division bit 2 position\n.equ CLKCTRL_PDIV3_bm = (1<<4)           ; Prescaler division bit 3 mask\n.equ CLKCTRL_PDIV3_bp = 4                ; Prescaler division bit 3 position\n.equ CLKCTRL_PEN_bm = 0x01               ; Prescaler enable bit mask\n.equ CLKCTRL_PEN_bp = 0                  ; Prescaler enable bit position\n\n; CLKCTRL_MCLKLOCK masks\n.equ CLKCTRL_LOCKEN_bm = 0x01            ; lock ebable bit mask\n.equ CLKCTRL_LOCKEN_bp = 0               ; lock ebable bit position\n\n; CLKCTRL_MCLKSTATUS masks\n.equ CLKCTRL_EXTS_bm = 0x80              ; External Clock status bit mask\n.equ CLKCTRL_EXTS_bp = 7                 ; External Clock status bit position\n.equ CLKCTRL_OSC20MS_bm = 0x10           ; 20MHz oscillator status bit mask\n.equ CLKCTRL_OSC20MS_bp = 4              ; 20MHz oscillator status bit position\n.equ CLKCTRL_OSC32KS_bm = 0x20           ; 32KHz oscillator status bit mask\n.equ CLKCTRL_OSC32KS_bp = 5              ; 32KHz oscillator status bit position\n.equ CLKCTRL_SOSC_bm = 0x01              ; System Oscillator changing bit mask\n.equ CLKCTRL_SOSC_bp = 0                 ; System Oscillator changing bit position\n\n; CLKCTRL_OSC20MCALIBA masks\n.equ CLKCTRL_CAL20M_gm = 0x3F            ; Calibration group mask\n.equ CLKCTRL_CAL20M_gp = 0               ; Calibration group position\n.equ CLKCTRL_CAL20M0_bm = (1<<0)         ; Calibration bit 0 mask\n.equ CLKCTRL_CAL20M0_bp = 0              ; Calibration bit 0 position\n.equ CLKCTRL_CAL20M1_bm = (1<<1)         ; Calibration bit 1 mask\n.equ CLKCTRL_CAL20M1_bp = 1              ; Calibration bit 1 position\n.equ CLKCTRL_CAL20M2_bm = (1<<2)         ; Calibration bit 2 mask\n.equ CLKCTRL_CAL20M2_bp = 2              ; Calibration bit 2 position\n.equ CLKCTRL_CAL20M3_bm = (1<<3)         ; Calibration bit 3 mask\n.equ CLKCTRL_CAL20M3_bp = 3              ; Calibration bit 3 position\n.equ CLKCTRL_CAL20M4_bm = (1<<4)         ; Calibration bit 4 mask\n.equ CLKCTRL_CAL20M4_bp = 4              ; Calibration bit 4 position\n.equ CLKCTRL_CAL20M5_bm = (1<<5)         ; Calibration bit 5 mask\n.equ CLKCTRL_CAL20M5_bp = 5              ; Calibration bit 5 position\n\n; CLKCTRL_OSC20MCALIBB masks\n.equ CLKCTRL_LOCK_bm = 0x80              ; Lock bit mask\n.equ CLKCTRL_LOCK_bp = 7                 ; Lock bit position\n.equ CLKCTRL_TEMPCAL20M_gm = 0x0F        ; Oscillator temperature coefficient group mask\n.equ CLKCTRL_TEMPCAL20M_gp = 0           ; Oscillator temperature coefficient group position\n.equ CLKCTRL_TEMPCAL20M0_bm = (1<<0)     ; Oscillator temperature coefficient bit 0 mask\n.equ CLKCTRL_TEMPCAL20M0_bp = 0          ; Oscillator temperature coefficient bit 0 position\n.equ CLKCTRL_TEMPCAL20M1_bm = (1<<1)     ; Oscillator temperature coefficient bit 1 mask\n.equ CLKCTRL_TEMPCAL20M1_bp = 1          ; Oscillator temperature coefficient bit 1 position\n.equ CLKCTRL_TEMPCAL20M2_bm = (1<<2)     ; Oscillator temperature coefficient bit 2 mask\n.equ CLKCTRL_TEMPCAL20M2_bp = 2          ; Oscillator temperature coefficient bit 2 position\n.equ CLKCTRL_TEMPCAL20M3_bm = (1<<3)     ; Oscillator temperature coefficient bit 3 mask\n.equ CLKCTRL_TEMPCAL20M3_bp = 3          ; Oscillator temperature coefficient bit 3 position\n\n; CLKCTRL_OSC20MCTRLA masks\n.equ CLKCTRL_RUNSTDBY_bm = 0x02          ; Run standby bit mask\n.equ CLKCTRL_RUNSTDBY_bp = 1             ; Run standby bit position\n\n; CLKCTRL_OSC32KCTRLA masks\n; Masks for CLKCTRL_RUNSTDBY already defined\n\n; clock select select\n.equ CLKCTRL_CLKSEL_OSC20M_gc = (0x00<<0) ; 20MHz internal oscillator\n.equ CLKCTRL_CLKSEL_OSCULP32K_gc = (0x01<<0) ; 32KHz internal Ultra Low Power oscillator\n.equ CLKCTRL_CLKSEL_EXTCLK_gc = (0x03<<0) ; External clock\n\n; Prescaler division select\n.equ CLKCTRL_PDIV_2X_gc = (0x00<<1)      ; 2X\n.equ CLKCTRL_PDIV_4X_gc = (0x01<<1)      ; 4X\n.equ CLKCTRL_PDIV_8X_gc = (0x02<<1)      ; 8X\n.equ CLKCTRL_PDIV_16X_gc = (0x03<<1)     ; 16X\n.equ CLKCTRL_PDIV_32X_gc = (0x04<<1)     ; 32X\n.equ CLKCTRL_PDIV_64X_gc = (0x05<<1)     ; 64X\n.equ CLKCTRL_PDIV_6X_gc = (0x08<<1)      ; 6X\n.equ CLKCTRL_PDIV_10X_gc = (0x09<<1)     ; 10X\n.equ CLKCTRL_PDIV_12X_gc = (0x0A<<1)     ; 12X\n.equ CLKCTRL_PDIV_24X_gc = (0x0B<<1)     ; 24X\n.equ CLKCTRL_PDIV_48X_gc = (0x0C<<1)     ; 48X\n\n\n;*************************************************************************\n;** CPU - CPU\n;*************************************************************************\n\n; CPU_CCP masks\n.equ CPU_CCP_gm = 0xFF                   ; CCP signature group mask\n.equ CPU_CCP_gp = 0                      ; CCP signature group position\n.equ CPU_CCP0_bm = (1<<0)                ; CCP signature bit 0 mask\n.equ CPU_CCP0_bp = 0                     ; CCP signature bit 0 position\n.equ CPU_CCP1_bm = (1<<1)                ; CCP signature bit 1 mask\n.equ CPU_CCP1_bp = 1                     ; CCP signature bit 1 position\n.equ CPU_CCP2_bm = (1<<2)                ; CCP signature bit 2 mask\n.equ CPU_CCP2_bp = 2                     ; CCP signature bit 2 position\n.equ CPU_CCP3_bm = (1<<3)                ; CCP signature bit 3 mask\n.equ CPU_CCP3_bp = 3                     ; CCP signature bit 3 position\n.equ CPU_CCP4_bm = (1<<4)                ; CCP signature bit 4 mask\n.equ CPU_CCP4_bp = 4                     ; CCP signature bit 4 position\n.equ CPU_CCP5_bm = (1<<5)                ; CCP signature bit 5 mask\n.equ CPU_CCP5_bp = 5                     ; CCP signature bit 5 position\n.equ CPU_CCP6_bm = (1<<6)                ; CCP signature bit 6 mask\n.equ CPU_CCP6_bp = 6                     ; CCP signature bit 6 position\n.equ CPU_CCP7_bm = (1<<7)                ; CCP signature bit 7 mask\n.equ CPU_CCP7_bp = 7                     ; CCP signature bit 7 position\n\n; CPU_SREG masks\n.equ CPU_C_bm = 0x01                     ; Carry Flag bit mask\n.equ CPU_C_bp = 0                        ; Carry Flag bit position\n.equ CPU_H_bm = 0x20                     ; Half Carry Flag bit mask\n.equ CPU_H_bp = 5                        ; Half Carry Flag bit position\n.equ CPU_I_bm = 0x80                     ; Global Interrupt Enable Flag bit mask\n.equ CPU_I_bp = 7                        ; Global Interrupt Enable Flag bit position\n.equ CPU_N_bm = 0x04                     ; Negative Flag bit mask\n.equ CPU_N_bp = 2                        ; Negative Flag bit position\n.equ CPU_S_bm = 0x10                     ; N Exclusive Or V Flag bit mask\n.equ CPU_S_bp = 4                        ; N Exclusive Or V Flag bit position\n.equ CPU_T_bm = 0x40                     ; Transfer Bit bit mask\n.equ CPU_T_bp = 6                        ; Transfer Bit bit position\n.equ CPU_V_bm = 0x08                     ; Two's Complement Overflow Flag bit mask\n.equ CPU_V_bp = 3                        ; Two's Complement Overflow Flag bit position\n.equ CPU_Z_bm = 0x02                     ; Zero Flag bit mask\n.equ CPU_Z_bp = 1                        ; Zero Flag bit position\n\n; CCP signature select\n.equ CPU_CCP_SPM_gc = (0x9D<<0)          ; SPM Instruction Protection\n.equ CPU_CCP_IOREG_gc = (0xD8<<0)        ; IO Register Protection\n\n\n;*************************************************************************\n;** CPUINT - Interrupt Controller\n;*************************************************************************\n\n; CPUINT_CTRLA masks\n.equ CPUINT_CVT_bm = 0x20                ; Compact Vector Table bit mask\n.equ CPUINT_CVT_bp = 5                   ; Compact Vector Table bit position\n.equ CPUINT_IVSEL_bm = 0x40              ; Interrupt Vector Select bit mask\n.equ CPUINT_IVSEL_bp = 6                 ; Interrupt Vector Select bit position\n.equ CPUINT_LVL0RR_bm = 0x01             ; Round-robin Scheduling Enable bit mask\n.equ CPUINT_LVL0RR_bp = 0                ; Round-robin Scheduling Enable bit position\n\n; CPUINT_LVL0PRI masks\n.equ CPUINT_LVL0PRI_gm = 0xFF            ; Interrupt Level Priority group mask\n.equ CPUINT_LVL0PRI_gp = 0               ; Interrupt Level Priority group position\n.equ CPUINT_LVL0PRI0_bm = (1<<0)         ; Interrupt Level Priority bit 0 mask\n.equ CPUINT_LVL0PRI0_bp = 0              ; Interrupt Level Priority bit 0 position\n.equ CPUINT_LVL0PRI1_bm = (1<<1)         ; Interrupt Level Priority bit 1 mask\n.equ CPUINT_LVL0PRI1_bp = 1              ; Interrupt Level Priority bit 1 position\n.equ CPUINT_LVL0PRI2_bm = (1<<2)         ; Interrupt Level Priority bit 2 mask\n.equ CPUINT_LVL0PRI2_bp = 2              ; Interrupt Level Priority bit 2 position\n.equ CPUINT_LVL0PRI3_bm = (1<<3)         ; Interrupt Level Priority bit 3 mask\n.equ CPUINT_LVL0PRI3_bp = 3              ; Interrupt Level Priority bit 3 position\n.equ CPUINT_LVL0PRI4_bm = (1<<4)         ; Interrupt Level Priority bit 4 mask\n.equ CPUINT_LVL0PRI4_bp = 4              ; Interrupt Level Priority bit 4 position\n.equ CPUINT_LVL0PRI5_bm = (1<<5)         ; Interrupt Level Priority bit 5 mask\n.equ CPUINT_LVL0PRI5_bp = 5              ; Interrupt Level Priority bit 5 position\n.equ CPUINT_LVL0PRI6_bm = (1<<6)         ; Interrupt Level Priority bit 6 mask\n.equ CPUINT_LVL0PRI6_bp = 6              ; Interrupt Level Priority bit 6 position\n.equ CPUINT_LVL0PRI7_bm = (1<<7)         ; Interrupt Level Priority bit 7 mask\n.equ CPUINT_LVL0PRI7_bp = 7              ; Interrupt Level Priority bit 7 position\n\n; CPUINT_LVL1VEC masks\n.equ CPUINT_LVL1VEC_gm = 0xFF            ; Interrupt Vector with High Priority group mask\n.equ CPUINT_LVL1VEC_gp = 0               ; Interrupt Vector with High Priority group position\n.equ CPUINT_LVL1VEC0_bm = (1<<0)         ; Interrupt Vector with High Priority bit 0 mask\n.equ CPUINT_LVL1VEC0_bp = 0              ; Interrupt Vector with High Priority bit 0 position\n.equ CPUINT_LVL1VEC1_bm = (1<<1)         ; Interrupt Vector with High Priority bit 1 mask\n.equ CPUINT_LVL1VEC1_bp = 1              ; Interrupt Vector with High Priority bit 1 position\n.equ CPUINT_LVL1VEC2_bm = (1<<2)         ; Interrupt Vector with High Priority bit 2 mask\n.equ CPUINT_LVL1VEC2_bp = 2              ; Interrupt Vector with High Priority bit 2 position\n.equ CPUINT_LVL1VEC3_bm = (1<<3)         ; Interrupt Vector with High Priority bit 3 mask\n.equ CPUINT_LVL1VEC3_bp = 3              ; Interrupt Vector with High Priority bit 3 position\n.equ CPUINT_LVL1VEC4_bm = (1<<4)         ; Interrupt Vector with High Priority bit 4 mask\n.equ CPUINT_LVL1VEC4_bp = 4              ; Interrupt Vector with High Priority bit 4 position\n.equ CPUINT_LVL1VEC5_bm = (1<<5)         ; Interrupt Vector with High Priority bit 5 mask\n.equ CPUINT_LVL1VEC5_bp = 5              ; Interrupt Vector with High Priority bit 5 position\n.equ CPUINT_LVL1VEC6_bm = (1<<6)         ; Interrupt Vector with High Priority bit 6 mask\n.equ CPUINT_LVL1VEC6_bp = 6              ; Interrupt Vector with High Priority bit 6 position\n.equ CPUINT_LVL1VEC7_bm = (1<<7)         ; Interrupt Vector with High Priority bit 7 mask\n.equ CPUINT_LVL1VEC7_bp = 7              ; Interrupt Vector with High Priority bit 7 position\n\n; CPUINT_STATUS masks\n.equ CPUINT_LVL0EX_bm = 0x01             ; Level 0 Interrupt Executing bit mask\n.equ CPUINT_LVL0EX_bp = 0                ; Level 0 Interrupt Executing bit position\n.equ CPUINT_LVL1EX_bm = 0x02             ; Level 1 Interrupt Executing bit mask\n.equ CPUINT_LVL1EX_bp = 1                ; Level 1 Interrupt Executing bit position\n.equ CPUINT_NMIEX_bm = 0x80              ; Non-maskable Interrupt Executing bit mask\n.equ CPUINT_NMIEX_bp = 7                 ; Non-maskable Interrupt Executing bit position\n\n\n;*************************************************************************\n;** CRCSCAN - CRCSCAN\n;*************************************************************************\n\n; CRCSCAN_CTRLA masks\n.equ CRCSCAN_ENABLE_bm = 0x01            ; Enable CRC scan bit mask\n.equ CRCSCAN_ENABLE_bp = 0               ; Enable CRC scan bit position\n.equ CRCSCAN_NMIEN_bm = 0x02             ; Enable NMI Trigger bit mask\n.equ CRCSCAN_NMIEN_bp = 1                ; Enable NMI Trigger bit position\n.equ CRCSCAN_RESET_bm = 0x80             ; Reset CRC scan bit mask\n.equ CRCSCAN_RESET_bp = 7                ; Reset CRC scan bit position\n\n; CRCSCAN_CTRLB masks\n.equ CRCSCAN_MODE_gm = 0x30              ; CRC Flash Access Mode group mask\n.equ CRCSCAN_MODE_gp = 4                 ; CRC Flash Access Mode group position\n.equ CRCSCAN_MODE0_bm = (1<<4)           ; CRC Flash Access Mode bit 0 mask\n.equ CRCSCAN_MODE0_bp = 4                ; CRC Flash Access Mode bit 0 position\n.equ CRCSCAN_MODE1_bm = (1<<5)           ; CRC Flash Access Mode bit 1 mask\n.equ CRCSCAN_MODE1_bp = 5                ; CRC Flash Access Mode bit 1 position\n.equ CRCSCAN_SRC_gm = 0x03               ; CRC Source group mask\n.equ CRCSCAN_SRC_gp = 0                  ; CRC Source group position\n.equ CRCSCAN_SRC0_bm = (1<<0)            ; CRC Source bit 0 mask\n.equ CRCSCAN_SRC0_bp = 0                 ; CRC Source bit 0 position\n.equ CRCSCAN_SRC1_bm = (1<<1)            ; CRC Source bit 1 mask\n.equ CRCSCAN_SRC1_bp = 1                 ; CRC Source bit 1 position\n\n; CRCSCAN_STATUS masks\n.equ CRCSCAN_BUSY_bm = 0x01              ; CRC Busy bit mask\n.equ CRCSCAN_BUSY_bp = 0                 ; CRC Busy bit position\n.equ CRCSCAN_OK_bm = 0x02                ; CRC Ok bit mask\n.equ CRCSCAN_OK_bp = 1                   ; CRC Ok bit position\n\n; CRC Flash Access Mode select\n.equ CRCSCAN_MODE_PRIORITY_gc = (0x00<<4) ; Priority to flash\n.equ CRCSCAN_MODE_RESERVED_gc = (0x01<<4) ; Reserved\n.equ CRCSCAN_MODE_BACKGROUND_gc = (0x02<<4) ; Lowest priority to flash\n.equ CRCSCAN_MODE_CONTINUOUS_gc = (0x03<<4) ; Continuous checks in background\n\n; CRC Source select\n.equ CRCSCAN_SRC_FLASH_gc = (0x00<<0)    ; CRC on entire flash\n.equ CRCSCAN_SRC_APPLICATION_gc = (0x01<<0) ; CRC on boot and appl section of flash\n.equ CRCSCAN_SRC_BOOT_gc = (0x02<<0)     ; CRC on boot section of flash\n\n\n;*************************************************************************\n;** EVSYS - Event System\n;*************************************************************************\n\n; EVSYS_ASYNCCH0 masks\n.equ EVSYS_ASYNCCH0_gm = 0xFF            ; Asynchronous Channel 0 Generator Selection group mask\n.equ EVSYS_ASYNCCH0_gp = 0               ; Asynchronous Channel 0 Generator Selection group position\n.equ EVSYS_ASYNCCH00_bm = (1<<0)         ; Asynchronous Channel 0 Generator Selection bit 0 mask\n.equ EVSYS_ASYNCCH00_bp = 0              ; Asynchronous Channel 0 Generator Selection bit 0 position\n.equ EVSYS_ASYNCCH01_bm = (1<<1)         ; Asynchronous Channel 0 Generator Selection bit 1 mask\n.equ EVSYS_ASYNCCH01_bp = 1              ; Asynchronous Channel 0 Generator Selection bit 1 position\n.equ EVSYS_ASYNCCH02_bm = (1<<2)         ; Asynchronous Channel 0 Generator Selection bit 2 mask\n.equ EVSYS_ASYNCCH02_bp = 2              ; Asynchronous Channel 0 Generator Selection bit 2 position\n.equ EVSYS_ASYNCCH03_bm = (1<<3)         ; Asynchronous Channel 0 Generator Selection bit 3 mask\n.equ EVSYS_ASYNCCH03_bp = 3              ; Asynchronous Channel 0 Generator Selection bit 3 position\n.equ EVSYS_ASYNCCH04_bm = (1<<4)         ; Asynchronous Channel 0 Generator Selection bit 4 mask\n.equ EVSYS_ASYNCCH04_bp = 4              ; Asynchronous Channel 0 Generator Selection bit 4 position\n.equ EVSYS_ASYNCCH05_bm = (1<<5)         ; Asynchronous Channel 0 Generator Selection bit 5 mask\n.equ EVSYS_ASYNCCH05_bp = 5              ; Asynchronous Channel 0 Generator Selection bit 5 position\n.equ EVSYS_ASYNCCH06_bm = (1<<6)         ; Asynchronous Channel 0 Generator Selection bit 6 mask\n.equ EVSYS_ASYNCCH06_bp = 6              ; Asynchronous Channel 0 Generator Selection bit 6 position\n.equ EVSYS_ASYNCCH07_bm = (1<<7)         ; Asynchronous Channel 0 Generator Selection bit 7 mask\n.equ EVSYS_ASYNCCH07_bp = 7              ; Asynchronous Channel 0 Generator Selection bit 7 position\n\n; EVSYS_ASYNCCH1 masks\n.equ EVSYS_ASYNCCH1_gm = 0xFF            ; Asynchronous Channel 1 Generator Selection group mask\n.equ EVSYS_ASYNCCH1_gp = 0               ; Asynchronous Channel 1 Generator Selection group position\n.equ EVSYS_ASYNCCH10_bm = (1<<0)         ; Asynchronous Channel 1 Generator Selection bit 0 mask\n.equ EVSYS_ASYNCCH10_bp = 0              ; Asynchronous Channel 1 Generator Selection bit 0 position\n.equ EVSYS_ASYNCCH11_bm = (1<<1)         ; Asynchronous Channel 1 Generator Selection bit 1 mask\n.equ EVSYS_ASYNCCH11_bp = 1              ; Asynchronous Channel 1 Generator Selection bit 1 position\n.equ EVSYS_ASYNCCH12_bm = (1<<2)         ; Asynchronous Channel 1 Generator Selection bit 2 mask\n.equ EVSYS_ASYNCCH12_bp = 2              ; Asynchronous Channel 1 Generator Selection bit 2 position\n.equ EVSYS_ASYNCCH13_bm = (1<<3)         ; Asynchronous Channel 1 Generator Selection bit 3 mask\n.equ EVSYS_ASYNCCH13_bp = 3              ; Asynchronous Channel 1 Generator Selection bit 3 position\n.equ EVSYS_ASYNCCH14_bm = (1<<4)         ; Asynchronous Channel 1 Generator Selection bit 4 mask\n.equ EVSYS_ASYNCCH14_bp = 4              ; Asynchronous Channel 1 Generator Selection bit 4 position\n.equ EVSYS_ASYNCCH15_bm = (1<<5)         ; Asynchronous Channel 1 Generator Selection bit 5 mask\n.equ EVSYS_ASYNCCH15_bp = 5              ; Asynchronous Channel 1 Generator Selection bit 5 position\n.equ EVSYS_ASYNCCH16_bm = (1<<6)         ; Asynchronous Channel 1 Generator Selection bit 6 mask\n.equ EVSYS_ASYNCCH16_bp = 6              ; Asynchronous Channel 1 Generator Selection bit 6 position\n.equ EVSYS_ASYNCCH17_bm = (1<<7)         ; Asynchronous Channel 1 Generator Selection bit 7 mask\n.equ EVSYS_ASYNCCH17_bp = 7              ; Asynchronous Channel 1 Generator Selection bit 7 position\n\n; EVSYS_ASYNCUSER0 masks\n.equ EVSYS_ASYNCUSER0_gm = 0xFF          ; Asynchronous User Ch 0 Input Selection - TCB0 group mask\n.equ EVSYS_ASYNCUSER0_gp = 0             ; Asynchronous User Ch 0 Input Selection - TCB0 group position\n.equ EVSYS_ASYNCUSER00_bm = (1<<0)       ; Asynchronous User Ch 0 Input Selection - TCB0 bit 0 mask\n.equ EVSYS_ASYNCUSER00_bp = 0            ; Asynchronous User Ch 0 Input Selection - TCB0 bit 0 position\n.equ EVSYS_ASYNCUSER01_bm = (1<<1)       ; Asynchronous User Ch 0 Input Selection - TCB0 bit 1 mask\n.equ EVSYS_ASYNCUSER01_bp = 1            ; Asynchronous User Ch 0 Input Selection - TCB0 bit 1 position\n.equ EVSYS_ASYNCUSER02_bm = (1<<2)       ; Asynchronous User Ch 0 Input Selection - TCB0 bit 2 mask\n.equ EVSYS_ASYNCUSER02_bp = 2            ; Asynchronous User Ch 0 Input Selection - TCB0 bit 2 position\n.equ EVSYS_ASYNCUSER03_bm = (1<<3)       ; Asynchronous User Ch 0 Input Selection - TCB0 bit 3 mask\n.equ EVSYS_ASYNCUSER03_bp = 3            ; Asynchronous User Ch 0 Input Selection - TCB0 bit 3 position\n.equ EVSYS_ASYNCUSER04_bm = (1<<4)       ; Asynchronous User Ch 0 Input Selection - TCB0 bit 4 mask\n.equ EVSYS_ASYNCUSER04_bp = 4            ; Asynchronous User Ch 0 Input Selection - TCB0 bit 4 position\n.equ EVSYS_ASYNCUSER05_bm = (1<<5)       ; Asynchronous User Ch 0 Input Selection - TCB0 bit 5 mask\n.equ EVSYS_ASYNCUSER05_bp = 5            ; Asynchronous User Ch 0 Input Selection - TCB0 bit 5 position\n.equ EVSYS_ASYNCUSER06_bm = (1<<6)       ; Asynchronous User Ch 0 Input Selection - TCB0 bit 6 mask\n.equ EVSYS_ASYNCUSER06_bp = 6            ; Asynchronous User Ch 0 Input Selection - TCB0 bit 6 position\n.equ EVSYS_ASYNCUSER07_bm = (1<<7)       ; Asynchronous User Ch 0 Input Selection - TCB0 bit 7 mask\n.equ EVSYS_ASYNCUSER07_bp = 7            ; Asynchronous User Ch 0 Input Selection - TCB0 bit 7 position\n\n; EVSYS_ASYNCUSER1 masks\n.equ EVSYS_ASYNCUSER1_gm = 0xFF          ; Asynchronous User Ch 1 Input Selection - ADC0 group mask\n.equ EVSYS_ASYNCUSER1_gp = 0             ; Asynchronous User Ch 1 Input Selection - ADC0 group position\n.equ EVSYS_ASYNCUSER10_bm = (1<<0)       ; Asynchronous User Ch 1 Input Selection - ADC0 bit 0 mask\n.equ EVSYS_ASYNCUSER10_bp = 0            ; Asynchronous User Ch 1 Input Selection - ADC0 bit 0 position\n.equ EVSYS_ASYNCUSER11_bm = (1<<1)       ; Asynchronous User Ch 1 Input Selection - ADC0 bit 1 mask\n.equ EVSYS_ASYNCUSER11_bp = 1            ; Asynchronous User Ch 1 Input Selection - ADC0 bit 1 position\n.equ EVSYS_ASYNCUSER12_bm = (1<<2)       ; Asynchronous User Ch 1 Input Selection - ADC0 bit 2 mask\n.equ EVSYS_ASYNCUSER12_bp = 2            ; Asynchronous User Ch 1 Input Selection - ADC0 bit 2 position\n.equ EVSYS_ASYNCUSER13_bm = (1<<3)       ; Asynchronous User Ch 1 Input Selection - ADC0 bit 3 mask\n.equ EVSYS_ASYNCUSER13_bp = 3            ; Asynchronous User Ch 1 Input Selection - ADC0 bit 3 position\n.equ EVSYS_ASYNCUSER14_bm = (1<<4)       ; Asynchronous User Ch 1 Input Selection - ADC0 bit 4 mask\n.equ EVSYS_ASYNCUSER14_bp = 4            ; Asynchronous User Ch 1 Input Selection - ADC0 bit 4 position\n.equ EVSYS_ASYNCUSER15_bm = (1<<5)       ; Asynchronous User Ch 1 Input Selection - ADC0 bit 5 mask\n.equ EVSYS_ASYNCUSER15_bp = 5            ; Asynchronous User Ch 1 Input Selection - ADC0 bit 5 position\n.equ EVSYS_ASYNCUSER16_bm = (1<<6)       ; Asynchronous User Ch 1 Input Selection - ADC0 bit 6 mask\n.equ EVSYS_ASYNCUSER16_bp = 6            ; Asynchronous User Ch 1 Input Selection - ADC0 bit 6 position\n.equ EVSYS_ASYNCUSER17_bm = (1<<7)       ; Asynchronous User Ch 1 Input Selection - ADC0 bit 7 mask\n.equ EVSYS_ASYNCUSER17_bp = 7            ; Asynchronous User Ch 1 Input Selection - ADC0 bit 7 position\n\n; EVSYS_ASYNCUSER2 masks\n.equ EVSYS_ASYNCUSER2_gm = 0xFF          ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 group mask\n.equ EVSYS_ASYNCUSER2_gp = 0             ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 group position\n.equ EVSYS_ASYNCUSER20_bm = (1<<0)       ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 0 mask\n.equ EVSYS_ASYNCUSER20_bp = 0            ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 0 position\n.equ EVSYS_ASYNCUSER21_bm = (1<<1)       ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 1 mask\n.equ EVSYS_ASYNCUSER21_bp = 1            ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 1 position\n.equ EVSYS_ASYNCUSER22_bm = (1<<2)       ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 2 mask\n.equ EVSYS_ASYNCUSER22_bp = 2            ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 2 position\n.equ EVSYS_ASYNCUSER23_bm = (1<<3)       ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 3 mask\n.equ EVSYS_ASYNCUSER23_bp = 3            ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 3 position\n.equ EVSYS_ASYNCUSER24_bm = (1<<4)       ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 4 mask\n.equ EVSYS_ASYNCUSER24_bp = 4            ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 4 position\n.equ EVSYS_ASYNCUSER25_bm = (1<<5)       ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 5 mask\n.equ EVSYS_ASYNCUSER25_bp = 5            ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 5 position\n.equ EVSYS_ASYNCUSER26_bm = (1<<6)       ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 6 mask\n.equ EVSYS_ASYNCUSER26_bp = 6            ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 6 position\n.equ EVSYS_ASYNCUSER27_bm = (1<<7)       ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 7 mask\n.equ EVSYS_ASYNCUSER27_bp = 7            ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 7 position\n\n; EVSYS_ASYNCUSER3 masks\n.equ EVSYS_ASYNCUSER3_gm = 0xFF          ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 group mask\n.equ EVSYS_ASYNCUSER3_gp = 0             ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 group position\n.equ EVSYS_ASYNCUSER30_bm = (1<<0)       ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 0 mask\n.equ EVSYS_ASYNCUSER30_bp = 0            ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 0 position\n.equ EVSYS_ASYNCUSER31_bm = (1<<1)       ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 1 mask\n.equ EVSYS_ASYNCUSER31_bp = 1            ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 1 position\n.equ EVSYS_ASYNCUSER32_bm = (1<<2)       ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 2 mask\n.equ EVSYS_ASYNCUSER32_bp = 2            ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 2 position\n.equ EVSYS_ASYNCUSER33_bm = (1<<3)       ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 3 mask\n.equ EVSYS_ASYNCUSER33_bp = 3            ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 3 position\n.equ EVSYS_ASYNCUSER34_bm = (1<<4)       ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 4 mask\n.equ EVSYS_ASYNCUSER34_bp = 4            ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 4 position\n.equ EVSYS_ASYNCUSER35_bm = (1<<5)       ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 5 mask\n.equ EVSYS_ASYNCUSER35_bp = 5            ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 5 position\n.equ EVSYS_ASYNCUSER36_bm = (1<<6)       ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 6 mask\n.equ EVSYS_ASYNCUSER36_bp = 6            ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 6 position\n.equ EVSYS_ASYNCUSER37_bm = (1<<7)       ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 7 mask\n.equ EVSYS_ASYNCUSER37_bp = 7            ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 7 position\n\n; EVSYS_ASYNCUSER4 masks\n.equ EVSYS_ASYNCUSER4_gm = 0xFF          ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 group mask\n.equ EVSYS_ASYNCUSER4_gp = 0             ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 group position\n.equ EVSYS_ASYNCUSER40_bm = (1<<0)       ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 0 mask\n.equ EVSYS_ASYNCUSER40_bp = 0            ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 0 position\n.equ EVSYS_ASYNCUSER41_bm = (1<<1)       ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 1 mask\n.equ EVSYS_ASYNCUSER41_bp = 1            ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 1 position\n.equ EVSYS_ASYNCUSER42_bm = (1<<2)       ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 2 mask\n.equ EVSYS_ASYNCUSER42_bp = 2            ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 2 position\n.equ EVSYS_ASYNCUSER43_bm = (1<<3)       ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 3 mask\n.equ EVSYS_ASYNCUSER43_bp = 3            ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 3 position\n.equ EVSYS_ASYNCUSER44_bm = (1<<4)       ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 4 mask\n.equ EVSYS_ASYNCUSER44_bp = 4            ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 4 position\n.equ EVSYS_ASYNCUSER45_bm = (1<<5)       ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 5 mask\n.equ EVSYS_ASYNCUSER45_bp = 5            ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 5 position\n.equ EVSYS_ASYNCUSER46_bm = (1<<6)       ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 6 mask\n.equ EVSYS_ASYNCUSER46_bp = 6            ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 6 position\n.equ EVSYS_ASYNCUSER47_bm = (1<<7)       ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 7 mask\n.equ EVSYS_ASYNCUSER47_bp = 7            ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 7 position\n\n; EVSYS_ASYNCUSER5 masks\n.equ EVSYS_ASYNCUSER5_gm = 0xFF          ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 group mask\n.equ EVSYS_ASYNCUSER5_gp = 0             ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 group position\n.equ EVSYS_ASYNCUSER50_bm = (1<<0)       ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 0 mask\n.equ EVSYS_ASYNCUSER50_bp = 0            ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 0 position\n.equ EVSYS_ASYNCUSER51_bm = (1<<1)       ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 1 mask\n.equ EVSYS_ASYNCUSER51_bp = 1            ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 1 position\n.equ EVSYS_ASYNCUSER52_bm = (1<<2)       ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 2 mask\n.equ EVSYS_ASYNCUSER52_bp = 2            ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 2 position\n.equ EVSYS_ASYNCUSER53_bm = (1<<3)       ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 3 mask\n.equ EVSYS_ASYNCUSER53_bp = 3            ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 3 position\n.equ EVSYS_ASYNCUSER54_bm = (1<<4)       ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 4 mask\n.equ EVSYS_ASYNCUSER54_bp = 4            ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 4 position\n.equ EVSYS_ASYNCUSER55_bm = (1<<5)       ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 5 mask\n.equ EVSYS_ASYNCUSER55_bp = 5            ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 5 position\n.equ EVSYS_ASYNCUSER56_bm = (1<<6)       ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 6 mask\n.equ EVSYS_ASYNCUSER56_bp = 6            ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 6 position\n.equ EVSYS_ASYNCUSER57_bm = (1<<7)       ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 7 mask\n.equ EVSYS_ASYNCUSER57_bp = 7            ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 7 position\n\n; EVSYS_ASYNCUSER6 masks\n.equ EVSYS_ASYNCUSER6_gm = 0xFF          ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 group mask\n.equ EVSYS_ASYNCUSER6_gp = 0             ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 group position\n.equ EVSYS_ASYNCUSER60_bm = (1<<0)       ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 0 mask\n.equ EVSYS_ASYNCUSER60_bp = 0            ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 0 position\n.equ EVSYS_ASYNCUSER61_bm = (1<<1)       ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 1 mask\n.equ EVSYS_ASYNCUSER61_bp = 1            ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 1 position\n.equ EVSYS_ASYNCUSER62_bm = (1<<2)       ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 2 mask\n.equ EVSYS_ASYNCUSER62_bp = 2            ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 2 position\n.equ EVSYS_ASYNCUSER63_bm = (1<<3)       ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 3 mask\n.equ EVSYS_ASYNCUSER63_bp = 3            ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 3 position\n.equ EVSYS_ASYNCUSER64_bm = (1<<4)       ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 4 mask\n.equ EVSYS_ASYNCUSER64_bp = 4            ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 4 position\n.equ EVSYS_ASYNCUSER65_bm = (1<<5)       ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 5 mask\n.equ EVSYS_ASYNCUSER65_bp = 5            ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 5 position\n.equ EVSYS_ASYNCUSER66_bm = (1<<6)       ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 6 mask\n.equ EVSYS_ASYNCUSER66_bp = 6            ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 6 position\n.equ EVSYS_ASYNCUSER67_bm = (1<<7)       ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 7 mask\n.equ EVSYS_ASYNCUSER67_bp = 7            ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 7 position\n\n; EVSYS_ASYNCUSER7 masks\n.equ EVSYS_ASYNCUSER7_gm = 0xFF          ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 group mask\n.equ EVSYS_ASYNCUSER7_gp = 0             ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 group position\n.equ EVSYS_ASYNCUSER70_bm = (1<<0)       ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 0 mask\n.equ EVSYS_ASYNCUSER70_bp = 0            ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 0 position\n.equ EVSYS_ASYNCUSER71_bm = (1<<1)       ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 1 mask\n.equ EVSYS_ASYNCUSER71_bp = 1            ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 1 position\n.equ EVSYS_ASYNCUSER72_bm = (1<<2)       ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 2 mask\n.equ EVSYS_ASYNCUSER72_bp = 2            ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 2 position\n.equ EVSYS_ASYNCUSER73_bm = (1<<3)       ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 3 mask\n.equ EVSYS_ASYNCUSER73_bp = 3            ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 3 position\n.equ EVSYS_ASYNCUSER74_bm = (1<<4)       ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 4 mask\n.equ EVSYS_ASYNCUSER74_bp = 4            ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 4 position\n.equ EVSYS_ASYNCUSER75_bm = (1<<5)       ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 5 mask\n.equ EVSYS_ASYNCUSER75_bp = 5            ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 5 position\n.equ EVSYS_ASYNCUSER76_bm = (1<<6)       ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 6 mask\n.equ EVSYS_ASYNCUSER76_bp = 6            ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 6 position\n.equ EVSYS_ASYNCUSER77_bm = (1<<7)       ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 7 mask\n.equ EVSYS_ASYNCUSER77_bp = 7            ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 7 position\n\n; EVSYS_ASYNCUSER8 masks\n.equ EVSYS_ASYNCUSER8_gm = 0xFF          ; Asynchronous User Ch 8 Input Selection - Event Out 0 group mask\n.equ EVSYS_ASYNCUSER8_gp = 0             ; Asynchronous User Ch 8 Input Selection - Event Out 0 group position\n.equ EVSYS_ASYNCUSER80_bm = (1<<0)       ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 0 mask\n.equ EVSYS_ASYNCUSER80_bp = 0            ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 0 position\n.equ EVSYS_ASYNCUSER81_bm = (1<<1)       ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 1 mask\n.equ EVSYS_ASYNCUSER81_bp = 1            ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 1 position\n.equ EVSYS_ASYNCUSER82_bm = (1<<2)       ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 2 mask\n.equ EVSYS_ASYNCUSER82_bp = 2            ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 2 position\n.equ EVSYS_ASYNCUSER83_bm = (1<<3)       ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 3 mask\n.equ EVSYS_ASYNCUSER83_bp = 3            ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 3 position\n.equ EVSYS_ASYNCUSER84_bm = (1<<4)       ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 4 mask\n.equ EVSYS_ASYNCUSER84_bp = 4            ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 4 position\n.equ EVSYS_ASYNCUSER85_bm = (1<<5)       ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 5 mask\n.equ EVSYS_ASYNCUSER85_bp = 5            ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 5 position\n.equ EVSYS_ASYNCUSER86_bm = (1<<6)       ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 6 mask\n.equ EVSYS_ASYNCUSER86_bp = 6            ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 6 position\n.equ EVSYS_ASYNCUSER87_bm = (1<<7)       ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 7 mask\n.equ EVSYS_ASYNCUSER87_bp = 7            ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 7 position\n\n; EVSYS_ASYNCUSER9 masks\n.equ EVSYS_ASYNCUSER9_gm = 0xFF          ; Asynchronous User Ch 9 Input Selection - Event Out 1 group mask\n.equ EVSYS_ASYNCUSER9_gp = 0             ; Asynchronous User Ch 9 Input Selection - Event Out 1 group position\n.equ EVSYS_ASYNCUSER90_bm = (1<<0)       ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 0 mask\n.equ EVSYS_ASYNCUSER90_bp = 0            ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 0 position\n.equ EVSYS_ASYNCUSER91_bm = (1<<1)       ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 1 mask\n.equ EVSYS_ASYNCUSER91_bp = 1            ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 1 position\n.equ EVSYS_ASYNCUSER92_bm = (1<<2)       ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 2 mask\n.equ EVSYS_ASYNCUSER92_bp = 2            ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 2 position\n.equ EVSYS_ASYNCUSER93_bm = (1<<3)       ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 3 mask\n.equ EVSYS_ASYNCUSER93_bp = 3            ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 3 position\n.equ EVSYS_ASYNCUSER94_bm = (1<<4)       ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 4 mask\n.equ EVSYS_ASYNCUSER94_bp = 4            ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 4 position\n.equ EVSYS_ASYNCUSER95_bm = (1<<5)       ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 5 mask\n.equ EVSYS_ASYNCUSER95_bp = 5            ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 5 position\n.equ EVSYS_ASYNCUSER96_bm = (1<<6)       ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 6 mask\n.equ EVSYS_ASYNCUSER96_bp = 6            ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 6 position\n.equ EVSYS_ASYNCUSER97_bm = (1<<7)       ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 7 mask\n.equ EVSYS_ASYNCUSER97_bp = 7            ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 7 position\n\n; EVSYS_ASYNCUSER10 masks\n.equ EVSYS_ASYNCUSER10_gm = 0xFF         ; Asynchronous User Ch 10 Input Selection - Event Out 2 group mask\n.equ EVSYS_ASYNCUSER10_gp = 0            ; Asynchronous User Ch 10 Input Selection - Event Out 2 group position\n.equ EVSYS_ASYNCUSER100_bm = (1<<0)      ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 0 mask\n.equ EVSYS_ASYNCUSER100_bp = 0           ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 0 position\n.equ EVSYS_ASYNCUSER101_bm = (1<<1)      ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 1 mask\n.equ EVSYS_ASYNCUSER101_bp = 1           ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 1 position\n.equ EVSYS_ASYNCUSER102_bm = (1<<2)      ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 2 mask\n.equ EVSYS_ASYNCUSER102_bp = 2           ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 2 position\n.equ EVSYS_ASYNCUSER103_bm = (1<<3)      ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 3 mask\n.equ EVSYS_ASYNCUSER103_bp = 3           ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 3 position\n.equ EVSYS_ASYNCUSER104_bm = (1<<4)      ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 4 mask\n.equ EVSYS_ASYNCUSER104_bp = 4           ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 4 position\n.equ EVSYS_ASYNCUSER105_bm = (1<<5)      ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 5 mask\n.equ EVSYS_ASYNCUSER105_bp = 5           ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 5 position\n.equ EVSYS_ASYNCUSER106_bm = (1<<6)      ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 6 mask\n.equ EVSYS_ASYNCUSER106_bp = 6           ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 6 position\n.equ EVSYS_ASYNCUSER107_bm = (1<<7)      ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 7 mask\n.equ EVSYS_ASYNCUSER107_bp = 7           ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 7 position\n\n; EVSYS_SYNCCH0 masks\n.equ EVSYS_SYNCCH0_gm = 0xFF             ; Synchronous Channel 0 Generator Selection group mask\n.equ EVSYS_SYNCCH0_gp = 0                ; Synchronous Channel 0 Generator Selection group position\n.equ EVSYS_SYNCCH00_bm = (1<<0)          ; Synchronous Channel 0 Generator Selection bit 0 mask\n.equ EVSYS_SYNCCH00_bp = 0               ; Synchronous Channel 0 Generator Selection bit 0 position\n.equ EVSYS_SYNCCH01_bm = (1<<1)          ; Synchronous Channel 0 Generator Selection bit 1 mask\n.equ EVSYS_SYNCCH01_bp = 1               ; Synchronous Channel 0 Generator Selection bit 1 position\n.equ EVSYS_SYNCCH02_bm = (1<<2)          ; Synchronous Channel 0 Generator Selection bit 2 mask\n.equ EVSYS_SYNCCH02_bp = 2               ; Synchronous Channel 0 Generator Selection bit 2 position\n.equ EVSYS_SYNCCH03_bm = (1<<3)          ; Synchronous Channel 0 Generator Selection bit 3 mask\n.equ EVSYS_SYNCCH03_bp = 3               ; Synchronous Channel 0 Generator Selection bit 3 position\n.equ EVSYS_SYNCCH04_bm = (1<<4)          ; Synchronous Channel 0 Generator Selection bit 4 mask\n.equ EVSYS_SYNCCH04_bp = 4               ; Synchronous Channel 0 Generator Selection bit 4 position\n.equ EVSYS_SYNCCH05_bm = (1<<5)          ; Synchronous Channel 0 Generator Selection bit 5 mask\n.equ EVSYS_SYNCCH05_bp = 5               ; Synchronous Channel 0 Generator Selection bit 5 position\n.equ EVSYS_SYNCCH06_bm = (1<<6)          ; Synchronous Channel 0 Generator Selection bit 6 mask\n.equ EVSYS_SYNCCH06_bp = 6               ; Synchronous Channel 0 Generator Selection bit 6 position\n.equ EVSYS_SYNCCH07_bm = (1<<7)          ; Synchronous Channel 0 Generator Selection bit 7 mask\n.equ EVSYS_SYNCCH07_bp = 7               ; Synchronous Channel 0 Generator Selection bit 7 position\n\n; EVSYS_SYNCCH1 masks\n.equ EVSYS_SYNCCH1_gm = 0xFF             ; Synchronous Channel 1 Generator Selection group mask\n.equ EVSYS_SYNCCH1_gp = 0                ; Synchronous Channel 1 Generator Selection group position\n.equ EVSYS_SYNCCH10_bm = (1<<0)          ; Synchronous Channel 1 Generator Selection bit 0 mask\n.equ EVSYS_SYNCCH10_bp = 0               ; Synchronous Channel 1 Generator Selection bit 0 position\n.equ EVSYS_SYNCCH11_bm = (1<<1)          ; Synchronous Channel 1 Generator Selection bit 1 mask\n.equ EVSYS_SYNCCH11_bp = 1               ; Synchronous Channel 1 Generator Selection bit 1 position\n.equ EVSYS_SYNCCH12_bm = (1<<2)          ; Synchronous Channel 1 Generator Selection bit 2 mask\n.equ EVSYS_SYNCCH12_bp = 2               ; Synchronous Channel 1 Generator Selection bit 2 position\n.equ EVSYS_SYNCCH13_bm = (1<<3)          ; Synchronous Channel 1 Generator Selection bit 3 mask\n.equ EVSYS_SYNCCH13_bp = 3               ; Synchronous Channel 1 Generator Selection bit 3 position\n.equ EVSYS_SYNCCH14_bm = (1<<4)          ; Synchronous Channel 1 Generator Selection bit 4 mask\n.equ EVSYS_SYNCCH14_bp = 4               ; Synchronous Channel 1 Generator Selection bit 4 position\n.equ EVSYS_SYNCCH15_bm = (1<<5)          ; Synchronous Channel 1 Generator Selection bit 5 mask\n.equ EVSYS_SYNCCH15_bp = 5               ; Synchronous Channel 1 Generator Selection bit 5 position\n.equ EVSYS_SYNCCH16_bm = (1<<6)          ; Synchronous Channel 1 Generator Selection bit 6 mask\n.equ EVSYS_SYNCCH16_bp = 6               ; Synchronous Channel 1 Generator Selection bit 6 position\n.equ EVSYS_SYNCCH17_bm = (1<<7)          ; Synchronous Channel 1 Generator Selection bit 7 mask\n.equ EVSYS_SYNCCH17_bp = 7               ; Synchronous Channel 1 Generator Selection bit 7 position\n\n; EVSYS_SYNCUSER0 masks\n.equ EVSYS_SYNCUSER0_gm = 0xFF           ; Synchronous User Ch 0 Input Selection - TCA0 group mask\n.equ EVSYS_SYNCUSER0_gp = 0              ; Synchronous User Ch 0 Input Selection - TCA0 group position\n.equ EVSYS_SYNCUSER00_bm = (1<<0)        ; Synchronous User Ch 0 Input Selection - TCA0 bit 0 mask\n.equ EVSYS_SYNCUSER00_bp = 0             ; Synchronous User Ch 0 Input Selection - TCA0 bit 0 position\n.equ EVSYS_SYNCUSER01_bm = (1<<1)        ; Synchronous User Ch 0 Input Selection - TCA0 bit 1 mask\n.equ EVSYS_SYNCUSER01_bp = 1             ; Synchronous User Ch 0 Input Selection - TCA0 bit 1 position\n.equ EVSYS_SYNCUSER02_bm = (1<<2)        ; Synchronous User Ch 0 Input Selection - TCA0 bit 2 mask\n.equ EVSYS_SYNCUSER02_bp = 2             ; Synchronous User Ch 0 Input Selection - TCA0 bit 2 position\n.equ EVSYS_SYNCUSER03_bm = (1<<3)        ; Synchronous User Ch 0 Input Selection - TCA0 bit 3 mask\n.equ EVSYS_SYNCUSER03_bp = 3             ; Synchronous User Ch 0 Input Selection - TCA0 bit 3 position\n.equ EVSYS_SYNCUSER04_bm = (1<<4)        ; Synchronous User Ch 0 Input Selection - TCA0 bit 4 mask\n.equ EVSYS_SYNCUSER04_bp = 4             ; Synchronous User Ch 0 Input Selection - TCA0 bit 4 position\n.equ EVSYS_SYNCUSER05_bm = (1<<5)        ; Synchronous User Ch 0 Input Selection - TCA0 bit 5 mask\n.equ EVSYS_SYNCUSER05_bp = 5             ; Synchronous User Ch 0 Input Selection - TCA0 bit 5 position\n.equ EVSYS_SYNCUSER06_bm = (1<<6)        ; Synchronous User Ch 0 Input Selection - TCA0 bit 6 mask\n.equ EVSYS_SYNCUSER06_bp = 6             ; Synchronous User Ch 0 Input Selection - TCA0 bit 6 position\n.equ EVSYS_SYNCUSER07_bm = (1<<7)        ; Synchronous User Ch 0 Input Selection - TCA0 bit 7 mask\n.equ EVSYS_SYNCUSER07_bp = 7             ; Synchronous User Ch 0 Input Selection - TCA0 bit 7 position\n\n; Asynchronous Channel 0 Generator Selection select\n.equ EVSYS_ASYNCCH0_OFF_gc = (0x00<<0)   ; Off\n.equ EVSYS_ASYNCCH0_CCL_LUT0_gc = (0x01<<0) ; Configurable Custom Logic LUT0\n.equ EVSYS_ASYNCCH0_CCL_LUT1_gc = (0x02<<0) ; Configurable Custom Logic LUT1\n.equ EVSYS_ASYNCCH0_AC0_OUT_gc = (0x03<<0) ; Analog Comparator 0 out\n.equ EVSYS_ASYNCCH0_TCD0_CMPBCLR_gc = (0x04<<0) ; Timer/Counter D0 compare B clear\n.equ EVSYS_ASYNCCH0_TCD0_CMPASET_gc = (0x05<<0) ; Timer/Counter D0 compare A set\n.equ EVSYS_ASYNCCH0_TCD0_CMPBSET_gc = (0x06<<0) ; Timer/Counter D0 compare B set\n.equ EVSYS_ASYNCCH0_TCD0_PROGEV_gc = (0x07<<0) ; Timer/Counter D0 program event\n.equ EVSYS_ASYNCCH0_RTC_OVF_gc = (0x08<<0) ; Real Time Counter overflow\n.equ EVSYS_ASYNCCH0_RTC_CMP_gc = (0x09<<0) ; Real Time Counter compare\n.equ EVSYS_ASYNCCH0_PORTA_PIN0_gc = (0x0A<<0) ; Asynchronous Event from Pin PA0\n.equ EVSYS_ASYNCCH0_PORTA_PIN1_gc = (0x0B<<0) ; Asynchronous Event from Pin PA1\n.equ EVSYS_ASYNCCH0_PORTA_PIN2_gc = (0x0C<<0) ; Asynchronous Event from Pin PA2\n.equ EVSYS_ASYNCCH0_PORTA_PIN3_gc = (0x0D<<0) ; Asynchronous Event from Pin PA3\n.equ EVSYS_ASYNCCH0_PORTA_PIN4_gc = (0x0E<<0) ; Asynchronous Event from Pin PA4\n.equ EVSYS_ASYNCCH0_PORTA_PIN5_gc = (0x0F<<0) ; Asynchronous Event from Pin PA5\n.equ EVSYS_ASYNCCH0_PORTA_PIN6_gc = (0x10<<0) ; Asynchronous Event from Pin PA6\n.equ EVSYS_ASYNCCH0_PORTA_PIN7_gc = (0x11<<0) ; Asynchronous Event from Pin PA7\n.equ EVSYS_ASYNCCH0_UPDI_gc = (0x12<<0)  ; Unified Program and debug interface\n\n; Asynchronous Channel 1 Generator Selection select\n.equ EVSYS_ASYNCCH1_OFF_gc = (0x00<<0)   ; Off\n.equ EVSYS_ASYNCCH1_CCL_LUT0_gc = (0x01<<0) ; Configurable custom logic LUT0\n.equ EVSYS_ASYNCCH1_CCL_LUT1_gc = (0x02<<0) ; Configurable custom logic LUT1\n.equ EVSYS_ASYNCCH1_AC0_OUT_gc = (0x03<<0) ; Analog Comparator 0 out\n.equ EVSYS_ASYNCCH1_TCD0_CMPBCLR_gc = (0x04<<0) ; Timer/Counter D0 compare B clear\n.equ EVSYS_ASYNCCH1_TCD0_CMPASET_gc = (0x05<<0) ; Timer/Counter D0 compare A set\n.equ EVSYS_ASYNCCH1_TCD0_CMPBSET_gc = (0x06<<0) ; Timer/Counter D0 compare B set\n.equ EVSYS_ASYNCCH1_TCD0_PROGEV_gc = (0x07<<0) ; Timer/Counter D0 program event\n.equ EVSYS_ASYNCCH1_RTC_OVF_gc = (0x08<<0) ; Real Time Counter overflow\n.equ EVSYS_ASYNCCH1_RTC_CMP_gc = (0x09<<0) ; Real Time Counter compare\n.equ EVSYS_ASYNCCH1_PORTB_PIN0_gc = (0x0A<<0) ; Asynchronous Event from Pin PB0\n.equ EVSYS_ASYNCCH1_PORTB_PIN1_gc = (0x0B<<0) ; Asynchronous Event from Pin PB1\n.equ EVSYS_ASYNCCH1_PORTB_PIN2_gc = (0x0C<<0) ; Asynchronous Event from Pin PB2\n.equ EVSYS_ASYNCCH1_PORTB_PIN3_gc = (0x0D<<0) ; Asynchronous Event from Pin PB3\n.equ EVSYS_ASYNCCH1_PORTB_PIN4_gc = (0x0E<<0) ; Asynchronous Event from Pin PB4\n.equ EVSYS_ASYNCCH1_PORTB_PIN5_gc = (0x0F<<0) ; Asynchronous Event from Pin PB5\n.equ EVSYS_ASYNCCH1_PORTB_PIN6_gc = (0x10<<0) ; Asynchronous Event from Pin PB6\n.equ EVSYS_ASYNCCH1_PORTB_PIN7_gc = (0x11<<0) ; Asynchronous Event from Pin PB7\n\n; Asynchronous User Ch 0 Input Selection - TCB0 select\n.equ EVSYS_ASYNCUSER0_OFF_gc = (0x00<<0) ; Off\n.equ EVSYS_ASYNCUSER0_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_ASYNCUSER0_ASYNCCH0_gc = (0x03<<0) ; Asynchronous Event Channel 0\n.equ EVSYS_ASYNCUSER0_ASYNCCH1_gc = (0x04<<0) ; Asynchronous Event Channel 1\n\n; Asynchronous User Ch 1 Input Selection - ADC0 select\n.equ EVSYS_ASYNCUSER1_OFF_gc = (0x00<<0) ; Off\n.equ EVSYS_ASYNCUSER1_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_ASYNCUSER1_ASYNCCH0_gc = (0x03<<0) ; Asynchronous Event Channel 0\n.equ EVSYS_ASYNCUSER1_ASYNCCH1_gc = (0x04<<0) ; Asynchronous Event Channel 1\n\n; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 select\n.equ EVSYS_ASYNCUSER2_OFF_gc = (0x00<<0) ; Off\n.equ EVSYS_ASYNCUSER2_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_ASYNCUSER2_ASYNCCH0_gc = (0x03<<0) ; Asynchronous Event Channel 0\n.equ EVSYS_ASYNCUSER2_ASYNCCH1_gc = (0x04<<0) ; Asynchronous Event Channel 1\n\n; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 select\n.equ EVSYS_ASYNCUSER3_OFF_gc = (0x00<<0) ; Off\n.equ EVSYS_ASYNCUSER3_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_ASYNCUSER3_ASYNCCH0_gc = (0x03<<0) ; Asynchronous Event Channel 0\n.equ EVSYS_ASYNCUSER3_ASYNCCH1_gc = (0x04<<0) ; Asynchronous Event Channel 1\n\n; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 select\n.equ EVSYS_ASYNCUSER4_OFF_gc = (0x00<<0) ; Off\n.equ EVSYS_ASYNCUSER4_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_ASYNCUSER4_ASYNCCH0_gc = (0x03<<0) ; Asynchronous Event Channel 0\n.equ EVSYS_ASYNCUSER4_ASYNCCH1_gc = (0x04<<0) ; Asynchronous Event Channel 1\n\n; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 select\n.equ EVSYS_ASYNCUSER5_OFF_gc = (0x00<<0) ; Off\n.equ EVSYS_ASYNCUSER5_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_ASYNCUSER5_ASYNCCH0_gc = (0x03<<0) ; Asynchronous Event Channel 0\n.equ EVSYS_ASYNCUSER5_ASYNCCH1_gc = (0x04<<0) ; Asynchronous Event Channel 1\n\n; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 select\n.equ EVSYS_ASYNCUSER6_OFF_gc = (0x00<<0) ; Off\n.equ EVSYS_ASYNCUSER6_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_ASYNCUSER6_ASYNCCH0_gc = (0x03<<0) ; Asynchronous Event Channel 0\n.equ EVSYS_ASYNCUSER6_ASYNCCH1_gc = (0x04<<0) ; Asynchronous Event Channel 1\n\n; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 select\n.equ EVSYS_ASYNCUSER7_OFF_gc = (0x00<<0) ; Off\n.equ EVSYS_ASYNCUSER7_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_ASYNCUSER7_ASYNCCH0_gc = (0x03<<0) ; Asynchronous Event Channel 0\n.equ EVSYS_ASYNCUSER7_ASYNCCH1_gc = (0x04<<0) ; Asynchronous Event Channel 1\n\n; Asynchronous User Ch 8 Input Selection - Event Out 0 select\n.equ EVSYS_ASYNCUSER8_OFF_gc = (0x00<<0) ; Off\n.equ EVSYS_ASYNCUSER8_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_ASYNCUSER8_ASYNCCH0_gc = (0x03<<0) ; Asynchronous Event Channel 0\n.equ EVSYS_ASYNCUSER8_ASYNCCH1_gc = (0x04<<0) ; Asynchronous Event Channel 1\n\n; Asynchronous User Ch 9 Input Selection - Event Out 1 select\n.equ EVSYS_ASYNCUSER9_OFF_gc = (0x00<<0) ; Off\n.equ EVSYS_ASYNCUSER9_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_ASYNCUSER9_ASYNCCH0_gc = (0x03<<0) ; Asynchronous Event Channel 0\n.equ EVSYS_ASYNCUSER9_ASYNCCH1_gc = (0x04<<0) ; Asynchronous Event Channel 1\n\n; Asynchronous User Ch 10 Input Selection - Event Out 2 select\n.equ EVSYS_ASYNCUSER10_OFF_gc = (0x00<<0) ; Off\n.equ EVSYS_ASYNCUSER10_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_ASYNCUSER10_ASYNCCH0_gc = (0x03<<0) ; Asynchronous Event Channel 0\n.equ EVSYS_ASYNCUSER10_ASYNCCH1_gc = (0x04<<0) ; Asynchronous Event Channel 1\n\n; Synchronous Channel 0 Generator Selection select\n.equ EVSYS_SYNCCH0_OFF_gc = (0x00<<0)    ; Off\n.equ EVSYS_SYNCCH0_TCB0_gc = (0x01<<0)   ; Timer/Counter B0\n.equ EVSYS_SYNCCH0_TCA0_OVF_LUNF_gc = (0x02<<0) ; Timer/Counter A0 overflow\n.equ EVSYS_SYNCCH0_TCA0_HUNF_gc = (0x03<<0) ; Timer/Counter A0 underflow high byte (split mode)\n.equ EVSYS_SYNCCH0_TCA0_CMP0_gc = (0x04<<0) ; Timer/Counter A0 compare 0\n.equ EVSYS_SYNCCH0_TCA0_CMP1_gc = (0x05<<0) ; Timer/Counter A0 compare 1\n.equ EVSYS_SYNCCH0_TCA0_CMP2_gc = (0x06<<0) ; Timer/Counter A0 compare 2\n.equ EVSYS_SYNCCH0_PORTC_PIN0_gc = (0x07<<0) ; Synchronous Event from Pin PC0\n.equ EVSYS_SYNCCH0_PORTC_PIN1_gc = (0x08<<0) ; Synchronous Event from Pin PC1\n.equ EVSYS_SYNCCH0_PORTC_PIN2_gc = (0x09<<0) ; Synchronous Event from Pin PC2\n.equ EVSYS_SYNCCH0_PORTC_PIN3_gc = (0x0A<<0) ; Synchronous Event from Pin PC3\n.equ EVSYS_SYNCCH0_PORTC_PIN4_gc = (0x0B<<0) ; Synchronous Event from Pin PC4\n.equ EVSYS_SYNCCH0_PORTC_PIN5_gc = (0x0C<<0) ; Synchronous Event from Pin PC5\n.equ EVSYS_SYNCCH0_PORTA_PIN0_gc = (0x0D<<0) ; Synchronous Event from Pin PA0\n.equ EVSYS_SYNCCH0_PORTA_PIN1_gc = (0x0E<<0) ; Synchronous Event from Pin PA1\n.equ EVSYS_SYNCCH0_PORTA_PIN2_gc = (0x0F<<0) ; Synchronous Event from Pin PA2\n.equ EVSYS_SYNCCH0_PORTA_PIN3_gc = (0x10<<0) ; Synchronous Event from Pin PA3\n.equ EVSYS_SYNCCH0_PORTA_PIN4_gc = (0x11<<0) ; Synchronous Event from Pin PA4\n.equ EVSYS_SYNCCH0_PORTA_PIN5_gc = (0x12<<0) ; Synchronous Event from Pin PA5\n.equ EVSYS_SYNCCH0_PORTA_PIN6_gc = (0x13<<0) ; Synchronous Event from Pin PA6\n.equ EVSYS_SYNCCH0_PORTA_PIN7_gc = (0x14<<0) ; Synchronous Event from Pin PA7\n\n; Synchronous Channel 1 Generator Selection select\n.equ EVSYS_SYNCCH1_OFF_gc = (0x00<<0)    ; Off\n.equ EVSYS_SYNCCH1_TCB0_gc = (0x01<<0)   ; Timer/Counter B0\n.equ EVSYS_SYNCCH1_TCA0_OVF_LUNF_gc = (0x02<<0) ; Timer/Counter A0 overflow\n.equ EVSYS_SYNCCH1_TCA0_HUNF_gc = (0x03<<0) ; Timer/Counter A0 underflow high byte (split mode)\n.equ EVSYS_SYNCCH1_TCA0_CMP0_gc = (0x04<<0) ; Timer/Counter A0 compare 0\n.equ EVSYS_SYNCCH1_TCA0_CMP1_gc = (0x05<<0) ; Timer/Counter A0 compare 1\n.equ EVSYS_SYNCCH1_TCA0_CMP2_gc = (0x06<<0) ; Timer/Counter A0 compare 2\n.equ EVSYS_SYNCCH1_PORTB_PIN0_gc = (0x08<<0) ; Synchronous Event from Pin PB0\n.equ EVSYS_SYNCCH1_PORTB_PIN1_gc = (0x09<<0) ; Synchronous Event from Pin PB1\n.equ EVSYS_SYNCCH1_PORTB_PIN2_gc = (0x0A<<0) ; Synchronous Event from Pin PB2\n.equ EVSYS_SYNCCH1_PORTB_PIN3_gc = (0x0B<<0) ; Synchronous Event from Pin PB3\n.equ EVSYS_SYNCCH1_PORTB_PIN4_gc = (0x0C<<0) ; Synchronous Event from Pin PB4\n.equ EVSYS_SYNCCH1_PORTB_PIN5_gc = (0x0D<<0) ; Synchronous Event from Pin PB5\n.equ EVSYS_SYNCCH1_PORTB_PIN6_gc = (0x0E<<0) ; Synchronous Event from Pin PB6\n.equ EVSYS_SYNCCH1_PORTB_PIN7_gc = (0x0F<<0) ; Synchronous Event from Pin PB7\n\n; Synchronous User Ch 0 Input Selection - TCA0 select\n.equ EVSYS_SYNCUSER0_OFF_gc = (0x00<<0)  ; Off\n.equ EVSYS_SYNCUSER0_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n\n\n;*************************************************************************\n;** FUSE - Fuses\n;*************************************************************************\n\n; FUSE_BODCFG masks\n.equ FUSE_ACTIVE_gm = 0x0C               ; BOD Operation in Active Mode group mask\n.equ FUSE_ACTIVE_gp = 2                  ; BOD Operation in Active Mode group position\n.equ FUSE_ACTIVE0_bm = (1<<2)            ; BOD Operation in Active Mode bit 0 mask\n.equ FUSE_ACTIVE0_bp = 2                 ; BOD Operation in Active Mode bit 0 position\n.equ FUSE_ACTIVE1_bm = (1<<3)            ; BOD Operation in Active Mode bit 1 mask\n.equ FUSE_ACTIVE1_bp = 3                 ; BOD Operation in Active Mode bit 1 position\n.equ FUSE_LVL_gm = 0xE0                  ; BOD Level group mask\n.equ FUSE_LVL_gp = 5                     ; BOD Level group position\n.equ FUSE_LVL0_bm = (1<<5)               ; BOD Level bit 0 mask\n.equ FUSE_LVL0_bp = 5                    ; BOD Level bit 0 position\n.equ FUSE_LVL1_bm = (1<<6)               ; BOD Level bit 1 mask\n.equ FUSE_LVL1_bp = 6                    ; BOD Level bit 1 position\n.equ FUSE_LVL2_bm = (1<<7)               ; BOD Level bit 2 mask\n.equ FUSE_LVL2_bp = 7                    ; BOD Level bit 2 position\n.equ FUSE_SAMPFREQ_bm = 0x10             ; BOD Sample Frequency bit mask\n.equ FUSE_SAMPFREQ_bp = 4                ; BOD Sample Frequency bit position\n.equ FUSE_SLEEP_gm = 0x03                ; BOD Operation in Sleep Mode group mask\n.equ FUSE_SLEEP_gp = 0                   ; BOD Operation in Sleep Mode group position\n.equ FUSE_SLEEP0_bm = (1<<0)             ; BOD Operation in Sleep Mode bit 0 mask\n.equ FUSE_SLEEP0_bp = 0                  ; BOD Operation in Sleep Mode bit 0 position\n.equ FUSE_SLEEP1_bm = (1<<1)             ; BOD Operation in Sleep Mode bit 1 mask\n.equ FUSE_SLEEP1_bp = 1                  ; BOD Operation in Sleep Mode bit 1 position\n\n; FUSE_OSCCFG masks\n.equ FUSE_FREQSEL_gm = 0x03              ; Frequency Select group mask\n.equ FUSE_FREQSEL_gp = 0                 ; Frequency Select group position\n.equ FUSE_FREQSEL0_bm = (1<<0)           ; Frequency Select bit 0 mask\n.equ FUSE_FREQSEL0_bp = 0                ; Frequency Select bit 0 position\n.equ FUSE_FREQSEL1_bm = (1<<1)           ; Frequency Select bit 1 mask\n.equ FUSE_FREQSEL1_bp = 1                ; Frequency Select bit 1 position\n.equ FUSE_OSCLOCK_bm = 0x80              ; Oscillator Lock bit mask\n.equ FUSE_OSCLOCK_bp = 7                 ; Oscillator Lock bit position\n\n; FUSE_SYSCFG0 masks\n.equ FUSE_CRCSRC_gm = 0xC0               ; CRC Source group mask\n.equ FUSE_CRCSRC_gp = 6                  ; CRC Source group position\n.equ FUSE_CRCSRC0_bm = (1<<6)            ; CRC Source bit 0 mask\n.equ FUSE_CRCSRC0_bp = 6                 ; CRC Source bit 0 position\n.equ FUSE_CRCSRC1_bm = (1<<7)            ; CRC Source bit 1 mask\n.equ FUSE_CRCSRC1_bp = 7                 ; CRC Source bit 1 position\n.equ FUSE_EESAVE_bm = 0x01               ; EEPROM Save bit mask\n.equ FUSE_EESAVE_bp = 0                  ; EEPROM Save bit position\n.equ FUSE_RSTPINCFG_gm = 0x0C            ; Reset Pin Configuration group mask\n.equ FUSE_RSTPINCFG_gp = 2               ; Reset Pin Configuration group position\n.equ FUSE_RSTPINCFG0_bm = (1<<2)         ; Reset Pin Configuration bit 0 mask\n.equ FUSE_RSTPINCFG0_bp = 2              ; Reset Pin Configuration bit 0 position\n.equ FUSE_RSTPINCFG1_bm = (1<<3)         ; Reset Pin Configuration bit 1 mask\n.equ FUSE_RSTPINCFG1_bp = 3              ; Reset Pin Configuration bit 1 position\n\n; FUSE_SYSCFG1 masks\n.equ FUSE_SUT_gm = 0x07                  ; Startup Time group mask\n.equ FUSE_SUT_gp = 0                     ; Startup Time group position\n.equ FUSE_SUT0_bm = (1<<0)               ; Startup Time bit 0 mask\n.equ FUSE_SUT0_bp = 0                    ; Startup Time bit 0 position\n.equ FUSE_SUT1_bm = (1<<1)               ; Startup Time bit 1 mask\n.equ FUSE_SUT1_bp = 1                    ; Startup Time bit 1 position\n.equ FUSE_SUT2_bm = (1<<2)               ; Startup Time bit 2 mask\n.equ FUSE_SUT2_bp = 2                    ; Startup Time bit 2 position\n\n; FUSE_TCD0CFG masks\n.equ FUSE_CMPA_bm = 0x01                 ; Compare A Default Output Value bit mask\n.equ FUSE_CMPA_bp = 0                    ; Compare A Default Output Value bit position\n.equ FUSE_CMPAEN_bm = 0x10               ; Compare A Output Enable bit mask\n.equ FUSE_CMPAEN_bp = 4                  ; Compare A Output Enable bit position\n.equ FUSE_CMPB_bm = 0x02                 ; Compare B Default Output Value bit mask\n.equ FUSE_CMPB_bp = 1                    ; Compare B Default Output Value bit position\n.equ FUSE_CMPBEN_bm = 0x20               ; Compare B Output Enable bit mask\n.equ FUSE_CMPBEN_bp = 5                  ; Compare B Output Enable bit position\n.equ FUSE_CMPC_bm = 0x04                 ; Compare C Default Output Value bit mask\n.equ FUSE_CMPC_bp = 2                    ; Compare C Default Output Value bit position\n.equ FUSE_CMPCEN_bm = 0x40               ; Compare C Output Enable bit mask\n.equ FUSE_CMPCEN_bp = 6                  ; Compare C Output Enable bit position\n.equ FUSE_CMPD_bm = 0x08                 ; Compare D Default Output Value bit mask\n.equ FUSE_CMPD_bp = 3                    ; Compare D Default Output Value bit position\n.equ FUSE_CMPDEN_bm = 0x80               ; Compare D Output Enable bit mask\n.equ FUSE_CMPDEN_bp = 7                  ; Compare D Output Enable bit position\n\n; FUSE_WDTCFG masks\n.equ FUSE_PERIOD_gm = 0x0F               ; Watchdog Timeout Period group mask\n.equ FUSE_PERIOD_gp = 0                  ; Watchdog Timeout Period group position\n.equ FUSE_PERIOD0_bm = (1<<0)            ; Watchdog Timeout Period bit 0 mask\n.equ FUSE_PERIOD0_bp = 0                 ; Watchdog Timeout Period bit 0 position\n.equ FUSE_PERIOD1_bm = (1<<1)            ; Watchdog Timeout Period bit 1 mask\n.equ FUSE_PERIOD1_bp = 1                 ; Watchdog Timeout Period bit 1 position\n.equ FUSE_PERIOD2_bm = (1<<2)            ; Watchdog Timeout Period bit 2 mask\n.equ FUSE_PERIOD2_bp = 2                 ; Watchdog Timeout Period bit 2 position\n.equ FUSE_PERIOD3_bm = (1<<3)            ; Watchdog Timeout Period bit 3 mask\n.equ FUSE_PERIOD3_bp = 3                 ; Watchdog Timeout Period bit 3 position\n.equ FUSE_WINDOW_gm = 0xF0               ; Watchdog Window Timeout Period group mask\n.equ FUSE_WINDOW_gp = 4                  ; Watchdog Window Timeout Period group position\n.equ FUSE_WINDOW0_bm = (1<<4)            ; Watchdog Window Timeout Period bit 0 mask\n.equ FUSE_WINDOW0_bp = 4                 ; Watchdog Window Timeout Period bit 0 position\n.equ FUSE_WINDOW1_bm = (1<<5)            ; Watchdog Window Timeout Period bit 1 mask\n.equ FUSE_WINDOW1_bp = 5                 ; Watchdog Window Timeout Period bit 1 position\n.equ FUSE_WINDOW2_bm = (1<<6)            ; Watchdog Window Timeout Period bit 2 mask\n.equ FUSE_WINDOW2_bp = 6                 ; Watchdog Window Timeout Period bit 2 position\n.equ FUSE_WINDOW3_bm = (1<<7)            ; Watchdog Window Timeout Period bit 3 mask\n.equ FUSE_WINDOW3_bp = 7                 ; Watchdog Window Timeout Period bit 3 position\n\n; BOD Operation in Active Mode select\n.equ FUSE_ACTIVE_DIS_gc = (0x00<<2)      ; Disabled\n.equ FUSE_ACTIVE_ENABLED_gc = (0x01<<2)  ; Enabled\n.equ FUSE_ACTIVE_SAMPLED_gc = (0x02<<2)  ; Sampled\n.equ FUSE_ACTIVE_ENWAKE_gc = (0x03<<2)   ; Enabled with wake-up halted until BOD is ready\n\n; BOD Level select\n.equ FUSE_LVL_BODLEVEL0_gc = (0x00<<5)   ; 1.8 V\n.equ FUSE_LVL_BODLEVEL2_gc = (0x02<<5)   ; 2.6 V\n.equ FUSE_LVL_BODLEVEL7_gc = (0x07<<5)   ; 4.2 V\n\n; BOD Sample Frequency select\n.equ FUSE_SAMPFREQ_1KHz_gc = (0x00<<4)   ; 1kHz sampling frequency\n.equ FUSE_SAMPFREQ_125Hz_gc = (0x01<<4)  ; 125Hz sampling frequency\n\n; BOD Operation in Sleep Mode select\n.equ FUSE_SLEEP_DIS_gc = (0x00<<0)       ; Disabled\n.equ FUSE_SLEEP_ENABLED_gc = (0x01<<0)   ; Enabled\n.equ FUSE_SLEEP_SAMPLED_gc = (0x02<<0)   ; Sampled\n\n; Frequency Select select\n.equ FUSE_FREQSEL_16MHZ_gc = (0x01<<0)   ; 16 MHz\n.equ FUSE_FREQSEL_20MHZ_gc = (0x02<<0)   ; 20 MHz\n\n; CRC Source select\n.equ FUSE_CRCSRC_FLASH_gc = (0x00<<6)    ; The CRC is performed on the entire Flash (boot, application code and application data section).\n.equ FUSE_CRCSRC_BOOT_gc = (0x01<<6)     ; The CRC is performed on the boot section of Flash\n.equ FUSE_CRCSRC_BOOTAPP_gc = (0x02<<6)  ; The CRC is performed on the boot and application code section of Flash\n.equ FUSE_CRCSRC_NOCRC_gc = (0x03<<6)    ; Disable CRC.\n\n; Reset Pin Configuration select\n.equ FUSE_RSTPINCFG_GPIO_gc = (0x00<<2)  ; GPIO mode\n.equ FUSE_RSTPINCFG_UPDI_gc = (0x01<<2)  ; UPDI mode\n.equ FUSE_RSTPINCFG_RST_gc = (0x02<<2)   ; Reset mode\n\n; Startup Time select\n.equ FUSE_SUT_0MS_gc = (0x00<<0)         ; 0 ms\n.equ FUSE_SUT_1MS_gc = (0x01<<0)         ; 1 ms\n.equ FUSE_SUT_2MS_gc = (0x02<<0)         ; 2 ms\n.equ FUSE_SUT_4MS_gc = (0x03<<0)         ; 4 ms\n.equ FUSE_SUT_8MS_gc = (0x04<<0)         ; 8 ms\n.equ FUSE_SUT_16MS_gc = (0x05<<0)        ; 16 ms\n.equ FUSE_SUT_32MS_gc = (0x06<<0)        ; 32 ms\n.equ FUSE_SUT_64MS_gc = (0x07<<0)        ; 64 ms\n\n; Watchdog Timeout Period select\n.equ FUSE_PERIOD_OFF_gc = (0x00<<0)      ; Watch-Dog timer Off\n.equ FUSE_PERIOD_8CLK_gc = (0x01<<0)     ; 8 cycles (8ms)\n.equ FUSE_PERIOD_16CLK_gc = (0x02<<0)    ; 16 cycles (16ms)\n.equ FUSE_PERIOD_32CLK_gc = (0x03<<0)    ; 32 cycles (32ms)\n.equ FUSE_PERIOD_64CLK_gc = (0x04<<0)    ; 64 cycles (64ms)\n.equ FUSE_PERIOD_128CLK_gc = (0x05<<0)   ; 128 cycles (0.128s)\n.equ FUSE_PERIOD_256CLK_gc = (0x06<<0)   ; 256 cycles (0.256s)\n.equ FUSE_PERIOD_512CLK_gc = (0x07<<0)   ; 512 cycles (0.512s)\n.equ FUSE_PERIOD_1KCLK_gc = (0x08<<0)    ; 1K cycles (1.0s)\n.equ FUSE_PERIOD_2KCLK_gc = (0x09<<0)    ; 2K cycles (2.0s)\n.equ FUSE_PERIOD_4KCLK_gc = (0x0A<<0)    ; 4K cycles (4.1s)\n.equ FUSE_PERIOD_8KCLK_gc = (0x0B<<0)    ; 8K cycles (8.2s)\n\n; Watchdog Window Timeout Period select\n.equ FUSE_WINDOW_OFF_gc = (0x00<<4)      ; Window mode off\n.equ FUSE_WINDOW_8CLK_gc = (0x01<<4)     ; 8 cycles (8ms)\n.equ FUSE_WINDOW_16CLK_gc = (0x02<<4)    ; 16 cycles (16ms)\n.equ FUSE_WINDOW_32CLK_gc = (0x03<<4)    ; 32 cycles (32ms)\n.equ FUSE_WINDOW_64CLK_gc = (0x04<<4)    ; 64 cycles (64ms)\n.equ FUSE_WINDOW_128CLK_gc = (0x05<<4)   ; 128 cycles (0.128s)\n.equ FUSE_WINDOW_256CLK_gc = (0x06<<4)   ; 256 cycles (0.256s)\n.equ FUSE_WINDOW_512CLK_gc = (0x07<<4)   ; 512 cycles (0.512s)\n.equ FUSE_WINDOW_1KCLK_gc = (0x08<<4)    ; 1K cycles (1.0s)\n.equ FUSE_WINDOW_2KCLK_gc = (0x09<<4)    ; 2K cycles (2.0s)\n.equ FUSE_WINDOW_4KCLK_gc = (0x0A<<4)    ; 4K cycles (4.1s)\n.equ FUSE_WINDOW_8KCLK_gc = (0x0B<<4)    ; 8K cycles (8.2s)\n\n\n;*************************************************************************\n;** GPIO - General Purpose IO\n;*************************************************************************\n\n\n;*************************************************************************\n;** LOCKBIT - Lockbit\n;*************************************************************************\n\n; LOCKBIT_LOCKBIT masks\n.equ LOCKBIT_LB_gm = 0xFF                ; Lock Bits group mask\n.equ LOCKBIT_LB_gp = 0                   ; Lock Bits group position\n.equ LOCKBIT_LB0_bm = (1<<0)             ; Lock Bits bit 0 mask\n.equ LOCKBIT_LB0_bp = 0                  ; Lock Bits bit 0 position\n.equ LOCKBIT_LB1_bm = (1<<1)             ; Lock Bits bit 1 mask\n.equ LOCKBIT_LB1_bp = 1                  ; Lock Bits bit 1 position\n.equ LOCKBIT_LB2_bm = (1<<2)             ; Lock Bits bit 2 mask\n.equ LOCKBIT_LB2_bp = 2                  ; Lock Bits bit 2 position\n.equ LOCKBIT_LB3_bm = (1<<3)             ; Lock Bits bit 3 mask\n.equ LOCKBIT_LB3_bp = 3                  ; Lock Bits bit 3 position\n.equ LOCKBIT_LB4_bm = (1<<4)             ; Lock Bits bit 4 mask\n.equ LOCKBIT_LB4_bp = 4                  ; Lock Bits bit 4 position\n.equ LOCKBIT_LB5_bm = (1<<5)             ; Lock Bits bit 5 mask\n.equ LOCKBIT_LB5_bp = 5                  ; Lock Bits bit 5 position\n.equ LOCKBIT_LB6_bm = (1<<6)             ; Lock Bits bit 6 mask\n.equ LOCKBIT_LB6_bp = 6                  ; Lock Bits bit 6 position\n.equ LOCKBIT_LB7_bm = (1<<7)             ; Lock Bits bit 7 mask\n.equ LOCKBIT_LB7_bp = 7                  ; Lock Bits bit 7 position\n\n; Lock Bits select\n.equ LOCKBIT_LB_RWLOCK_gc = (0x3A<<0)    ; Read and write lock\n.equ LOCKBIT_LB_NOLOCK_gc = (0xC5<<0)    ; No locks\n\n\n;*************************************************************************\n;** NVMCTRL - Non-volatile Memory Controller\n;*************************************************************************\n\n; NVMCTRL_CTRLA masks\n.equ NVMCTRL_CMD_gm = 0x07               ; Command group mask\n.equ NVMCTRL_CMD_gp = 0                  ; Command group position\n.equ NVMCTRL_CMD0_bm = (1<<0)            ; Command bit 0 mask\n.equ NVMCTRL_CMD0_bp = 0                 ; Command bit 0 position\n.equ NVMCTRL_CMD1_bm = (1<<1)            ; Command bit 1 mask\n.equ NVMCTRL_CMD1_bp = 1                 ; Command bit 1 position\n.equ NVMCTRL_CMD2_bm = (1<<2)            ; Command bit 2 mask\n.equ NVMCTRL_CMD2_bp = 2                 ; Command bit 2 position\n\n; NVMCTRL_CTRLB masks\n.equ NVMCTRL_APCWP_bm = 0x01             ; Application code write protect bit mask\n.equ NVMCTRL_APCWP_bp = 0                ; Application code write protect bit position\n.equ NVMCTRL_BOOTLOCK_bm = 0x02          ; Boot Lock bit mask\n.equ NVMCTRL_BOOTLOCK_bp = 1             ; Boot Lock bit position\n\n; NVMCTRL_INTCTRL masks\n.equ NVMCTRL_EEREADY_bm = 0x01           ; EEPROM Ready bit mask\n.equ NVMCTRL_EEREADY_bp = 0              ; EEPROM Ready bit position\n\n; NVMCTRL_INTFLAGS masks\n; Masks for NVMCTRL_EEREADY already defined\n\n; NVMCTRL_STATUS masks\n.equ NVMCTRL_EEBUSY_bm = 0x02            ; EEPROM busy bit mask\n.equ NVMCTRL_EEBUSY_bp = 1               ; EEPROM busy bit position\n.equ NVMCTRL_FBUSY_bm = 0x01             ; Flash busy bit mask\n.equ NVMCTRL_FBUSY_bp = 0                ; Flash busy bit position\n.equ NVMCTRL_WRERROR_bm = 0x04           ; Write error bit mask\n.equ NVMCTRL_WRERROR_bp = 2              ; Write error bit position\n\n; Command select\n.equ NVMCTRL_CMD_NONE_gc = (0x00<<0)     ; No Command\n.equ NVMCTRL_CMD_PAGEWRITE_gc = (0x01<<0) ; Write page\n.equ NVMCTRL_CMD_PAGEERASE_gc = (0x02<<0) ; Erase page\n.equ NVMCTRL_CMD_PAGEERASEWRITE_gc = (0x03<<0) ; Erase and write page\n.equ NVMCTRL_CMD_PAGEBUFCLR_gc = (0x04<<0) ; Page buffer clear\n.equ NVMCTRL_CMD_CHIPERASE_gc = (0x05<<0) ; Chip erase\n.equ NVMCTRL_CMD_EEERASE_gc = (0x06<<0)  ; EEPROM erase\n.equ NVMCTRL_CMD_FUSEWRITE_gc = (0x07<<0) ; Write fuse (PDI only)\n\n\n;*************************************************************************\n;** PORT - I/O Ports\n;*************************************************************************\n\n; PORT_INTFLAGS masks\n.equ PORT_INT_gm = 0xFF                  ; Pin Interrupt group mask\n.equ PORT_INT_gp = 0                     ; Pin Interrupt group position\n.equ PORT_INT0_bm = (1<<0)               ; Pin Interrupt bit 0 mask\n.equ PORT_INT0_bp = 0                    ; Pin Interrupt bit 0 position\n.equ PORT_INT1_bm = (1<<1)               ; Pin Interrupt bit 1 mask\n.equ PORT_INT1_bp = 1                    ; Pin Interrupt bit 1 position\n.equ PORT_INT2_bm = (1<<2)               ; Pin Interrupt bit 2 mask\n.equ PORT_INT2_bp = 2                    ; Pin Interrupt bit 2 position\n.equ PORT_INT3_bm = (1<<3)               ; Pin Interrupt bit 3 mask\n.equ PORT_INT3_bp = 3                    ; Pin Interrupt bit 3 position\n.equ PORT_INT4_bm = (1<<4)               ; Pin Interrupt bit 4 mask\n.equ PORT_INT4_bp = 4                    ; Pin Interrupt bit 4 position\n.equ PORT_INT5_bm = (1<<5)               ; Pin Interrupt bit 5 mask\n.equ PORT_INT5_bp = 5                    ; Pin Interrupt bit 5 position\n.equ PORT_INT6_bm = (1<<6)               ; Pin Interrupt bit 6 mask\n.equ PORT_INT6_bp = 6                    ; Pin Interrupt bit 6 position\n.equ PORT_INT7_bm = (1<<7)               ; Pin Interrupt bit 7 mask\n.equ PORT_INT7_bp = 7                    ; Pin Interrupt bit 7 position\n\n; PORT_PIN0CTRL masks\n.equ PORT_INVEN_bm = 0x80                ; Inverted I/O Enable bit mask\n.equ PORT_INVEN_bp = 7                   ; Inverted I/O Enable bit position\n.equ PORT_ISC_gm = 0x07                  ; Input/Sense Configuration group mask\n.equ PORT_ISC_gp = 0                     ; Input/Sense Configuration group position\n.equ PORT_ISC0_bm = (1<<0)               ; Input/Sense Configuration bit 0 mask\n.equ PORT_ISC0_bp = 0                    ; Input/Sense Configuration bit 0 position\n.equ PORT_ISC1_bm = (1<<1)               ; Input/Sense Configuration bit 1 mask\n.equ PORT_ISC1_bp = 1                    ; Input/Sense Configuration bit 1 position\n.equ PORT_ISC2_bm = (1<<2)               ; Input/Sense Configuration bit 2 mask\n.equ PORT_ISC2_bp = 2                    ; Input/Sense Configuration bit 2 position\n.equ PORT_PULLUPEN_bm = 0x08             ; Pullup enable bit mask\n.equ PORT_PULLUPEN_bp = 3                ; Pullup enable bit position\n\n; PORT_PIN1CTRL masks\n; Masks for PORT_INVEN already defined\n; Masks for PORT_ISC already defined\n; Masks for PORT_PULLUPEN already defined\n\n; PORT_PIN2CTRL masks\n; Masks for PORT_INVEN already defined\n; Masks for PORT_ISC already defined\n; Masks for PORT_PULLUPEN already defined\n\n; PORT_PIN3CTRL masks\n; Masks for PORT_INVEN already defined\n; Masks for PORT_ISC already defined\n; Masks for PORT_PULLUPEN already defined\n\n; PORT_PIN4CTRL masks\n; Masks for PORT_INVEN already defined\n; Masks for PORT_ISC already defined\n; Masks for PORT_PULLUPEN already defined\n\n; PORT_PIN5CTRL masks\n; Masks for PORT_INVEN already defined\n; Masks for PORT_ISC already defined\n; Masks for PORT_PULLUPEN already defined\n\n; PORT_PIN6CTRL masks\n; Masks for PORT_INVEN already defined\n; Masks for PORT_ISC already defined\n; Masks for PORT_PULLUPEN already defined\n\n; PORT_PIN7CTRL masks\n; Masks for PORT_INVEN already defined\n; Masks for PORT_ISC already defined\n; Masks for PORT_PULLUPEN already defined\n\n; Input/Sense Configuration select\n.equ PORT_ISC_INTDISABLE_gc = (0x00<<0)  ; Interrupt disabled but input buffer enabled\n.equ PORT_ISC_BOTHEDGES_gc = (0x01<<0)   ; Sense Both Edges\n.equ PORT_ISC_RISING_gc = (0x02<<0)      ; Sense Rising Edge\n.equ PORT_ISC_FALLING_gc = (0x03<<0)     ; Sense Falling Edge\n.equ PORT_ISC_INPUT_DISABLE_gc = (0x04<<0) ; Digital Input Buffer disabled\n.equ PORT_ISC_LEVEL_gc = (0x05<<0)       ; Sense low Level\n\n\n;*************************************************************************\n;** PORTMUX - Port Multiplexer\n;*************************************************************************\n\n; PORTMUX_CTRLA masks\n.equ PORTMUX_EVOUT0_bm = 0x01            ; Event Output 0 bit mask\n.equ PORTMUX_EVOUT0_bp = 0               ; Event Output 0 bit position\n.equ PORTMUX_EVOUT1_bm = 0x02            ; Event Output 1 bit mask\n.equ PORTMUX_EVOUT1_bp = 1               ; Event Output 1 bit position\n.equ PORTMUX_EVOUT2_bm = 0x04            ; Event Output 2 bit mask\n.equ PORTMUX_EVOUT2_bp = 2               ; Event Output 2 bit position\n.equ PORTMUX_LUT0_bm = 0x10              ; Configurable Custom Logic LUT0 bit mask\n.equ PORTMUX_LUT0_bp = 4                 ; Configurable Custom Logic LUT0 bit position\n.equ PORTMUX_LUT1_bm = 0x20              ; Configurable Custom Logic LUT1 bit mask\n.equ PORTMUX_LUT1_bp = 5                 ; Configurable Custom Logic LUT1 bit position\n\n; PORTMUX_CTRLB masks\n.equ PORTMUX_SPI0_bm = 0x04              ; Port Multiplexer SPI0 bit mask\n.equ PORTMUX_SPI0_bp = 2                 ; Port Multiplexer SPI0 bit position\n.equ PORTMUX_USART0_bm = 0x01            ; Port Multiplexer USART0 bit mask\n.equ PORTMUX_USART0_bp = 0               ; Port Multiplexer USART0 bit position\n\n; PORTMUX_CTRLC masks\n.equ PORTMUX_TCA00_bm = 0x01             ; Port Multiplexer TCA0 Output 0 bit mask\n.equ PORTMUX_TCA00_bp = 0                ; Port Multiplexer TCA0 Output 0 bit position\n.equ PORTMUX_TCA01_bm = 0x02             ; Port Multiplexer TCA0 Output 1 bit mask\n.equ PORTMUX_TCA01_bp = 1                ; Port Multiplexer TCA0 Output 1 bit position\n.equ PORTMUX_TCA02_bm = 0x04             ; Port Multiplexer TCA0 Output 2 bit mask\n.equ PORTMUX_TCA02_bp = 2                ; Port Multiplexer TCA0 Output 2 bit position\n.equ PORTMUX_TCA03_bm = 0x08             ; Port Multiplexer TCA0 Output 3 bit mask\n.equ PORTMUX_TCA03_bp = 3                ; Port Multiplexer TCA0 Output 3 bit position\n\n; PORTMUX_CTRLD masks\n.equ PORTMUX_TCB0_bm = 0x01              ; Port Multiplexer TCB bit mask\n.equ PORTMUX_TCB0_bp = 0                 ; Port Multiplexer TCB bit position\n\n; Configurable Custom Logic LUT0 select\n.equ PORTMUX_LUT0_DEFAULT_gc = (0x00<<4) ; Default pin\n.equ PORTMUX_LUT0_ALTERNATE_gc = (0x01<<4) ; Alternate pin\n\n; Configurable Custom Logic LUT1 select\n.equ PORTMUX_LUT1_DEFAULT_gc = (0x00<<5) ; Default pin\n.equ PORTMUX_LUT1_ALTERNATE_gc = (0x01<<5) ; Alternate pin\n\n; Port Multiplexer SPI0 select\n.equ PORTMUX_SPI0_DEFAULT_gc = (0x00<<2) ; Default pins\n.equ PORTMUX_SPI0_ALTERNATE_gc = (0x01<<2) ; Alternate pins\n\n; Port Multiplexer USART0 select\n.equ PORTMUX_USART0_DEFAULT_gc = (0x00<<0) ; Default pins\n.equ PORTMUX_USART0_ALTERNATE_gc = (0x01<<0) ; Alternate pins\n\n; Port Multiplexer TCA0 Output 0 select\n.equ PORTMUX_TCA00_DEFAULT_gc = (0x00<<0) ; Default pin\n.equ PORTMUX_TCA00_ALTERNATE_gc = (0x01<<0) ; Alternate pin\n\n; Port Multiplexer TCA0 Output 1 select\n.equ PORTMUX_TCA01_DEFAULT_gc = (0x00<<1) ; Default pin\n.equ PORTMUX_TCA01_ALTERNATE_gc = (0x01<<1) ; Alternate pin\n\n; Port Multiplexer TCA0 Output 2 select\n.equ PORTMUX_TCA02_DEFAULT_gc = (0x00<<2) ; Default pin\n.equ PORTMUX_TCA02_ALTERNATE_gc = (0x01<<2) ; Alternate pin\n\n; Port Multiplexer TCA0 Output 3 select\n.equ PORTMUX_TCA03_DEFAULT_gc = (0x00<<3) ; Default pin\n.equ PORTMUX_TCA03_ALTERNATE_gc = (0x01<<3) ; Alternate pin\n\n; Port Multiplexer TCB select\n.equ PORTMUX_TCB0_DEFAULT_gc = (0x00<<0) ; Default pin\n.equ PORTMUX_TCB0_ALTERNATE_gc = (0x01<<0) ; Alternate pin\n\n\n;*************************************************************************\n;** RSTCTRL - Reset controller\n;*************************************************************************\n\n; RSTCTRL_RSTFR masks\n.equ RSTCTRL_BORF_bm = 0x02              ; Brown out detector Reset flag bit mask\n.equ RSTCTRL_BORF_bp = 1                 ; Brown out detector Reset flag bit position\n.equ RSTCTRL_EXTRF_bm = 0x04             ; External Reset flag bit mask\n.equ RSTCTRL_EXTRF_bp = 2                ; External Reset flag bit position\n.equ RSTCTRL_PORF_bm = 0x01              ; Power on Reset flag bit mask\n.equ RSTCTRL_PORF_bp = 0                 ; Power on Reset flag bit position\n.equ RSTCTRL_SWRF_bm = 0x10              ; Software Reset flag bit mask\n.equ RSTCTRL_SWRF_bp = 4                 ; Software Reset flag bit position\n.equ RSTCTRL_UPDIRF_bm = 0x20            ; UPDI Reset flag bit mask\n.equ RSTCTRL_UPDIRF_bp = 5               ; UPDI Reset flag bit position\n.equ RSTCTRL_WDRF_bm = 0x08              ; Watch dog Reset flag bit mask\n.equ RSTCTRL_WDRF_bp = 3                 ; Watch dog Reset flag bit position\n\n; RSTCTRL_SWRR masks\n.equ RSTCTRL_SWRE_bm = 0x01              ; Software reset enable bit mask\n.equ RSTCTRL_SWRE_bp = 0                 ; Software reset enable bit position\n\n\n;*************************************************************************\n;** RTC - Real-Time Counter\n;*************************************************************************\n\n; RTC_CLKSEL masks\n.equ RTC_CLKSEL_gm = 0x03                ; Clock Select group mask\n.equ RTC_CLKSEL_gp = 0                   ; Clock Select group position\n.equ RTC_CLKSEL0_bm = (1<<0)             ; Clock Select bit 0 mask\n.equ RTC_CLKSEL0_bp = 0                  ; Clock Select bit 0 position\n.equ RTC_CLKSEL1_bm = (1<<1)             ; Clock Select bit 1 mask\n.equ RTC_CLKSEL1_bp = 1                  ; Clock Select bit 1 position\n\n; RTC_CTRLA masks\n.equ RTC_PRESCALER_gm = 0x78             ; Prescaling Factor group mask\n.equ RTC_PRESCALER_gp = 3                ; Prescaling Factor group position\n.equ RTC_PRESCALER0_bm = (1<<3)          ; Prescaling Factor bit 0 mask\n.equ RTC_PRESCALER0_bp = 3               ; Prescaling Factor bit 0 position\n.equ RTC_PRESCALER1_bm = (1<<4)          ; Prescaling Factor bit 1 mask\n.equ RTC_PRESCALER1_bp = 4               ; Prescaling Factor bit 1 position\n.equ RTC_PRESCALER2_bm = (1<<5)          ; Prescaling Factor bit 2 mask\n.equ RTC_PRESCALER2_bp = 5               ; Prescaling Factor bit 2 position\n.equ RTC_PRESCALER3_bm = (1<<6)          ; Prescaling Factor bit 3 mask\n.equ RTC_PRESCALER3_bp = 6               ; Prescaling Factor bit 3 position\n.equ RTC_RTCEN_bm = 0x01                 ; Enable bit mask\n.equ RTC_RTCEN_bp = 0                    ; Enable bit position\n.equ RTC_RUNSTDBY_bm = 0x80              ; Run In Standby bit mask\n.equ RTC_RUNSTDBY_bp = 7                 ; Run In Standby bit position\n\n; RTC_DBGCTRL masks\n.equ RTC_DBGRUN_bm = 0x01                ; Run in debug bit mask\n.equ RTC_DBGRUN_bp = 0                   ; Run in debug bit position\n\n; RTC_INTCTRL masks\n.equ RTC_CMP_bm = 0x02                   ; Compare Match Interrupt enable bit mask\n.equ RTC_CMP_bp = 1                      ; Compare Match Interrupt enable bit position\n.equ RTC_OVF_bm = 0x01                   ; Overflow Interrupt enable bit mask\n.equ RTC_OVF_bp = 0                      ; Overflow Interrupt enable bit position\n\n; RTC_INTFLAGS masks\n; Masks for RTC_CMP already defined\n; Masks for RTC_OVF already defined\n\n; RTC_PITCTRLA masks\n.equ RTC_PERIOD_gm = 0x78                ; Period group mask\n.equ RTC_PERIOD_gp = 3                   ; Period group position\n.equ RTC_PERIOD0_bm = (1<<3)             ; Period bit 0 mask\n.equ RTC_PERIOD0_bp = 3                  ; Period bit 0 position\n.equ RTC_PERIOD1_bm = (1<<4)             ; Period bit 1 mask\n.equ RTC_PERIOD1_bp = 4                  ; Period bit 1 position\n.equ RTC_PERIOD2_bm = (1<<5)             ; Period bit 2 mask\n.equ RTC_PERIOD2_bp = 5                  ; Period bit 2 position\n.equ RTC_PERIOD3_bm = (1<<6)             ; Period bit 3 mask\n.equ RTC_PERIOD3_bp = 6                  ; Period bit 3 position\n.equ RTC_PITEN_bm = 0x01                 ; Enable bit mask\n.equ RTC_PITEN_bp = 0                    ; Enable bit position\n\n; RTC_PITDBGCTRL masks\n; Masks for RTC_DBGRUN already defined\n\n; RTC_PITINTCTRL masks\n.equ RTC_PI_bm = 0x01                    ; Periodic Interrupt bit mask\n.equ RTC_PI_bp = 0                       ; Periodic Interrupt bit position\n\n; RTC_PITINTFLAGS masks\n; Masks for RTC_PI already defined\n\n; RTC_PITSTATUS masks\n.equ RTC_CTRLBUSY_bm = 0x01              ; CTRLA Synchronization Busy Flag bit mask\n.equ RTC_CTRLBUSY_bp = 0                 ; CTRLA Synchronization Busy Flag bit position\n\n; RTC_STATUS masks\n.equ RTC_CMPBUSY_bm = 0x08               ; Comparator Synchronization Busy Flag bit mask\n.equ RTC_CMPBUSY_bp = 3                  ; Comparator Synchronization Busy Flag bit position\n.equ RTC_CNTBUSY_bm = 0x02               ; Count Synchronization Busy Flag bit mask\n.equ RTC_CNTBUSY_bp = 1                  ; Count Synchronization Busy Flag bit position\n.equ RTC_CTRLABUSY_bm = 0x01             ; CTRLA Synchronization Busy Flag bit mask\n.equ RTC_CTRLABUSY_bp = 0                ; CTRLA Synchronization Busy Flag bit position\n.equ RTC_PERBUSY_bm = 0x04               ; Period Synchronization Busy Flag bit mask\n.equ RTC_PERBUSY_bp = 2                  ; Period Synchronization Busy Flag bit position\n\n; Clock Select select\n.equ RTC_CLKSEL_INT32K_gc = (0x00<<0)    ; Internal 32kHz OSC\n.equ RTC_CLKSEL_INT1K_gc = (0x01<<0)     ; Internal 1kHz OSC\n.equ RTC_CLKSEL_EXTCLK_gc = (0x03<<0)    ; External Clock\n\n; Prescaling Factor select\n.equ RTC_PRESCALER_DIV1_gc = (0x00<<3)   ; RTC Clock / 1\n.equ RTC_PRESCALER_DIV2_gc = (0x01<<3)   ; RTC Clock / 2\n.equ RTC_PRESCALER_DIV4_gc = (0x02<<3)   ; RTC Clock / 4\n.equ RTC_PRESCALER_DIV8_gc = (0x03<<3)   ; RTC Clock / 8\n.equ RTC_PRESCALER_DIV16_gc = (0x04<<3)  ; RTC Clock / 16\n.equ RTC_PRESCALER_DIV32_gc = (0x05<<3)  ; RTC Clock / 32\n.equ RTC_PRESCALER_DIV64_gc = (0x06<<3)  ; RTC Clock / 64\n.equ RTC_PRESCALER_DIV128_gc = (0x07<<3) ; RTC Clock / 128\n.equ RTC_PRESCALER_DIV256_gc = (0x08<<3) ; RTC Clock / 256\n.equ RTC_PRESCALER_DIV512_gc = (0x09<<3) ; RTC Clock / 512\n.equ RTC_PRESCALER_DIV1024_gc = (0x0A<<3) ; RTC Clock / 1024\n.equ RTC_PRESCALER_DIV2048_gc = (0x0B<<3) ; RTC Clock / 2048\n.equ RTC_PRESCALER_DIV4096_gc = (0x0C<<3) ; RTC Clock / 4096\n.equ RTC_PRESCALER_DIV8192_gc = (0x0D<<3) ; RTC Clock / 8192\n.equ RTC_PRESCALER_DIV16384_gc = (0x0E<<3) ; RTC Clock / 16384\n.equ RTC_PRESCALER_DIV32768_gc = (0x0F<<3) ; RTC Clock / 32768\n\n; Period select\n.equ RTC_PERIOD_OFF_gc = (0x00<<3)       ; Off\n.equ RTC_PERIOD_CYC4_gc = (0x01<<3)      ; RTC Clock Cycles 4\n.equ RTC_PERIOD_CYC8_gc = (0x02<<3)      ; RTC Clock Cycles 8\n.equ RTC_PERIOD_CYC16_gc = (0x03<<3)     ; RTC Clock Cycles 16\n.equ RTC_PERIOD_CYC32_gc = (0x04<<3)     ; RTC Clock Cycles 32\n.equ RTC_PERIOD_CYC64_gc = (0x05<<3)     ; RTC Clock Cycles 64\n.equ RTC_PERIOD_CYC128_gc = (0x06<<3)    ; RTC Clock Cycles 128\n.equ RTC_PERIOD_CYC256_gc = (0x07<<3)    ; RTC Clock Cycles 256\n.equ RTC_PERIOD_CYC512_gc = (0x08<<3)    ; RTC Clock Cycles 512\n.equ RTC_PERIOD_CYC1024_gc = (0x09<<3)   ; RTC Clock Cycles 1024\n.equ RTC_PERIOD_CYC2048_gc = (0x0A<<3)   ; RTC Clock Cycles 2048\n.equ RTC_PERIOD_CYC4096_gc = (0x0B<<3)   ; RTC Clock Cycles 4096\n.equ RTC_PERIOD_CYC8192_gc = (0x0C<<3)   ; RTC Clock Cycles 8192\n.equ RTC_PERIOD_CYC16384_gc = (0x0D<<3)  ; RTC Clock Cycles 16384\n.equ RTC_PERIOD_CYC32768_gc = (0x0E<<3)  ; RTC Clock Cycles 32768\n\n\n;*************************************************************************\n;** SIGROW - Signature row\n;*************************************************************************\n\n\n;*************************************************************************\n;** SLPCTRL - Sleep Controller\n;*************************************************************************\n\n; SLPCTRL_CTRLA masks\n.equ SLPCTRL_SEN_bm = 0x01               ; Sleep enable bit mask\n.equ SLPCTRL_SEN_bp = 0                  ; Sleep enable bit position\n.equ SLPCTRL_SMODE_gm = 0x06             ; Sleep mode group mask\n.equ SLPCTRL_SMODE_gp = 1                ; Sleep mode group position\n.equ SLPCTRL_SMODE0_bm = (1<<1)          ; Sleep mode bit 0 mask\n.equ SLPCTRL_SMODE0_bp = 1               ; Sleep mode bit 0 position\n.equ SLPCTRL_SMODE1_bm = (1<<2)          ; Sleep mode bit 1 mask\n.equ SLPCTRL_SMODE1_bp = 2               ; Sleep mode bit 1 position\n\n; Sleep mode select\n.equ SLPCTRL_SMODE_IDLE_gc = (0x00<<1)   ; Idle mode\n.equ SLPCTRL_SMODE_STDBY_gc = (0x01<<1)  ; Standby Mode\n.equ SLPCTRL_SMODE_PDOWN_gc = (0x02<<1)  ; Power-down Mode\n\n\n;*************************************************************************\n;** SPI - Serial Peripheral Interface\n;*************************************************************************\n\n; SPI_CTRLA masks\n.equ SPI_CLK2X_bm = 0x10                 ; Enable Double Speed bit mask\n.equ SPI_CLK2X_bp = 4                    ; Enable Double Speed bit position\n.equ SPI_DORD_bm = 0x40                  ; Data Order Setting bit mask\n.equ SPI_DORD_bp = 6                     ; Data Order Setting bit position\n.equ SPI_ENABLE_bm = 0x01                ; Enable Module bit mask\n.equ SPI_ENABLE_bp = 0                   ; Enable Module bit position\n.equ SPI_MASTER_bm = 0x20                ; Master Operation Enable bit mask\n.equ SPI_MASTER_bp = 5                   ; Master Operation Enable bit position\n.equ SPI_PRESC_gm = 0x06                 ; Prescaler group mask\n.equ SPI_PRESC_gp = 1                    ; Prescaler group position\n.equ SPI_PRESC0_bm = (1<<1)              ; Prescaler bit 0 mask\n.equ SPI_PRESC0_bp = 1                   ; Prescaler bit 0 position\n.equ SPI_PRESC1_bm = (1<<2)              ; Prescaler bit 1 mask\n.equ SPI_PRESC1_bp = 2                   ; Prescaler bit 1 position\n\n; SPI_CTRLB masks\n.equ SPI_BUFEN_bm = 0x80                 ; Buffer Mode Enable bit mask\n.equ SPI_BUFEN_bp = 7                    ; Buffer Mode Enable bit position\n.equ SPI_BUFWR_bm = 0x40                 ; Buffer Write Mode bit mask\n.equ SPI_BUFWR_bp = 6                    ; Buffer Write Mode bit position\n.equ SPI_MODE_gm = 0x03                  ; SPI Mode group mask\n.equ SPI_MODE_gp = 0                     ; SPI Mode group position\n.equ SPI_MODE0_bm = (1<<0)               ; SPI Mode bit 0 mask\n.equ SPI_MODE0_bp = 0                    ; SPI Mode bit 0 position\n.equ SPI_MODE1_bm = (1<<1)               ; SPI Mode bit 1 mask\n.equ SPI_MODE1_bp = 1                    ; SPI Mode bit 1 position\n.equ SPI_SSD_bm = 0x04                   ; Slave Select Disable bit mask\n.equ SPI_SSD_bp = 2                      ; Slave Select Disable bit position\n\n; SPI_INTCTRL masks\n.equ SPI_DREIE_bm = 0x20                 ; Data Register Empty Interrupt Enable bit mask\n.equ SPI_DREIE_bp = 5                    ; Data Register Empty Interrupt Enable bit position\n.equ SPI_IE_bm = 0x01                    ; Interrupt Enable bit mask\n.equ SPI_IE_bp = 0                       ; Interrupt Enable bit position\n.equ SPI_RXCIE_bm = 0x80                 ; Receive Complete Interrupt Enable bit mask\n.equ SPI_RXCIE_bp = 7                    ; Receive Complete Interrupt Enable bit position\n.equ SPI_SSIE_bm = 0x10                  ; Slave Select Trigger Interrupt Enable bit mask\n.equ SPI_SSIE_bp = 4                     ; Slave Select Trigger Interrupt Enable bit position\n.equ SPI_TXCIE_bm = 0x40                 ; Transfer Complete Interrupt Enable bit mask\n.equ SPI_TXCIE_bp = 6                    ; Transfer Complete Interrupt Enable bit position\n\n; SPI_INTFLAGS masks\n.equ SPI_BUFOVF_bm = 0x01                ; Buffer Overflow bit mask\n.equ SPI_BUFOVF_bp = 0                   ; Buffer Overflow bit position\n.equ SPI_DREIF_bm = 0x20                 ; Data Register Empty Interrupt Flag bit mask\n.equ SPI_DREIF_bp = 5                    ; Data Register Empty Interrupt Flag bit position\n.equ SPI_RXCIF_bm = 0x80                 ; Receive Complete Interrupt Flag bit mask\n.equ SPI_RXCIF_bp = 7                    ; Receive Complete Interrupt Flag bit position\n.equ SPI_SSIF_bm = 0x10                  ; Slave Select Trigger Interrupt Flag bit mask\n.equ SPI_SSIF_bp = 4                     ; Slave Select Trigger Interrupt Flag bit position\n.equ SPI_TXCIF_bm = 0x40                 ; Transfer Complete Interrupt Flag bit mask\n.equ SPI_TXCIF_bp = 6                    ; Transfer Complete Interrupt Flag bit position\n.equ SPI_IF_bm = 0x80                    ; Interrupt Flag bit mask\n.equ SPI_IF_bp = 7                       ; Interrupt Flag bit position\n.equ SPI_WRCOL_bm = 0x40                 ; Write Collision bit mask\n.equ SPI_WRCOL_bp = 6                    ; Write Collision bit position\n\n; Prescaler select\n.equ SPI_PRESC_DIV4_gc = (0x00<<1)       ; System Clock / 4\n.equ SPI_PRESC_DIV16_gc = (0x01<<1)      ; System Clock / 16\n.equ SPI_PRESC_DIV64_gc = (0x02<<1)      ; System Clock / 64\n.equ SPI_PRESC_DIV128_gc = (0x03<<1)     ; System Clock / 128\n\n; SPI Mode select\n.equ SPI_MODE_0_gc = (0x00<<0)           ; SPI Mode 0\n.equ SPI_MODE_1_gc = (0x01<<0)           ; SPI Mode 1\n.equ SPI_MODE_2_gc = (0x02<<0)           ; SPI Mode 2\n.equ SPI_MODE_3_gc = (0x03<<0)           ; SPI Mode 3\n\n\n;*************************************************************************\n;** SYSCFG - System Configuration Registers\n;*************************************************************************\n\n; SYSCFG_EXTBRK masks\n.equ SYSCFG_ENEXTBRK_bm = 0x01           ; External break enable bit mask\n.equ SYSCFG_ENEXTBRK_bp = 0              ; External break enable bit position\n\n\n;*************************************************************************\n;** TCA - 16-bit Timer/Counter Type A\n;*************************************************************************\n\n; TCA_SINGLE_CTRLA masks\n.equ TCA_SINGLE_CLKSEL_gm = 0x0E         ; Clock Selection group mask\n.equ TCA_SINGLE_CLKSEL_gp = 1            ; Clock Selection group position\n.equ TCA_SINGLE_CLKSEL0_bm = (1<<1)      ; Clock Selection bit 0 mask\n.equ TCA_SINGLE_CLKSEL0_bp = 1           ; Clock Selection bit 0 position\n.equ TCA_SINGLE_CLKSEL1_bm = (1<<2)      ; Clock Selection bit 1 mask\n.equ TCA_SINGLE_CLKSEL1_bp = 2           ; Clock Selection bit 1 position\n.equ TCA_SINGLE_CLKSEL2_bm = (1<<3)      ; Clock Selection bit 2 mask\n.equ TCA_SINGLE_CLKSEL2_bp = 3           ; Clock Selection bit 2 position\n.equ TCA_SINGLE_ENABLE_bm = 0x01         ; Module Enable bit mask\n.equ TCA_SINGLE_ENABLE_bp = 0            ; Module Enable bit position\n\n; TCA_SINGLE_CTRLB masks\n.equ TCA_SINGLE_ALUPD_bm = 0x08          ; Auto Lock Update bit mask\n.equ TCA_SINGLE_ALUPD_bp = 3             ; Auto Lock Update bit position\n.equ TCA_SINGLE_CMP0EN_bm = 0x10         ; Compare 0 Enable bit mask\n.equ TCA_SINGLE_CMP0EN_bp = 4            ; Compare 0 Enable bit position\n.equ TCA_SINGLE_CMP1EN_bm = 0x20         ; Compare 1 Enable bit mask\n.equ TCA_SINGLE_CMP1EN_bp = 5            ; Compare 1 Enable bit position\n.equ TCA_SINGLE_CMP2EN_bm = 0x40         ; Compare 2 Enable bit mask\n.equ TCA_SINGLE_CMP2EN_bp = 6            ; Compare 2 Enable bit position\n.equ TCA_SINGLE_WGMODE_gm = 0x07         ; Waveform generation mode group mask\n.equ TCA_SINGLE_WGMODE_gp = 0            ; Waveform generation mode group position\n.equ TCA_SINGLE_WGMODE0_bm = (1<<0)      ; Waveform generation mode bit 0 mask\n.equ TCA_SINGLE_WGMODE0_bp = 0           ; Waveform generation mode bit 0 position\n.equ TCA_SINGLE_WGMODE1_bm = (1<<1)      ; Waveform generation mode bit 1 mask\n.equ TCA_SINGLE_WGMODE1_bp = 1           ; Waveform generation mode bit 1 position\n.equ TCA_SINGLE_WGMODE2_bm = (1<<2)      ; Waveform generation mode bit 2 mask\n.equ TCA_SINGLE_WGMODE2_bp = 2           ; Waveform generation mode bit 2 position\n\n; TCA_SINGLE_CTRLC masks\n.equ TCA_SINGLE_CMP0OV_bm = 0x01         ; Compare 0 Waveform Output Value bit mask\n.equ TCA_SINGLE_CMP0OV_bp = 0            ; Compare 0 Waveform Output Value bit position\n.equ TCA_SINGLE_CMP1OV_bm = 0x02         ; Compare 1 Waveform Output Value bit mask\n.equ TCA_SINGLE_CMP1OV_bp = 1            ; Compare 1 Waveform Output Value bit position\n.equ TCA_SINGLE_CMP2OV_bm = 0x04         ; Compare 2 Waveform Output Value bit mask\n.equ TCA_SINGLE_CMP2OV_bp = 2            ; Compare 2 Waveform Output Value bit position\n\n; TCA_SINGLE_CTRLD masks\n.equ TCA_SINGLE_SPLITM_bm = 0x01         ; Split Mode Enable bit mask\n.equ TCA_SINGLE_SPLITM_bp = 0            ; Split Mode Enable bit position\n\n; TCA_SINGLE_CTRLECLR masks\n.equ TCA_SINGLE_CMD_gm = 0x0C            ; Command group mask\n.equ TCA_SINGLE_CMD_gp = 2               ; Command group position\n.equ TCA_SINGLE_CMD0_bm = (1<<2)         ; Command bit 0 mask\n.equ TCA_SINGLE_CMD0_bp = 2              ; Command bit 0 position\n.equ TCA_SINGLE_CMD1_bm = (1<<3)         ; Command bit 1 mask\n.equ TCA_SINGLE_CMD1_bp = 3              ; Command bit 1 position\n.equ TCA_SINGLE_DIR_bm = 0x01            ; Direction bit mask\n.equ TCA_SINGLE_DIR_bp = 0               ; Direction bit position\n.equ TCA_SINGLE_LUPD_bm = 0x02           ; Lock Update bit mask\n.equ TCA_SINGLE_LUPD_bp = 1              ; Lock Update bit position\n\n; TCA_SINGLE_CTRLESET masks\n; Masks for TCA_SINGLE_CMD already defined\n; Masks for TCA_SINGLE_DIR already defined\n; Masks for TCA_SINGLE_LUPD already defined\n\n; TCA_SINGLE_CTRLFCLR masks\n.equ TCA_SINGLE_CMP0BV_bm = 0x02         ; Compare 0 Buffer Valid bit mask\n.equ TCA_SINGLE_CMP0BV_bp = 1            ; Compare 0 Buffer Valid bit position\n.equ TCA_SINGLE_CMP1BV_bm = 0x04         ; Compare 1 Buffer Valid bit mask\n.equ TCA_SINGLE_CMP1BV_bp = 2            ; Compare 1 Buffer Valid bit position\n.equ TCA_SINGLE_CMP2BV_bm = 0x08         ; Compare 2 Buffer Valid bit mask\n.equ TCA_SINGLE_CMP2BV_bp = 3            ; Compare 2 Buffer Valid bit position\n.equ TCA_SINGLE_PERBV_bm = 0x01          ; Period Buffer Valid bit mask\n.equ TCA_SINGLE_PERBV_bp = 0             ; Period Buffer Valid bit position\n\n; TCA_SINGLE_CTRLFSET masks\n; Masks for TCA_SINGLE_CMP0BV already defined\n; Masks for TCA_SINGLE_CMP1BV already defined\n; Masks for TCA_SINGLE_CMP2BV already defined\n; Masks for TCA_SINGLE_PERBV already defined\n\n; TCA_SINGLE_DBGCTRL masks\n.equ TCA_SINGLE_DBGRUN_bm = 0x01         ; Debug Run bit mask\n.equ TCA_SINGLE_DBGRUN_bp = 0            ; Debug Run bit position\n\n; TCA_SINGLE_EVCTRL masks\n.equ TCA_SINGLE_CNTEI_bm = 0x01          ; Count on Event Input bit mask\n.equ TCA_SINGLE_CNTEI_bp = 0             ; Count on Event Input bit position\n.equ TCA_SINGLE_EVACT_gm = 0x06          ; Event Action group mask\n.equ TCA_SINGLE_EVACT_gp = 1             ; Event Action group position\n.equ TCA_SINGLE_EVACT0_bm = (1<<1)       ; Event Action bit 0 mask\n.equ TCA_SINGLE_EVACT0_bp = 1            ; Event Action bit 0 position\n.equ TCA_SINGLE_EVACT1_bm = (1<<2)       ; Event Action bit 1 mask\n.equ TCA_SINGLE_EVACT1_bp = 2            ; Event Action bit 1 position\n\n; TCA_SINGLE_INTCTRL masks\n.equ TCA_SINGLE_CMP0_bm = 0x10           ; Compare 0 Interrupt bit mask\n.equ TCA_SINGLE_CMP0_bp = 4              ; Compare 0 Interrupt bit position\n.equ TCA_SINGLE_CMP1_bm = 0x20           ; Compare 1 Interrupt bit mask\n.equ TCA_SINGLE_CMP1_bp = 5              ; Compare 1 Interrupt bit position\n.equ TCA_SINGLE_CMP2_bm = 0x40           ; Compare 2 Interrupt bit mask\n.equ TCA_SINGLE_CMP2_bp = 6              ; Compare 2 Interrupt bit position\n.equ TCA_SINGLE_OVF_bm = 0x01            ; Overflow Interrupt bit mask\n.equ TCA_SINGLE_OVF_bp = 0               ; Overflow Interrupt bit position\n\n; TCA_SINGLE_INTFLAGS masks\n; Masks for TCA_SINGLE_CMP0 already defined\n; Masks for TCA_SINGLE_CMP1 already defined\n; Masks for TCA_SINGLE_CMP2 already defined\n; Masks for TCA_SINGLE_OVF already defined\n\n; TCA_SPLIT_CTRLA masks\n.equ TCA_SPLIT_CLKSEL_gm = 0x0E          ; Clock Selection group mask\n.equ TCA_SPLIT_CLKSEL_gp = 1             ; Clock Selection group position\n.equ TCA_SPLIT_CLKSEL0_bm = (1<<1)       ; Clock Selection bit 0 mask\n.equ TCA_SPLIT_CLKSEL0_bp = 1            ; Clock Selection bit 0 position\n.equ TCA_SPLIT_CLKSEL1_bm = (1<<2)       ; Clock Selection bit 1 mask\n.equ TCA_SPLIT_CLKSEL1_bp = 2            ; Clock Selection bit 1 position\n.equ TCA_SPLIT_CLKSEL2_bm = (1<<3)       ; Clock Selection bit 2 mask\n.equ TCA_SPLIT_CLKSEL2_bp = 3            ; Clock Selection bit 2 position\n.equ TCA_SPLIT_ENABLE_bm = 0x01          ; Module Enable bit mask\n.equ TCA_SPLIT_ENABLE_bp = 0             ; Module Enable bit position\n\n; TCA_SPLIT_CTRLB masks\n.equ TCA_SPLIT_HCMP0EN_bm = 0x10         ; High Compare 0 Enable bit mask\n.equ TCA_SPLIT_HCMP0EN_bp = 4            ; High Compare 0 Enable bit position\n.equ TCA_SPLIT_HCMP1EN_bm = 0x20         ; High Compare 1 Enable bit mask\n.equ TCA_SPLIT_HCMP1EN_bp = 5            ; High Compare 1 Enable bit position\n.equ TCA_SPLIT_HCMP2EN_bm = 0x40         ; High Compare 2 Enable bit mask\n.equ TCA_SPLIT_HCMP2EN_bp = 6            ; High Compare 2 Enable bit position\n.equ TCA_SPLIT_LCMP0EN_bm = 0x01         ; Low Compare 0 Enable bit mask\n.equ TCA_SPLIT_LCMP0EN_bp = 0            ; Low Compare 0 Enable bit position\n.equ TCA_SPLIT_LCMP1EN_bm = 0x02         ; Low Compare 1 Enable bit mask\n.equ TCA_SPLIT_LCMP1EN_bp = 1            ; Low Compare 1 Enable bit position\n.equ TCA_SPLIT_LCMP2EN_bm = 0x04         ; Low Compare 2 Enable bit mask\n.equ TCA_SPLIT_LCMP2EN_bp = 2            ; Low Compare 2 Enable bit position\n\n; TCA_SPLIT_CTRLC masks\n.equ TCA_SPLIT_HCMP0OV_bm = 0x10         ; High Compare 0 Output Value bit mask\n.equ TCA_SPLIT_HCMP0OV_bp = 4            ; High Compare 0 Output Value bit position\n.equ TCA_SPLIT_HCMP1OV_bm = 0x20         ; High Compare 1 Output Value bit mask\n.equ TCA_SPLIT_HCMP1OV_bp = 5            ; High Compare 1 Output Value bit position\n.equ TCA_SPLIT_HCMP2OV_bm = 0x40         ; High Compare 2 Output Value bit mask\n.equ TCA_SPLIT_HCMP2OV_bp = 6            ; High Compare 2 Output Value bit position\n.equ TCA_SPLIT_LCMP0OV_bm = 0x01         ; Low Compare 0 Output Value bit mask\n.equ TCA_SPLIT_LCMP0OV_bp = 0            ; Low Compare 0 Output Value bit position\n.equ TCA_SPLIT_LCMP1OV_bm = 0x02         ; Low Compare 1 Output Value bit mask\n.equ TCA_SPLIT_LCMP1OV_bp = 1            ; Low Compare 1 Output Value bit position\n.equ TCA_SPLIT_LCMP2OV_bm = 0x04         ; Low Compare 2 Output Value bit mask\n.equ TCA_SPLIT_LCMP2OV_bp = 2            ; Low Compare 2 Output Value bit position\n\n; TCA_SPLIT_CTRLD masks\n.equ TCA_SPLIT_SPLITM_bm = 0x01          ; Split Mode Enable bit mask\n.equ TCA_SPLIT_SPLITM_bp = 0             ; Split Mode Enable bit position\n\n; TCA_SPLIT_CTRLECLR masks\n.equ TCA_SPLIT_CMD_gm = 0x0C             ; Command group mask\n.equ TCA_SPLIT_CMD_gp = 2                ; Command group position\n.equ TCA_SPLIT_CMD0_bm = (1<<2)          ; Command bit 0 mask\n.equ TCA_SPLIT_CMD0_bp = 2               ; Command bit 0 position\n.equ TCA_SPLIT_CMD1_bm = (1<<3)          ; Command bit 1 mask\n.equ TCA_SPLIT_CMD1_bp = 3               ; Command bit 1 position\n\n; TCA_SPLIT_CTRLESET masks\n; Masks for TCA_SPLIT_CMD already defined\n\n; TCA_SPLIT_DBGCTRL masks\n.equ TCA_SPLIT_DBGRUN_bm = 0x01          ; Debug Run bit mask\n.equ TCA_SPLIT_DBGRUN_bp = 0             ; Debug Run bit position\n\n; TCA_SPLIT_INTCTRL masks\n.equ TCA_SPLIT_HUNF_bm = 0x02            ; High Underflow Interrupt Enable bit mask\n.equ TCA_SPLIT_HUNF_bp = 1               ; High Underflow Interrupt Enable bit position\n.equ TCA_SPLIT_LCMP0_bm = 0x10           ; Low Compare 0 Interrupt Enable bit mask\n.equ TCA_SPLIT_LCMP0_bp = 4              ; Low Compare 0 Interrupt Enable bit position\n.equ TCA_SPLIT_LCMP1_bm = 0x20           ; Low Compare 1 Interrupt Enable bit mask\n.equ TCA_SPLIT_LCMP1_bp = 5              ; Low Compare 1 Interrupt Enable bit position\n.equ TCA_SPLIT_LCMP2_bm = 0x40           ; Low Compare 2 Interrupt Enable bit mask\n.equ TCA_SPLIT_LCMP2_bp = 6              ; Low Compare 2 Interrupt Enable bit position\n.equ TCA_SPLIT_LUNF_bm = 0x01            ; Low Underflow Interrupt Enable bit mask\n.equ TCA_SPLIT_LUNF_bp = 0               ; Low Underflow Interrupt Enable bit position\n\n; TCA_SPLIT_INTFLAGS masks\n; Masks for TCA_SPLIT_HUNF already defined\n; Masks for TCA_SPLIT_LCMP0 already defined\n; Masks for TCA_SPLIT_LCMP1 already defined\n; Masks for TCA_SPLIT_LCMP2 already defined\n; Masks for TCA_SPLIT_LUNF already defined\n\n; Clock Selection select\n.equ TCA_SINGLE_CLKSEL_DIV1_gc = (0x00<<1) ; System Clock\n.equ TCA_SINGLE_CLKSEL_DIV2_gc = (0x01<<1) ; System Clock / 2\n.equ TCA_SINGLE_CLKSEL_DIV4_gc = (0x02<<1) ; System Clock / 4\n.equ TCA_SINGLE_CLKSEL_DIV8_gc = (0x03<<1) ; System Clock / 8\n.equ TCA_SINGLE_CLKSEL_DIV16_gc = (0x04<<1) ; System Clock / 16\n.equ TCA_SINGLE_CLKSEL_DIV64_gc = (0x05<<1) ; System Clock / 64\n.equ TCA_SINGLE_CLKSEL_DIV256_gc = (0x06<<1) ; System Clock / 256\n.equ TCA_SINGLE_CLKSEL_DIV1024_gc = (0x07<<1) ; System Clock / 1024\n\n; Waveform generation mode select\n.equ TCA_SINGLE_WGMODE_NORMAL_gc = (0x00<<0) ; Normal Mode\n.equ TCA_SINGLE_WGMODE_FRQ_gc = (0x01<<0) ; Frequency Generation Mode\n.equ TCA_SINGLE_WGMODE_SINGLESLOPE_gc = (0x03<<0) ; Single Slope PWM\n.equ TCA_SINGLE_WGMODE_DSTOP_gc = (0x05<<0) ; Dual Slope PWM, overflow on TOP\n.equ TCA_SINGLE_WGMODE_DSBOTH_gc = (0x06<<0) ; Dual Slope PWM, overflow on TOP and BOTTOM\n.equ TCA_SINGLE_WGMODE_DSBOTTOM_gc = (0x07<<0) ; Dual Slope PWM, overflow on BOTTOM\n\n; Command select\n.equ TCA_SINGLE_CMD_NONE_gc = (0x00<<2)  ; No Command\n.equ TCA_SINGLE_CMD_UPDATE_gc = (0x01<<2) ; Force Update\n.equ TCA_SINGLE_CMD_RESTART_gc = (0x02<<2) ; Force Restart\n.equ TCA_SINGLE_CMD_RESET_gc = (0x03<<2) ; Force Hard Reset\n\n; Direction select\n.equ TCA_SINGLE_DIR_UP_gc = (0x00<<0)    ; Count up\n.equ TCA_SINGLE_DIR_DOWN_gc = (0x01<<0)  ; Count down\n\n; Event Action select\n.equ TCA_SINGLE_EVACT_POSEDGE_gc = (0x00<<1) ; Count on positive edge event\n.equ TCA_SINGLE_EVACT_ANYEDGE_gc = (0x01<<1) ; Count on any edge event\n.equ TCA_SINGLE_EVACT_HIGHLVL_gc = (0x02<<1) ; Count on prescaled clock while event line is 1.\n.equ TCA_SINGLE_EVACT_UPDOWN_gc = (0x03<<1) ; Count on prescaled clock. Event controls count direction. Up-count when event line is 0, down-count when event line is 1.\n\n; Clock Selection select\n.equ TCA_SPLIT_CLKSEL_DIV1_gc = (0x00<<1) ; System Clock\n.equ TCA_SPLIT_CLKSEL_DIV2_gc = (0x01<<1) ; System Clock / 2\n.equ TCA_SPLIT_CLKSEL_DIV4_gc = (0x02<<1) ; System Clock / 4\n.equ TCA_SPLIT_CLKSEL_DIV8_gc = (0x03<<1) ; System Clock / 8\n.equ TCA_SPLIT_CLKSEL_DIV16_gc = (0x04<<1) ; System Clock / 16\n.equ TCA_SPLIT_CLKSEL_DIV64_gc = (0x05<<1) ; System Clock / 64\n.equ TCA_SPLIT_CLKSEL_DIV256_gc = (0x06<<1) ; System Clock / 256\n.equ TCA_SPLIT_CLKSEL_DIV1024_gc = (0x07<<1) ; System Clock / 1024\n\n; Command select\n.equ TCA_SPLIT_CMD_NONE_gc = (0x00<<2)   ; No Command\n.equ TCA_SPLIT_CMD_UPDATE_gc = (0x01<<2) ; Force Update\n.equ TCA_SPLIT_CMD_RESTART_gc = (0x02<<2) ; Force Restart\n.equ TCA_SPLIT_CMD_RESET_gc = (0x03<<2)  ; Force Hard Reset\n\n\n;*************************************************************************\n;** TCB - 16-bit Timer Type B\n;*************************************************************************\n\n; TCB_CTRLA masks\n.equ TCB_CLKSEL_gm = 0x06                ; Clock Select group mask\n.equ TCB_CLKSEL_gp = 1                   ; Clock Select group position\n.equ TCB_CLKSEL0_bm = (1<<1)             ; Clock Select bit 0 mask\n.equ TCB_CLKSEL0_bp = 1                  ; Clock Select bit 0 position\n.equ TCB_CLKSEL1_bm = (1<<2)             ; Clock Select bit 1 mask\n.equ TCB_CLKSEL1_bp = 2                  ; Clock Select bit 1 position\n.equ TCB_ENABLE_bm = 0x01                ; Enable bit mask\n.equ TCB_ENABLE_bp = 0                   ; Enable bit position\n.equ TCB_RUNSTDBY_bm = 0x40              ; Run Standby bit mask\n.equ TCB_RUNSTDBY_bp = 6                 ; Run Standby bit position\n.equ TCB_SYNCUPD_bm = 0x10               ; Synchronize Update bit mask\n.equ TCB_SYNCUPD_bp = 4                  ; Synchronize Update bit position\n\n; TCB_CTRLB masks\n.equ TCB_ASYNC_bm = 0x40                 ; Asynchronous Enable bit mask\n.equ TCB_ASYNC_bp = 6                    ; Asynchronous Enable bit position\n.equ TCB_CCMPEN_bm = 0x10                ; Pin Output Enable bit mask\n.equ TCB_CCMPEN_bp = 4                   ; Pin Output Enable bit position\n.equ TCB_CCMPINIT_bm = 0x20              ; Pin Initial State bit mask\n.equ TCB_CCMPINIT_bp = 5                 ; Pin Initial State bit position\n.equ TCB_CNTMODE_gm = 0x07               ; Timer Mode group mask\n.equ TCB_CNTMODE_gp = 0                  ; Timer Mode group position\n.equ TCB_CNTMODE0_bm = (1<<0)            ; Timer Mode bit 0 mask\n.equ TCB_CNTMODE0_bp = 0                 ; Timer Mode bit 0 position\n.equ TCB_CNTMODE1_bm = (1<<1)            ; Timer Mode bit 1 mask\n.equ TCB_CNTMODE1_bp = 1                 ; Timer Mode bit 1 position\n.equ TCB_CNTMODE2_bm = (1<<2)            ; Timer Mode bit 2 mask\n.equ TCB_CNTMODE2_bp = 2                 ; Timer Mode bit 2 position\n\n; TCB_DBGCTRL masks\n.equ TCB_DBGRUN_bm = 0x01                ; Debug Run bit mask\n.equ TCB_DBGRUN_bp = 0                   ; Debug Run bit position\n\n; TCB_EVCTRL masks\n.equ TCB_CAPTEI_bm = 0x01                ; Event Input Enable bit mask\n.equ TCB_CAPTEI_bp = 0                   ; Event Input Enable bit position\n.equ TCB_EDGE_bm = 0x10                  ; Event Edge bit mask\n.equ TCB_EDGE_bp = 4                     ; Event Edge bit position\n.equ TCB_FILTER_bm = 0x40                ; Input Capture Noise Cancellation Filter bit mask\n.equ TCB_FILTER_bp = 6                   ; Input Capture Noise Cancellation Filter bit position\n\n; TCB_INTCTRL masks\n.equ TCB_CAPT_bm = 0x01                  ; Capture or Timeout bit mask\n.equ TCB_CAPT_bp = 0                     ; Capture or Timeout bit position\n\n; TCB_INTFLAGS masks\n; Masks for TCB_CAPT already defined\n\n; TCB_STATUS masks\n.equ TCB_RUN_bm = 0x01                   ; Run bit mask\n.equ TCB_RUN_bp = 0                      ; Run bit position\n\n; Clock Select select\n.equ TCB_CLKSEL_CLKDIV1_gc = (0x00<<1)   ; CLK_PER (No Prescaling)\n.equ TCB_CLKSEL_CLKDIV2_gc = (0x01<<1)   ; CLK_PER/2 (From Prescaler)\n.equ TCB_CLKSEL_CLKTCA_gc = (0x02<<1)    ; Use Clock from TCA\n\n; Timer Mode select\n.equ TCB_CNTMODE_INT_gc = (0x00<<0)      ; Periodic Interrupt\n.equ TCB_CNTMODE_TIMEOUT_gc = (0x01<<0)  ; Periodic Timeout\n.equ TCB_CNTMODE_CAPT_gc = (0x02<<0)     ; Input Capture Event\n.equ TCB_CNTMODE_FRQ_gc = (0x03<<0)      ; Input Capture Frequency measurement\n.equ TCB_CNTMODE_PW_gc = (0x04<<0)       ; Input Capture Pulse-Width measurement\n.equ TCB_CNTMODE_FRQPW_gc = (0x05<<0)    ; Input Capture Frequency and Pulse-Width measurement\n.equ TCB_CNTMODE_SINGLE_gc = (0x06<<0)   ; Single Shot\n.equ TCB_CNTMODE_PWM8_gc = (0x07<<0)     ; 8-bit PWM\n\n\n;*************************************************************************\n;** TWI - Two-Wire Interface\n;*************************************************************************\n\n; TWI_CTRLA masks\n.equ TWI_FMPEN_bm = 0x02                 ; FM Plus Enable bit mask\n.equ TWI_FMPEN_bp = 1                    ; FM Plus Enable bit position\n.equ TWI_SDAHOLD_gm = 0x0C               ; SDA Hold Time group mask\n.equ TWI_SDAHOLD_gp = 2                  ; SDA Hold Time group position\n.equ TWI_SDAHOLD0_bm = (1<<2)            ; SDA Hold Time bit 0 mask\n.equ TWI_SDAHOLD0_bp = 2                 ; SDA Hold Time bit 0 position\n.equ TWI_SDAHOLD1_bm = (1<<3)            ; SDA Hold Time bit 1 mask\n.equ TWI_SDAHOLD1_bp = 3                 ; SDA Hold Time bit 1 position\n.equ TWI_SDASETUP_bm = 0x10              ; SDA Setup Time bit mask\n.equ TWI_SDASETUP_bp = 4                 ; SDA Setup Time bit position\n\n; TWI_DBGCTRL masks\n.equ TWI_DBGRUN_bm = 0x01                ; Debug Run bit mask\n.equ TWI_DBGRUN_bp = 0                   ; Debug Run bit position\n\n; TWI_MCTRLA masks\n.equ TWI_ENABLE_bm = 0x01                ; Enable TWI Master bit mask\n.equ TWI_ENABLE_bp = 0                   ; Enable TWI Master bit position\n.equ TWI_QCEN_bm = 0x10                  ; Quick Command Enable bit mask\n.equ TWI_QCEN_bp = 4                     ; Quick Command Enable bit position\n.equ TWI_RIEN_bm = 0x80                  ; Read Interrupt Enable bit mask\n.equ TWI_RIEN_bp = 7                     ; Read Interrupt Enable bit position\n.equ TWI_SMEN_bm = 0x02                  ; Smart Mode Enable bit mask\n.equ TWI_SMEN_bp = 1                     ; Smart Mode Enable bit position\n.equ TWI_TIMEOUT_gm = 0x0C               ; Inactive Bus Timeout group mask\n.equ TWI_TIMEOUT_gp = 2                  ; Inactive Bus Timeout group position\n.equ TWI_TIMEOUT0_bm = (1<<2)            ; Inactive Bus Timeout bit 0 mask\n.equ TWI_TIMEOUT0_bp = 2                 ; Inactive Bus Timeout bit 0 position\n.equ TWI_TIMEOUT1_bm = (1<<3)            ; Inactive Bus Timeout bit 1 mask\n.equ TWI_TIMEOUT1_bp = 3                 ; Inactive Bus Timeout bit 1 position\n.equ TWI_WIEN_bm = 0x40                  ; Write Interrupt Enable bit mask\n.equ TWI_WIEN_bp = 6                     ; Write Interrupt Enable bit position\n\n; TWI_MCTRLB masks\n.equ TWI_ACKACT_bm = 0x04                ; Acknowledge Action bit mask\n.equ TWI_ACKACT_bp = 2                   ; Acknowledge Action bit position\n.equ TWI_FLUSH_bm = 0x08                 ; Flush bit mask\n.equ TWI_FLUSH_bp = 3                    ; Flush bit position\n.equ TWI_MCMD_gm = 0x03                  ; Command group mask\n.equ TWI_MCMD_gp = 0                     ; Command group position\n.equ TWI_MCMD0_bm = (1<<0)               ; Command bit 0 mask\n.equ TWI_MCMD0_bp = 0                    ; Command bit 0 position\n.equ TWI_MCMD1_bm = (1<<1)               ; Command bit 1 mask\n.equ TWI_MCMD1_bp = 1                    ; Command bit 1 position\n\n; TWI_MSTATUS masks\n.equ TWI_ARBLOST_bm = 0x08               ; Arbitration Lost bit mask\n.equ TWI_ARBLOST_bp = 3                  ; Arbitration Lost bit position\n.equ TWI_BUSERR_bm = 0x04                ; Bus Error bit mask\n.equ TWI_BUSERR_bp = 2                   ; Bus Error bit position\n.equ TWI_BUSSTATE_gm = 0x03              ; Bus State group mask\n.equ TWI_BUSSTATE_gp = 0                 ; Bus State group position\n.equ TWI_BUSSTATE0_bm = (1<<0)           ; Bus State bit 0 mask\n.equ TWI_BUSSTATE0_bp = 0                ; Bus State bit 0 position\n.equ TWI_BUSSTATE1_bm = (1<<1)           ; Bus State bit 1 mask\n.equ TWI_BUSSTATE1_bp = 1                ; Bus State bit 1 position\n.equ TWI_CLKHOLD_bm = 0x20               ; Clock Hold bit mask\n.equ TWI_CLKHOLD_bp = 5                  ; Clock Hold bit position\n.equ TWI_RIF_bm = 0x80                   ; Read Interrupt Flag bit mask\n.equ TWI_RIF_bp = 7                      ; Read Interrupt Flag bit position\n.equ TWI_RXACK_bm = 0x10                 ; Received Acknowledge bit mask\n.equ TWI_RXACK_bp = 4                    ; Received Acknowledge bit position\n.equ TWI_WIF_bm = 0x40                   ; Write Interrupt Flag bit mask\n.equ TWI_WIF_bp = 6                      ; Write Interrupt Flag bit position\n\n; TWI_SADDRMASK masks\n.equ TWI_ADDREN_bm = 0x01                ; Address Enable bit mask\n.equ TWI_ADDREN_bp = 0                   ; Address Enable bit position\n.equ TWI_ADDRMASK_gm = 0xFE              ; Address Mask group mask\n.equ TWI_ADDRMASK_gp = 1                 ; Address Mask group position\n.equ TWI_ADDRMASK0_bm = (1<<1)           ; Address Mask bit 0 mask\n.equ TWI_ADDRMASK0_bp = 1                ; Address Mask bit 0 position\n.equ TWI_ADDRMASK1_bm = (1<<2)           ; Address Mask bit 1 mask\n.equ TWI_ADDRMASK1_bp = 2                ; Address Mask bit 1 position\n.equ TWI_ADDRMASK2_bm = (1<<3)           ; Address Mask bit 2 mask\n.equ TWI_ADDRMASK2_bp = 3                ; Address Mask bit 2 position\n.equ TWI_ADDRMASK3_bm = (1<<4)           ; Address Mask bit 3 mask\n.equ TWI_ADDRMASK3_bp = 4                ; Address Mask bit 3 position\n.equ TWI_ADDRMASK4_bm = (1<<5)           ; Address Mask bit 4 mask\n.equ TWI_ADDRMASK4_bp = 5                ; Address Mask bit 4 position\n.equ TWI_ADDRMASK5_bm = (1<<6)           ; Address Mask bit 5 mask\n.equ TWI_ADDRMASK5_bp = 6                ; Address Mask bit 5 position\n.equ TWI_ADDRMASK6_bm = (1<<7)           ; Address Mask bit 6 mask\n.equ TWI_ADDRMASK6_bp = 7                ; Address Mask bit 6 position\n\n; TWI_SCTRLA masks\n.equ TWI_APIEN_bm = 0x40                 ; Address/Stop Interrupt Enable bit mask\n.equ TWI_APIEN_bp = 6                    ; Address/Stop Interrupt Enable bit position\n.equ TWI_DIEN_bm = 0x80                  ; Data Interrupt Enable bit mask\n.equ TWI_DIEN_bp = 7                     ; Data Interrupt Enable bit position\n; Masks for TWI_ENABLE already defined\n.equ TWI_PIEN_bm = 0x20                  ; Stop Interrupt Enable bit mask\n.equ TWI_PIEN_bp = 5                     ; Stop Interrupt Enable bit position\n.equ TWI_PMEN_bm = 0x04                  ; Promiscuous Mode Enable bit mask\n.equ TWI_PMEN_bp = 2                     ; Promiscuous Mode Enable bit position\n; Masks for TWI_SMEN already defined\n\n; TWI_SCTRLB masks\n; Masks for TWI_ACKACT already defined\n.equ TWI_SCMD_gm = 0x03                  ; Command group mask\n.equ TWI_SCMD_gp = 0                     ; Command group position\n.equ TWI_SCMD0_bm = (1<<0)               ; Command bit 0 mask\n.equ TWI_SCMD0_bp = 0                    ; Command bit 0 position\n.equ TWI_SCMD1_bm = (1<<1)               ; Command bit 1 mask\n.equ TWI_SCMD1_bp = 1                    ; Command bit 1 position\n\n; TWI_SSTATUS masks\n.equ TWI_AP_bm = 0x01                    ; Slave Address or Stop bit mask\n.equ TWI_AP_bp = 0                       ; Slave Address or Stop bit position\n.equ TWI_APIF_bm = 0x40                  ; Address/Stop Interrupt Flag bit mask\n.equ TWI_APIF_bp = 6                     ; Address/Stop Interrupt Flag bit position\n; Masks for TWI_BUSERR already defined\n; Masks for TWI_CLKHOLD already defined\n.equ TWI_COLL_bm = 0x08                  ; Collision bit mask\n.equ TWI_COLL_bp = 3                     ; Collision bit position\n.equ TWI_DIF_bm = 0x80                   ; Data Interrupt Flag bit mask\n.equ TWI_DIF_bp = 7                      ; Data Interrupt Flag bit position\n.equ TWI_DIR_bm = 0x02                   ; Read/Write Direction bit mask\n.equ TWI_DIR_bp = 1                      ; Read/Write Direction bit position\n; Masks for TWI_RXACK already defined\n\n; SDA Hold Time select\n.equ TWI_SDAHOLD_OFF_gc = (0x00<<2)      ; SDA hold time off\n.equ TWI_SDAHOLD_50NS_gc = (0x01<<2)     ; Typical 50ns hold time\n.equ TWI_SDAHOLD_300NS_gc = (0x02<<2)    ; Typical 300ns hold time\n.equ TWI_SDAHOLD_500NS_gc = (0x03<<2)    ; Typical 500ns hold time\n\n; SDA Setup Time select\n.equ TWI_SDASETUP_4CYC_gc = (0x00<<4)    ; SDA setup time is 4 clock cycles\n.equ TWI_SDASETUP_8CYC_gc = (0x01<<4)    ; SDA setup time is 8 clock cycles\n\n; Inactive Bus Timeout select\n.equ TWI_TIMEOUT_DISABLED_gc = (0x00<<2) ; Bus Timeout Disabled\n.equ TWI_TIMEOUT_50US_gc = (0x01<<2)     ; 50 Microseconds\n.equ TWI_TIMEOUT_100US_gc = (0x02<<2)    ; 100 Microseconds\n.equ TWI_TIMEOUT_200US_gc = (0x03<<2)    ; 200 Microseconds\n\n; Acknowledge Action select\n.equ TWI_ACKACT_ACK_gc = (0x00<<2)       ; Send ACK\n.equ TWI_ACKACT_NACK_gc = (0x01<<2)      ; Send NACK\n\n; Command select\n.equ TWI_MCMD_NOACT_gc = (0x00<<0)       ; No Action\n.equ TWI_MCMD_REPSTART_gc = (0x01<<0)    ; Issue Repeated Start Condition\n.equ TWI_MCMD_RECVTRANS_gc = (0x02<<0)   ; Receive or Transmit Data, depending on DIR\n.equ TWI_MCMD_STOP_gc = (0x03<<0)        ; Issue Stop Condition\n\n; Bus State select\n.equ TWI_BUSSTATE_UNKNOWN_gc = (0x00<<0) ; Unknown Bus State\n.equ TWI_BUSSTATE_IDLE_gc = (0x01<<0)    ; Bus is Idle\n.equ TWI_BUSSTATE_OWNER_gc = (0x02<<0)   ; This Module Controls The Bus\n.equ TWI_BUSSTATE_BUSY_gc = (0x03<<0)    ; The Bus is Busy\n\n; Command select\n.equ TWI_SCMD_NOACT_gc = (0x00<<0)       ; No Action\n.equ TWI_SCMD_COMPTRANS_gc = (0x02<<0)   ; Used To Complete a Transaction\n.equ TWI_SCMD_RESPONSE_gc = (0x03<<0)    ; Used in Response to Address/Data Interrupt\n\n; Slave Address or Stop select\n.equ TWI_AP_STOP_gc = (0x00<<0)          ; Stop condition generated APIF\n.equ TWI_AP_ADR_gc = (0x01<<0)           ; Address detection generated APIF\n\n\n;*************************************************************************\n;** USART - Universal Synchronous and Asynchronous Receiver and Transmitter\n;*************************************************************************\n\n; USART_CTRLA masks\n.equ USART_ABEIE_bm = 0x04               ; Auto-baud Error Interrupt Enable bit mask\n.equ USART_ABEIE_bp = 2                  ; Auto-baud Error Interrupt Enable bit position\n.equ USART_DREIE_bm = 0x20               ; Data Register Empty Interrupt Enable bit mask\n.equ USART_DREIE_bp = 5                  ; Data Register Empty Interrupt Enable bit position\n.equ USART_LBME_bm = 0x08                ; Loop-back Mode Enable bit mask\n.equ USART_LBME_bp = 3                   ; Loop-back Mode Enable bit position\n.equ USART_RS485_gm = 0x03               ; RS485 Mode internal transmitter group mask\n.equ USART_RS485_gp = 0                  ; RS485 Mode internal transmitter group position\n.equ USART_RS4850_bm = (1<<0)            ; RS485 Mode internal transmitter bit 0 mask\n.equ USART_RS4850_bp = 0                 ; RS485 Mode internal transmitter bit 0 position\n.equ USART_RS4851_bm = (1<<1)            ; RS485 Mode internal transmitter bit 1 mask\n.equ USART_RS4851_bp = 1                 ; RS485 Mode internal transmitter bit 1 position\n.equ USART_RXCIE_bm = 0x80               ; Receive Complete Interrupt Enable bit mask\n.equ USART_RXCIE_bp = 7                  ; Receive Complete Interrupt Enable bit position\n.equ USART_RXSIE_bm = 0x10               ; Receiver Start Frame Interrupt Enable bit mask\n.equ USART_RXSIE_bp = 4                  ; Receiver Start Frame Interrupt Enable bit position\n.equ USART_TXCIE_bm = 0x40               ; Transmit Complete Interrupt Enable bit mask\n.equ USART_TXCIE_bp = 6                  ; Transmit Complete Interrupt Enable bit position\n\n; USART_CTRLB masks\n.equ USART_MPCM_bm = 0x01                ; Multi-processor Communication Mode bit mask\n.equ USART_MPCM_bp = 0                   ; Multi-processor Communication Mode bit position\n.equ USART_ODME_bm = 0x08                ; Open Drain Mode Enable bit mask\n.equ USART_ODME_bp = 3                   ; Open Drain Mode Enable bit position\n.equ USART_RXEN_bm = 0x80                ; Reciever enable bit mask\n.equ USART_RXEN_bp = 7                   ; Reciever enable bit position\n.equ USART_RXMODE_gm = 0x06              ; Receiver Mode group mask\n.equ USART_RXMODE_gp = 1                 ; Receiver Mode group position\n.equ USART_RXMODE0_bm = (1<<1)           ; Receiver Mode bit 0 mask\n.equ USART_RXMODE0_bp = 1                ; Receiver Mode bit 0 position\n.equ USART_RXMODE1_bm = (1<<2)           ; Receiver Mode bit 1 mask\n.equ USART_RXMODE1_bp = 2                ; Receiver Mode bit 1 position\n.equ USART_SFDEN_bm = 0x10               ; Start Frame Detection Enable bit mask\n.equ USART_SFDEN_bp = 4                  ; Start Frame Detection Enable bit position\n.equ USART_TXEN_bm = 0x40                ; Transmitter Enable bit mask\n.equ USART_TXEN_bp = 6                   ; Transmitter Enable bit position\n\n; USART_CTRLC masks\n.equ USART_CMODE_gm = 0xC0               ; Communication Mode group mask\n.equ USART_CMODE_gp = 6                  ; Communication Mode group position\n.equ USART_CMODE0_bm = (1<<6)            ; Communication Mode bit 0 mask\n.equ USART_CMODE0_bp = 6                 ; Communication Mode bit 0 position\n.equ USART_CMODE1_bm = (1<<7)            ; Communication Mode bit 1 mask\n.equ USART_CMODE1_bp = 7                 ; Communication Mode bit 1 position\n.equ USART_UCPHA_bm = 0x02               ; SPI Master Mode, Clock Phase bit mask\n.equ USART_UCPHA_bp = 1                  ; SPI Master Mode, Clock Phase bit position\n.equ USART_UDORD_bm = 0x04               ; SPI Master Mode, Data Order bit mask\n.equ USART_UDORD_bp = 2                  ; SPI Master Mode, Data Order bit position\n.equ USART_CHSIZE_gm = 0x07              ; Character Size group mask\n.equ USART_CHSIZE_gp = 0                 ; Character Size group position\n.equ USART_CHSIZE0_bm = (1<<0)           ; Character Size bit 0 mask\n.equ USART_CHSIZE0_bp = 0                ; Character Size bit 0 position\n.equ USART_CHSIZE1_bm = (1<<1)           ; Character Size bit 1 mask\n.equ USART_CHSIZE1_bp = 1                ; Character Size bit 1 position\n.equ USART_CHSIZE2_bm = (1<<2)           ; Character Size bit 2 mask\n.equ USART_CHSIZE2_bp = 2                ; Character Size bit 2 position\n; Masks for USART_CMODE already defined\n.equ USART_PMODE_gm = 0x30               ; Parity Mode group mask\n.equ USART_PMODE_gp = 4                  ; Parity Mode group position\n.equ USART_PMODE0_bm = (1<<4)            ; Parity Mode bit 0 mask\n.equ USART_PMODE0_bp = 4                 ; Parity Mode bit 0 position\n.equ USART_PMODE1_bm = (1<<5)            ; Parity Mode bit 1 mask\n.equ USART_PMODE1_bp = 5                 ; Parity Mode bit 1 position\n.equ USART_SBMODE_bm = 0x08              ; Stop Bit Mode bit mask\n.equ USART_SBMODE_bp = 3                 ; Stop Bit Mode bit position\n\n; USART_DBGCTRL masks\n.equ USART_DBGRUN_bm = 0x01              ; Debug Run bit mask\n.equ USART_DBGRUN_bp = 0                 ; Debug Run bit position\n\n; USART_EVCTRL masks\n.equ USART_IREI_bm = 0x01                ; IrDA Event Input Enable bit mask\n.equ USART_IREI_bp = 0                   ; IrDA Event Input Enable bit position\n\n; USART_RXDATAH masks\n.equ USART_BUFOVF_bm = 0x40              ; Buffer Overflow bit mask\n.equ USART_BUFOVF_bp = 6                 ; Buffer Overflow bit position\n.equ USART_DATA8_bm = 0x01               ; Receiver Data Register bit mask\n.equ USART_DATA8_bp = 0                  ; Receiver Data Register bit position\n.equ USART_FERR_bm = 0x04                ; Frame Error bit mask\n.equ USART_FERR_bp = 2                   ; Frame Error bit position\n.equ USART_PERR_bm = 0x02                ; Parity Error bit mask\n.equ USART_PERR_bp = 1                   ; Parity Error bit position\n.equ USART_RXCIF_bm = 0x80               ; Receive Complete Interrupt Flag bit mask\n.equ USART_RXCIF_bp = 7                  ; Receive Complete Interrupt Flag bit position\n\n; USART_RXDATAL masks\n.equ USART_DATA_gm = 0xFF                ; RX Data group mask\n.equ USART_DATA_gp = 0                   ; RX Data group position\n.equ USART_DATA0_bm = (1<<0)             ; RX Data bit 0 mask\n.equ USART_DATA0_bp = 0                  ; RX Data bit 0 position\n.equ USART_DATA1_bm = (1<<1)             ; RX Data bit 1 mask\n.equ USART_DATA1_bp = 1                  ; RX Data bit 1 position\n.equ USART_DATA2_bm = (1<<2)             ; RX Data bit 2 mask\n.equ USART_DATA2_bp = 2                  ; RX Data bit 2 position\n.equ USART_DATA3_bm = (1<<3)             ; RX Data bit 3 mask\n.equ USART_DATA3_bp = 3                  ; RX Data bit 3 position\n.equ USART_DATA4_bm = (1<<4)             ; RX Data bit 4 mask\n.equ USART_DATA4_bp = 4                  ; RX Data bit 4 position\n.equ USART_DATA5_bm = (1<<5)             ; RX Data bit 5 mask\n.equ USART_DATA5_bp = 5                  ; RX Data bit 5 position\n.equ USART_DATA6_bm = (1<<6)             ; RX Data bit 6 mask\n.equ USART_DATA6_bp = 6                  ; RX Data bit 6 position\n.equ USART_DATA7_bm = (1<<7)             ; RX Data bit 7 mask\n.equ USART_DATA7_bp = 7                  ; RX Data bit 7 position\n\n; USART_RXPLCTRL masks\n.equ USART_RXPL_gm = 0x7F                ; Receiver Pulse Lenght group mask\n.equ USART_RXPL_gp = 0                   ; Receiver Pulse Lenght group position\n.equ USART_RXPL0_bm = (1<<0)             ; Receiver Pulse Lenght bit 0 mask\n.equ USART_RXPL0_bp = 0                  ; Receiver Pulse Lenght bit 0 position\n.equ USART_RXPL1_bm = (1<<1)             ; Receiver Pulse Lenght bit 1 mask\n.equ USART_RXPL1_bp = 1                  ; Receiver Pulse Lenght bit 1 position\n.equ USART_RXPL2_bm = (1<<2)             ; Receiver Pulse Lenght bit 2 mask\n.equ USART_RXPL2_bp = 2                  ; Receiver Pulse Lenght bit 2 position\n.equ USART_RXPL3_bm = (1<<3)             ; Receiver Pulse Lenght bit 3 mask\n.equ USART_RXPL3_bp = 3                  ; Receiver Pulse Lenght bit 3 position\n.equ USART_RXPL4_bm = (1<<4)             ; Receiver Pulse Lenght bit 4 mask\n.equ USART_RXPL4_bp = 4                  ; Receiver Pulse Lenght bit 4 position\n.equ USART_RXPL5_bm = (1<<5)             ; Receiver Pulse Lenght bit 5 mask\n.equ USART_RXPL5_bp = 5                  ; Receiver Pulse Lenght bit 5 position\n.equ USART_RXPL6_bm = (1<<6)             ; Receiver Pulse Lenght bit 6 mask\n.equ USART_RXPL6_bp = 6                  ; Receiver Pulse Lenght bit 6 position\n\n; USART_STATUS masks\n.equ USART_BDF_bm = 0x02                 ; Break Detected Flag bit mask\n.equ USART_BDF_bp = 1                    ; Break Detected Flag bit position\n.equ USART_DREIF_bm = 0x20               ; Data Register Empty Flag bit mask\n.equ USART_DREIF_bp = 5                  ; Data Register Empty Flag bit position\n.equ USART_ISFIF_bm = 0x08               ; Inconsistent Sync Field Interrupt Flag bit mask\n.equ USART_ISFIF_bp = 3                  ; Inconsistent Sync Field Interrupt Flag bit position\n; Masks for USART_RXCIF already defined\n.equ USART_RXSIF_bm = 0x10               ; Receive Start Interrupt bit mask\n.equ USART_RXSIF_bp = 4                  ; Receive Start Interrupt bit position\n.equ USART_TXCIF_bm = 0x40               ; Transmit Interrupt Flag bit mask\n.equ USART_TXCIF_bp = 6                  ; Transmit Interrupt Flag bit position\n.equ USART_WFB_bm = 0x01                 ; Wait For Break bit mask\n.equ USART_WFB_bp = 0                    ; Wait For Break bit position\n\n; USART_TXDATAH masks\n; Masks for USART_DATA8 already defined\n\n; USART_TXDATAL masks\n; Masks for USART_DATA already defined\n\n; USART_TXPLCTRL masks\n.equ USART_TXPL_gm = 0xFF                ; Transmit pulse length group mask\n.equ USART_TXPL_gp = 0                   ; Transmit pulse length group position\n.equ USART_TXPL0_bm = (1<<0)             ; Transmit pulse length bit 0 mask\n.equ USART_TXPL0_bp = 0                  ; Transmit pulse length bit 0 position\n.equ USART_TXPL1_bm = (1<<1)             ; Transmit pulse length bit 1 mask\n.equ USART_TXPL1_bp = 1                  ; Transmit pulse length bit 1 position\n.equ USART_TXPL2_bm = (1<<2)             ; Transmit pulse length bit 2 mask\n.equ USART_TXPL2_bp = 2                  ; Transmit pulse length bit 2 position\n.equ USART_TXPL3_bm = (1<<3)             ; Transmit pulse length bit 3 mask\n.equ USART_TXPL3_bp = 3                  ; Transmit pulse length bit 3 position\n.equ USART_TXPL4_bm = (1<<4)             ; Transmit pulse length bit 4 mask\n.equ USART_TXPL4_bp = 4                  ; Transmit pulse length bit 4 position\n.equ USART_TXPL5_bm = (1<<5)             ; Transmit pulse length bit 5 mask\n.equ USART_TXPL5_bp = 5                  ; Transmit pulse length bit 5 position\n.equ USART_TXPL6_bm = (1<<6)             ; Transmit pulse length bit 6 mask\n.equ USART_TXPL6_bp = 6                  ; Transmit pulse length bit 6 position\n.equ USART_TXPL7_bm = (1<<7)             ; Transmit pulse length bit 7 mask\n.equ USART_TXPL7_bp = 7                  ; Transmit pulse length bit 7 position\n\n; RS485 Mode internal transmitter select\n.equ USART_RS485_OFF_gc = (0x00<<0)      ; RS485 Mode disabled\n.equ USART_RS485_EXT_gc = (0x01<<0)      ; RS485 Mode External drive\n.equ USART_RS485_INT_gc = (0x02<<0)      ; RS485 Mode Internal drive\n\n; Receiver Mode select\n.equ USART_RXMODE_NORMAL_gc = (0x00<<1)  ; Normal mode\n.equ USART_RXMODE_CLK2X_gc = (0x01<<1)   ; CLK2x mode\n.equ USART_RXMODE_GENAUTO_gc = (0x02<<1) ; Generic autobaud mode\n.equ USART_RXMODE_LINAUTO_gc = (0x03<<1) ; LIN constrained autobaud mode\n\n; Communication Mode select\n.equ USART_MSPI_CMODE_ASYNCHRONOUS_gc = (0x00<<6) ; Asynchronous Mode\n.equ USART_MSPI_CMODE_SYNCHRONOUS_gc = (0x01<<6) ; Synchronous Mode\n.equ USART_MSPI_CMODE_IRCOM_gc = (0x02<<6) ; Infrared Communication\n.equ USART_MSPI_CMODE_MSPI_gc = (0x03<<6) ; Master SPI Mode\n\n; Character Size select\n.equ USART_NORMAL_CHSIZE_5BIT_gc = (0x00<<0) ; Character size: 5 bit\n.equ USART_NORMAL_CHSIZE_6BIT_gc = (0x01<<0) ; Character size: 6 bit\n.equ USART_NORMAL_CHSIZE_7BIT_gc = (0x02<<0) ; Character size: 7 bit\n.equ USART_NORMAL_CHSIZE_8BIT_gc = (0x03<<0) ; Character size: 8 bit\n.equ USART_NORMAL_CHSIZE_9BITL_gc = (0x06<<0) ; Character size: 9 bit read low byte first\n.equ USART_NORMAL_CHSIZE_9BITH_gc = (0x07<<0) ; Character size: 9 bit read high byte first\n\n; Communication Mode select\n.equ USART_NORMAL_CMODE_ASYNCHRONOUS_gc = (0x00<<6) ; Asynchronous Mode\n.equ USART_NORMAL_CMODE_SYNCHRONOUS_gc = (0x01<<6) ; Synchronous Mode\n.equ USART_NORMAL_CMODE_IRCOM_gc = (0x02<<6) ; Infrared Communication\n.equ USART_NORMAL_CMODE_MSPI_gc = (0x03<<6) ; Master SPI Mode\n\n; Parity Mode select\n.equ USART_NORMAL_PMODE_DISABLED_gc = (0x00<<4) ; No Parity\n.equ USART_NORMAL_PMODE_EVEN_gc = (0x02<<4) ; Even Parity\n.equ USART_NORMAL_PMODE_ODD_gc = (0x03<<4) ; Odd Parity\n\n; Stop Bit Mode select\n.equ USART_NORMAL_SBMODE_1BIT_gc = (0x00<<3) ; 1 stop bit\n.equ USART_NORMAL_SBMODE_2BIT_gc = (0x01<<3) ; 2 stop bits\n\n\n;*************************************************************************\n;** USERROW - User Row\n;*************************************************************************\n\n\n;*************************************************************************\n;** VPORT - Virtual Ports\n;*************************************************************************\n\n; VPORT_INTFLAGS masks\n.equ VPORT_INT_gm = 0xFF                 ; Pin Interrupt group mask\n.equ VPORT_INT_gp = 0                    ; Pin Interrupt group position\n.equ VPORT_INT0_bm = (1<<0)              ; Pin Interrupt bit 0 mask\n.equ VPORT_INT0_bp = 0                   ; Pin Interrupt bit 0 position\n.equ VPORT_INT1_bm = (1<<1)              ; Pin Interrupt bit 1 mask\n.equ VPORT_INT1_bp = 1                   ; Pin Interrupt bit 1 position\n.equ VPORT_INT2_bm = (1<<2)              ; Pin Interrupt bit 2 mask\n.equ VPORT_INT2_bp = 2                   ; Pin Interrupt bit 2 position\n.equ VPORT_INT3_bm = (1<<3)              ; Pin Interrupt bit 3 mask\n.equ VPORT_INT3_bp = 3                   ; Pin Interrupt bit 3 position\n.equ VPORT_INT4_bm = (1<<4)              ; Pin Interrupt bit 4 mask\n.equ VPORT_INT4_bp = 4                   ; Pin Interrupt bit 4 position\n.equ VPORT_INT5_bm = (1<<5)              ; Pin Interrupt bit 5 mask\n.equ VPORT_INT5_bp = 5                   ; Pin Interrupt bit 5 position\n.equ VPORT_INT6_bm = (1<<6)              ; Pin Interrupt bit 6 mask\n.equ VPORT_INT6_bp = 6                   ; Pin Interrupt bit 6 position\n.equ VPORT_INT7_bm = (1<<7)              ; Pin Interrupt bit 7 mask\n.equ VPORT_INT7_bp = 7                   ; Pin Interrupt bit 7 position\n\n\n;*************************************************************************\n;** VREF - Voltage reference\n;*************************************************************************\n\n; VREF_CTRLA masks\n.equ VREF_ADC0REFSEL_gm = 0x70           ; ADC0 reference select group mask\n.equ VREF_ADC0REFSEL_gp = 4              ; ADC0 reference select group position\n.equ VREF_ADC0REFSEL0_bm = (1<<4)        ; ADC0 reference select bit 0 mask\n.equ VREF_ADC0REFSEL0_bp = 4             ; ADC0 reference select bit 0 position\n.equ VREF_ADC0REFSEL1_bm = (1<<5)        ; ADC0 reference select bit 1 mask\n.equ VREF_ADC0REFSEL1_bp = 5             ; ADC0 reference select bit 1 position\n.equ VREF_ADC0REFSEL2_bm = (1<<6)        ; ADC0 reference select bit 2 mask\n.equ VREF_ADC0REFSEL2_bp = 6             ; ADC0 reference select bit 2 position\n.equ VREF_DAC0REFSEL_gm = 0x07           ; DAC0/AC0 reference select group mask\n.equ VREF_DAC0REFSEL_gp = 0              ; DAC0/AC0 reference select group position\n.equ VREF_DAC0REFSEL0_bm = (1<<0)        ; DAC0/AC0 reference select bit 0 mask\n.equ VREF_DAC0REFSEL0_bp = 0             ; DAC0/AC0 reference select bit 0 position\n.equ VREF_DAC0REFSEL1_bm = (1<<1)        ; DAC0/AC0 reference select bit 1 mask\n.equ VREF_DAC0REFSEL1_bp = 1             ; DAC0/AC0 reference select bit 1 position\n.equ VREF_DAC0REFSEL2_bm = (1<<2)        ; DAC0/AC0 reference select bit 2 mask\n.equ VREF_DAC0REFSEL2_bp = 2             ; DAC0/AC0 reference select bit 2 position\n\n; VREF_CTRLB masks\n.equ VREF_ADC0REFEN_bm = 0x02            ; ADC0 reference enable bit mask\n.equ VREF_ADC0REFEN_bp = 1               ; ADC0 reference enable bit position\n.equ VREF_DAC0REFEN_bm = 0x01            ; DAC0/AC0 reference enable bit mask\n.equ VREF_DAC0REFEN_bp = 0               ; DAC0/AC0 reference enable bit position\n\n; ADC0 reference select select\n.equ VREF_ADC0REFSEL_0V55_gc = (0x00<<4) ; Voltage reference at 0.55V\n.equ VREF_ADC0REFSEL_1V1_gc = (0x01<<4)  ; Voltage reference at 1.1V\n.equ VREF_ADC0REFSEL_2V5_gc = (0x02<<4)  ; Voltage reference at 2.5V\n.equ VREF_ADC0REFSEL_4V34_gc = (0x03<<4) ; Voltage reference at 4.34V\n.equ VREF_ADC0REFSEL_1V5_gc = (0x04<<4)  ; Voltage reference at 1.5V\n\n; DAC0/AC0 reference select select\n.equ VREF_DAC0REFSEL_0V55_gc = (0x00<<0) ; Voltage reference at 0.55V\n.equ VREF_DAC0REFSEL_1V1_gc = (0x01<<0)  ; Voltage reference at 1.1V\n.equ VREF_DAC0REFSEL_2V5_gc = (0x02<<0)  ; Voltage reference at 2.5V\n.equ VREF_DAC0REFSEL_4V34_gc = (0x03<<0) ; Voltage reference at 4.34V\n.equ VREF_DAC0REFSEL_1V5_gc = (0x04<<0)  ; Voltage reference at 1.5V\n\n\n;*************************************************************************\n;** WDT - Watch-Dog Timer\n;*************************************************************************\n\n; WDT_CTRLA masks\n.equ WDT_PERIOD_gm = 0x0F                ; Period group mask\n.equ WDT_PERIOD_gp = 0                   ; Period group position\n.equ WDT_PERIOD0_bm = (1<<0)             ; Period bit 0 mask\n.equ WDT_PERIOD0_bp = 0                  ; Period bit 0 position\n.equ WDT_PERIOD1_bm = (1<<1)             ; Period bit 1 mask\n.equ WDT_PERIOD1_bp = 1                  ; Period bit 1 position\n.equ WDT_PERIOD2_bm = (1<<2)             ; Period bit 2 mask\n.equ WDT_PERIOD2_bp = 2                  ; Period bit 2 position\n.equ WDT_PERIOD3_bm = (1<<3)             ; Period bit 3 mask\n.equ WDT_PERIOD3_bp = 3                  ; Period bit 3 position\n.equ WDT_WINDOW_gm = 0xF0                ; Window group mask\n.equ WDT_WINDOW_gp = 4                   ; Window group position\n.equ WDT_WINDOW0_bm = (1<<4)             ; Window bit 0 mask\n.equ WDT_WINDOW0_bp = 4                  ; Window bit 0 position\n.equ WDT_WINDOW1_bm = (1<<5)             ; Window bit 1 mask\n.equ WDT_WINDOW1_bp = 5                  ; Window bit 1 position\n.equ WDT_WINDOW2_bm = (1<<6)             ; Window bit 2 mask\n.equ WDT_WINDOW2_bp = 6                  ; Window bit 2 position\n.equ WDT_WINDOW3_bm = (1<<7)             ; Window bit 3 mask\n.equ WDT_WINDOW3_bp = 7                  ; Window bit 3 position\n\n; WDT_STATUS masks\n.equ WDT_LOCK_bm = 0x80                  ; Lock enable bit mask\n.equ WDT_LOCK_bp = 7                     ; Lock enable bit position\n.equ WDT_SYNCBUSY_bm = 0x01              ; Syncronization busy bit mask\n.equ WDT_SYNCBUSY_bp = 0                 ; Syncronization busy bit position\n\n; Period select\n.equ WDT_PERIOD_OFF_gc = (0x00<<0)       ; Watch-Dog timer Off\n.equ WDT_PERIOD_8CLK_gc = (0x01<<0)      ; 8 cycles (8ms)\n.equ WDT_PERIOD_16CLK_gc = (0x02<<0)     ; 16 cycles (16ms)\n.equ WDT_PERIOD_32CLK_gc = (0x03<<0)     ; 32 cycles (32ms)\n.equ WDT_PERIOD_64CLK_gc = (0x04<<0)     ; 64 cycles (64ms)\n.equ WDT_PERIOD_128CLK_gc = (0x05<<0)    ; 128 cycles (0.128s)\n.equ WDT_PERIOD_256CLK_gc = (0x06<<0)    ; 256 cycles (0.256s)\n.equ WDT_PERIOD_512CLK_gc = (0x07<<0)    ; 512 cycles (0.512s)\n.equ WDT_PERIOD_1KCLK_gc = (0x08<<0)     ; 1K cycles (1.0s)\n.equ WDT_PERIOD_2KCLK_gc = (0x09<<0)     ; 2K cycles (2.0s)\n.equ WDT_PERIOD_4KCLK_gc = (0x0A<<0)     ; 4K cycles (4.1s)\n.equ WDT_PERIOD_8KCLK_gc = (0x0B<<0)     ; 8K cycles (8.2s)\n\n; Window select\n.equ WDT_WINDOW_OFF_gc = (0x00<<4)       ; Window mode off\n.equ WDT_WINDOW_8CLK_gc = (0x01<<4)      ; 8 cycles (8ms)\n.equ WDT_WINDOW_16CLK_gc = (0x02<<4)     ; 16 cycles (16ms)\n.equ WDT_WINDOW_32CLK_gc = (0x03<<4)     ; 32 cycles (32ms)\n.equ WDT_WINDOW_64CLK_gc = (0x04<<4)     ; 64 cycles (64ms)\n.equ WDT_WINDOW_128CLK_gc = (0x05<<4)    ; 128 cycles (0.128s)\n.equ WDT_WINDOW_256CLK_gc = (0x06<<4)    ; 256 cycles (0.256s)\n.equ WDT_WINDOW_512CLK_gc = (0x07<<4)    ; 512 cycles (0.512s)\n.equ WDT_WINDOW_1KCLK_gc = (0x08<<4)     ; 1K cycles (1.0s)\n.equ WDT_WINDOW_2KCLK_gc = (0x09<<4)     ; 2K cycles (2.0s)\n.equ WDT_WINDOW_4KCLK_gc = (0x0A<<4)     ; 4K cycles (4.1s)\n.equ WDT_WINDOW_8KCLK_gc = (0x0B<<4)     ; 8K cycles (8.2s)\n\n\n\n\n; ***** CPU REGISTER DEFINITIONS *****************************************\n.def\tXH\t= r27\n.def\tXL\t= r26\n.def\tYH\t= r29\n.def\tYL\t= r28\n.def\tZH\t= r31\n.def\tZL\t= r30\n\n\n; ***** DATA MEMORY DECLARATIONS *****************************************\n\n\n#define DATAMEM_START 0x0000\n#define DATAMEM_SIZE 0x8800\n#define DATAMEM_END (0x0000 + 0x8800 - 1)\n\n#define EEPROM_START 0x1400\n#define EEPROM_SIZE 0x0040\n#define EEPROM_END (0x1400 + 0x0040 - 1)\n#define EEPROM_PAGE_SIZE 0x20\n\n#define FUSES_START 0x1280\n#define FUSES_SIZE 0x000A\n#define FUSES_END (0x1280 + 0x000A - 1)\n#define FUSES_PAGE_SIZE 0x20\n\n#define INTERNAL_SRAM_START 0x3F80\n#define INTERNAL_SRAM_SIZE 0x0080\n#define INTERNAL_SRAM_END (0x3F80 + 0x0080 - 1)\n\n#define IO_START 0x0000\n#define IO_SIZE 0x1100\n#define IO_END (0x0000 + 0x1100 - 1)\n\n#define LOCKBITS_START 0x128A\n#define LOCKBITS_SIZE 0x0001\n#define LOCKBITS_END (0x128A + 0x0001 - 1)\n#define LOCKBITS_PAGE_SIZE 0x20\n\n#define MAPPED_PROGMEM_START 0x8000\n#define MAPPED_PROGMEM_SIZE 0x0800\n#define MAPPED_PROGMEM_END (0x8000 + 0x0800 - 1)\n#define MAPPED_PROGMEM_PAGE_SIZE 0x40\n\n#define PROD_SIGNATURES_START 0x1103\n#define PROD_SIGNATURES_SIZE 0x003D\n#define PROD_SIGNATURES_END (0x1103 + 0x003D - 1)\n#define PROD_SIGNATURES_PAGE_SIZE 0x40\n\n#define SIGNATURES_START 0x1100\n#define SIGNATURES_SIZE 0x0003\n#define SIGNATURES_END (0x1100 + 0x0003 - 1)\n#define SIGNATURES_PAGE_SIZE 0x40\n\n#define USER_SIGNATURES_START 0x1300\n#define USER_SIGNATURES_SIZE 0x0020\n#define USER_SIGNATURES_END (0x1300 + 0x0020 - 1)\n#define USER_SIGNATURES_PAGE_SIZE 0x20\n\n#define PROGMEM_START 0x0000\n#define PROGMEM_SIZE 0x0800\n#define PROGMEM_END (0x0000 + 0x0800 - 1)\n#define PROGMEM_PAGE_SIZE 0x40\n\n\n; Legacy definitions\n.equ    FLASHSTART    = (PROGMEM_START / 2) ; Note: Word address\n.equ    FLASHEND      = (PROGMEM_END / 2) ; Note: Word address\n.equ    IOEND         = IO_END\n.equ    SRAM_START    = INTERNAL_SRAM_START\n.equ    SRAM_SIZE     = INTERNAL_SRAM_SIZE\n.equ    RAMEND        = INTERNAL_SRAM_END\n.equ    E2END         = EEPROM_END\n.equ    EEPROMEND     = EEPROM_END\n\n\n; Definitions used by the assembler\n#pragma AVRPART MEMORY PROG_FLASH 0x0800\n#pragma AVRPART MEMORY EEPROM 0x0040\n#pragma AVRPART MEMORY INT_SRAM SIZE 0x0080\n#pragma AVRPART MEMORY INT_SRAM START_ADDR 0x3F80\n\n; ***** INTERRUPT VECTORS, ABSOLUTE ADDRESSES ****************************\n\n; CRCSCAN interrupt vectors\n.equ CRCSCAN_NMI_vect = 0x0001           ; \n\n; BOD interrupt vectors\n.equ BOD_VLM_vect = 0x0002               ; \n\n; PORTA interrupt vectors\n.equ PORTA_PORT_vect = 0x0003            ; \n\n; RTC interrupt vectors\n.equ RTC_CNT_vect = 0x0006               ; \n.equ RTC_PIT_vect = 0x0007               ; \n\n; TCA0 interrupt vectors\n.equ TCA0_LUNF_vect = 0x0008             ; \n.equ TCA0_OVF_vect = 0x0008              ; \n.equ TCA0_HUNF_vect = 0x0009             ; \n.equ TCA0_CMP0_vect = 0x000A             ; \n.equ TCA0_LCMP0_vect = 0x000A            ; \n.equ TCA0_CMP1_vect = 0x000B             ; \n.equ TCA0_LCMP1_vect = 0x000B            ; \n.equ TCA0_CMP2_vect = 0x000C             ; \n.equ TCA0_LCMP2_vect = 0x000C            ; \n\n; TCB0 interrupt vectors\n.equ TCB0_INT_vect = 0x000D              ; \n\n; AC0 interrupt vectors\n.equ AC0_AC_vect = 0x0010                ; \n\n; ADC0 interrupt vectors\n.equ ADC0_RESRDY_vect = 0x0011           ; \n.equ ADC0_WCOMP_vect = 0x0012            ; \n\n; TWI0 interrupt vectors\n.equ TWI0_TWIS_vect = 0x0013             ; \n.equ TWI0_TWIM_vect = 0x0014             ; \n\n; SPI0 interrupt vectors\n.equ SPI0_INT_vect = 0x0015              ; \n\n; USART0 interrupt vectors\n.equ USART0_RXC_vect = 0x0016            ; \n.equ USART0_DRE_vect = 0x0017            ; \n.equ USART0_TXC_vect = 0x0018            ; \n\n; NVMCTRL interrupt vectors\n.equ NVMCTRL_EE_vect = 0x0019            ; \n\n\n\n; ***** INTERRUPT VECTORS, MODULE BASES **********************************\n\n.equ CRCSCAN_vbase = 0x0001\n.equ BOD_vbase = 0x0002\n.equ PORTA_vbase = 0x0003\n.equ RTC_vbase = 0x0006\n.equ TCA0_vbase = 0x0008\n.equ TCB0_vbase = 0x000D\n.equ AC0_vbase = 0x0010\n.equ ADC0_vbase = 0x0011\n.equ TWI0_vbase = 0x0013\n.equ SPI0_vbase = 0x0015\n.equ USART0_vbase = 0x0016\n.equ NVMCTRL_vbase = 0x0019\n\n\n; ***** INTERRUPT VECTORS, VECTOR OFFSETS ********************************\n\n; CRCSCAN interrupt vector offsets\n\n.equ CRCSCAN_NMI_voffset = 0\n\n; BOD interrupt vector offsets\n\n.equ BOD_VLM_voffset = 0\n\n; PORTA interrupt vector offsets\n\n.equ PORTA_PORT_voffset = 0\n\n; RTC interrupt vector offsets\n\n.equ RTC_CNT_voffset = 0\n.equ RTC_PIT_voffset = 1\n\n; TCA0 interrupt vector offsets\n\n.equ TCA0_LUNF_voffset = 0\n.equ TCA0_OVF_voffset = 0\n.equ TCA0_HUNF_voffset = 1\n.equ TCA0_CMP0_voffset = 2\n.equ TCA0_LCMP0_voffset = 2\n.equ TCA0_CMP1_voffset = 3\n.equ TCA0_LCMP1_voffset = 3\n.equ TCA0_CMP2_voffset = 4\n.equ TCA0_LCMP2_voffset = 4\n\n; TCB0 interrupt vector offsets\n\n.equ TCB0_INT_voffset = 0\n\n; AC0 interrupt vector offsets\n\n.equ AC0_AC_voffset = 0\n\n; ADC0 interrupt vector offsets\n\n.equ ADC0_RESRDY_voffset = 0\n.equ ADC0_WCOMP_voffset = 1\n\n; TWI0 interrupt vector offsets\n\n.equ TWI0_TWIS_voffset = 0\n.equ TWI0_TWIM_voffset = 1\n\n; SPI0 interrupt vector offsets\n\n.equ SPI0_INT_voffset = 0\n\n; USART0 interrupt vector offsets\n\n.equ USART0_RXC_voffset = 0\n.equ USART0_DRE_voffset = 1\n.equ USART0_TXC_voffset = 2\n\n; NVMCTRL interrupt vector offsets\n\n.equ NVMCTRL_EE_voffset = 0\n\n\n\n.equ INT_VECTORS_SIZE = 26 ; size in words\n\n\n#endif /* _TN202DEF_INC_ */\n\n; ***** END OF FILE ******************************************************\n\n\n\n","inc/tn404def.inc":";***** THIS IS A MACHINE GENERATED FILE - DO NOT EDIT ********************\n\n;*************************************************************************\n;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y\n;*\n;* Number            : AVR000\n;* File Name         : tn404def.inc\n;* Title             : Register/Bit Definitions for the ATtiny404\n;* Created           : 2021-07-13 10:42\n;* Version           : 1.00\n;* Support e-mail    : avr@atmel.com\n;* Target MCU        : ATtiny404\n;*\n;* DESCRIPTION\n;* When including this file in the assembly program file, all I/O register\n;* names and I/O register bit names appearing in the data book can be used.\n;* In addition, the six registers forming the three data pointers X, Y and\n;* Z have been assigned names XL - ZH. Highest RAM address for Internal\n;* SRAM is also defined\n;*\n;*************************************************************************\n\n#ifndef _TN404DEF_INC_\n#define _TN404DEF_INC_\n\n\n#pragma partinc 0\n\n; ***** SPECIFY DEVICE ***************************************************\n.device\tATtiny404\n\n#pragma AVRPART ADMIN PART_NAME ATtiny404\n\n.equ\tSIGNATURE_000\t= 0x1E\n.equ\tSIGNATURE_001\t= 0x92\n.equ\tSIGNATURE_002\t= 0x26\n\n#pragma AVRPART CORE CORE_VERSION V4\n\n\n; ***** ABSOLUTE I/O REGISTER LOCATIONS **********************************\n\n\n;*************************************************************************\n;** AC0 - Analog Comparator\n;*************************************************************************\n\n.equ AC0_CTRLA = 0x0670                  ; Control A\n.equ AC0_MUXCTRLA = 0x0672               ; Mux Control A\n.equ AC0_INTCTRL = 0x0676                ; Interrupt Control\n.equ AC0_STATUS = 0x0677                 ; Status\n\n;*************************************************************************\n;** ADC0 - Analog to Digital Converter\n;*************************************************************************\n\n.equ ADC0_CTRLA = 0x0600                 ; Control A\n.equ ADC0_CTRLB = 0x0601                 ; Control B\n.equ ADC0_CTRLC = 0x0602                 ; Control C\n.equ ADC0_CTRLD = 0x0603                 ; Control D\n.equ ADC0_CTRLE = 0x0604                 ; Control E\n.equ ADC0_SAMPCTRL = 0x0605              ; Sample Control\n.equ ADC0_MUXPOS = 0x0606                ; Positive mux input\n.equ ADC0_COMMAND = 0x0608               ; Command\n.equ ADC0_EVCTRL = 0x0609                ; Event Control\n.equ ADC0_INTCTRL = 0x060A               ; Interrupt Control\n.equ ADC0_INTFLAGS = 0x060B              ; Interrupt Flags\n.equ ADC0_DBGCTRL = 0x060C               ; Debug Control\n.equ ADC0_TEMP = 0x060D                  ; Temporary Data\n.equ ADC0_RES = 0x0610                   ; ADC Accumulator Result\n.equ ADC0_RESL = 0x0610                  ; ADC Accumulator Result low byte\n.equ ADC0_RESH = 0x0611                  ; ADC Accumulator Result hi byte\n.equ ADC0_WINLT = 0x0612                 ; Window comparator low threshold\n.equ ADC0_WINLTL = 0x0612                ; Window comparator low threshold low byte\n.equ ADC0_WINLTH = 0x0613                ; Window comparator low threshold hi byte\n.equ ADC0_WINHT = 0x0614                 ; Window comparator high threshold\n.equ ADC0_WINHTL = 0x0614                ; Window comparator high threshold low byte\n.equ ADC0_WINHTH = 0x0615                ; Window comparator high threshold hi byte\n.equ ADC0_CALIB = 0x0616                 ; Calibration\n\n;*************************************************************************\n;** BOD - Bod interface\n;*************************************************************************\n\n.equ BOD_CTRLA = 0x0080                  ; Control A\n.equ BOD_CTRLB = 0x0081                  ; Control B\n.equ BOD_VLMCTRLA = 0x0088               ; Voltage level monitor Control\n.equ BOD_INTCTRL = 0x0089                ; Voltage level monitor interrupt Control\n.equ BOD_INTFLAGS = 0x008A               ; Voltage level monitor interrupt Flags\n.equ BOD_STATUS = 0x008B                 ; Voltage level monitor status\n\n;*************************************************************************\n;** CCL - Configurable Custom Logic\n;*************************************************************************\n\n.equ CCL_CTRLA = 0x01C0                  ; Control Register A\n.equ CCL_SEQCTRL0 = 0x01C1               ; Sequential Control 0\n.equ CCL_LUT0CTRLA = 0x01C5              ; LUT Control 0 A\n.equ CCL_LUT0CTRLB = 0x01C6              ; LUT Control 0 B\n.equ CCL_LUT0CTRLC = 0x01C7              ; LUT Control 0 C\n.equ CCL_TRUTH0 = 0x01C8                 ; Truth 0\n.equ CCL_LUT1CTRLA = 0x01C9              ; LUT Control 1 A\n.equ CCL_LUT1CTRLB = 0x01CA              ; LUT Control 1 B\n.equ CCL_LUT1CTRLC = 0x01CB              ; LUT Control 1 C\n.equ CCL_TRUTH1 = 0x01CC                 ; Truth 1\n\n;*************************************************************************\n;** CLKCTRL - Clock controller\n;*************************************************************************\n\n.equ CLKCTRL_MCLKCTRLA = 0x0060          ; MCLK Control A\n.equ CLKCTRL_MCLKCTRLB = 0x0061          ; MCLK Control B\n.equ CLKCTRL_MCLKLOCK = 0x0062           ; MCLK Lock\n.equ CLKCTRL_MCLKSTATUS = 0x0063         ; MCLK Status\n.equ CLKCTRL_OSC20MCTRLA = 0x0070        ; OSC20M Control A\n.equ CLKCTRL_OSC20MCALIBA = 0x0071       ; OSC20M Calibration A\n.equ CLKCTRL_OSC20MCALIBB = 0x0072       ; OSC20M Calibration B\n.equ CLKCTRL_OSC32KCTRLA = 0x0078        ; OSC32K Control A\n\n;*************************************************************************\n;** CPU - CPU\n;*************************************************************************\n\n.equ CPU_CCP = 0x0034                    ; Configuration Change Protection\n.equ CPU_SPL = 0x003D                    ; Stack Pointer Low\n.equ CPU_SPH = 0x003E                    ; Stack Pointer High\n.equ CPU_SREG = 0x003F                   ; Status Register\n\n;*************************************************************************\n;** CPUINT - Interrupt Controller\n;*************************************************************************\n\n.equ CPUINT_CTRLA = 0x0110               ; Control A\n.equ CPUINT_STATUS = 0x0111              ; Status\n.equ CPUINT_LVL0PRI = 0x0112             ; Interrupt Level 0 Priority\n.equ CPUINT_LVL1VEC = 0x0113             ; Interrupt Level 1 Priority Vector\n\n;*************************************************************************\n;** CRCSCAN - CRCSCAN\n;*************************************************************************\n\n.equ CRCSCAN_CTRLA = 0x0120              ; Control A\n.equ CRCSCAN_CTRLB = 0x0121              ; Control B\n.equ CRCSCAN_STATUS = 0x0122             ; Status\n\n;*************************************************************************\n;** EVSYS - Event System\n;*************************************************************************\n\n.equ EVSYS_ASYNCSTROBE = 0x0180          ; Asynchronous Channel Strobe\n.equ EVSYS_SYNCSTROBE = 0x0181           ; Synchronous Channel Strobe\n.equ EVSYS_ASYNCCH0 = 0x0182             ; Asynchronous Channel 0 Generator Selection\n.equ EVSYS_ASYNCCH1 = 0x0183             ; Asynchronous Channel 1 Generator Selection\n.equ EVSYS_SYNCCH0 = 0x018A              ; Synchronous Channel 0 Generator Selection\n.equ EVSYS_ASYNCUSER0 = 0x0192           ; Asynchronous User Ch 0 Input Selection - TCB0\n.equ EVSYS_ASYNCUSER1 = 0x0193           ; Asynchronous User Ch 1 Input Selection - ADC0\n.equ EVSYS_ASYNCUSER2 = 0x0194           ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0\n.equ EVSYS_ASYNCUSER3 = 0x0195           ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0\n.equ EVSYS_ASYNCUSER4 = 0x0196           ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1\n.equ EVSYS_ASYNCUSER5 = 0x0197           ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1\n.equ EVSYS_ASYNCUSER6 = 0x0198           ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0\n.equ EVSYS_ASYNCUSER7 = 0x0199           ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1\n.equ EVSYS_ASYNCUSER8 = 0x019A           ; Asynchronous User Ch 8 Input Selection - Event Out 0\n.equ EVSYS_ASYNCUSER9 = 0x019B           ; Asynchronous User Ch 9 Input Selection - Event Out 1\n.equ EVSYS_ASYNCUSER10 = 0x019C          ; Asynchronous User Ch 10 Input Selection - Event Out 2\n.equ EVSYS_SYNCUSER0 = 0x01A2            ; Synchronous User Ch 0 Input Selection - TCA0\n.equ EVSYS_SYNCUSER1 = 0x01A3            ; Synchronous User Ch 1 Input Selection - USART0\n\n;*************************************************************************\n;** FUSE - Fuses\n;*************************************************************************\n\n.equ FUSE_WDTCFG = 0x1280                ; Watchdog Configuration\n.equ FUSE_BODCFG = 0x1281                ; BOD Configuration\n.equ FUSE_OSCCFG = 0x1282                ; Oscillator Configuration\n.equ FUSE_TCD0CFG = 0x1284               ; TCD0 Configuration\n.equ FUSE_SYSCFG0 = 0x1285               ; System Configuration 0\n.equ FUSE_SYSCFG1 = 0x1286               ; System Configuration 1\n.equ FUSE_APPEND = 0x1287                ; Application Code Section End\n.equ FUSE_BOOTEND = 0x1288               ; Boot Section End\n\n;*************************************************************************\n;** GPIO - General Purpose IO\n;*************************************************************************\n\n.equ GPIO_GPIOR0 = 0x001C                ; General Purpose IO Register 0\n.equ GPIO_GPIOR1 = 0x001D                ; General Purpose IO Register 1\n.equ GPIO_GPIOR2 = 0x001E                ; General Purpose IO Register 2\n.equ GPIO_GPIOR3 = 0x001F                ; General Purpose IO Register 3\n\n;*************************************************************************\n;** LOCKBIT - Lockbit\n;*************************************************************************\n\n.equ LOCKBIT_LOCKBIT = 0x128A            ; Lock bits\n\n;*************************************************************************\n;** NVMCTRL - Non-volatile Memory Controller\n;*************************************************************************\n\n.equ NVMCTRL_CTRLA = 0x1000              ; Control A\n.equ NVMCTRL_CTRLB = 0x1001              ; Control B\n.equ NVMCTRL_STATUS = 0x1002             ; Status\n.equ NVMCTRL_INTCTRL = 0x1003            ; Interrupt Control\n.equ NVMCTRL_INTFLAGS = 0x1004           ; Interrupt Flags\n.equ NVMCTRL_DATA = 0x1006               ; Data\n.equ NVMCTRL_DATAL = 0x1006              ; Data low byte\n.equ NVMCTRL_DATAH = 0x1007              ; Data hi byte\n.equ NVMCTRL_ADDR = 0x1008               ; Address\n.equ NVMCTRL_ADDRL = 0x1008              ; Address low byte\n.equ NVMCTRL_ADDRH = 0x1009              ; Address hi byte\n\n;*************************************************************************\n;** PORTA - I/O Ports\n;*************************************************************************\n\n.equ PORTA_DIR = 0x0400                  ; Data Direction\n.equ PORTA_DIRSET = 0x0401               ; Data Direction Set\n.equ PORTA_DIRCLR = 0x0402               ; Data Direction Clear\n.equ PORTA_DIRTGL = 0x0403               ; Data Direction Toggle\n.equ PORTA_OUT = 0x0404                  ; Output Value\n.equ PORTA_OUTSET = 0x0405               ; Output Value Set\n.equ PORTA_OUTCLR = 0x0406               ; Output Value Clear\n.equ PORTA_OUTTGL = 0x0407               ; Output Value Toggle\n.equ PORTA_IN = 0x0408                   ; Input Value\n.equ PORTA_INTFLAGS = 0x0409             ; Interrupt Flags\n.equ PORTA_PIN0CTRL = 0x0410             ; Pin 0 Control\n.equ PORTA_PIN1CTRL = 0x0411             ; Pin 1 Control\n.equ PORTA_PIN2CTRL = 0x0412             ; Pin 2 Control\n.equ PORTA_PIN3CTRL = 0x0413             ; Pin 3 Control\n.equ PORTA_PIN4CTRL = 0x0414             ; Pin 4 Control\n.equ PORTA_PIN5CTRL = 0x0415             ; Pin 5 Control\n.equ PORTA_PIN6CTRL = 0x0416             ; Pin 6 Control\n.equ PORTA_PIN7CTRL = 0x0417             ; Pin 7 Control\n\n;*************************************************************************\n;** PORTB - I/O Ports\n;*************************************************************************\n\n.equ PORTB_DIR = 0x0420                  ; Data Direction\n.equ PORTB_DIRSET = 0x0421               ; Data Direction Set\n.equ PORTB_DIRCLR = 0x0422               ; Data Direction Clear\n.equ PORTB_DIRTGL = 0x0423               ; Data Direction Toggle\n.equ PORTB_OUT = 0x0424                  ; Output Value\n.equ PORTB_OUTSET = 0x0425               ; Output Value Set\n.equ PORTB_OUTCLR = 0x0426               ; Output Value Clear\n.equ PORTB_OUTTGL = 0x0427               ; Output Value Toggle\n.equ PORTB_IN = 0x0428                   ; Input Value\n.equ PORTB_INTFLAGS = 0x0429             ; Interrupt Flags\n.equ PORTB_PIN0CTRL = 0x0430             ; Pin 0 Control\n.equ PORTB_PIN1CTRL = 0x0431             ; Pin 1 Control\n.equ PORTB_PIN2CTRL = 0x0432             ; Pin 2 Control\n.equ PORTB_PIN3CTRL = 0x0433             ; Pin 3 Control\n.equ PORTB_PIN4CTRL = 0x0434             ; Pin 4 Control\n.equ PORTB_PIN5CTRL = 0x0435             ; Pin 5 Control\n.equ PORTB_PIN6CTRL = 0x0436             ; Pin 6 Control\n.equ PORTB_PIN7CTRL = 0x0437             ; Pin 7 Control\n\n;*************************************************************************\n;** PORTMUX - Port Multiplexer\n;*************************************************************************\n\n.equ PORTMUX_CTRLA = 0x0200              ; Port Multiplexer Control A\n.equ PORTMUX_CTRLB = 0x0201              ; Port Multiplexer Control B\n.equ PORTMUX_CTRLC = 0x0202              ; Port Multiplexer Control C\n.equ PORTMUX_CTRLD = 0x0203              ; Port Multiplexer Control D\n\n;*************************************************************************\n;** RSTCTRL - Reset controller\n;*************************************************************************\n\n.equ RSTCTRL_RSTFR = 0x0040              ; Reset Flags\n.equ RSTCTRL_SWRR = 0x0041               ; Software Reset\n\n;*************************************************************************\n;** RTC - Real-Time Counter\n;*************************************************************************\n\n.equ RTC_CTRLA = 0x0140                  ; Control A\n.equ RTC_STATUS = 0x0141                 ; Status\n.equ RTC_INTCTRL = 0x0142                ; Interrupt Control\n.equ RTC_INTFLAGS = 0x0143               ; Interrupt Flags\n.equ RTC_TEMP = 0x0144                   ; Temporary\n.equ RTC_DBGCTRL = 0x0145                ; Debug control\n.equ RTC_CLKSEL = 0x0147                 ; Clock Select\n.equ RTC_CNT = 0x0148                    ; Counter\n.equ RTC_CNTL = 0x0148                   ; Counter low byte\n.equ RTC_CNTH = 0x0149                   ; Counter hi byte\n.equ RTC_PER = 0x014A                    ; Period\n.equ RTC_PERL = 0x014A                   ; Period low byte\n.equ RTC_PERH = 0x014B                   ; Period hi byte\n.equ RTC_CMP = 0x014C                    ; Compare\n.equ RTC_CMPL = 0x014C                   ; Compare low byte\n.equ RTC_CMPH = 0x014D                   ; Compare hi byte\n.equ RTC_PITCTRLA = 0x0150               ; PIT Control A\n.equ RTC_PITSTATUS = 0x0151              ; PIT Status\n.equ RTC_PITINTCTRL = 0x0152             ; PIT Interrupt Control\n.equ RTC_PITINTFLAGS = 0x0153            ; PIT Interrupt Flags\n.equ RTC_PITDBGCTRL = 0x0155             ; PIT Debug control\n\n;*************************************************************************\n;** SIGROW - Signature row\n;*************************************************************************\n\n.equ SIGROW_DEVICEID0 = 0x1100           ; Device ID Byte 0\n.equ SIGROW_DEVICEID1 = 0x1101           ; Device ID Byte 1\n.equ SIGROW_DEVICEID2 = 0x1102           ; Device ID Byte 2\n.equ SIGROW_SERNUM0 = 0x1103             ; Serial Number Byte 0\n.equ SIGROW_SERNUM1 = 0x1104             ; Serial Number Byte 1\n.equ SIGROW_SERNUM2 = 0x1105             ; Serial Number Byte 2\n.equ SIGROW_SERNUM3 = 0x1106             ; Serial Number Byte 3\n.equ SIGROW_SERNUM4 = 0x1107             ; Serial Number Byte 4\n.equ SIGROW_SERNUM5 = 0x1108             ; Serial Number Byte 5\n.equ SIGROW_SERNUM6 = 0x1109             ; Serial Number Byte 6\n.equ SIGROW_SERNUM7 = 0x110A             ; Serial Number Byte 7\n.equ SIGROW_SERNUM8 = 0x110B             ; Serial Number Byte 8\n.equ SIGROW_SERNUM9 = 0x110C             ; Serial Number Byte 9\n.equ SIGROW_TEMPSENSE0 = 0x1120          ; Temperature Sensor Calibration Byte 0\n.equ SIGROW_TEMPSENSE1 = 0x1121          ; Temperature Sensor Calibration Byte 1\n.equ SIGROW_OSC16ERR3V = 0x1122          ; OSC16 error at 3V\n.equ SIGROW_OSC16ERR5V = 0x1123          ; OSC16 error at 5V\n.equ SIGROW_OSC20ERR3V = 0x1124          ; OSC20 error at 3V\n.equ SIGROW_OSC20ERR5V = 0x1125          ; OSC20 error at 5V\n\n;*************************************************************************\n;** SLPCTRL - Sleep Controller\n;*************************************************************************\n\n.equ SLPCTRL_CTRLA = 0x0050              ; Control\n\n;*************************************************************************\n;** SPI0 - Serial Peripheral Interface\n;*************************************************************************\n\n.equ SPI0_CTRLA = 0x0820                 ; Control A\n.equ SPI0_CTRLB = 0x0821                 ; Control B\n.equ SPI0_INTCTRL = 0x0822               ; Interrupt Control\n.equ SPI0_INTFLAGS = 0x0823              ; Interrupt Flags\n.equ SPI0_DATA = 0x0824                  ; Data\n\n;*************************************************************************\n;** SYSCFG - System Configuration Registers\n;*************************************************************************\n\n.equ SYSCFG_REVID = 0x0F01               ; Revision ID\n.equ SYSCFG_EXTBRK = 0x0F02              ; External Break\n\n;*************************************************************************\n;** TCA0 - 16-bit Timer/Counter Type A\n;*************************************************************************\n\n.equ TCA0_SINGLE_CTRLA = 0x0A00          ; SINGLE Control A\n.equ TCA0_SINGLE_CTRLB = 0x0A01          ; SINGLE Control B\n.equ TCA0_SINGLE_CTRLC = 0x0A02          ; SINGLE Control C\n.equ TCA0_SINGLE_CTRLD = 0x0A03          ; SINGLE Control D\n.equ TCA0_SINGLE_CTRLECLR = 0x0A04       ; SINGLE Control E Clear\n.equ TCA0_SINGLE_CTRLESET = 0x0A05       ; SINGLE Control E Set\n.equ TCA0_SINGLE_CTRLFCLR = 0x0A06       ; SINGLE Control F Clear\n.equ TCA0_SINGLE_CTRLFSET = 0x0A07       ; SINGLE Control F Set\n.equ TCA0_SINGLE_EVCTRL = 0x0A09         ; SINGLE Event Control\n.equ TCA0_SINGLE_INTCTRL = 0x0A0A        ; SINGLE Interrupt Control\n.equ TCA0_SINGLE_INTFLAGS = 0x0A0B       ; SINGLE Interrupt Flags\n.equ TCA0_SINGLE_DBGCTRL = 0x0A0E        ; SINGLE Degbug Control\n.equ TCA0_SINGLE_TEMP = 0x0A0F           ; SINGLE Temporary data for 16-bit Access\n.equ TCA0_SINGLE_CNT = 0x0A20            ; SINGLE Count\n.equ TCA0_SINGLE_PER = 0x0A26            ; SINGLE Period\n.equ TCA0_SINGLE_CMP0 = 0x0A28           ; SINGLE Compare 0\n.equ TCA0_SINGLE_CMP1 = 0x0A2A           ; SINGLE Compare 1\n.equ TCA0_SINGLE_CMP2 = 0x0A2C           ; SINGLE Compare 2\n.equ TCA0_SINGLE_PERBUF = 0x0A36         ; SINGLE Period Buffer\n.equ TCA0_SINGLE_CMP0BUF = 0x0A38        ; SINGLE Compare 0 Buffer\n.equ TCA0_SINGLE_CMP1BUF = 0x0A3A        ; SINGLE Compare 1 Buffer\n.equ TCA0_SINGLE_CMP2BUF = 0x0A3C        ; SINGLE Compare 2 Buffer\n.equ TCA0_SPLIT_CTRLA = 0x0A00           ; SPLIT Control A\n.equ TCA0_SPLIT_CTRLB = 0x0A01           ; SPLIT Control B\n.equ TCA0_SPLIT_CTRLC = 0x0A02           ; SPLIT Control C\n.equ TCA0_SPLIT_CTRLD = 0x0A03           ; SPLIT Control D\n.equ TCA0_SPLIT_CTRLECLR = 0x0A04        ; SPLIT Control E Clear\n.equ TCA0_SPLIT_CTRLESET = 0x0A05        ; SPLIT Control E Set\n.equ TCA0_SPLIT_INTCTRL = 0x0A0A         ; SPLIT Interrupt Control\n.equ TCA0_SPLIT_INTFLAGS = 0x0A0B        ; SPLIT Interrupt Flags\n.equ TCA0_SPLIT_DBGCTRL = 0x0A0E         ; SPLIT Degbug Control\n.equ TCA0_SPLIT_LCNT = 0x0A20            ; SPLIT Low Count\n.equ TCA0_SPLIT_HCNT = 0x0A21            ; SPLIT High Count\n.equ TCA0_SPLIT_LPER = 0x0A26            ; SPLIT Low Period\n.equ TCA0_SPLIT_HPER = 0x0A27            ; SPLIT High Period\n.equ TCA0_SPLIT_LCMP0 = 0x0A28           ; SPLIT Low Compare\n.equ TCA0_SPLIT_HCMP0 = 0x0A29           ; SPLIT High Compare\n.equ TCA0_SPLIT_LCMP1 = 0x0A2A           ; SPLIT Low Compare\n.equ TCA0_SPLIT_HCMP1 = 0x0A2B           ; SPLIT High Compare\n.equ TCA0_SPLIT_LCMP2 = 0x0A2C           ; SPLIT Low Compare\n.equ TCA0_SPLIT_HCMP2 = 0x0A2D           ; SPLIT High Compare\n\n;*************************************************************************\n;** TCB0 - 16-bit Timer Type B\n;*************************************************************************\n\n.equ TCB0_CTRLA = 0x0A40                 ; Control A\n.equ TCB0_CTRLB = 0x0A41                 ; Control Register B\n.equ TCB0_EVCTRL = 0x0A44                ; Event Control\n.equ TCB0_INTCTRL = 0x0A45               ; Interrupt Control\n.equ TCB0_INTFLAGS = 0x0A46              ; Interrupt Flags\n.equ TCB0_STATUS = 0x0A47                ; Status\n.equ TCB0_DBGCTRL = 0x0A48               ; Debug Control\n.equ TCB0_TEMP = 0x0A49                  ; Temporary Value\n.equ TCB0_CNT = 0x0A4A                   ; Count\n.equ TCB0_CNTL = 0x0A4A                  ; Count low byte\n.equ TCB0_CNTH = 0x0A4B                  ; Count hi byte\n.equ TCB0_CCMP = 0x0A4C                  ; Compare or Capture\n.equ TCB0_CCMPL = 0x0A4C                 ; Compare or Capture low byte\n.equ TCB0_CCMPH = 0x0A4D                 ; Compare or Capture hi byte\n\n;*************************************************************************\n;** TWI0 - Two-Wire Interface\n;*************************************************************************\n\n.equ TWI0_CTRLA = 0x0810                 ; Control A\n.equ TWI0_DBGCTRL = 0x0812               ; Debug Control Register\n.equ TWI0_MCTRLA = 0x0813                ; Master Control A\n.equ TWI0_MCTRLB = 0x0814                ; Master Control B\n.equ TWI0_MSTATUS = 0x0815               ; Master Status\n.equ TWI0_MBAUD = 0x0816                 ; Master Baurd Rate Control\n.equ TWI0_MADDR = 0x0817                 ; Master Address\n.equ TWI0_MDATA = 0x0818                 ; Master Data\n.equ TWI0_SCTRLA = 0x0819                ; Slave Control A\n.equ TWI0_SCTRLB = 0x081A                ; Slave Control B\n.equ TWI0_SSTATUS = 0x081B               ; Slave Status\n.equ TWI0_SADDR = 0x081C                 ; Slave Address\n.equ TWI0_SDATA = 0x081D                 ; Slave Data\n.equ TWI0_SADDRMASK = 0x081E             ; Slave Address Mask\n\n;*************************************************************************\n;** USART0 - Universal Synchronous and Asynchronous Receiver and Transmitter\n;*************************************************************************\n\n.equ USART0_RXDATAL = 0x0800             ; Receive Data Low Byte\n.equ USART0_RXDATAH = 0x0801             ; Receive Data High Byte\n.equ USART0_TXDATAL = 0x0802             ; Transmit Data Low Byte\n.equ USART0_TXDATAH = 0x0803             ; Transmit Data High Byte\n.equ USART0_STATUS = 0x0804              ; Status\n.equ USART0_CTRLA = 0x0805               ; Control A\n.equ USART0_CTRLB = 0x0806               ; Control B\n.equ USART0_CTRLC = 0x0807               ; Control C\n.equ USART0_BAUD = 0x0808                ; Baud Rate\n.equ USART0_BAUDL = 0x0808               ; Baud Rate low byte\n.equ USART0_BAUDH = 0x0809               ; Baud Rate hi byte\n.equ USART0_DBGCTRL = 0x080B             ; Debug Control\n.equ USART0_EVCTRL = 0x080C              ; Event Control\n.equ USART0_TXPLCTRL = 0x080D            ; IRCOM Transmitter Pulse Length Control\n.equ USART0_RXPLCTRL = 0x080E            ; IRCOM Receiver Pulse Length Control\n\n;*************************************************************************\n;** USERROW - User Row\n;*************************************************************************\n\n.equ USERROW_USERROW0 = 0x1300           ; User Row Byte 0\n.equ USERROW_USERROW1 = 0x1301           ; User Row Byte 1\n.equ USERROW_USERROW2 = 0x1302           ; User Row Byte 2\n.equ USERROW_USERROW3 = 0x1303           ; User Row Byte 3\n.equ USERROW_USERROW4 = 0x1304           ; User Row Byte 4\n.equ USERROW_USERROW5 = 0x1305           ; User Row Byte 5\n.equ USERROW_USERROW6 = 0x1306           ; User Row Byte 6\n.equ USERROW_USERROW7 = 0x1307           ; User Row Byte 7\n.equ USERROW_USERROW8 = 0x1308           ; User Row Byte 8\n.equ USERROW_USERROW9 = 0x1309           ; User Row Byte 9\n.equ USERROW_USERROW10 = 0x130A          ; User Row Byte 10\n.equ USERROW_USERROW11 = 0x130B          ; User Row Byte 11\n.equ USERROW_USERROW12 = 0x130C          ; User Row Byte 12\n.equ USERROW_USERROW13 = 0x130D          ; User Row Byte 13\n.equ USERROW_USERROW14 = 0x130E          ; User Row Byte 14\n.equ USERROW_USERROW15 = 0x130F          ; User Row Byte 15\n.equ USERROW_USERROW16 = 0x1310          ; User Row Byte 16\n.equ USERROW_USERROW17 = 0x1311          ; User Row Byte 17\n.equ USERROW_USERROW18 = 0x1312          ; User Row Byte 18\n.equ USERROW_USERROW19 = 0x1313          ; User Row Byte 19\n.equ USERROW_USERROW20 = 0x1314          ; User Row Byte 20\n.equ USERROW_USERROW21 = 0x1315          ; User Row Byte 21\n.equ USERROW_USERROW22 = 0x1316          ; User Row Byte 22\n.equ USERROW_USERROW23 = 0x1317          ; User Row Byte 23\n.equ USERROW_USERROW24 = 0x1318          ; User Row Byte 24\n.equ USERROW_USERROW25 = 0x1319          ; User Row Byte 25\n.equ USERROW_USERROW26 = 0x131A          ; User Row Byte 26\n.equ USERROW_USERROW27 = 0x131B          ; User Row Byte 27\n.equ USERROW_USERROW28 = 0x131C          ; User Row Byte 28\n.equ USERROW_USERROW29 = 0x131D          ; User Row Byte 29\n.equ USERROW_USERROW30 = 0x131E          ; User Row Byte 30\n.equ USERROW_USERROW31 = 0x131F          ; User Row Byte 31\n\n;*************************************************************************\n;** VPORTA - Virtual Ports\n;*************************************************************************\n\n.equ VPORTA_DIR = 0x0000                 ; Data Direction\n.equ VPORTA_OUT = 0x0001                 ; Output Value\n.equ VPORTA_IN = 0x0002                  ; Input Value\n.equ VPORTA_INTFLAGS = 0x0003            ; Interrupt Flags\n\n;*************************************************************************\n;** VPORTB - Virtual Ports\n;*************************************************************************\n\n.equ VPORTB_DIR = 0x0004                 ; Data Direction\n.equ VPORTB_OUT = 0x0005                 ; Output Value\n.equ VPORTB_IN = 0x0006                  ; Input Value\n.equ VPORTB_INTFLAGS = 0x0007            ; Interrupt Flags\n\n;*************************************************************************\n;** VPORTC - Virtual Ports\n;*************************************************************************\n\n.equ VPORTC_DIR = 0x0008                 ; Data Direction\n.equ VPORTC_OUT = 0x0009                 ; Output Value\n.equ VPORTC_IN = 0x000A                  ; Input Value\n.equ VPORTC_INTFLAGS = 0x000B            ; Interrupt Flags\n\n;*************************************************************************\n;** VREF - Voltage reference\n;*************************************************************************\n\n.equ VREF_CTRLA = 0x00A0                 ; Control A\n.equ VREF_CTRLB = 0x00A1                 ; Control B\n\n;*************************************************************************\n;** WDT - Watch-Dog Timer\n;*************************************************************************\n\n.equ WDT_CTRLA = 0x0100                  ; Control A\n.equ WDT_STATUS = 0x0101                 ; Status\n\n\n; ***** ALL MODULE BASE ADRESSES *****************************************\n\n.equ AC0_base = 0x0670                   ; Analog Comparator\n.equ ADC0_base = 0x0600                  ; Analog to Digital Converter\n.equ BOD_base = 0x0080                   ; Bod interface\n.equ CCL_base = 0x01C0                   ; Configurable Custom Logic\n.equ CLKCTRL_base = 0x0060               ; Clock controller\n.equ CPU_base = 0x0030                   ; CPU\n.equ CPUINT_base = 0x0110                ; Interrupt Controller\n.equ CRCSCAN_base = 0x0120               ; CRCSCAN\n.equ EVSYS_base = 0x0180                 ; Event System\n.equ FUSE_base = 0x1280                  ; Fuses\n.equ GPIO_base = 0x001C                  ; General Purpose IO\n.equ LOCKBIT_base = 0x128A               ; Lockbit\n.equ NVMCTRL_base = 0x1000               ; Non-volatile Memory Controller\n.equ PORTA_base = 0x0400                 ; I/O Ports\n.equ PORTB_base = 0x0420                 ; I/O Ports\n.equ PORTMUX_base = 0x0200               ; Port Multiplexer\n.equ RSTCTRL_base = 0x0040               ; Reset controller\n.equ RTC_base = 0x0140                   ; Real-Time Counter\n.equ SIGROW_base = 0x1100                ; Signature row\n.equ SLPCTRL_base = 0x0050               ; Sleep Controller\n.equ SPI0_base = 0x0820                  ; Serial Peripheral Interface\n.equ SYSCFG_base = 0x0F00                ; System Configuration Registers\n.equ TCA0_base = 0x0A00                  ; 16-bit Timer/Counter Type A\n.equ TCB0_base = 0x0A40                  ; 16-bit Timer Type B\n.equ TWI0_base = 0x0810                  ; Two-Wire Interface\n.equ USART0_base = 0x0800                ; Universal Synchronous and Asynchronous Receiver and Transmitter\n.equ USERROW_base = 0x1300               ; User Row\n.equ VPORTA_base = 0x0000                ; Virtual Ports\n.equ VPORTB_base = 0x0004                ; Virtual Ports\n.equ VPORTC_base = 0x0008                ; Virtual Ports\n.equ VREF_base = 0x00A0                  ; Voltage reference\n.equ WDT_base = 0x0100                   ; Watch-Dog Timer\n\n\n; ***** IO REGISTER OFFSETS **********************************************\n\n\n;*************************************************************************\n;** AC - Analog Comparator\n;*************************************************************************\n.equ AC_CTRLA_offset = 0x00              ; Control A\n.equ AC_MUXCTRLA_offset = 0x02           ; Mux Control A\n.equ AC_INTCTRL_offset = 0x06            ; Interrupt Control\n.equ AC_STATUS_offset = 0x07             ; Status\n\n;*************************************************************************\n;** ADC - Analog to Digital Converter\n;*************************************************************************\n.equ ADC_CTRLA_offset = 0x00             ; Control A\n.equ ADC_CTRLB_offset = 0x01             ; Control B\n.equ ADC_CTRLC_offset = 0x02             ; Control C\n.equ ADC_CTRLD_offset = 0x03             ; Control D\n.equ ADC_CTRLE_offset = 0x04             ; Control E\n.equ ADC_SAMPCTRL_offset = 0x05          ; Sample Control\n.equ ADC_MUXPOS_offset = 0x06            ; Positive mux input\n.equ ADC_COMMAND_offset = 0x08           ; Command\n.equ ADC_EVCTRL_offset = 0x09            ; Event Control\n.equ ADC_INTCTRL_offset = 0x0A           ; Interrupt Control\n.equ ADC_INTFLAGS_offset = 0x0B          ; Interrupt Flags\n.equ ADC_DBGCTRL_offset = 0x0C           ; Debug Control\n.equ ADC_TEMP_offset = 0x0D              ; Temporary Data\n.equ ADC_RES_offset = 0x10               ; ADC Accumulator Result\n.equ ADC_WINLT_offset = 0x12             ; Window comparator low threshold\n.equ ADC_WINHT_offset = 0x14             ; Window comparator high threshold\n.equ ADC_CALIB_offset = 0x16             ; Calibration\n\n;*************************************************************************\n;** BOD - Bod interface\n;*************************************************************************\n.equ BOD_CTRLA_offset = 0x00             ; Control A\n.equ BOD_CTRLB_offset = 0x01             ; Control B\n.equ BOD_VLMCTRLA_offset = 0x08          ; Voltage level monitor Control\n.equ BOD_INTCTRL_offset = 0x09           ; Voltage level monitor interrupt Control\n.equ BOD_INTFLAGS_offset = 0x0A          ; Voltage level monitor interrupt Flags\n.equ BOD_STATUS_offset = 0x0B            ; Voltage level monitor status\n\n;*************************************************************************\n;** CCL - Configurable Custom Logic\n;*************************************************************************\n.equ CCL_CTRLA_offset = 0x00             ; Control Register A\n.equ CCL_SEQCTRL0_offset = 0x01          ; Sequential Control 0\n.equ CCL_LUT0CTRLA_offset = 0x05         ; LUT Control 0 A\n.equ CCL_LUT0CTRLB_offset = 0x06         ; LUT Control 0 B\n.equ CCL_LUT0CTRLC_offset = 0x07         ; LUT Control 0 C\n.equ CCL_TRUTH0_offset = 0x08            ; Truth 0\n.equ CCL_LUT1CTRLA_offset = 0x09         ; LUT Control 1 A\n.equ CCL_LUT1CTRLB_offset = 0x0A         ; LUT Control 1 B\n.equ CCL_LUT1CTRLC_offset = 0x0B         ; LUT Control 1 C\n.equ CCL_TRUTH1_offset = 0x0C            ; Truth 1\n\n;*************************************************************************\n;** CLKCTRL - Clock controller\n;*************************************************************************\n.equ CLKCTRL_MCLKCTRLA_offset = 0x00     ; MCLK Control A\n.equ CLKCTRL_MCLKCTRLB_offset = 0x01     ; MCLK Control B\n.equ CLKCTRL_MCLKLOCK_offset = 0x02      ; MCLK Lock\n.equ CLKCTRL_MCLKSTATUS_offset = 0x03    ; MCLK Status\n.equ CLKCTRL_OSC20MCTRLA_offset = 0x10   ; OSC20M Control A\n.equ CLKCTRL_OSC20MCALIBA_offset = 0x11  ; OSC20M Calibration A\n.equ CLKCTRL_OSC20MCALIBB_offset = 0x12  ; OSC20M Calibration B\n.equ CLKCTRL_OSC32KCTRLA_offset = 0x18   ; OSC32K Control A\n\n;*************************************************************************\n;** CPU - CPU\n;*************************************************************************\n.equ CPU_CCP_offset = 0x04               ; Configuration Change Protection\n.equ CPU_SPL_offset = 0x0D               ; Stack Pointer Low\n.equ CPU_SPH_offset = 0x0E               ; Stack Pointer High\n.equ CPU_SREG_offset = 0x0F              ; Status Register\n\n;*************************************************************************\n;** CPUINT - Interrupt Controller\n;*************************************************************************\n.equ CPUINT_CTRLA_offset = 0x00          ; Control A\n.equ CPUINT_STATUS_offset = 0x01         ; Status\n.equ CPUINT_LVL0PRI_offset = 0x02        ; Interrupt Level 0 Priority\n.equ CPUINT_LVL1VEC_offset = 0x03        ; Interrupt Level 1 Priority Vector\n\n;*************************************************************************\n;** CRCSCAN - CRCSCAN\n;*************************************************************************\n.equ CRCSCAN_CTRLA_offset = 0x00         ; Control A\n.equ CRCSCAN_CTRLB_offset = 0x01         ; Control B\n.equ CRCSCAN_STATUS_offset = 0x02        ; Status\n\n;*************************************************************************\n;** EVSYS - Event System\n;*************************************************************************\n.equ EVSYS_ASYNCSTROBE_offset = 0x00     ; Asynchronous Channel Strobe\n.equ EVSYS_SYNCSTROBE_offset = 0x01      ; Synchronous Channel Strobe\n.equ EVSYS_ASYNCCH0_offset = 0x02        ; Asynchronous Channel 0 Generator Selection\n.equ EVSYS_ASYNCCH1_offset = 0x03        ; Asynchronous Channel 1 Generator Selection\n.equ EVSYS_SYNCCH0_offset = 0x0A         ; Synchronous Channel 0 Generator Selection\n.equ EVSYS_ASYNCUSER0_offset = 0x12      ; Asynchronous User Ch 0 Input Selection - TCB0\n.equ EVSYS_ASYNCUSER1_offset = 0x13      ; Asynchronous User Ch 1 Input Selection - ADC0\n.equ EVSYS_ASYNCUSER2_offset = 0x14      ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0\n.equ EVSYS_ASYNCUSER3_offset = 0x15      ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0\n.equ EVSYS_ASYNCUSER4_offset = 0x16      ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1\n.equ EVSYS_ASYNCUSER5_offset = 0x17      ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1\n.equ EVSYS_ASYNCUSER6_offset = 0x18      ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0\n.equ EVSYS_ASYNCUSER7_offset = 0x19      ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1\n.equ EVSYS_ASYNCUSER8_offset = 0x1A      ; Asynchronous User Ch 8 Input Selection - Event Out 0\n.equ EVSYS_ASYNCUSER9_offset = 0x1B      ; Asynchronous User Ch 9 Input Selection - Event Out 1\n.equ EVSYS_ASYNCUSER10_offset = 0x1C     ; Asynchronous User Ch 10 Input Selection - Event Out 2\n.equ EVSYS_SYNCUSER0_offset = 0x22       ; Synchronous User Ch 0 Input Selection - TCA0\n.equ EVSYS_SYNCUSER1_offset = 0x23       ; Synchronous User Ch 1 Input Selection - USART0\n\n;*************************************************************************\n;** FUSE - Fuses\n;*************************************************************************\n.equ FUSE_WDTCFG_offset = 0x00           ; Watchdog Configuration\n.equ FUSE_BODCFG_offset = 0x01           ; BOD Configuration\n.equ FUSE_OSCCFG_offset = 0x02           ; Oscillator Configuration\n.equ FUSE_TCD0CFG_offset = 0x04          ; TCD0 Configuration\n.equ FUSE_SYSCFG0_offset = 0x05          ; System Configuration 0\n.equ FUSE_SYSCFG1_offset = 0x06          ; System Configuration 1\n.equ FUSE_APPEND_offset = 0x07           ; Application Code Section End\n.equ FUSE_BOOTEND_offset = 0x08          ; Boot Section End\n\n;*************************************************************************\n;** GPIO - General Purpose IO\n;*************************************************************************\n.equ GPIO_GPIOR0_offset = 0x00           ; General Purpose IO Register 0\n.equ GPIO_GPIOR1_offset = 0x01           ; General Purpose IO Register 1\n.equ GPIO_GPIOR2_offset = 0x02           ; General Purpose IO Register 2\n.equ GPIO_GPIOR3_offset = 0x03           ; General Purpose IO Register 3\n\n;*************************************************************************\n;** LOCKBIT - Lockbit\n;*************************************************************************\n.equ LOCKBIT_LOCKBIT_offset = 0x00       ; Lock bits\n\n;*************************************************************************\n;** NVMCTRL - Non-volatile Memory Controller\n;*************************************************************************\n.equ NVMCTRL_CTRLA_offset = 0x00         ; Control A\n.equ NVMCTRL_CTRLB_offset = 0x01         ; Control B\n.equ NVMCTRL_STATUS_offset = 0x02        ; Status\n.equ NVMCTRL_INTCTRL_offset = 0x03       ; Interrupt Control\n.equ NVMCTRL_INTFLAGS_offset = 0x04      ; Interrupt Flags\n.equ NVMCTRL_DATA_offset = 0x06          ; Data\n.equ NVMCTRL_ADDR_offset = 0x08          ; Address\n\n;*************************************************************************\n;** PORT - I/O Ports\n;*************************************************************************\n.equ PORT_DIR_offset = 0x00              ; Data Direction\n.equ PORT_DIRSET_offset = 0x01           ; Data Direction Set\n.equ PORT_DIRCLR_offset = 0x02           ; Data Direction Clear\n.equ PORT_DIRTGL_offset = 0x03           ; Data Direction Toggle\n.equ PORT_OUT_offset = 0x04              ; Output Value\n.equ PORT_OUTSET_offset = 0x05           ; Output Value Set\n.equ PORT_OUTCLR_offset = 0x06           ; Output Value Clear\n.equ PORT_OUTTGL_offset = 0x07           ; Output Value Toggle\n.equ PORT_IN_offset = 0x08               ; Input Value\n.equ PORT_INTFLAGS_offset = 0x09         ; Interrupt Flags\n.equ PORT_PIN0CTRL_offset = 0x10         ; Pin 0 Control\n.equ PORT_PIN1CTRL_offset = 0x11         ; Pin 1 Control\n.equ PORT_PIN2CTRL_offset = 0x12         ; Pin 2 Control\n.equ PORT_PIN3CTRL_offset = 0x13         ; Pin 3 Control\n.equ PORT_PIN4CTRL_offset = 0x14         ; Pin 4 Control\n.equ PORT_PIN5CTRL_offset = 0x15         ; Pin 5 Control\n.equ PORT_PIN6CTRL_offset = 0x16         ; Pin 6 Control\n.equ PORT_PIN7CTRL_offset = 0x17         ; Pin 7 Control\n\n;*************************************************************************\n;** PORTMUX - Port Multiplexer\n;*************************************************************************\n.equ PORTMUX_CTRLA_offset = 0x00         ; Port Multiplexer Control A\n.equ PORTMUX_CTRLB_offset = 0x01         ; Port Multiplexer Control B\n.equ PORTMUX_CTRLC_offset = 0x02         ; Port Multiplexer Control C\n.equ PORTMUX_CTRLD_offset = 0x03         ; Port Multiplexer Control D\n\n;*************************************************************************\n;** RSTCTRL - Reset controller\n;*************************************************************************\n.equ RSTCTRL_RSTFR_offset = 0x00         ; Reset Flags\n.equ RSTCTRL_SWRR_offset = 0x01          ; Software Reset\n\n;*************************************************************************\n;** RTC - Real-Time Counter\n;*************************************************************************\n.equ RTC_CTRLA_offset = 0x00             ; Control A\n.equ RTC_STATUS_offset = 0x01            ; Status\n.equ RTC_INTCTRL_offset = 0x02           ; Interrupt Control\n.equ RTC_INTFLAGS_offset = 0x03          ; Interrupt Flags\n.equ RTC_TEMP_offset = 0x04              ; Temporary\n.equ RTC_DBGCTRL_offset = 0x05           ; Debug control\n.equ RTC_CLKSEL_offset = 0x07            ; Clock Select\n.equ RTC_CNT_offset = 0x08               ; Counter\n.equ RTC_PER_offset = 0x0A               ; Period\n.equ RTC_CMP_offset = 0x0C               ; Compare\n.equ RTC_PITCTRLA_offset = 0x10          ; PIT Control A\n.equ RTC_PITSTATUS_offset = 0x11         ; PIT Status\n.equ RTC_PITINTCTRL_offset = 0x12        ; PIT Interrupt Control\n.equ RTC_PITINTFLAGS_offset = 0x13       ; PIT Interrupt Flags\n.equ RTC_PITDBGCTRL_offset = 0x15        ; PIT Debug control\n\n;*************************************************************************\n;** SIGROW - Signature row\n;*************************************************************************\n.equ SIGROW_DEVICEID0_offset = 0x00      ; Device ID Byte 0\n.equ SIGROW_DEVICEID1_offset = 0x01      ; Device ID Byte 1\n.equ SIGROW_DEVICEID2_offset = 0x02      ; Device ID Byte 2\n.equ SIGROW_SERNUM0_offset = 0x03        ; Serial Number Byte 0\n.equ SIGROW_SERNUM1_offset = 0x04        ; Serial Number Byte 1\n.equ SIGROW_SERNUM2_offset = 0x05        ; Serial Number Byte 2\n.equ SIGROW_SERNUM3_offset = 0x06        ; Serial Number Byte 3\n.equ SIGROW_SERNUM4_offset = 0x07        ; Serial Number Byte 4\n.equ SIGROW_SERNUM5_offset = 0x08        ; Serial Number Byte 5\n.equ SIGROW_SERNUM6_offset = 0x09        ; Serial Number Byte 6\n.equ SIGROW_SERNUM7_offset = 0x0A        ; Serial Number Byte 7\n.equ SIGROW_SERNUM8_offset = 0x0B        ; Serial Number Byte 8\n.equ SIGROW_SERNUM9_offset = 0x0C        ; Serial Number Byte 9\n.equ SIGROW_TEMPSENSE0_offset = 0x20     ; Temperature Sensor Calibration Byte 0\n.equ SIGROW_TEMPSENSE1_offset = 0x21     ; Temperature Sensor Calibration Byte 1\n.equ SIGROW_OSC16ERR3V_offset = 0x22     ; OSC16 error at 3V\n.equ SIGROW_OSC16ERR5V_offset = 0x23     ; OSC16 error at 5V\n.equ SIGROW_OSC20ERR3V_offset = 0x24     ; OSC20 error at 3V\n.equ SIGROW_OSC20ERR5V_offset = 0x25     ; OSC20 error at 5V\n\n;*************************************************************************\n;** SLPCTRL - Sleep Controller\n;*************************************************************************\n.equ SLPCTRL_CTRLA_offset = 0x00         ; Control\n\n;*************************************************************************\n;** SPI - Serial Peripheral Interface\n;*************************************************************************\n.equ SPI_CTRLA_offset = 0x00             ; Control A\n.equ SPI_CTRLB_offset = 0x01             ; Control B\n.equ SPI_INTCTRL_offset = 0x02           ; Interrupt Control\n.equ SPI_INTFLAGS_offset = 0x03          ; Interrupt Flags\n.equ SPI_DATA_offset = 0x04              ; Data\n\n;*************************************************************************\n;** SYSCFG - System Configuration Registers\n;*************************************************************************\n.equ SYSCFG_REVID_offset = 0x01          ; Revision ID\n.equ SYSCFG_EXTBRK_offset = 0x02         ; External Break\n\n;*************************************************************************\n;** TCA - 16-bit Timer/Counter Type A\n;*************************************************************************\n.equ TCA_SINGLE_CTRLA_offset = 0x00      ; Control A\n.equ TCA_SINGLE_CTRLB_offset = 0x01      ; Control B\n.equ TCA_SINGLE_CTRLC_offset = 0x02      ; Control C\n.equ TCA_SINGLE_CTRLD_offset = 0x03      ; Control D\n.equ TCA_SINGLE_CTRLECLR_offset = 0x04   ; Control E Clear\n.equ TCA_SINGLE_CTRLESET_offset = 0x05   ; Control E Set\n.equ TCA_SINGLE_CTRLFCLR_offset = 0x06   ; Control F Clear\n.equ TCA_SINGLE_CTRLFSET_offset = 0x07   ; Control F Set\n.equ TCA_SINGLE_EVCTRL_offset = 0x09     ; Event Control\n.equ TCA_SINGLE_INTCTRL_offset = 0x0A    ; Interrupt Control\n.equ TCA_SINGLE_INTFLAGS_offset = 0x0B   ; Interrupt Flags\n.equ TCA_SINGLE_DBGCTRL_offset = 0x0E    ; Degbug Control\n.equ TCA_SINGLE_TEMP_offset = 0x0F       ; Temporary data for 16-bit Access\n.equ TCA_SINGLE_CNT_offset = 0x20        ; Count\n.equ TCA_SINGLE_PER_offset = 0x26        ; Period\n.equ TCA_SINGLE_CMP0_offset = 0x28       ; Compare 0\n.equ TCA_SINGLE_CMP1_offset = 0x2A       ; Compare 1\n.equ TCA_SINGLE_CMP2_offset = 0x2C       ; Compare 2\n.equ TCA_SINGLE_PERBUF_offset = 0x36     ; Period Buffer\n.equ TCA_SINGLE_CMP0BUF_offset = 0x38    ; Compare 0 Buffer\n.equ TCA_SINGLE_CMP1BUF_offset = 0x3A    ; Compare 1 Buffer\n.equ TCA_SINGLE_CMP2BUF_offset = 0x3C    ; Compare 2 Buffer\n.equ TCA_SPLIT_CTRLA_offset = 0x00       ; Control A\n.equ TCA_SPLIT_CTRLB_offset = 0x01       ; Control B\n.equ TCA_SPLIT_CTRLC_offset = 0x02       ; Control C\n.equ TCA_SPLIT_CTRLD_offset = 0x03       ; Control D\n.equ TCA_SPLIT_CTRLECLR_offset = 0x04    ; Control E Clear\n.equ TCA_SPLIT_CTRLESET_offset = 0x05    ; Control E Set\n.equ TCA_SPLIT_INTCTRL_offset = 0x0A     ; Interrupt Control\n.equ TCA_SPLIT_INTFLAGS_offset = 0x0B    ; Interrupt Flags\n.equ TCA_SPLIT_DBGCTRL_offset = 0x0E     ; Degbug Control\n.equ TCA_SPLIT_LCNT_offset = 0x20        ; Low Count\n.equ TCA_SPLIT_HCNT_offset = 0x21        ; High Count\n.equ TCA_SPLIT_LPER_offset = 0x26        ; Low Period\n.equ TCA_SPLIT_HPER_offset = 0x27        ; High Period\n.equ TCA_SPLIT_LCMP0_offset = 0x28       ; Low Compare\n.equ TCA_SPLIT_HCMP0_offset = 0x29       ; High Compare\n.equ TCA_SPLIT_LCMP1_offset = 0x2A       ; Low Compare\n.equ TCA_SPLIT_HCMP1_offset = 0x2B       ; High Compare\n.equ TCA_SPLIT_LCMP2_offset = 0x2C       ; Low Compare\n.equ TCA_SPLIT_HCMP2_offset = 0x2D       ; High Compare\n.equ TCA_SINGLE_offset = 0x00            ; \n.equ TCA_SPLIT_offset = 0x00             ; \n\n;*************************************************************************\n;** TCB - 16-bit Timer Type B\n;*************************************************************************\n.equ TCB_CTRLA_offset = 0x00             ; Control A\n.equ TCB_CTRLB_offset = 0x01             ; Control Register B\n.equ TCB_EVCTRL_offset = 0x04            ; Event Control\n.equ TCB_INTCTRL_offset = 0x05           ; Interrupt Control\n.equ TCB_INTFLAGS_offset = 0x06          ; Interrupt Flags\n.equ TCB_STATUS_offset = 0x07            ; Status\n.equ TCB_DBGCTRL_offset = 0x08           ; Debug Control\n.equ TCB_TEMP_offset = 0x09              ; Temporary Value\n.equ TCB_CNT_offset = 0x0A               ; Count\n.equ TCB_CCMP_offset = 0x0C              ; Compare or Capture\n\n;*************************************************************************\n;** TWI - Two-Wire Interface\n;*************************************************************************\n.equ TWI_CTRLA_offset = 0x00             ; Control A\n.equ TWI_DBGCTRL_offset = 0x02           ; Debug Control Register\n.equ TWI_MCTRLA_offset = 0x03            ; Master Control A\n.equ TWI_MCTRLB_offset = 0x04            ; Master Control B\n.equ TWI_MSTATUS_offset = 0x05           ; Master Status\n.equ TWI_MBAUD_offset = 0x06             ; Master Baurd Rate Control\n.equ TWI_MADDR_offset = 0x07             ; Master Address\n.equ TWI_MDATA_offset = 0x08             ; Master Data\n.equ TWI_SCTRLA_offset = 0x09            ; Slave Control A\n.equ TWI_SCTRLB_offset = 0x0A            ; Slave Control B\n.equ TWI_SSTATUS_offset = 0x0B           ; Slave Status\n.equ TWI_SADDR_offset = 0x0C             ; Slave Address\n.equ TWI_SDATA_offset = 0x0D             ; Slave Data\n.equ TWI_SADDRMASK_offset = 0x0E         ; Slave Address Mask\n\n;*************************************************************************\n;** USART - Universal Synchronous and Asynchronous Receiver and Transmitter\n;*************************************************************************\n.equ USART_RXDATAL_offset = 0x00         ; Receive Data Low Byte\n.equ USART_RXDATAH_offset = 0x01         ; Receive Data High Byte\n.equ USART_TXDATAL_offset = 0x02         ; Transmit Data Low Byte\n.equ USART_TXDATAH_offset = 0x03         ; Transmit Data High Byte\n.equ USART_STATUS_offset = 0x04          ; Status\n.equ USART_CTRLA_offset = 0x05           ; Control A\n.equ USART_CTRLB_offset = 0x06           ; Control B\n.equ USART_CTRLC_offset = 0x07           ; Control C\n.equ USART_BAUD_offset = 0x08            ; Baud Rate\n.equ USART_DBGCTRL_offset = 0x0B         ; Debug Control\n.equ USART_EVCTRL_offset = 0x0C          ; Event Control\n.equ USART_TXPLCTRL_offset = 0x0D        ; IRCOM Transmitter Pulse Length Control\n.equ USART_RXPLCTRL_offset = 0x0E        ; IRCOM Receiver Pulse Length Control\n\n;*************************************************************************\n;** USERROW - User Row\n;*************************************************************************\n.equ USERROW_USERROW0_offset = 0x00      ; User Row Byte 0\n.equ USERROW_USERROW1_offset = 0x01      ; User Row Byte 1\n.equ USERROW_USERROW2_offset = 0x02      ; User Row Byte 2\n.equ USERROW_USERROW3_offset = 0x03      ; User Row Byte 3\n.equ USERROW_USERROW4_offset = 0x04      ; User Row Byte 4\n.equ USERROW_USERROW5_offset = 0x05      ; User Row Byte 5\n.equ USERROW_USERROW6_offset = 0x06      ; User Row Byte 6\n.equ USERROW_USERROW7_offset = 0x07      ; User Row Byte 7\n.equ USERROW_USERROW8_offset = 0x08      ; User Row Byte 8\n.equ USERROW_USERROW9_offset = 0x09      ; User Row Byte 9\n.equ USERROW_USERROW10_offset = 0x0A     ; User Row Byte 10\n.equ USERROW_USERROW11_offset = 0x0B     ; User Row Byte 11\n.equ USERROW_USERROW12_offset = 0x0C     ; User Row Byte 12\n.equ USERROW_USERROW13_offset = 0x0D     ; User Row Byte 13\n.equ USERROW_USERROW14_offset = 0x0E     ; User Row Byte 14\n.equ USERROW_USERROW15_offset = 0x0F     ; User Row Byte 15\n.equ USERROW_USERROW16_offset = 0x10     ; User Row Byte 16\n.equ USERROW_USERROW17_offset = 0x11     ; User Row Byte 17\n.equ USERROW_USERROW18_offset = 0x12     ; User Row Byte 18\n.equ USERROW_USERROW19_offset = 0x13     ; User Row Byte 19\n.equ USERROW_USERROW20_offset = 0x14     ; User Row Byte 20\n.equ USERROW_USERROW21_offset = 0x15     ; User Row Byte 21\n.equ USERROW_USERROW22_offset = 0x16     ; User Row Byte 22\n.equ USERROW_USERROW23_offset = 0x17     ; User Row Byte 23\n.equ USERROW_USERROW24_offset = 0x18     ; User Row Byte 24\n.equ USERROW_USERROW25_offset = 0x19     ; User Row Byte 25\n.equ USERROW_USERROW26_offset = 0x1A     ; User Row Byte 26\n.equ USERROW_USERROW27_offset = 0x1B     ; User Row Byte 27\n.equ USERROW_USERROW28_offset = 0x1C     ; User Row Byte 28\n.equ USERROW_USERROW29_offset = 0x1D     ; User Row Byte 29\n.equ USERROW_USERROW30_offset = 0x1E     ; User Row Byte 30\n.equ USERROW_USERROW31_offset = 0x1F     ; User Row Byte 31\n\n;*************************************************************************\n;** VPORT - Virtual Ports\n;*************************************************************************\n.equ VPORT_DIR_offset = 0x00             ; Data Direction\n.equ VPORT_OUT_offset = 0x01             ; Output Value\n.equ VPORT_IN_offset = 0x02              ; Input Value\n.equ VPORT_INTFLAGS_offset = 0x03        ; Interrupt Flags\n\n;*************************************************************************\n;** VREF - Voltage reference\n;*************************************************************************\n.equ VREF_CTRLA_offset = 0x00            ; Control A\n.equ VREF_CTRLB_offset = 0x01            ; Control B\n\n;*************************************************************************\n;** WDT - Watch-Dog Timer\n;*************************************************************************\n.equ WDT_CTRLA_offset = 0x00             ; Control A\n.equ WDT_STATUS_offset = 0x01            ; Status\n\n\n; ***** LOCKBIT REGISTER LOCATIONS ***************************************\n\n\n\n\n; ***** FUSE REGISTER LOCATIONS ******************************************\n\n\n\n\n; ***** BIT AND VALUE DEFINITIONS ****************************************\n\n\n;*************************************************************************\n;** AC - Analog Comparator\n;*************************************************************************\n\n; AC_CTRLA masks\n.equ AC_ENABLE_bm = 0x01                 ; Enable bit mask\n.equ AC_ENABLE_bp = 0                    ; Enable bit position\n.equ AC_HYSMODE_gm = 0x06                ; Hysteresis Mode group mask\n.equ AC_HYSMODE_gp = 1                   ; Hysteresis Mode group position\n.equ AC_HYSMODE0_bm = (1<<1)             ; Hysteresis Mode bit 0 mask\n.equ AC_HYSMODE0_bp = 1                  ; Hysteresis Mode bit 0 position\n.equ AC_HYSMODE1_bm = (1<<2)             ; Hysteresis Mode bit 1 mask\n.equ AC_HYSMODE1_bp = 2                  ; Hysteresis Mode bit 1 position\n.equ AC_INTMODE_gm = 0x30                ; Interrupt Mode group mask\n.equ AC_INTMODE_gp = 4                   ; Interrupt Mode group position\n.equ AC_INTMODE0_bm = (1<<4)             ; Interrupt Mode bit 0 mask\n.equ AC_INTMODE0_bp = 4                  ; Interrupt Mode bit 0 position\n.equ AC_INTMODE1_bm = (1<<5)             ; Interrupt Mode bit 1 mask\n.equ AC_INTMODE1_bp = 5                  ; Interrupt Mode bit 1 position\n.equ AC_OUTEN_bm = 0x40                  ; Output Buffer Enable bit mask\n.equ AC_OUTEN_bp = 6                     ; Output Buffer Enable bit position\n.equ AC_RUNSTDBY_bm = 0x80               ; Run in Standby Mode bit mask\n.equ AC_RUNSTDBY_bp = 7                  ; Run in Standby Mode bit position\n\n; AC_INTCTRL masks\n.equ AC_CMP_bm = 0x01                    ; Analog Comparator 0 Interrupt Enable bit mask\n.equ AC_CMP_bp = 0                       ; Analog Comparator 0 Interrupt Enable bit position\n\n; AC_MUXCTRLA masks\n.equ AC_INVERT_bm = 0x80                 ; Invert AC Output bit mask\n.equ AC_INVERT_bp = 7                    ; Invert AC Output bit position\n.equ AC_MUXNEG_gm = 0x03                 ; Negative Input MUX Selection group mask\n.equ AC_MUXNEG_gp = 0                    ; Negative Input MUX Selection group position\n.equ AC_MUXNEG0_bm = (1<<0)              ; Negative Input MUX Selection bit 0 mask\n.equ AC_MUXNEG0_bp = 0                   ; Negative Input MUX Selection bit 0 position\n.equ AC_MUXNEG1_bm = (1<<1)              ; Negative Input MUX Selection bit 1 mask\n.equ AC_MUXNEG1_bp = 1                   ; Negative Input MUX Selection bit 1 position\n.equ AC_MUXPOS_gm = 0x18                 ; Positive Input MUX Selection group mask\n.equ AC_MUXPOS_gp = 3                    ; Positive Input MUX Selection group position\n.equ AC_MUXPOS0_bm = (1<<3)              ; Positive Input MUX Selection bit 0 mask\n.equ AC_MUXPOS0_bp = 3                   ; Positive Input MUX Selection bit 0 position\n.equ AC_MUXPOS1_bm = (1<<4)              ; Positive Input MUX Selection bit 1 mask\n.equ AC_MUXPOS1_bp = 4                   ; Positive Input MUX Selection bit 1 position\n\n; AC_STATUS masks\n; Masks for AC_CMP already defined\n.equ AC_STATE_bm = 0x10                  ; Analog Comparator State bit mask\n.equ AC_STATE_bp = 4                     ; Analog Comparator State bit position\n\n; Hysteresis Mode select\n.equ AC_HYSMODE_OFF_gc = (0x00<<1)       ; No hysteresis\n.equ AC_HYSMODE_10mV_gc = (0x01<<1)      ; 10mV hysteresis\n.equ AC_HYSMODE_25mV_gc = (0x02<<1)      ; 25mV hysteresis\n.equ AC_HYSMODE_50mV_gc = (0x03<<1)      ; 50mV hysteresis\n\n; Interrupt Mode select\n.equ AC_INTMODE_BOTHEDGE_gc = (0x00<<4)  ; Any Edge\n.equ AC_INTMODE_NEGEDGE_gc = (0x02<<4)   ; Negative Edge\n.equ AC_INTMODE_POSEDGE_gc = (0x03<<4)   ; Positive Edge\n\n; Negative Input MUX Selection select\n.equ AC_MUXNEG_PIN0_gc = (0x00<<0)       ; Negative Pin 0\n.equ AC_MUXNEG_VREF_gc = (0x02<<0)       ; Voltage Reference\n\n; Positive Input MUX Selection select\n.equ AC_MUXPOS_PIN0_gc = (0x00<<3)       ; Positive Pin 0\n\n\n;*************************************************************************\n;** ADC - Analog to Digital Converter\n;*************************************************************************\n\n; ADC_CALIB masks\n.equ ADC_DUTYCYC_bm = 0x01               ; Duty Cycle bit mask\n.equ ADC_DUTYCYC_bp = 0                  ; Duty Cycle bit position\n\n; ADC_COMMAND masks\n.equ ADC_STCONV_bm = 0x01                ; Start Conversion Operation bit mask\n.equ ADC_STCONV_bp = 0                   ; Start Conversion Operation bit position\n\n; ADC_CTRLA masks\n.equ ADC_ENABLE_bm = 0x01                ; ADC Enable bit mask\n.equ ADC_ENABLE_bp = 0                   ; ADC Enable bit position\n.equ ADC_FREERUN_bm = 0x02               ; ADC Freerun mode bit mask\n.equ ADC_FREERUN_bp = 1                  ; ADC Freerun mode bit position\n.equ ADC_RESSEL_bm = 0x04                ; ADC Resolution bit mask\n.equ ADC_RESSEL_bp = 2                   ; ADC Resolution bit position\n.equ ADC_RUNSTBY_bm = 0x80               ; Run standby mode bit mask\n.equ ADC_RUNSTBY_bp = 7                  ; Run standby mode bit position\n\n; ADC_CTRLB masks\n.equ ADC_SAMPNUM_gm = 0x07               ; Accumulation Samples group mask\n.equ ADC_SAMPNUM_gp = 0                  ; Accumulation Samples group position\n.equ ADC_SAMPNUM0_bm = (1<<0)            ; Accumulation Samples bit 0 mask\n.equ ADC_SAMPNUM0_bp = 0                 ; Accumulation Samples bit 0 position\n.equ ADC_SAMPNUM1_bm = (1<<1)            ; Accumulation Samples bit 1 mask\n.equ ADC_SAMPNUM1_bp = 1                 ; Accumulation Samples bit 1 position\n.equ ADC_SAMPNUM2_bm = (1<<2)            ; Accumulation Samples bit 2 mask\n.equ ADC_SAMPNUM2_bp = 2                 ; Accumulation Samples bit 2 position\n\n; ADC_CTRLC masks\n.equ ADC_PRESC_gm = 0x07                 ; Clock Pre-scaler group mask\n.equ ADC_PRESC_gp = 0                    ; Clock Pre-scaler group position\n.equ ADC_PRESC0_bm = (1<<0)              ; Clock Pre-scaler bit 0 mask\n.equ ADC_PRESC0_bp = 0                   ; Clock Pre-scaler bit 0 position\n.equ ADC_PRESC1_bm = (1<<1)              ; Clock Pre-scaler bit 1 mask\n.equ ADC_PRESC1_bp = 1                   ; Clock Pre-scaler bit 1 position\n.equ ADC_PRESC2_bm = (1<<2)              ; Clock Pre-scaler bit 2 mask\n.equ ADC_PRESC2_bp = 2                   ; Clock Pre-scaler bit 2 position\n.equ ADC_REFSEL_gm = 0x30                ; Reference Selection group mask\n.equ ADC_REFSEL_gp = 4                   ; Reference Selection group position\n.equ ADC_REFSEL0_bm = (1<<4)             ; Reference Selection bit 0 mask\n.equ ADC_REFSEL0_bp = 4                  ; Reference Selection bit 0 position\n.equ ADC_REFSEL1_bm = (1<<5)             ; Reference Selection bit 1 mask\n.equ ADC_REFSEL1_bp = 5                  ; Reference Selection bit 1 position\n.equ ADC_SAMPCAP_bm = 0x40               ; Sample Capacitance Selection bit mask\n.equ ADC_SAMPCAP_bp = 6                  ; Sample Capacitance Selection bit position\n\n; ADC_CTRLD masks\n.equ ADC_ASDV_bm = 0x10                  ; Automatic Sampling Delay Variation bit mask\n.equ ADC_ASDV_bp = 4                     ; Automatic Sampling Delay Variation bit position\n.equ ADC_INITDLY_gm = 0xE0               ; Initial Delay Selection group mask\n.equ ADC_INITDLY_gp = 5                  ; Initial Delay Selection group position\n.equ ADC_INITDLY0_bm = (1<<5)            ; Initial Delay Selection bit 0 mask\n.equ ADC_INITDLY0_bp = 5                 ; Initial Delay Selection bit 0 position\n.equ ADC_INITDLY1_bm = (1<<6)            ; Initial Delay Selection bit 1 mask\n.equ ADC_INITDLY1_bp = 6                 ; Initial Delay Selection bit 1 position\n.equ ADC_INITDLY2_bm = (1<<7)            ; Initial Delay Selection bit 2 mask\n.equ ADC_INITDLY2_bp = 7                 ; Initial Delay Selection bit 2 position\n.equ ADC_SAMPDLY_gm = 0x0F               ; Sampling Delay Selection group mask\n.equ ADC_SAMPDLY_gp = 0                  ; Sampling Delay Selection group position\n.equ ADC_SAMPDLY0_bm = (1<<0)            ; Sampling Delay Selection bit 0 mask\n.equ ADC_SAMPDLY0_bp = 0                 ; Sampling Delay Selection bit 0 position\n.equ ADC_SAMPDLY1_bm = (1<<1)            ; Sampling Delay Selection bit 1 mask\n.equ ADC_SAMPDLY1_bp = 1                 ; Sampling Delay Selection bit 1 position\n.equ ADC_SAMPDLY2_bm = (1<<2)            ; Sampling Delay Selection bit 2 mask\n.equ ADC_SAMPDLY2_bp = 2                 ; Sampling Delay Selection bit 2 position\n.equ ADC_SAMPDLY3_bm = (1<<3)            ; Sampling Delay Selection bit 3 mask\n.equ ADC_SAMPDLY3_bp = 3                 ; Sampling Delay Selection bit 3 position\n\n; ADC_CTRLE masks\n.equ ADC_WINCM_gm = 0x07                 ; Window Comparator Mode group mask\n.equ ADC_WINCM_gp = 0                    ; Window Comparator Mode group position\n.equ ADC_WINCM0_bm = (1<<0)              ; Window Comparator Mode bit 0 mask\n.equ ADC_WINCM0_bp = 0                   ; Window Comparator Mode bit 0 position\n.equ ADC_WINCM1_bm = (1<<1)              ; Window Comparator Mode bit 1 mask\n.equ ADC_WINCM1_bp = 1                   ; Window Comparator Mode bit 1 position\n.equ ADC_WINCM2_bm = (1<<2)              ; Window Comparator Mode bit 2 mask\n.equ ADC_WINCM2_bp = 2                   ; Window Comparator Mode bit 2 position\n\n; ADC_DBGCTRL masks\n.equ ADC_DBGRUN_bm = 0x01                ; Debug run bit mask\n.equ ADC_DBGRUN_bp = 0                   ; Debug run bit position\n\n; ADC_EVCTRL masks\n.equ ADC_STARTEI_bm = 0x01               ; Start Event Input Enable bit mask\n.equ ADC_STARTEI_bp = 0                  ; Start Event Input Enable bit position\n\n; ADC_INTCTRL masks\n.equ ADC_RESRDY_bm = 0x01                ; Result Ready Interrupt Enable bit mask\n.equ ADC_RESRDY_bp = 0                   ; Result Ready Interrupt Enable bit position\n.equ ADC_WCMP_bm = 0x02                  ; Window Comparator Interrupt Enable bit mask\n.equ ADC_WCMP_bp = 1                     ; Window Comparator Interrupt Enable bit position\n\n; ADC_INTFLAGS masks\n; Masks for ADC_RESRDY already defined\n; Masks for ADC_WCMP already defined\n\n; ADC_MUXPOS masks\n.equ ADC_MUXPOS_gm = 0x1F                ; Analog Channel Selection Bits group mask\n.equ ADC_MUXPOS_gp = 0                   ; Analog Channel Selection Bits group position\n.equ ADC_MUXPOS0_bm = (1<<0)             ; Analog Channel Selection Bits bit 0 mask\n.equ ADC_MUXPOS0_bp = 0                  ; Analog Channel Selection Bits bit 0 position\n.equ ADC_MUXPOS1_bm = (1<<1)             ; Analog Channel Selection Bits bit 1 mask\n.equ ADC_MUXPOS1_bp = 1                  ; Analog Channel Selection Bits bit 1 position\n.equ ADC_MUXPOS2_bm = (1<<2)             ; Analog Channel Selection Bits bit 2 mask\n.equ ADC_MUXPOS2_bp = 2                  ; Analog Channel Selection Bits bit 2 position\n.equ ADC_MUXPOS3_bm = (1<<3)             ; Analog Channel Selection Bits bit 3 mask\n.equ ADC_MUXPOS3_bp = 3                  ; Analog Channel Selection Bits bit 3 position\n.equ ADC_MUXPOS4_bm = (1<<4)             ; Analog Channel Selection Bits bit 4 mask\n.equ ADC_MUXPOS4_bp = 4                  ; Analog Channel Selection Bits bit 4 position\n\n; ADC_SAMPCTRL masks\n.equ ADC_SAMPLEN_gm = 0x1F               ; Sample lenght group mask\n.equ ADC_SAMPLEN_gp = 0                  ; Sample lenght group position\n.equ ADC_SAMPLEN0_bm = (1<<0)            ; Sample lenght bit 0 mask\n.equ ADC_SAMPLEN0_bp = 0                 ; Sample lenght bit 0 position\n.equ ADC_SAMPLEN1_bm = (1<<1)            ; Sample lenght bit 1 mask\n.equ ADC_SAMPLEN1_bp = 1                 ; Sample lenght bit 1 position\n.equ ADC_SAMPLEN2_bm = (1<<2)            ; Sample lenght bit 2 mask\n.equ ADC_SAMPLEN2_bp = 2                 ; Sample lenght bit 2 position\n.equ ADC_SAMPLEN3_bm = (1<<3)            ; Sample lenght bit 3 mask\n.equ ADC_SAMPLEN3_bp = 3                 ; Sample lenght bit 3 position\n.equ ADC_SAMPLEN4_bm = (1<<4)            ; Sample lenght bit 4 mask\n.equ ADC_SAMPLEN4_bp = 4                 ; Sample lenght bit 4 position\n\n; ADC_TEMP masks\n.equ ADC_TEMP_gm = 0xFF                  ; Temporary group mask\n.equ ADC_TEMP_gp = 0                     ; Temporary group position\n.equ ADC_TEMP0_bm = (1<<0)               ; Temporary bit 0 mask\n.equ ADC_TEMP0_bp = 0                    ; Temporary bit 0 position\n.equ ADC_TEMP1_bm = (1<<1)               ; Temporary bit 1 mask\n.equ ADC_TEMP1_bp = 1                    ; Temporary bit 1 position\n.equ ADC_TEMP2_bm = (1<<2)               ; Temporary bit 2 mask\n.equ ADC_TEMP2_bp = 2                    ; Temporary bit 2 position\n.equ ADC_TEMP3_bm = (1<<3)               ; Temporary bit 3 mask\n.equ ADC_TEMP3_bp = 3                    ; Temporary bit 3 position\n.equ ADC_TEMP4_bm = (1<<4)               ; Temporary bit 4 mask\n.equ ADC_TEMP4_bp = 4                    ; Temporary bit 4 position\n.equ ADC_TEMP5_bm = (1<<5)               ; Temporary bit 5 mask\n.equ ADC_TEMP5_bp = 5                    ; Temporary bit 5 position\n.equ ADC_TEMP6_bm = (1<<6)               ; Temporary bit 6 mask\n.equ ADC_TEMP6_bp = 6                    ; Temporary bit 6 position\n.equ ADC_TEMP7_bm = (1<<7)               ; Temporary bit 7 mask\n.equ ADC_TEMP7_bp = 7                    ; Temporary bit 7 position\n\n; Duty Cycle select\n.equ ADC_DUTYCYC_DUTY50_gc = (0x00<<0)   ; 50% Duty cycle\n.equ ADC_DUTYCYC_DUTY25_gc = (0x01<<0)   ; 25% Duty cycle\n\n; ADC Resolution select\n.equ ADC_RESSEL_10BIT_gc = (0x00<<2)     ; 10-bit mode\n.equ ADC_RESSEL_8BIT_gc = (0x01<<2)      ; 8-bit mode\n\n; Accumulation Samples select\n.equ ADC_SAMPNUM_ACC1_gc = (0x00<<0)     ; 1 ADC sample\n.equ ADC_SAMPNUM_ACC2_gc = (0x01<<0)     ; Accumulate 2 samples\n.equ ADC_SAMPNUM_ACC4_gc = (0x02<<0)     ; Accumulate 4 samples\n.equ ADC_SAMPNUM_ACC8_gc = (0x03<<0)     ; Accumulate 8 samples\n.equ ADC_SAMPNUM_ACC16_gc = (0x04<<0)    ; Accumulate 16 samples\n.equ ADC_SAMPNUM_ACC32_gc = (0x05<<0)    ; Accumulate 32 samples\n.equ ADC_SAMPNUM_ACC64_gc = (0x06<<0)    ; Accumulate 64 samples\n\n; Clock Pre-scaler select\n.equ ADC_PRESC_DIV2_gc = (0x00<<0)       ; CLK_PER divided by 2\n.equ ADC_PRESC_DIV4_gc = (0x01<<0)       ; CLK_PER divided by 4\n.equ ADC_PRESC_DIV8_gc = (0x02<<0)       ; CLK_PER divided by 8\n.equ ADC_PRESC_DIV16_gc = (0x03<<0)      ; CLK_PER divided by 16\n.equ ADC_PRESC_DIV32_gc = (0x04<<0)      ; CLK_PER divided by 32\n.equ ADC_PRESC_DIV64_gc = (0x05<<0)      ; CLK_PER divided by 64\n.equ ADC_PRESC_DIV128_gc = (0x06<<0)     ; CLK_PER divided by 128\n.equ ADC_PRESC_DIV256_gc = (0x07<<0)     ; CLK_PER divided by 256\n\n; Reference Selection select\n.equ ADC_REFSEL_INTREF_gc = (0x00<<4)    ; Internal reference\n.equ ADC_REFSEL_VDDREF_gc = (0x01<<4)    ; VDD\n\n; Automatic Sampling Delay Variation select\n.equ ADC_ASDV_ASVOFF_gc = (0x00<<4)      ; The Automatic Sampling Delay Variation is disabled\n.equ ADC_ASDV_ASVON_gc = (0x01<<4)       ; The Automatic Sampling Delay Variation is enabled\n\n; Initial Delay Selection select\n.equ ADC_INITDLY_DLY0_gc = (0x00<<5)     ; Delay 0 CLK_ADC cycles\n.equ ADC_INITDLY_DLY16_gc = (0x01<<5)    ; Delay 16 CLK_ADC cycles\n.equ ADC_INITDLY_DLY32_gc = (0x02<<5)    ; Delay 32 CLK_ADC cycles\n.equ ADC_INITDLY_DLY64_gc = (0x03<<5)    ; Delay 64 CLK_ADC cycles\n.equ ADC_INITDLY_DLY128_gc = (0x04<<5)   ; Delay 128 CLK_ADC cycles\n.equ ADC_INITDLY_DLY256_gc = (0x05<<5)   ; Delay 256 CLK_ADC cycles\n\n; Window Comparator Mode select\n.equ ADC_WINCM_NONE_gc = (0x00<<0)       ; No Window Comparison\n.equ ADC_WINCM_BELOW_gc = (0x01<<0)      ; Below Window\n.equ ADC_WINCM_ABOVE_gc = (0x02<<0)      ; Above Window\n.equ ADC_WINCM_INSIDE_gc = (0x03<<0)     ; Inside Window\n.equ ADC_WINCM_OUTSIDE_gc = (0x04<<0)    ; Outside Window\n\n; Analog Channel Selection Bits select\n.equ ADC_MUXPOS_AIN0_gc = (0x00<<0)      ; ADC input pin 0\n.equ ADC_MUXPOS_AIN1_gc = (0x01<<0)      ; ADC input pin 1\n.equ ADC_MUXPOS_AIN2_gc = (0x02<<0)      ; ADC input pin 2\n.equ ADC_MUXPOS_AIN3_gc = (0x03<<0)      ; ADC input pin 3\n.equ ADC_MUXPOS_AIN4_gc = (0x04<<0)      ; ADC input pin 4\n.equ ADC_MUXPOS_AIN5_gc = (0x05<<0)      ; ADC input pin 5\n.equ ADC_MUXPOS_AIN6_gc = (0x06<<0)      ; ADC input pin 6\n.equ ADC_MUXPOS_AIN7_gc = (0x07<<0)      ; ADC input pin 7\n.equ ADC_MUXPOS_AIN8_gc = (0x08<<0)      ; ADC input pin 8\n.equ ADC_MUXPOS_AIN9_gc = (0x09<<0)      ; ADC input pin 9\n.equ ADC_MUXPOS_AIN10_gc = (0x0A<<0)     ; ADC input pin 10\n.equ ADC_MUXPOS_AIN11_gc = (0x0B<<0)     ; ADC input pin 11\n.equ ADC_MUXPOS_DAC0_gc = (0x1C<<0)      ; DAC0\n.equ ADC_MUXPOS_INTREF_gc = (0x1D<<0)    ; Internal Ref\n.equ ADC_MUXPOS_TEMPSENSE_gc = (0x1E<<0) ; Temp sensor\n.equ ADC_MUXPOS_GND_gc = (0x1F<<0)       ; GND\n\n\n;*************************************************************************\n;** BOD - Bod interface\n;*************************************************************************\n\n; BOD_CTRLA masks\n.equ BOD_ACTIVE_gm = 0x0C                ; Operation in active mode group mask\n.equ BOD_ACTIVE_gp = 2                   ; Operation in active mode group position\n.equ BOD_ACTIVE0_bm = (1<<2)             ; Operation in active mode bit 0 mask\n.equ BOD_ACTIVE0_bp = 2                  ; Operation in active mode bit 0 position\n.equ BOD_ACTIVE1_bm = (1<<3)             ; Operation in active mode bit 1 mask\n.equ BOD_ACTIVE1_bp = 3                  ; Operation in active mode bit 1 position\n.equ BOD_SAMPFREQ_bm = 0x10              ; Sample frequency bit mask\n.equ BOD_SAMPFREQ_bp = 4                 ; Sample frequency bit position\n.equ BOD_SLEEP_gm = 0x03                 ; Operation in sleep mode group mask\n.equ BOD_SLEEP_gp = 0                    ; Operation in sleep mode group position\n.equ BOD_SLEEP0_bm = (1<<0)              ; Operation in sleep mode bit 0 mask\n.equ BOD_SLEEP0_bp = 0                   ; Operation in sleep mode bit 0 position\n.equ BOD_SLEEP1_bm = (1<<1)              ; Operation in sleep mode bit 1 mask\n.equ BOD_SLEEP1_bp = 1                   ; Operation in sleep mode bit 1 position\n\n; BOD_CTRLB masks\n.equ BOD_LVL_gm = 0x07                   ; Bod level group mask\n.equ BOD_LVL_gp = 0                      ; Bod level group position\n.equ BOD_LVL0_bm = (1<<0)                ; Bod level bit 0 mask\n.equ BOD_LVL0_bp = 0                     ; Bod level bit 0 position\n.equ BOD_LVL1_bm = (1<<1)                ; Bod level bit 1 mask\n.equ BOD_LVL1_bp = 1                     ; Bod level bit 1 position\n.equ BOD_LVL2_bm = (1<<2)                ; Bod level bit 2 mask\n.equ BOD_LVL2_bp = 2                     ; Bod level bit 2 position\n\n; BOD_INTCTRL masks\n.equ BOD_VLMCFG_gm = 0x06                ; Configuration group mask\n.equ BOD_VLMCFG_gp = 1                   ; Configuration group position\n.equ BOD_VLMCFG0_bm = (1<<1)             ; Configuration bit 0 mask\n.equ BOD_VLMCFG0_bp = 1                  ; Configuration bit 0 position\n.equ BOD_VLMCFG1_bm = (1<<2)             ; Configuration bit 1 mask\n.equ BOD_VLMCFG1_bp = 2                  ; Configuration bit 1 position\n.equ BOD_VLMIE_bm = 0x01                 ; voltage level monitor interrrupt enable bit mask\n.equ BOD_VLMIE_bp = 0                    ; voltage level monitor interrrupt enable bit position\n\n; BOD_INTFLAGS masks\n.equ BOD_VLMIF_bm = 0x01                 ; Voltage level monitor interrupt flag bit mask\n.equ BOD_VLMIF_bp = 0                    ; Voltage level monitor interrupt flag bit position\n\n; BOD_STATUS masks\n.equ BOD_VLMS_bm = 0x01                  ; Voltage level monitor status bit mask\n.equ BOD_VLMS_bp = 0                     ; Voltage level monitor status bit position\n\n; BOD_VLMCTRLA masks\n.equ BOD_VLMLVL_gm = 0x03                ; voltage level monitor level group mask\n.equ BOD_VLMLVL_gp = 0                   ; voltage level monitor level group position\n.equ BOD_VLMLVL0_bm = (1<<0)             ; voltage level monitor level bit 0 mask\n.equ BOD_VLMLVL0_bp = 0                  ; voltage level monitor level bit 0 position\n.equ BOD_VLMLVL1_bm = (1<<1)             ; voltage level monitor level bit 1 mask\n.equ BOD_VLMLVL1_bp = 1                  ; voltage level monitor level bit 1 position\n\n; Operation in active mode select\n.equ BOD_ACTIVE_DIS_gc = (0x00<<2)       ; Disabled\n.equ BOD_ACTIVE_ENABLED_gc = (0x01<<2)   ; Enabled\n.equ BOD_ACTIVE_SAMPLED_gc = (0x02<<2)   ; Sampled\n.equ BOD_ACTIVE_ENWAKE_gc = (0x03<<2)    ; Enabled with wakeup halt\n\n; Sample frequency select\n.equ BOD_SAMPFREQ_1KHZ_gc = (0x00<<4)    ; 1kHz sampling\n.equ BOD_SAMPFREQ_125Hz_gc = (0x01<<4)   ; 125Hz sampling\n\n; Operation in sleep mode select\n.equ BOD_SLEEP_DIS_gc = (0x00<<0)        ; Disabled\n.equ BOD_SLEEP_ENABLED_gc = (0x01<<0)    ; Enabled\n.equ BOD_SLEEP_SAMPLED_gc = (0x02<<0)    ; Sampled\n\n; Bod level select\n.equ BOD_LVL_BODLEVEL0_gc = (0x00<<0)    ; 1.8 V\n.equ BOD_LVL_BODLEVEL2_gc = (0x02<<0)    ; 2.6 V\n.equ BOD_LVL_BODLEVEL7_gc = (0x07<<0)    ; 4.2 V\n\n; Configuration select\n.equ BOD_VLMCFG_BELOW_gc = (0x00<<1)     ; Interrupt when supply goes below VLM level\n.equ BOD_VLMCFG_ABOVE_gc = (0x01<<1)     ; Interrupt when supply goes above VLM level\n.equ BOD_VLMCFG_CROSS_gc = (0x02<<1)     ; Interrupt when supply crosses VLM level\n\n; voltage level monitor level select\n.equ BOD_VLMLVL_5ABOVE_gc = (0x00<<0)    ; VLM threshold 5% above BOD level\n.equ BOD_VLMLVL_15ABOVE_gc = (0x01<<0)   ; VLM threshold 15% above BOD level\n.equ BOD_VLMLVL_25ABOVE_gc = (0x02<<0)   ; VLM threshold 25% above BOD level\n\n\n;*************************************************************************\n;** CCL - Configurable Custom Logic\n;*************************************************************************\n\n; CCL_CTRLA masks\n.equ CCL_ENABLE_bm = 0x01                ; Enable bit mask\n.equ CCL_ENABLE_bp = 0                   ; Enable bit position\n.equ CCL_RUNSTDBY_bm = 0x40              ; Run in Standby bit mask\n.equ CCL_RUNSTDBY_bp = 6                 ; Run in Standby bit position\n\n; CCL_LUT0CTRLA masks\n.equ CCL_CLKSRC_bm = 0x40                ; Clock Source Selection bit mask\n.equ CCL_CLKSRC_bp = 6                   ; Clock Source Selection bit position\n.equ CCL_EDGEDET_bm = 0x80               ; Edge Detection Enable bit mask\n.equ CCL_EDGEDET_bp = 7                  ; Edge Detection Enable bit position\n; Masks for CCL_ENABLE already defined\n.equ CCL_FILTSEL_gm = 0x30               ; Filter Selection group mask\n.equ CCL_FILTSEL_gp = 4                  ; Filter Selection group position\n.equ CCL_FILTSEL0_bm = (1<<4)            ; Filter Selection bit 0 mask\n.equ CCL_FILTSEL0_bp = 4                 ; Filter Selection bit 0 position\n.equ CCL_FILTSEL1_bm = (1<<5)            ; Filter Selection bit 1 mask\n.equ CCL_FILTSEL1_bp = 5                 ; Filter Selection bit 1 position\n.equ CCL_OUTEN_bm = 0x08                 ; Output Enable bit mask\n.equ CCL_OUTEN_bp = 3                    ; Output Enable bit position\n\n; CCL_LUT0CTRLB masks\n.equ CCL_INSEL0_gm = 0x0F                ; LUT Input 0 Source Selection group mask\n.equ CCL_INSEL0_gp = 0                   ; LUT Input 0 Source Selection group position\n.equ CCL_INSEL00_bm = (1<<0)             ; LUT Input 0 Source Selection bit 0 mask\n.equ CCL_INSEL00_bp = 0                  ; LUT Input 0 Source Selection bit 0 position\n.equ CCL_INSEL01_bm = (1<<1)             ; LUT Input 0 Source Selection bit 1 mask\n.equ CCL_INSEL01_bp = 1                  ; LUT Input 0 Source Selection bit 1 position\n.equ CCL_INSEL02_bm = (1<<2)             ; LUT Input 0 Source Selection bit 2 mask\n.equ CCL_INSEL02_bp = 2                  ; LUT Input 0 Source Selection bit 2 position\n.equ CCL_INSEL03_bm = (1<<3)             ; LUT Input 0 Source Selection bit 3 mask\n.equ CCL_INSEL03_bp = 3                  ; LUT Input 0 Source Selection bit 3 position\n.equ CCL_INSEL1_gm = 0xF0                ; LUT Input 1 Source Selection group mask\n.equ CCL_INSEL1_gp = 4                   ; LUT Input 1 Source Selection group position\n.equ CCL_INSEL10_bm = (1<<4)             ; LUT Input 1 Source Selection bit 0 mask\n.equ CCL_INSEL10_bp = 4                  ; LUT Input 1 Source Selection bit 0 position\n.equ CCL_INSEL11_bm = (1<<5)             ; LUT Input 1 Source Selection bit 1 mask\n.equ CCL_INSEL11_bp = 5                  ; LUT Input 1 Source Selection bit 1 position\n.equ CCL_INSEL12_bm = (1<<6)             ; LUT Input 1 Source Selection bit 2 mask\n.equ CCL_INSEL12_bp = 6                  ; LUT Input 1 Source Selection bit 2 position\n.equ CCL_INSEL13_bm = (1<<7)             ; LUT Input 1 Source Selection bit 3 mask\n.equ CCL_INSEL13_bp = 7                  ; LUT Input 1 Source Selection bit 3 position\n\n; CCL_LUT0CTRLC masks\n.equ CCL_INSEL2_gm = 0x0F                ; LUT Input 2 Source Selection group mask\n.equ CCL_INSEL2_gp = 0                   ; LUT Input 2 Source Selection group position\n.equ CCL_INSEL20_bm = (1<<0)             ; LUT Input 2 Source Selection bit 0 mask\n.equ CCL_INSEL20_bp = 0                  ; LUT Input 2 Source Selection bit 0 position\n.equ CCL_INSEL21_bm = (1<<1)             ; LUT Input 2 Source Selection bit 1 mask\n.equ CCL_INSEL21_bp = 1                  ; LUT Input 2 Source Selection bit 1 position\n.equ CCL_INSEL22_bm = (1<<2)             ; LUT Input 2 Source Selection bit 2 mask\n.equ CCL_INSEL22_bp = 2                  ; LUT Input 2 Source Selection bit 2 position\n.equ CCL_INSEL23_bm = (1<<3)             ; LUT Input 2 Source Selection bit 3 mask\n.equ CCL_INSEL23_bp = 3                  ; LUT Input 2 Source Selection bit 3 position\n\n; CCL_LUT1CTRLA masks\n; Masks for CCL_CLKSRC already defined\n; Masks for CCL_EDGEDET already defined\n; Masks for CCL_ENABLE already defined\n; Masks for CCL_FILTSEL already defined\n; Masks for CCL_OUTEN already defined\n\n; CCL_LUT1CTRLB masks\n; Masks for CCL_INSEL0 already defined\n; Masks for CCL_INSEL1 already defined\n\n; CCL_LUT1CTRLC masks\n; Masks for CCL_INSEL2 already defined\n\n; CCL_SEQCTRL0 masks\n.equ CCL_SEQSEL_gm = 0x07                ; Sequential Selection group mask\n.equ CCL_SEQSEL_gp = 0                   ; Sequential Selection group position\n.equ CCL_SEQSEL0_bm = (1<<0)             ; Sequential Selection bit 0 mask\n.equ CCL_SEQSEL0_bp = 0                  ; Sequential Selection bit 0 position\n.equ CCL_SEQSEL1_bm = (1<<1)             ; Sequential Selection bit 1 mask\n.equ CCL_SEQSEL1_bp = 1                  ; Sequential Selection bit 1 position\n.equ CCL_SEQSEL2_bm = (1<<2)             ; Sequential Selection bit 2 mask\n.equ CCL_SEQSEL2_bp = 2                  ; Sequential Selection bit 2 position\n\n; CCL_TRUTH0 masks\n.equ CCL_TRUTH_gm = 0xFF                 ; Truth Table group mask\n.equ CCL_TRUTH_gp = 0                    ; Truth Table group position\n.equ CCL_TRUTH0_bm = (1<<0)              ; Truth Table bit 0 mask\n.equ CCL_TRUTH0_bp = 0                   ; Truth Table bit 0 position\n.equ CCL_TRUTH1_bm = (1<<1)              ; Truth Table bit 1 mask\n.equ CCL_TRUTH1_bp = 1                   ; Truth Table bit 1 position\n.equ CCL_TRUTH2_bm = (1<<2)              ; Truth Table bit 2 mask\n.equ CCL_TRUTH2_bp = 2                   ; Truth Table bit 2 position\n.equ CCL_TRUTH3_bm = (1<<3)              ; Truth Table bit 3 mask\n.equ CCL_TRUTH3_bp = 3                   ; Truth Table bit 3 position\n.equ CCL_TRUTH4_bm = (1<<4)              ; Truth Table bit 4 mask\n.equ CCL_TRUTH4_bp = 4                   ; Truth Table bit 4 position\n.equ CCL_TRUTH5_bm = (1<<5)              ; Truth Table bit 5 mask\n.equ CCL_TRUTH5_bp = 5                   ; Truth Table bit 5 position\n.equ CCL_TRUTH6_bm = (1<<6)              ; Truth Table bit 6 mask\n.equ CCL_TRUTH6_bp = 6                   ; Truth Table bit 6 position\n.equ CCL_TRUTH7_bm = (1<<7)              ; Truth Table bit 7 mask\n.equ CCL_TRUTH7_bp = 7                   ; Truth Table bit 7 position\n\n; CCL_TRUTH1 masks\n; Masks for CCL_TRUTH already defined\n\n; Edge Detection Enable select\n.equ CCL_EDGEDET_DIS_gc = (0x00<<7)      ; Edge detector is disabled\n.equ CCL_EDGEDET_EN_gc = (0x01<<7)       ; Edge detector is enabled\n\n; Filter Selection select\n.equ CCL_FILTSEL_DISABLE_gc = (0x00<<4)  ; Filter disabled\n.equ CCL_FILTSEL_SYNCH_gc = (0x01<<4)    ; Synchronizer enabled\n.equ CCL_FILTSEL_FILTER_gc = (0x02<<4)   ; Filter enabled\n\n; LUT Input 0 Source Selection select\n.equ CCL_INSEL0_MASK_gc = (0x00<<0)      ; Masked input\n.equ CCL_INSEL0_FEEDBACK_gc = (0x01<<0)  ; Feedback input source\n.equ CCL_INSEL0_LINK_gc = (0x02<<0)      ; Linked LUT input source\n.equ CCL_INSEL0_EVENT0_gc = (0x03<<0)    ; Event input source 0\n.equ CCL_INSEL0_EVENT1_gc = (0x04<<0)    ; Event input source 1\n.equ CCL_INSEL0_IO_gc = (0x05<<0)        ; IO pin LUTn-IN0 input source\n.equ CCL_INSEL0_AC0_gc = (0x06<<0)       ; AC0 OUT input source\n.equ CCL_INSEL0_TCB0_gc = (0x07<<0)      ; TCB0 WO input source\n.equ CCL_INSEL0_TCA0_gc = (0x08<<0)      ; TCA0 WO0 input source\n.equ CCL_INSEL0_TCD0_gc = (0x09<<0)      ; TCD0 WOA input source\n.equ CCL_INSEL0_USART0_gc = (0x0A<<0)    ; USART0 XCK input source\n.equ CCL_INSEL0_SPI0_gc = (0x0B<<0)      ; SPI0 SCK source\n\n; LUT Input 1 Source Selection select\n.equ CCL_INSEL1_MASK_gc = (0x00<<4)      ; Masked input\n.equ CCL_INSEL1_FEEDBACK_gc = (0x01<<4)  ; Feedback input source\n.equ CCL_INSEL1_LINK_gc = (0x02<<4)      ; Linked LUT input source\n.equ CCL_INSEL1_EVENT0_gc = (0x03<<4)    ; Event input source 0\n.equ CCL_INSEL1_EVENT1_gc = (0x04<<4)    ; Event input source 1\n.equ CCL_INSEL1_IO_gc = (0x05<<4)        ; IO pin LUTn-N1 input source\n.equ CCL_INSEL1_AC0_gc = (0x06<<4)       ; AC0 OUT input source\n.equ CCL_INSEL1_TCB0_gc = (0x07<<4)      ; TCB0 WO input source\n.equ CCL_INSEL1_TCA0_gc = (0x08<<4)      ; TCA0 WO1 input source\n.equ CCL_INSEL1_TCD0_gc = (0x09<<4)      ; TCD0 WOB input source\n.equ CCL_INSEL1_USART0_gc = (0x0A<<4)    ; USART0 TXD input source\n.equ CCL_INSEL1_SPI0_gc = (0x0B<<4)      ; SPI0 MOSI input source\n\n; LUT Input 2 Source Selection select\n.equ CCL_INSEL2_MASK_gc = (0x00<<0)      ; Masked input\n.equ CCL_INSEL2_FEEDBACK_gc = (0x01<<0)  ; Feedback input source\n.equ CCL_INSEL2_LINK_gc = (0x02<<0)      ; Linked LUT input source\n.equ CCL_INSEL2_EVENT0_gc = (0x03<<0)    ; Event input source 0\n.equ CCL_INSEL2_EVENT1_gc = (0x04<<0)    ; Event input source 1\n.equ CCL_INSEL2_IO_gc = (0x05<<0)        ; IO pin LUTn-IN2 input source\n.equ CCL_INSEL2_AC0_gc = (0x06<<0)       ; AC0 OUT input source\n.equ CCL_INSEL2_TCB0_gc = (0x07<<0)      ; TCB0 WO input source\n.equ CCL_INSEL2_TCA0_gc = (0x08<<0)      ; TCA0 WO2 input source\n.equ CCL_INSEL2_TCD0_gc = (0x09<<0)      ; TCD0 WOA input source\n.equ CCL_INSEL2_SPI0_gc = (0x0B<<0)      ; SPI0 MISO source\n\n; Sequential Selection select\n.equ CCL_SEQSEL_DISABLE_gc = (0x00<<0)   ; Sequential logic disabled\n.equ CCL_SEQSEL_DFF_gc = (0x01<<0)       ; D FlipFlop\n.equ CCL_SEQSEL_JK_gc = (0x02<<0)        ; JK FlipFlop\n.equ CCL_SEQSEL_LATCH_gc = (0x03<<0)     ; D Latch\n.equ CCL_SEQSEL_RS_gc = (0x04<<0)        ; RS Latch\n\n\n;*************************************************************************\n;** CLKCTRL - Clock controller\n;*************************************************************************\n\n; CLKCTRL_MCLKCTRLA masks\n.equ CLKCTRL_CLKOUT_bm = 0x80            ; System clock out bit mask\n.equ CLKCTRL_CLKOUT_bp = 7               ; System clock out bit position\n.equ CLKCTRL_CLKSEL_gm = 0x03            ; clock select group mask\n.equ CLKCTRL_CLKSEL_gp = 0               ; clock select group position\n.equ CLKCTRL_CLKSEL0_bm = (1<<0)         ; clock select bit 0 mask\n.equ CLKCTRL_CLKSEL0_bp = 0              ; clock select bit 0 position\n.equ CLKCTRL_CLKSEL1_bm = (1<<1)         ; clock select bit 1 mask\n.equ CLKCTRL_CLKSEL1_bp = 1              ; clock select bit 1 position\n\n; CLKCTRL_MCLKCTRLB masks\n.equ CLKCTRL_PDIV_gm = 0x1E              ; Prescaler division group mask\n.equ CLKCTRL_PDIV_gp = 1                 ; Prescaler division group position\n.equ CLKCTRL_PDIV0_bm = (1<<1)           ; Prescaler division bit 0 mask\n.equ CLKCTRL_PDIV0_bp = 1                ; Prescaler division bit 0 position\n.equ CLKCTRL_PDIV1_bm = (1<<2)           ; Prescaler division bit 1 mask\n.equ CLKCTRL_PDIV1_bp = 2                ; Prescaler division bit 1 position\n.equ CLKCTRL_PDIV2_bm = (1<<3)           ; Prescaler division bit 2 mask\n.equ CLKCTRL_PDIV2_bp = 3                ; Prescaler division bit 2 position\n.equ CLKCTRL_PDIV3_bm = (1<<4)           ; Prescaler division bit 3 mask\n.equ CLKCTRL_PDIV3_bp = 4                ; Prescaler division bit 3 position\n.equ CLKCTRL_PEN_bm = 0x01               ; Prescaler enable bit mask\n.equ CLKCTRL_PEN_bp = 0                  ; Prescaler enable bit position\n\n; CLKCTRL_MCLKLOCK masks\n.equ CLKCTRL_LOCKEN_bm = 0x01            ; lock ebable bit mask\n.equ CLKCTRL_LOCKEN_bp = 0               ; lock ebable bit position\n\n; CLKCTRL_MCLKSTATUS masks\n.equ CLKCTRL_EXTS_bm = 0x80              ; External Clock status bit mask\n.equ CLKCTRL_EXTS_bp = 7                 ; External Clock status bit position\n.equ CLKCTRL_OSC20MS_bm = 0x10           ; 20MHz oscillator status bit mask\n.equ CLKCTRL_OSC20MS_bp = 4              ; 20MHz oscillator status bit position\n.equ CLKCTRL_OSC32KS_bm = 0x20           ; 32KHz oscillator status bit mask\n.equ CLKCTRL_OSC32KS_bp = 5              ; 32KHz oscillator status bit position\n.equ CLKCTRL_SOSC_bm = 0x01              ; System Oscillator changing bit mask\n.equ CLKCTRL_SOSC_bp = 0                 ; System Oscillator changing bit position\n\n; CLKCTRL_OSC20MCALIBA masks\n.equ CLKCTRL_CAL20M_gm = 0x3F            ; Calibration group mask\n.equ CLKCTRL_CAL20M_gp = 0               ; Calibration group position\n.equ CLKCTRL_CAL20M0_bm = (1<<0)         ; Calibration bit 0 mask\n.equ CLKCTRL_CAL20M0_bp = 0              ; Calibration bit 0 position\n.equ CLKCTRL_CAL20M1_bm = (1<<1)         ; Calibration bit 1 mask\n.equ CLKCTRL_CAL20M1_bp = 1              ; Calibration bit 1 position\n.equ CLKCTRL_CAL20M2_bm = (1<<2)         ; Calibration bit 2 mask\n.equ CLKCTRL_CAL20M2_bp = 2              ; Calibration bit 2 position\n.equ CLKCTRL_CAL20M3_bm = (1<<3)         ; Calibration bit 3 mask\n.equ CLKCTRL_CAL20M3_bp = 3              ; Calibration bit 3 position\n.equ CLKCTRL_CAL20M4_bm = (1<<4)         ; Calibration bit 4 mask\n.equ CLKCTRL_CAL20M4_bp = 4              ; Calibration bit 4 position\n.equ CLKCTRL_CAL20M5_bm = (1<<5)         ; Calibration bit 5 mask\n.equ CLKCTRL_CAL20M5_bp = 5              ; Calibration bit 5 position\n\n; CLKCTRL_OSC20MCALIBB masks\n.equ CLKCTRL_LOCK_bm = 0x80              ; Lock bit mask\n.equ CLKCTRL_LOCK_bp = 7                 ; Lock bit position\n.equ CLKCTRL_TEMPCAL20M_gm = 0x0F        ; Oscillator temperature coefficient group mask\n.equ CLKCTRL_TEMPCAL20M_gp = 0           ; Oscillator temperature coefficient group position\n.equ CLKCTRL_TEMPCAL20M0_bm = (1<<0)     ; Oscillator temperature coefficient bit 0 mask\n.equ CLKCTRL_TEMPCAL20M0_bp = 0          ; Oscillator temperature coefficient bit 0 position\n.equ CLKCTRL_TEMPCAL20M1_bm = (1<<1)     ; Oscillator temperature coefficient bit 1 mask\n.equ CLKCTRL_TEMPCAL20M1_bp = 1          ; Oscillator temperature coefficient bit 1 position\n.equ CLKCTRL_TEMPCAL20M2_bm = (1<<2)     ; Oscillator temperature coefficient bit 2 mask\n.equ CLKCTRL_TEMPCAL20M2_bp = 2          ; Oscillator temperature coefficient bit 2 position\n.equ CLKCTRL_TEMPCAL20M3_bm = (1<<3)     ; Oscillator temperature coefficient bit 3 mask\n.equ CLKCTRL_TEMPCAL20M3_bp = 3          ; Oscillator temperature coefficient bit 3 position\n\n; CLKCTRL_OSC20MCTRLA masks\n.equ CLKCTRL_RUNSTDBY_bm = 0x02          ; Run standby bit mask\n.equ CLKCTRL_RUNSTDBY_bp = 1             ; Run standby bit position\n\n; CLKCTRL_OSC32KCTRLA masks\n; Masks for CLKCTRL_RUNSTDBY already defined\n\n; clock select select\n.equ CLKCTRL_CLKSEL_OSC20M_gc = (0x00<<0) ; 20MHz internal oscillator\n.equ CLKCTRL_CLKSEL_OSCULP32K_gc = (0x01<<0) ; 32KHz internal Ultra Low Power oscillator\n.equ CLKCTRL_CLKSEL_EXTCLK_gc = (0x03<<0) ; External clock\n\n; Prescaler division select\n.equ CLKCTRL_PDIV_2X_gc = (0x00<<1)      ; 2X\n.equ CLKCTRL_PDIV_4X_gc = (0x01<<1)      ; 4X\n.equ CLKCTRL_PDIV_8X_gc = (0x02<<1)      ; 8X\n.equ CLKCTRL_PDIV_16X_gc = (0x03<<1)     ; 16X\n.equ CLKCTRL_PDIV_32X_gc = (0x04<<1)     ; 32X\n.equ CLKCTRL_PDIV_64X_gc = (0x05<<1)     ; 64X\n.equ CLKCTRL_PDIV_6X_gc = (0x08<<1)      ; 6X\n.equ CLKCTRL_PDIV_10X_gc = (0x09<<1)     ; 10X\n.equ CLKCTRL_PDIV_12X_gc = (0x0A<<1)     ; 12X\n.equ CLKCTRL_PDIV_24X_gc = (0x0B<<1)     ; 24X\n.equ CLKCTRL_PDIV_48X_gc = (0x0C<<1)     ; 48X\n\n\n;*************************************************************************\n;** CPU - CPU\n;*************************************************************************\n\n; CPU_CCP masks\n.equ CPU_CCP_gm = 0xFF                   ; CCP signature group mask\n.equ CPU_CCP_gp = 0                      ; CCP signature group position\n.equ CPU_CCP0_bm = (1<<0)                ; CCP signature bit 0 mask\n.equ CPU_CCP0_bp = 0                     ; CCP signature bit 0 position\n.equ CPU_CCP1_bm = (1<<1)                ; CCP signature bit 1 mask\n.equ CPU_CCP1_bp = 1                     ; CCP signature bit 1 position\n.equ CPU_CCP2_bm = (1<<2)                ; CCP signature bit 2 mask\n.equ CPU_CCP2_bp = 2                     ; CCP signature bit 2 position\n.equ CPU_CCP3_bm = (1<<3)                ; CCP signature bit 3 mask\n.equ CPU_CCP3_bp = 3                     ; CCP signature bit 3 position\n.equ CPU_CCP4_bm = (1<<4)                ; CCP signature bit 4 mask\n.equ CPU_CCP4_bp = 4                     ; CCP signature bit 4 position\n.equ CPU_CCP5_bm = (1<<5)                ; CCP signature bit 5 mask\n.equ CPU_CCP5_bp = 5                     ; CCP signature bit 5 position\n.equ CPU_CCP6_bm = (1<<6)                ; CCP signature bit 6 mask\n.equ CPU_CCP6_bp = 6                     ; CCP signature bit 6 position\n.equ CPU_CCP7_bm = (1<<7)                ; CCP signature bit 7 mask\n.equ CPU_CCP7_bp = 7                     ; CCP signature bit 7 position\n\n; CPU_SREG masks\n.equ CPU_C_bm = 0x01                     ; Carry Flag bit mask\n.equ CPU_C_bp = 0                        ; Carry Flag bit position\n.equ CPU_H_bm = 0x20                     ; Half Carry Flag bit mask\n.equ CPU_H_bp = 5                        ; Half Carry Flag bit position\n.equ CPU_I_bm = 0x80                     ; Global Interrupt Enable Flag bit mask\n.equ CPU_I_bp = 7                        ; Global Interrupt Enable Flag bit position\n.equ CPU_N_bm = 0x04                     ; Negative Flag bit mask\n.equ CPU_N_bp = 2                        ; Negative Flag bit position\n.equ CPU_S_bm = 0x10                     ; N Exclusive Or V Flag bit mask\n.equ CPU_S_bp = 4                        ; N Exclusive Or V Flag bit position\n.equ CPU_T_bm = 0x40                     ; Transfer Bit bit mask\n.equ CPU_T_bp = 6                        ; Transfer Bit bit position\n.equ CPU_V_bm = 0x08                     ; Two's Complement Overflow Flag bit mask\n.equ CPU_V_bp = 3                        ; Two's Complement Overflow Flag bit position\n.equ CPU_Z_bm = 0x02                     ; Zero Flag bit mask\n.equ CPU_Z_bp = 1                        ; Zero Flag bit position\n\n; CCP signature select\n.equ CPU_CCP_SPM_gc = (0x9D<<0)          ; SPM Instruction Protection\n.equ CPU_CCP_IOREG_gc = (0xD8<<0)        ; IO Register Protection\n\n\n;*************************************************************************\n;** CPUINT - Interrupt Controller\n;*************************************************************************\n\n; CPUINT_CTRLA masks\n.equ CPUINT_CVT_bm = 0x20                ; Compact Vector Table bit mask\n.equ CPUINT_CVT_bp = 5                   ; Compact Vector Table bit position\n.equ CPUINT_IVSEL_bm = 0x40              ; Interrupt Vector Select bit mask\n.equ CPUINT_IVSEL_bp = 6                 ; Interrupt Vector Select bit position\n.equ CPUINT_LVL0RR_bm = 0x01             ; Round-robin Scheduling Enable bit mask\n.equ CPUINT_LVL0RR_bp = 0                ; Round-robin Scheduling Enable bit position\n\n; CPUINT_LVL0PRI masks\n.equ CPUINT_LVL0PRI_gm = 0xFF            ; Interrupt Level Priority group mask\n.equ CPUINT_LVL0PRI_gp = 0               ; Interrupt Level Priority group position\n.equ CPUINT_LVL0PRI0_bm = (1<<0)         ; Interrupt Level Priority bit 0 mask\n.equ CPUINT_LVL0PRI0_bp = 0              ; Interrupt Level Priority bit 0 position\n.equ CPUINT_LVL0PRI1_bm = (1<<1)         ; Interrupt Level Priority bit 1 mask\n.equ CPUINT_LVL0PRI1_bp = 1              ; Interrupt Level Priority bit 1 position\n.equ CPUINT_LVL0PRI2_bm = (1<<2)         ; Interrupt Level Priority bit 2 mask\n.equ CPUINT_LVL0PRI2_bp = 2              ; Interrupt Level Priority bit 2 position\n.equ CPUINT_LVL0PRI3_bm = (1<<3)         ; Interrupt Level Priority bit 3 mask\n.equ CPUINT_LVL0PRI3_bp = 3              ; Interrupt Level Priority bit 3 position\n.equ CPUINT_LVL0PRI4_bm = (1<<4)         ; Interrupt Level Priority bit 4 mask\n.equ CPUINT_LVL0PRI4_bp = 4              ; Interrupt Level Priority bit 4 position\n.equ CPUINT_LVL0PRI5_bm = (1<<5)         ; Interrupt Level Priority bit 5 mask\n.equ CPUINT_LVL0PRI5_bp = 5              ; Interrupt Level Priority bit 5 position\n.equ CPUINT_LVL0PRI6_bm = (1<<6)         ; Interrupt Level Priority bit 6 mask\n.equ CPUINT_LVL0PRI6_bp = 6              ; Interrupt Level Priority bit 6 position\n.equ CPUINT_LVL0PRI7_bm = (1<<7)         ; Interrupt Level Priority bit 7 mask\n.equ CPUINT_LVL0PRI7_bp = 7              ; Interrupt Level Priority bit 7 position\n\n; CPUINT_LVL1VEC masks\n.equ CPUINT_LVL1VEC_gm = 0xFF            ; Interrupt Vector with High Priority group mask\n.equ CPUINT_LVL1VEC_gp = 0               ; Interrupt Vector with High Priority group position\n.equ CPUINT_LVL1VEC0_bm = (1<<0)         ; Interrupt Vector with High Priority bit 0 mask\n.equ CPUINT_LVL1VEC0_bp = 0              ; Interrupt Vector with High Priority bit 0 position\n.equ CPUINT_LVL1VEC1_bm = (1<<1)         ; Interrupt Vector with High Priority bit 1 mask\n.equ CPUINT_LVL1VEC1_bp = 1              ; Interrupt Vector with High Priority bit 1 position\n.equ CPUINT_LVL1VEC2_bm = (1<<2)         ; Interrupt Vector with High Priority bit 2 mask\n.equ CPUINT_LVL1VEC2_bp = 2              ; Interrupt Vector with High Priority bit 2 position\n.equ CPUINT_LVL1VEC3_bm = (1<<3)         ; Interrupt Vector with High Priority bit 3 mask\n.equ CPUINT_LVL1VEC3_bp = 3              ; Interrupt Vector with High Priority bit 3 position\n.equ CPUINT_LVL1VEC4_bm = (1<<4)         ; Interrupt Vector with High Priority bit 4 mask\n.equ CPUINT_LVL1VEC4_bp = 4              ; Interrupt Vector with High Priority bit 4 position\n.equ CPUINT_LVL1VEC5_bm = (1<<5)         ; Interrupt Vector with High Priority bit 5 mask\n.equ CPUINT_LVL1VEC5_bp = 5              ; Interrupt Vector with High Priority bit 5 position\n.equ CPUINT_LVL1VEC6_bm = (1<<6)         ; Interrupt Vector with High Priority bit 6 mask\n.equ CPUINT_LVL1VEC6_bp = 6              ; Interrupt Vector with High Priority bit 6 position\n.equ CPUINT_LVL1VEC7_bm = (1<<7)         ; Interrupt Vector with High Priority bit 7 mask\n.equ CPUINT_LVL1VEC7_bp = 7              ; Interrupt Vector with High Priority bit 7 position\n\n; CPUINT_STATUS masks\n.equ CPUINT_LVL0EX_bm = 0x01             ; Level 0 Interrupt Executing bit mask\n.equ CPUINT_LVL0EX_bp = 0                ; Level 0 Interrupt Executing bit position\n.equ CPUINT_LVL1EX_bm = 0x02             ; Level 1 Interrupt Executing bit mask\n.equ CPUINT_LVL1EX_bp = 1                ; Level 1 Interrupt Executing bit position\n.equ CPUINT_NMIEX_bm = 0x80              ; Non-maskable Interrupt Executing bit mask\n.equ CPUINT_NMIEX_bp = 7                 ; Non-maskable Interrupt Executing bit position\n\n\n;*************************************************************************\n;** CRCSCAN - CRCSCAN\n;*************************************************************************\n\n; CRCSCAN_CTRLA masks\n.equ CRCSCAN_ENABLE_bm = 0x01            ; Enable CRC scan bit mask\n.equ CRCSCAN_ENABLE_bp = 0               ; Enable CRC scan bit position\n.equ CRCSCAN_NMIEN_bm = 0x02             ; Enable NMI Trigger bit mask\n.equ CRCSCAN_NMIEN_bp = 1                ; Enable NMI Trigger bit position\n.equ CRCSCAN_RESET_bm = 0x80             ; Reset CRC scan bit mask\n.equ CRCSCAN_RESET_bp = 7                ; Reset CRC scan bit position\n\n; CRCSCAN_CTRLB masks\n.equ CRCSCAN_MODE_gm = 0x30              ; CRC Flash Access Mode group mask\n.equ CRCSCAN_MODE_gp = 4                 ; CRC Flash Access Mode group position\n.equ CRCSCAN_MODE0_bm = (1<<4)           ; CRC Flash Access Mode bit 0 mask\n.equ CRCSCAN_MODE0_bp = 4                ; CRC Flash Access Mode bit 0 position\n.equ CRCSCAN_MODE1_bm = (1<<5)           ; CRC Flash Access Mode bit 1 mask\n.equ CRCSCAN_MODE1_bp = 5                ; CRC Flash Access Mode bit 1 position\n.equ CRCSCAN_SRC_gm = 0x03               ; CRC Source group mask\n.equ CRCSCAN_SRC_gp = 0                  ; CRC Source group position\n.equ CRCSCAN_SRC0_bm = (1<<0)            ; CRC Source bit 0 mask\n.equ CRCSCAN_SRC0_bp = 0                 ; CRC Source bit 0 position\n.equ CRCSCAN_SRC1_bm = (1<<1)            ; CRC Source bit 1 mask\n.equ CRCSCAN_SRC1_bp = 1                 ; CRC Source bit 1 position\n\n; CRCSCAN_STATUS masks\n.equ CRCSCAN_BUSY_bm = 0x01              ; CRC Busy bit mask\n.equ CRCSCAN_BUSY_bp = 0                 ; CRC Busy bit position\n.equ CRCSCAN_OK_bm = 0x02                ; CRC Ok bit mask\n.equ CRCSCAN_OK_bp = 1                   ; CRC Ok bit position\n\n; CRC Flash Access Mode select\n.equ CRCSCAN_MODE_PRIORITY_gc = (0x00<<4) ; Priority to flash\n.equ CRCSCAN_MODE_RESERVED_gc = (0x01<<4) ; Reserved\n.equ CRCSCAN_MODE_BACKGROUND_gc = (0x02<<4) ; Lowest priority to flash\n.equ CRCSCAN_MODE_CONTINUOUS_gc = (0x03<<4) ; Continuous checks in background\n\n; CRC Source select\n.equ CRCSCAN_SRC_FLASH_gc = (0x00<<0)    ; CRC on entire flash\n.equ CRCSCAN_SRC_APPLICATION_gc = (0x01<<0) ; CRC on boot and appl section of flash\n.equ CRCSCAN_SRC_BOOT_gc = (0x02<<0)     ; CRC on boot section of flash\n\n\n;*************************************************************************\n;** EVSYS - Event System\n;*************************************************************************\n\n; EVSYS_ASYNCCH0 masks\n.equ EVSYS_ASYNCCH0_gm = 0xFF            ; Asynchronous Channel 0 Generator Selection group mask\n.equ EVSYS_ASYNCCH0_gp = 0               ; Asynchronous Channel 0 Generator Selection group position\n.equ EVSYS_ASYNCCH00_bm = (1<<0)         ; Asynchronous Channel 0 Generator Selection bit 0 mask\n.equ EVSYS_ASYNCCH00_bp = 0              ; Asynchronous Channel 0 Generator Selection bit 0 position\n.equ EVSYS_ASYNCCH01_bm = (1<<1)         ; Asynchronous Channel 0 Generator Selection bit 1 mask\n.equ EVSYS_ASYNCCH01_bp = 1              ; Asynchronous Channel 0 Generator Selection bit 1 position\n.equ EVSYS_ASYNCCH02_bm = (1<<2)         ; Asynchronous Channel 0 Generator Selection bit 2 mask\n.equ EVSYS_ASYNCCH02_bp = 2              ; Asynchronous Channel 0 Generator Selection bit 2 position\n.equ EVSYS_ASYNCCH03_bm = (1<<3)         ; Asynchronous Channel 0 Generator Selection bit 3 mask\n.equ EVSYS_ASYNCCH03_bp = 3              ; Asynchronous Channel 0 Generator Selection bit 3 position\n.equ EVSYS_ASYNCCH04_bm = (1<<4)         ; Asynchronous Channel 0 Generator Selection bit 4 mask\n.equ EVSYS_ASYNCCH04_bp = 4              ; Asynchronous Channel 0 Generator Selection bit 4 position\n.equ EVSYS_ASYNCCH05_bm = (1<<5)         ; Asynchronous Channel 0 Generator Selection bit 5 mask\n.equ EVSYS_ASYNCCH05_bp = 5              ; Asynchronous Channel 0 Generator Selection bit 5 position\n.equ EVSYS_ASYNCCH06_bm = (1<<6)         ; Asynchronous Channel 0 Generator Selection bit 6 mask\n.equ EVSYS_ASYNCCH06_bp = 6              ; Asynchronous Channel 0 Generator Selection bit 6 position\n.equ EVSYS_ASYNCCH07_bm = (1<<7)         ; Asynchronous Channel 0 Generator Selection bit 7 mask\n.equ EVSYS_ASYNCCH07_bp = 7              ; Asynchronous Channel 0 Generator Selection bit 7 position\n\n; EVSYS_ASYNCCH1 masks\n.equ EVSYS_ASYNCCH1_gm = 0xFF            ; Asynchronous Channel 1 Generator Selection group mask\n.equ EVSYS_ASYNCCH1_gp = 0               ; Asynchronous Channel 1 Generator Selection group position\n.equ EVSYS_ASYNCCH10_bm = (1<<0)         ; Asynchronous Channel 1 Generator Selection bit 0 mask\n.equ EVSYS_ASYNCCH10_bp = 0              ; Asynchronous Channel 1 Generator Selection bit 0 position\n.equ EVSYS_ASYNCCH11_bm = (1<<1)         ; Asynchronous Channel 1 Generator Selection bit 1 mask\n.equ EVSYS_ASYNCCH11_bp = 1              ; Asynchronous Channel 1 Generator Selection bit 1 position\n.equ EVSYS_ASYNCCH12_bm = (1<<2)         ; Asynchronous Channel 1 Generator Selection bit 2 mask\n.equ EVSYS_ASYNCCH12_bp = 2              ; Asynchronous Channel 1 Generator Selection bit 2 position\n.equ EVSYS_ASYNCCH13_bm = (1<<3)         ; Asynchronous Channel 1 Generator Selection bit 3 mask\n.equ EVSYS_ASYNCCH13_bp = 3              ; Asynchronous Channel 1 Generator Selection bit 3 position\n.equ EVSYS_ASYNCCH14_bm = (1<<4)         ; Asynchronous Channel 1 Generator Selection bit 4 mask\n.equ EVSYS_ASYNCCH14_bp = 4              ; Asynchronous Channel 1 Generator Selection bit 4 position\n.equ EVSYS_ASYNCCH15_bm = (1<<5)         ; Asynchronous Channel 1 Generator Selection bit 5 mask\n.equ EVSYS_ASYNCCH15_bp = 5              ; Asynchronous Channel 1 Generator Selection bit 5 position\n.equ EVSYS_ASYNCCH16_bm = (1<<6)         ; Asynchronous Channel 1 Generator Selection bit 6 mask\n.equ EVSYS_ASYNCCH16_bp = 6              ; Asynchronous Channel 1 Generator Selection bit 6 position\n.equ EVSYS_ASYNCCH17_bm = (1<<7)         ; Asynchronous Channel 1 Generator Selection bit 7 mask\n.equ EVSYS_ASYNCCH17_bp = 7              ; Asynchronous Channel 1 Generator Selection bit 7 position\n\n; EVSYS_ASYNCUSER0 masks\n.equ EVSYS_ASYNCUSER0_gm = 0xFF          ; Asynchronous User Ch 0 Input Selection - TCB0 group mask\n.equ EVSYS_ASYNCUSER0_gp = 0             ; Asynchronous User Ch 0 Input Selection - TCB0 group position\n.equ EVSYS_ASYNCUSER00_bm = (1<<0)       ; Asynchronous User Ch 0 Input Selection - TCB0 bit 0 mask\n.equ EVSYS_ASYNCUSER00_bp = 0            ; Asynchronous User Ch 0 Input Selection - TCB0 bit 0 position\n.equ EVSYS_ASYNCUSER01_bm = (1<<1)       ; Asynchronous User Ch 0 Input Selection - TCB0 bit 1 mask\n.equ EVSYS_ASYNCUSER01_bp = 1            ; Asynchronous User Ch 0 Input Selection - TCB0 bit 1 position\n.equ EVSYS_ASYNCUSER02_bm = (1<<2)       ; Asynchronous User Ch 0 Input Selection - TCB0 bit 2 mask\n.equ EVSYS_ASYNCUSER02_bp = 2            ; Asynchronous User Ch 0 Input Selection - TCB0 bit 2 position\n.equ EVSYS_ASYNCUSER03_bm = (1<<3)       ; Asynchronous User Ch 0 Input Selection - TCB0 bit 3 mask\n.equ EVSYS_ASYNCUSER03_bp = 3            ; Asynchronous User Ch 0 Input Selection - TCB0 bit 3 position\n.equ EVSYS_ASYNCUSER04_bm = (1<<4)       ; Asynchronous User Ch 0 Input Selection - TCB0 bit 4 mask\n.equ EVSYS_ASYNCUSER04_bp = 4            ; Asynchronous User Ch 0 Input Selection - TCB0 bit 4 position\n.equ EVSYS_ASYNCUSER05_bm = (1<<5)       ; Asynchronous User Ch 0 Input Selection - TCB0 bit 5 mask\n.equ EVSYS_ASYNCUSER05_bp = 5            ; Asynchronous User Ch 0 Input Selection - TCB0 bit 5 position\n.equ EVSYS_ASYNCUSER06_bm = (1<<6)       ; Asynchronous User Ch 0 Input Selection - TCB0 bit 6 mask\n.equ EVSYS_ASYNCUSER06_bp = 6            ; Asynchronous User Ch 0 Input Selection - TCB0 bit 6 position\n.equ EVSYS_ASYNCUSER07_bm = (1<<7)       ; Asynchronous User Ch 0 Input Selection - TCB0 bit 7 mask\n.equ EVSYS_ASYNCUSER07_bp = 7            ; Asynchronous User Ch 0 Input Selection - TCB0 bit 7 position\n\n; EVSYS_ASYNCUSER1 masks\n.equ EVSYS_ASYNCUSER1_gm = 0xFF          ; Asynchronous User Ch 1 Input Selection - ADC0 group mask\n.equ EVSYS_ASYNCUSER1_gp = 0             ; Asynchronous User Ch 1 Input Selection - ADC0 group position\n.equ EVSYS_ASYNCUSER10_bm = (1<<0)       ; Asynchronous User Ch 1 Input Selection - ADC0 bit 0 mask\n.equ EVSYS_ASYNCUSER10_bp = 0            ; Asynchronous User Ch 1 Input Selection - ADC0 bit 0 position\n.equ EVSYS_ASYNCUSER11_bm = (1<<1)       ; Asynchronous User Ch 1 Input Selection - ADC0 bit 1 mask\n.equ EVSYS_ASYNCUSER11_bp = 1            ; Asynchronous User Ch 1 Input Selection - ADC0 bit 1 position\n.equ EVSYS_ASYNCUSER12_bm = (1<<2)       ; Asynchronous User Ch 1 Input Selection - ADC0 bit 2 mask\n.equ EVSYS_ASYNCUSER12_bp = 2            ; Asynchronous User Ch 1 Input Selection - ADC0 bit 2 position\n.equ EVSYS_ASYNCUSER13_bm = (1<<3)       ; Asynchronous User Ch 1 Input Selection - ADC0 bit 3 mask\n.equ EVSYS_ASYNCUSER13_bp = 3            ; Asynchronous User Ch 1 Input Selection - ADC0 bit 3 position\n.equ EVSYS_ASYNCUSER14_bm = (1<<4)       ; Asynchronous User Ch 1 Input Selection - ADC0 bit 4 mask\n.equ EVSYS_ASYNCUSER14_bp = 4            ; Asynchronous User Ch 1 Input Selection - ADC0 bit 4 position\n.equ EVSYS_ASYNCUSER15_bm = (1<<5)       ; Asynchronous User Ch 1 Input Selection - ADC0 bit 5 mask\n.equ EVSYS_ASYNCUSER15_bp = 5            ; Asynchronous User Ch 1 Input Selection - ADC0 bit 5 position\n.equ EVSYS_ASYNCUSER16_bm = (1<<6)       ; Asynchronous User Ch 1 Input Selection - ADC0 bit 6 mask\n.equ EVSYS_ASYNCUSER16_bp = 6            ; Asynchronous User Ch 1 Input Selection - ADC0 bit 6 position\n.equ EVSYS_ASYNCUSER17_bm = (1<<7)       ; Asynchronous User Ch 1 Input Selection - ADC0 bit 7 mask\n.equ EVSYS_ASYNCUSER17_bp = 7            ; Asynchronous User Ch 1 Input Selection - ADC0 bit 7 position\n\n; EVSYS_ASYNCUSER2 masks\n.equ EVSYS_ASYNCUSER2_gm = 0xFF          ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 group mask\n.equ EVSYS_ASYNCUSER2_gp = 0             ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 group position\n.equ EVSYS_ASYNCUSER20_bm = (1<<0)       ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 0 mask\n.equ EVSYS_ASYNCUSER20_bp = 0            ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 0 position\n.equ EVSYS_ASYNCUSER21_bm = (1<<1)       ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 1 mask\n.equ EVSYS_ASYNCUSER21_bp = 1            ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 1 position\n.equ EVSYS_ASYNCUSER22_bm = (1<<2)       ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 2 mask\n.equ EVSYS_ASYNCUSER22_bp = 2            ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 2 position\n.equ EVSYS_ASYNCUSER23_bm = (1<<3)       ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 3 mask\n.equ EVSYS_ASYNCUSER23_bp = 3            ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 3 position\n.equ EVSYS_ASYNCUSER24_bm = (1<<4)       ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 4 mask\n.equ EVSYS_ASYNCUSER24_bp = 4            ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 4 position\n.equ EVSYS_ASYNCUSER25_bm = (1<<5)       ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 5 mask\n.equ EVSYS_ASYNCUSER25_bp = 5            ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 5 position\n.equ EVSYS_ASYNCUSER26_bm = (1<<6)       ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 6 mask\n.equ EVSYS_ASYNCUSER26_bp = 6            ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 6 position\n.equ EVSYS_ASYNCUSER27_bm = (1<<7)       ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 7 mask\n.equ EVSYS_ASYNCUSER27_bp = 7            ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 7 position\n\n; EVSYS_ASYNCUSER3 masks\n.equ EVSYS_ASYNCUSER3_gm = 0xFF          ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 group mask\n.equ EVSYS_ASYNCUSER3_gp = 0             ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 group position\n.equ EVSYS_ASYNCUSER30_bm = (1<<0)       ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 0 mask\n.equ EVSYS_ASYNCUSER30_bp = 0            ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 0 position\n.equ EVSYS_ASYNCUSER31_bm = (1<<1)       ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 1 mask\n.equ EVSYS_ASYNCUSER31_bp = 1            ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 1 position\n.equ EVSYS_ASYNCUSER32_bm = (1<<2)       ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 2 mask\n.equ EVSYS_ASYNCUSER32_bp = 2            ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 2 position\n.equ EVSYS_ASYNCUSER33_bm = (1<<3)       ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 3 mask\n.equ EVSYS_ASYNCUSER33_bp = 3            ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 3 position\n.equ EVSYS_ASYNCUSER34_bm = (1<<4)       ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 4 mask\n.equ EVSYS_ASYNCUSER34_bp = 4            ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 4 position\n.equ EVSYS_ASYNCUSER35_bm = (1<<5)       ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 5 mask\n.equ EVSYS_ASYNCUSER35_bp = 5            ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 5 position\n.equ EVSYS_ASYNCUSER36_bm = (1<<6)       ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 6 mask\n.equ EVSYS_ASYNCUSER36_bp = 6            ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 6 position\n.equ EVSYS_ASYNCUSER37_bm = (1<<7)       ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 7 mask\n.equ EVSYS_ASYNCUSER37_bp = 7            ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 7 position\n\n; EVSYS_ASYNCUSER4 masks\n.equ EVSYS_ASYNCUSER4_gm = 0xFF          ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 group mask\n.equ EVSYS_ASYNCUSER4_gp = 0             ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 group position\n.equ EVSYS_ASYNCUSER40_bm = (1<<0)       ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 0 mask\n.equ EVSYS_ASYNCUSER40_bp = 0            ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 0 position\n.equ EVSYS_ASYNCUSER41_bm = (1<<1)       ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 1 mask\n.equ EVSYS_ASYNCUSER41_bp = 1            ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 1 position\n.equ EVSYS_ASYNCUSER42_bm = (1<<2)       ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 2 mask\n.equ EVSYS_ASYNCUSER42_bp = 2            ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 2 position\n.equ EVSYS_ASYNCUSER43_bm = (1<<3)       ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 3 mask\n.equ EVSYS_ASYNCUSER43_bp = 3            ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 3 position\n.equ EVSYS_ASYNCUSER44_bm = (1<<4)       ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 4 mask\n.equ EVSYS_ASYNCUSER44_bp = 4            ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 4 position\n.equ EVSYS_ASYNCUSER45_bm = (1<<5)       ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 5 mask\n.equ EVSYS_ASYNCUSER45_bp = 5            ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 5 position\n.equ EVSYS_ASYNCUSER46_bm = (1<<6)       ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 6 mask\n.equ EVSYS_ASYNCUSER46_bp = 6            ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 6 position\n.equ EVSYS_ASYNCUSER47_bm = (1<<7)       ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 7 mask\n.equ EVSYS_ASYNCUSER47_bp = 7            ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 7 position\n\n; EVSYS_ASYNCUSER5 masks\n.equ EVSYS_ASYNCUSER5_gm = 0xFF          ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 group mask\n.equ EVSYS_ASYNCUSER5_gp = 0             ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 group position\n.equ EVSYS_ASYNCUSER50_bm = (1<<0)       ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 0 mask\n.equ EVSYS_ASYNCUSER50_bp = 0            ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 0 position\n.equ EVSYS_ASYNCUSER51_bm = (1<<1)       ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 1 mask\n.equ EVSYS_ASYNCUSER51_bp = 1            ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 1 position\n.equ EVSYS_ASYNCUSER52_bm = (1<<2)       ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 2 mask\n.equ EVSYS_ASYNCUSER52_bp = 2            ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 2 position\n.equ EVSYS_ASYNCUSER53_bm = (1<<3)       ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 3 mask\n.equ EVSYS_ASYNCUSER53_bp = 3            ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 3 position\n.equ EVSYS_ASYNCUSER54_bm = (1<<4)       ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 4 mask\n.equ EVSYS_ASYNCUSER54_bp = 4            ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 4 position\n.equ EVSYS_ASYNCUSER55_bm = (1<<5)       ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 5 mask\n.equ EVSYS_ASYNCUSER55_bp = 5            ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 5 position\n.equ EVSYS_ASYNCUSER56_bm = (1<<6)       ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 6 mask\n.equ EVSYS_ASYNCUSER56_bp = 6            ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 6 position\n.equ EVSYS_ASYNCUSER57_bm = (1<<7)       ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 7 mask\n.equ EVSYS_ASYNCUSER57_bp = 7            ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 7 position\n\n; EVSYS_ASYNCUSER6 masks\n.equ EVSYS_ASYNCUSER6_gm = 0xFF          ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 group mask\n.equ EVSYS_ASYNCUSER6_gp = 0             ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 group position\n.equ EVSYS_ASYNCUSER60_bm = (1<<0)       ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 0 mask\n.equ EVSYS_ASYNCUSER60_bp = 0            ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 0 position\n.equ EVSYS_ASYNCUSER61_bm = (1<<1)       ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 1 mask\n.equ EVSYS_ASYNCUSER61_bp = 1            ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 1 position\n.equ EVSYS_ASYNCUSER62_bm = (1<<2)       ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 2 mask\n.equ EVSYS_ASYNCUSER62_bp = 2            ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 2 position\n.equ EVSYS_ASYNCUSER63_bm = (1<<3)       ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 3 mask\n.equ EVSYS_ASYNCUSER63_bp = 3            ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 3 position\n.equ EVSYS_ASYNCUSER64_bm = (1<<4)       ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 4 mask\n.equ EVSYS_ASYNCUSER64_bp = 4            ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 4 position\n.equ EVSYS_ASYNCUSER65_bm = (1<<5)       ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 5 mask\n.equ EVSYS_ASYNCUSER65_bp = 5            ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 5 position\n.equ EVSYS_ASYNCUSER66_bm = (1<<6)       ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 6 mask\n.equ EVSYS_ASYNCUSER66_bp = 6            ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 6 position\n.equ EVSYS_ASYNCUSER67_bm = (1<<7)       ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 7 mask\n.equ EVSYS_ASYNCUSER67_bp = 7            ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 7 position\n\n; EVSYS_ASYNCUSER7 masks\n.equ EVSYS_ASYNCUSER7_gm = 0xFF          ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 group mask\n.equ EVSYS_ASYNCUSER7_gp = 0             ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 group position\n.equ EVSYS_ASYNCUSER70_bm = (1<<0)       ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 0 mask\n.equ EVSYS_ASYNCUSER70_bp = 0            ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 0 position\n.equ EVSYS_ASYNCUSER71_bm = (1<<1)       ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 1 mask\n.equ EVSYS_ASYNCUSER71_bp = 1            ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 1 position\n.equ EVSYS_ASYNCUSER72_bm = (1<<2)       ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 2 mask\n.equ EVSYS_ASYNCUSER72_bp = 2            ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 2 position\n.equ EVSYS_ASYNCUSER73_bm = (1<<3)       ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 3 mask\n.equ EVSYS_ASYNCUSER73_bp = 3            ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 3 position\n.equ EVSYS_ASYNCUSER74_bm = (1<<4)       ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 4 mask\n.equ EVSYS_ASYNCUSER74_bp = 4            ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 4 position\n.equ EVSYS_ASYNCUSER75_bm = (1<<5)       ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 5 mask\n.equ EVSYS_ASYNCUSER75_bp = 5            ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 5 position\n.equ EVSYS_ASYNCUSER76_bm = (1<<6)       ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 6 mask\n.equ EVSYS_ASYNCUSER76_bp = 6            ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 6 position\n.equ EVSYS_ASYNCUSER77_bm = (1<<7)       ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 7 mask\n.equ EVSYS_ASYNCUSER77_bp = 7            ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 7 position\n\n; EVSYS_ASYNCUSER8 masks\n.equ EVSYS_ASYNCUSER8_gm = 0xFF          ; Asynchronous User Ch 8 Input Selection - Event Out 0 group mask\n.equ EVSYS_ASYNCUSER8_gp = 0             ; Asynchronous User Ch 8 Input Selection - Event Out 0 group position\n.equ EVSYS_ASYNCUSER80_bm = (1<<0)       ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 0 mask\n.equ EVSYS_ASYNCUSER80_bp = 0            ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 0 position\n.equ EVSYS_ASYNCUSER81_bm = (1<<1)       ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 1 mask\n.equ EVSYS_ASYNCUSER81_bp = 1            ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 1 position\n.equ EVSYS_ASYNCUSER82_bm = (1<<2)       ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 2 mask\n.equ EVSYS_ASYNCUSER82_bp = 2            ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 2 position\n.equ EVSYS_ASYNCUSER83_bm = (1<<3)       ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 3 mask\n.equ EVSYS_ASYNCUSER83_bp = 3            ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 3 position\n.equ EVSYS_ASYNCUSER84_bm = (1<<4)       ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 4 mask\n.equ EVSYS_ASYNCUSER84_bp = 4            ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 4 position\n.equ EVSYS_ASYNCUSER85_bm = (1<<5)       ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 5 mask\n.equ EVSYS_ASYNCUSER85_bp = 5            ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 5 position\n.equ EVSYS_ASYNCUSER86_bm = (1<<6)       ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 6 mask\n.equ EVSYS_ASYNCUSER86_bp = 6            ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 6 position\n.equ EVSYS_ASYNCUSER87_bm = (1<<7)       ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 7 mask\n.equ EVSYS_ASYNCUSER87_bp = 7            ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 7 position\n\n; EVSYS_ASYNCUSER9 masks\n.equ EVSYS_ASYNCUSER9_gm = 0xFF          ; Asynchronous User Ch 9 Input Selection - Event Out 1 group mask\n.equ EVSYS_ASYNCUSER9_gp = 0             ; Asynchronous User Ch 9 Input Selection - Event Out 1 group position\n.equ EVSYS_ASYNCUSER90_bm = (1<<0)       ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 0 mask\n.equ EVSYS_ASYNCUSER90_bp = 0            ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 0 position\n.equ EVSYS_ASYNCUSER91_bm = (1<<1)       ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 1 mask\n.equ EVSYS_ASYNCUSER91_bp = 1            ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 1 position\n.equ EVSYS_ASYNCUSER92_bm = (1<<2)       ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 2 mask\n.equ EVSYS_ASYNCUSER92_bp = 2            ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 2 position\n.equ EVSYS_ASYNCUSER93_bm = (1<<3)       ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 3 mask\n.equ EVSYS_ASYNCUSER93_bp = 3            ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 3 position\n.equ EVSYS_ASYNCUSER94_bm = (1<<4)       ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 4 mask\n.equ EVSYS_ASYNCUSER94_bp = 4            ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 4 position\n.equ EVSYS_ASYNCUSER95_bm = (1<<5)       ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 5 mask\n.equ EVSYS_ASYNCUSER95_bp = 5            ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 5 position\n.equ EVSYS_ASYNCUSER96_bm = (1<<6)       ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 6 mask\n.equ EVSYS_ASYNCUSER96_bp = 6            ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 6 position\n.equ EVSYS_ASYNCUSER97_bm = (1<<7)       ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 7 mask\n.equ EVSYS_ASYNCUSER97_bp = 7            ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 7 position\n\n; EVSYS_ASYNCUSER10 masks\n.equ EVSYS_ASYNCUSER10_gm = 0xFF         ; Asynchronous User Ch 10 Input Selection - Event Out 2 group mask\n.equ EVSYS_ASYNCUSER10_gp = 0            ; Asynchronous User Ch 10 Input Selection - Event Out 2 group position\n.equ EVSYS_ASYNCUSER100_bm = (1<<0)      ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 0 mask\n.equ EVSYS_ASYNCUSER100_bp = 0           ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 0 position\n.equ EVSYS_ASYNCUSER101_bm = (1<<1)      ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 1 mask\n.equ EVSYS_ASYNCUSER101_bp = 1           ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 1 position\n.equ EVSYS_ASYNCUSER102_bm = (1<<2)      ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 2 mask\n.equ EVSYS_ASYNCUSER102_bp = 2           ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 2 position\n.equ EVSYS_ASYNCUSER103_bm = (1<<3)      ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 3 mask\n.equ EVSYS_ASYNCUSER103_bp = 3           ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 3 position\n.equ EVSYS_ASYNCUSER104_bm = (1<<4)      ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 4 mask\n.equ EVSYS_ASYNCUSER104_bp = 4           ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 4 position\n.equ EVSYS_ASYNCUSER105_bm = (1<<5)      ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 5 mask\n.equ EVSYS_ASYNCUSER105_bp = 5           ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 5 position\n.equ EVSYS_ASYNCUSER106_bm = (1<<6)      ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 6 mask\n.equ EVSYS_ASYNCUSER106_bp = 6           ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 6 position\n.equ EVSYS_ASYNCUSER107_bm = (1<<7)      ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 7 mask\n.equ EVSYS_ASYNCUSER107_bp = 7           ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 7 position\n\n; EVSYS_SYNCCH0 masks\n.equ EVSYS_SYNCCH0_gm = 0xFF             ; Synchronous Channel 0 Generator Selection group mask\n.equ EVSYS_SYNCCH0_gp = 0                ; Synchronous Channel 0 Generator Selection group position\n.equ EVSYS_SYNCCH00_bm = (1<<0)          ; Synchronous Channel 0 Generator Selection bit 0 mask\n.equ EVSYS_SYNCCH00_bp = 0               ; Synchronous Channel 0 Generator Selection bit 0 position\n.equ EVSYS_SYNCCH01_bm = (1<<1)          ; Synchronous Channel 0 Generator Selection bit 1 mask\n.equ EVSYS_SYNCCH01_bp = 1               ; Synchronous Channel 0 Generator Selection bit 1 position\n.equ EVSYS_SYNCCH02_bm = (1<<2)          ; Synchronous Channel 0 Generator Selection bit 2 mask\n.equ EVSYS_SYNCCH02_bp = 2               ; Synchronous Channel 0 Generator Selection bit 2 position\n.equ EVSYS_SYNCCH03_bm = (1<<3)          ; Synchronous Channel 0 Generator Selection bit 3 mask\n.equ EVSYS_SYNCCH03_bp = 3               ; Synchronous Channel 0 Generator Selection bit 3 position\n.equ EVSYS_SYNCCH04_bm = (1<<4)          ; Synchronous Channel 0 Generator Selection bit 4 mask\n.equ EVSYS_SYNCCH04_bp = 4               ; Synchronous Channel 0 Generator Selection bit 4 position\n.equ EVSYS_SYNCCH05_bm = (1<<5)          ; Synchronous Channel 0 Generator Selection bit 5 mask\n.equ EVSYS_SYNCCH05_bp = 5               ; Synchronous Channel 0 Generator Selection bit 5 position\n.equ EVSYS_SYNCCH06_bm = (1<<6)          ; Synchronous Channel 0 Generator Selection bit 6 mask\n.equ EVSYS_SYNCCH06_bp = 6               ; Synchronous Channel 0 Generator Selection bit 6 position\n.equ EVSYS_SYNCCH07_bm = (1<<7)          ; Synchronous Channel 0 Generator Selection bit 7 mask\n.equ EVSYS_SYNCCH07_bp = 7               ; Synchronous Channel 0 Generator Selection bit 7 position\n\n; EVSYS_SYNCUSER0 masks\n.equ EVSYS_SYNCUSER0_gm = 0xFF           ; Synchronous User Ch 0 Input Selection - TCA0 group mask\n.equ EVSYS_SYNCUSER0_gp = 0              ; Synchronous User Ch 0 Input Selection - TCA0 group position\n.equ EVSYS_SYNCUSER00_bm = (1<<0)        ; Synchronous User Ch 0 Input Selection - TCA0 bit 0 mask\n.equ EVSYS_SYNCUSER00_bp = 0             ; Synchronous User Ch 0 Input Selection - TCA0 bit 0 position\n.equ EVSYS_SYNCUSER01_bm = (1<<1)        ; Synchronous User Ch 0 Input Selection - TCA0 bit 1 mask\n.equ EVSYS_SYNCUSER01_bp = 1             ; Synchronous User Ch 0 Input Selection - TCA0 bit 1 position\n.equ EVSYS_SYNCUSER02_bm = (1<<2)        ; Synchronous User Ch 0 Input Selection - TCA0 bit 2 mask\n.equ EVSYS_SYNCUSER02_bp = 2             ; Synchronous User Ch 0 Input Selection - TCA0 bit 2 position\n.equ EVSYS_SYNCUSER03_bm = (1<<3)        ; Synchronous User Ch 0 Input Selection - TCA0 bit 3 mask\n.equ EVSYS_SYNCUSER03_bp = 3             ; Synchronous User Ch 0 Input Selection - TCA0 bit 3 position\n.equ EVSYS_SYNCUSER04_bm = (1<<4)        ; Synchronous User Ch 0 Input Selection - TCA0 bit 4 mask\n.equ EVSYS_SYNCUSER04_bp = 4             ; Synchronous User Ch 0 Input Selection - TCA0 bit 4 position\n.equ EVSYS_SYNCUSER05_bm = (1<<5)        ; Synchronous User Ch 0 Input Selection - TCA0 bit 5 mask\n.equ EVSYS_SYNCUSER05_bp = 5             ; Synchronous User Ch 0 Input Selection - TCA0 bit 5 position\n.equ EVSYS_SYNCUSER06_bm = (1<<6)        ; Synchronous User Ch 0 Input Selection - TCA0 bit 6 mask\n.equ EVSYS_SYNCUSER06_bp = 6             ; Synchronous User Ch 0 Input Selection - TCA0 bit 6 position\n.equ EVSYS_SYNCUSER07_bm = (1<<7)        ; Synchronous User Ch 0 Input Selection - TCA0 bit 7 mask\n.equ EVSYS_SYNCUSER07_bp = 7             ; Synchronous User Ch 0 Input Selection - TCA0 bit 7 position\n\n; EVSYS_SYNCUSER1 masks\n.equ EVSYS_SYNCUSER1_gm = 0xFF           ; Synchronous User Ch 1 Input Selection - USART0 group mask\n.equ EVSYS_SYNCUSER1_gp = 0              ; Synchronous User Ch 1 Input Selection - USART0 group position\n.equ EVSYS_SYNCUSER10_bm = (1<<0)        ; Synchronous User Ch 1 Input Selection - USART0 bit 0 mask\n.equ EVSYS_SYNCUSER10_bp = 0             ; Synchronous User Ch 1 Input Selection - USART0 bit 0 position\n.equ EVSYS_SYNCUSER11_bm = (1<<1)        ; Synchronous User Ch 1 Input Selection - USART0 bit 1 mask\n.equ EVSYS_SYNCUSER11_bp = 1             ; Synchronous User Ch 1 Input Selection - USART0 bit 1 position\n.equ EVSYS_SYNCUSER12_bm = (1<<2)        ; Synchronous User Ch 1 Input Selection - USART0 bit 2 mask\n.equ EVSYS_SYNCUSER12_bp = 2             ; Synchronous User Ch 1 Input Selection - USART0 bit 2 position\n.equ EVSYS_SYNCUSER13_bm = (1<<3)        ; Synchronous User Ch 1 Input Selection - USART0 bit 3 mask\n.equ EVSYS_SYNCUSER13_bp = 3             ; Synchronous User Ch 1 Input Selection - USART0 bit 3 position\n.equ EVSYS_SYNCUSER14_bm = (1<<4)        ; Synchronous User Ch 1 Input Selection - USART0 bit 4 mask\n.equ EVSYS_SYNCUSER14_bp = 4             ; Synchronous User Ch 1 Input Selection - USART0 bit 4 position\n.equ EVSYS_SYNCUSER15_bm = (1<<5)        ; Synchronous User Ch 1 Input Selection - USART0 bit 5 mask\n.equ EVSYS_SYNCUSER15_bp = 5             ; Synchronous User Ch 1 Input Selection - USART0 bit 5 position\n.equ EVSYS_SYNCUSER16_bm = (1<<6)        ; Synchronous User Ch 1 Input Selection - USART0 bit 6 mask\n.equ EVSYS_SYNCUSER16_bp = 6             ; Synchronous User Ch 1 Input Selection - USART0 bit 6 position\n.equ EVSYS_SYNCUSER17_bm = (1<<7)        ; Synchronous User Ch 1 Input Selection - USART0 bit 7 mask\n.equ EVSYS_SYNCUSER17_bp = 7             ; Synchronous User Ch 1 Input Selection - USART0 bit 7 position\n\n; Asynchronous Channel 0 Generator Selection select\n.equ EVSYS_ASYNCCH0_OFF_gc = (0x00<<0)   ; Off\n.equ EVSYS_ASYNCCH0_CCL_LUT0_gc = (0x01<<0) ; Configurable Custom Logic LUT0\n.equ EVSYS_ASYNCCH0_CCL_LUT1_gc = (0x02<<0) ; Configurable Custom Logic LUT1\n.equ EVSYS_ASYNCCH0_AC0_OUT_gc = (0x03<<0) ; Analog Comparator 0 out\n.equ EVSYS_ASYNCCH0_TCD0_CMPBCLR_gc = (0x04<<0) ; Timer/Counter D0 compare B clear\n.equ EVSYS_ASYNCCH0_TCD0_CMPASET_gc = (0x05<<0) ; Timer/Counter D0 compare A set\n.equ EVSYS_ASYNCCH0_TCD0_CMPBSET_gc = (0x06<<0) ; Timer/Counter D0 compare B set\n.equ EVSYS_ASYNCCH0_TCD0_PROGEV_gc = (0x07<<0) ; Timer/Counter D0 program event\n.equ EVSYS_ASYNCCH0_RTC_OVF_gc = (0x08<<0) ; Real Time Counter overflow\n.equ EVSYS_ASYNCCH0_RTC_CMP_gc = (0x09<<0) ; Real Time Counter compare\n.equ EVSYS_ASYNCCH0_PORTA_PIN0_gc = (0x0A<<0) ; Asynchronous Event from Pin PA0\n.equ EVSYS_ASYNCCH0_PORTA_PIN1_gc = (0x0B<<0) ; Asynchronous Event from Pin PA1\n.equ EVSYS_ASYNCCH0_PORTA_PIN2_gc = (0x0C<<0) ; Asynchronous Event from Pin PA2\n.equ EVSYS_ASYNCCH0_PORTA_PIN3_gc = (0x0D<<0) ; Asynchronous Event from Pin PA3\n.equ EVSYS_ASYNCCH0_PORTA_PIN4_gc = (0x0E<<0) ; Asynchronous Event from Pin PA4\n.equ EVSYS_ASYNCCH0_PORTA_PIN5_gc = (0x0F<<0) ; Asynchronous Event from Pin PA5\n.equ EVSYS_ASYNCCH0_PORTA_PIN6_gc = (0x10<<0) ; Asynchronous Event from Pin PA6\n.equ EVSYS_ASYNCCH0_PORTA_PIN7_gc = (0x11<<0) ; Asynchronous Event from Pin PA7\n.equ EVSYS_ASYNCCH0_UPDI_gc = (0x12<<0)  ; Unified Program and debug interface\n\n; Asynchronous Channel 1 Generator Selection select\n.equ EVSYS_ASYNCCH1_OFF_gc = (0x00<<0)   ; Off\n.equ EVSYS_ASYNCCH1_CCL_LUT0_gc = (0x01<<0) ; Configurable custom logic LUT0\n.equ EVSYS_ASYNCCH1_CCL_LUT1_gc = (0x02<<0) ; Configurable custom logic LUT1\n.equ EVSYS_ASYNCCH1_AC0_OUT_gc = (0x03<<0) ; Analog Comparator 0 out\n.equ EVSYS_ASYNCCH1_TCD0_CMPBCLR_gc = (0x04<<0) ; Timer/Counter D0 compare B clear\n.equ EVSYS_ASYNCCH1_TCD0_CMPASET_gc = (0x05<<0) ; Timer/Counter D0 compare A set\n.equ EVSYS_ASYNCCH1_TCD0_CMPBSET_gc = (0x06<<0) ; Timer/Counter D0 compare B set\n.equ EVSYS_ASYNCCH1_TCD0_PROGEV_gc = (0x07<<0) ; Timer/Counter D0 program event\n.equ EVSYS_ASYNCCH1_RTC_OVF_gc = (0x08<<0) ; Real Time Counter overflow\n.equ EVSYS_ASYNCCH1_RTC_CMP_gc = (0x09<<0) ; Real Time Counter compare\n.equ EVSYS_ASYNCCH1_PORTB_PIN0_gc = (0x0A<<0) ; Asynchronous Event from Pin PB0\n.equ EVSYS_ASYNCCH1_PORTB_PIN1_gc = (0x0B<<0) ; Asynchronous Event from Pin PB1\n.equ EVSYS_ASYNCCH1_PORTB_PIN2_gc = (0x0C<<0) ; Asynchronous Event from Pin PB2\n.equ EVSYS_ASYNCCH1_PORTB_PIN3_gc = (0x0D<<0) ; Asynchronous Event from Pin PB3\n.equ EVSYS_ASYNCCH1_PORTB_PIN4_gc = (0x0E<<0) ; Asynchronous Event from Pin PB4\n.equ EVSYS_ASYNCCH1_PORTB_PIN5_gc = (0x0F<<0) ; Asynchronous Event from Pin PB5\n.equ EVSYS_ASYNCCH1_PORTB_PIN6_gc = (0x10<<0) ; Asynchronous Event from Pin PB6\n.equ EVSYS_ASYNCCH1_PORTB_PIN7_gc = (0x11<<0) ; Asynchronous Event from Pin PB7\n\n; Asynchronous User Ch 0 Input Selection - TCB0 select\n.equ EVSYS_ASYNCUSER0_OFF_gc = (0x00<<0) ; Off\n.equ EVSYS_ASYNCUSER0_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_ASYNCUSER0_SYNCCH1_gc = (0x02<<0) ; Synchronous Event Channel 1\n.equ EVSYS_ASYNCUSER0_ASYNCCH0_gc = (0x03<<0) ; Asynchronous Event Channel 0\n.equ EVSYS_ASYNCUSER0_ASYNCCH1_gc = (0x04<<0) ; Asynchronous Event Channel 1\n.equ EVSYS_ASYNCUSER0_ASYNCCH2_gc = (0x05<<0) ; Asynchronous Event Channel 2\n.equ EVSYS_ASYNCUSER0_ASYNCCH3_gc = (0x06<<0) ; Asynchronous Event Channel 3\n\n; Asynchronous User Ch 1 Input Selection - ADC0 select\n.equ EVSYS_ASYNCUSER1_OFF_gc = (0x00<<0) ; Off\n.equ EVSYS_ASYNCUSER1_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_ASYNCUSER1_SYNCCH1_gc = (0x02<<0) ; Synchronous Event Channel 1\n.equ EVSYS_ASYNCUSER1_ASYNCCH0_gc = (0x03<<0) ; Asynchronous Event Channel 0\n.equ EVSYS_ASYNCUSER1_ASYNCCH1_gc = (0x04<<0) ; Asynchronous Event Channel 1\n.equ EVSYS_ASYNCUSER1_ASYNCCH2_gc = (0x05<<0) ; Asynchronous Event Channel 2\n.equ EVSYS_ASYNCUSER1_ASYNCCH3_gc = (0x06<<0) ; Asynchronous Event Channel 3\n\n; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 select\n.equ EVSYS_ASYNCUSER2_OFF_gc = (0x00<<0) ; Off\n.equ EVSYS_ASYNCUSER2_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_ASYNCUSER2_SYNCCH1_gc = (0x02<<0) ; Synchronous Event Channel 1\n.equ EVSYS_ASYNCUSER2_ASYNCCH0_gc = (0x03<<0) ; Asynchronous Event Channel 0\n.equ EVSYS_ASYNCUSER2_ASYNCCH1_gc = (0x04<<0) ; Asynchronous Event Channel 1\n.equ EVSYS_ASYNCUSER2_ASYNCCH2_gc = (0x05<<0) ; Asynchronous Event Channel 2\n.equ EVSYS_ASYNCUSER2_ASYNCCH3_gc = (0x06<<0) ; Asynchronous Event Channel 3\n\n; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 select\n.equ EVSYS_ASYNCUSER3_OFF_gc = (0x00<<0) ; Off\n.equ EVSYS_ASYNCUSER3_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_ASYNCUSER3_SYNCCH1_gc = (0x02<<0) ; Synchronous Event Channel 1\n.equ EVSYS_ASYNCUSER3_ASYNCCH0_gc = (0x03<<0) ; Asynchronous Event Channel 0\n.equ EVSYS_ASYNCUSER3_ASYNCCH1_gc = (0x04<<0) ; Asynchronous Event Channel 1\n.equ EVSYS_ASYNCUSER3_ASYNCCH2_gc = (0x05<<0) ; Asynchronous Event Channel 2\n.equ EVSYS_ASYNCUSER3_ASYNCCH3_gc = (0x06<<0) ; Asynchronous Event Channel 3\n\n; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 select\n.equ EVSYS_ASYNCUSER4_OFF_gc = (0x00<<0) ; Off\n.equ EVSYS_ASYNCUSER4_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_ASYNCUSER4_SYNCCH1_gc = (0x02<<0) ; Synchronous Event Channel 1\n.equ EVSYS_ASYNCUSER4_ASYNCCH0_gc = (0x03<<0) ; Asynchronous Event Channel 0\n.equ EVSYS_ASYNCUSER4_ASYNCCH1_gc = (0x04<<0) ; Asynchronous Event Channel 1\n.equ EVSYS_ASYNCUSER4_ASYNCCH2_gc = (0x05<<0) ; Asynchronous Event Channel 2\n.equ EVSYS_ASYNCUSER4_ASYNCCH3_gc = (0x06<<0) ; Asynchronous Event Channel 3\n\n; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 select\n.equ EVSYS_ASYNCUSER5_OFF_gc = (0x00<<0) ; Off\n.equ EVSYS_ASYNCUSER5_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_ASYNCUSER5_SYNCCH1_gc = (0x02<<0) ; Synchronous Event Channel 1\n.equ EVSYS_ASYNCUSER5_ASYNCCH0_gc = (0x03<<0) ; Asynchronous Event Channel 0\n.equ EVSYS_ASYNCUSER5_ASYNCCH1_gc = (0x04<<0) ; Asynchronous Event Channel 1\n.equ EVSYS_ASYNCUSER5_ASYNCCH2_gc = (0x05<<0) ; Asynchronous Event Channel 2\n.equ EVSYS_ASYNCUSER5_ASYNCCH3_gc = (0x06<<0) ; Asynchronous Event Channel 3\n\n; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 select\n.equ EVSYS_ASYNCUSER6_OFF_gc = (0x00<<0) ; Off\n.equ EVSYS_ASYNCUSER6_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_ASYNCUSER6_SYNCCH1_gc = (0x02<<0) ; Synchronous Event Channel 1\n.equ EVSYS_ASYNCUSER6_ASYNCCH0_gc = (0x03<<0) ; Asynchronous Event Channel 0\n.equ EVSYS_ASYNCUSER6_ASYNCCH1_gc = (0x04<<0) ; Asynchronous Event Channel 1\n.equ EVSYS_ASYNCUSER6_ASYNCCH2_gc = (0x05<<0) ; Asynchronous Event Channel 2\n.equ EVSYS_ASYNCUSER6_ASYNCCH3_gc = (0x06<<0) ; Asynchronous Event Channel 3\n\n; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 select\n.equ EVSYS_ASYNCUSER7_OFF_gc = (0x00<<0) ; Off\n.equ EVSYS_ASYNCUSER7_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_ASYNCUSER7_SYNCCH1_gc = (0x02<<0) ; Synchronous Event Channel 1\n.equ EVSYS_ASYNCUSER7_ASYNCCH0_gc = (0x03<<0) ; Asynchronous Event Channel 0\n.equ EVSYS_ASYNCUSER7_ASYNCCH1_gc = (0x04<<0) ; Asynchronous Event Channel 1\n.equ EVSYS_ASYNCUSER7_ASYNCCH2_gc = (0x05<<0) ; Asynchronous Event Channel 2\n.equ EVSYS_ASYNCUSER7_ASYNCCH3_gc = (0x06<<0) ; Asynchronous Event Channel 3\n\n; Asynchronous User Ch 8 Input Selection - Event Out 0 select\n.equ EVSYS_ASYNCUSER8_OFF_gc = (0x00<<0) ; Off\n.equ EVSYS_ASYNCUSER8_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_ASYNCUSER8_SYNCCH1_gc = (0x02<<0) ; Synchronous Event Channel 1\n.equ EVSYS_ASYNCUSER8_ASYNCCH0_gc = (0x03<<0) ; Asynchronous Event Channel 0\n.equ EVSYS_ASYNCUSER8_ASYNCCH1_gc = (0x04<<0) ; Asynchronous Event Channel 1\n.equ EVSYS_ASYNCUSER8_ASYNCCH2_gc = (0x05<<0) ; Asynchronous Event Channel 2\n.equ EVSYS_ASYNCUSER8_ASYNCCH3_gc = (0x06<<0) ; Asynchronous Event Channel 3\n\n; Asynchronous User Ch 9 Input Selection - Event Out 1 select\n.equ EVSYS_ASYNCUSER9_OFF_gc = (0x00<<0) ; Off\n.equ EVSYS_ASYNCUSER9_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_ASYNCUSER9_SYNCCH1_gc = (0x02<<0) ; Synchronous Event Channel 1\n.equ EVSYS_ASYNCUSER9_ASYNCCH0_gc = (0x03<<0) ; Asynchronous Event Channel 0\n.equ EVSYS_ASYNCUSER9_ASYNCCH1_gc = (0x04<<0) ; Asynchronous Event Channel 1\n.equ EVSYS_ASYNCUSER9_ASYNCCH2_gc = (0x05<<0) ; Asynchronous Event Channel 2\n.equ EVSYS_ASYNCUSER9_ASYNCCH3_gc = (0x06<<0) ; Asynchronous Event Channel 3\n\n; Asynchronous User Ch 10 Input Selection - Event Out 2 select\n.equ EVSYS_ASYNCUSER10_OFF_gc = (0x00<<0) ; Off\n.equ EVSYS_ASYNCUSER10_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_ASYNCUSER10_SYNCCH1_gc = (0x02<<0) ; Synchronous Event Channel 1\n.equ EVSYS_ASYNCUSER10_ASYNCCH0_gc = (0x03<<0) ; Asynchronous Event Channel 0\n.equ EVSYS_ASYNCUSER10_ASYNCCH1_gc = (0x04<<0) ; Asynchronous Event Channel 1\n.equ EVSYS_ASYNCUSER10_ASYNCCH2_gc = (0x05<<0) ; Asynchronous Event Channel 2\n.equ EVSYS_ASYNCUSER10_ASYNCCH3_gc = (0x06<<0) ; Asynchronous Event Channel 3\n\n; Synchronous Channel 0 Generator Selection select\n.equ EVSYS_SYNCCH0_OFF_gc = (0x00<<0)    ; Off\n.equ EVSYS_SYNCCH0_TCB0_gc = (0x01<<0)   ; Timer/Counter B0\n.equ EVSYS_SYNCCH0_TCA0_OVF_LUNF_gc = (0x02<<0) ; Timer/Counter A0 overflow\n.equ EVSYS_SYNCCH0_TCA0_HUNF_gc = (0x03<<0) ; Timer/Counter A0 underflow high byte (split mode)\n.equ EVSYS_SYNCCH0_TCA0_CMP0_gc = (0x04<<0) ; Timer/Counter A0 compare 0\n.equ EVSYS_SYNCCH0_TCA0_CMP1_gc = (0x05<<0) ; Timer/Counter A0 compare 1\n.equ EVSYS_SYNCCH0_TCA0_CMP2_gc = (0x06<<0) ; Timer/Counter A0 compare 2\n.equ EVSYS_SYNCCH0_PORTC_PIN0_gc = (0x07<<0) ; Synchronous Event from Pin PC0\n.equ EVSYS_SYNCCH0_PORTC_PIN1_gc = (0x08<<0) ; Synchronous Event from Pin PC1\n.equ EVSYS_SYNCCH0_PORTC_PIN2_gc = (0x09<<0) ; Synchronous Event from Pin PC2\n.equ EVSYS_SYNCCH0_PORTC_PIN3_gc = (0x0A<<0) ; Synchronous Event from Pin PC3\n.equ EVSYS_SYNCCH0_PORTC_PIN4_gc = (0x0B<<0) ; Synchronous Event from Pin PC4\n.equ EVSYS_SYNCCH0_PORTC_PIN5_gc = (0x0C<<0) ; Synchronous Event from Pin PC5\n.equ EVSYS_SYNCCH0_PORTA_PIN0_gc = (0x0D<<0) ; Synchronous Event from Pin PA0\n.equ EVSYS_SYNCCH0_PORTA_PIN1_gc = (0x0E<<0) ; Synchronous Event from Pin PA1\n.equ EVSYS_SYNCCH0_PORTA_PIN2_gc = (0x0F<<0) ; Synchronous Event from Pin PA2\n.equ EVSYS_SYNCCH0_PORTA_PIN3_gc = (0x10<<0) ; Synchronous Event from Pin PA3\n.equ EVSYS_SYNCCH0_PORTA_PIN4_gc = (0x11<<0) ; Synchronous Event from Pin PA4\n.equ EVSYS_SYNCCH0_PORTA_PIN5_gc = (0x12<<0) ; Synchronous Event from Pin PA5\n.equ EVSYS_SYNCCH0_PORTA_PIN6_gc = (0x13<<0) ; Synchronous Event from Pin PA6\n.equ EVSYS_SYNCCH0_PORTA_PIN7_gc = (0x14<<0) ; Synchronous Event from Pin PA7\n\n; Synchronous User Ch 0 Input Selection - TCA0 select\n.equ EVSYS_SYNCUSER0_OFF_gc = (0x00<<0)  ; Off\n.equ EVSYS_SYNCUSER0_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_SYNCUSER0_SYNCCH1_gc = (0x02<<0) ; Synchronous Event Channel 1\n\n; Synchronous User Ch 1 Input Selection - USART0 select\n.equ EVSYS_SYNCUSER1_OFF_gc = (0x00<<0)  ; Off\n.equ EVSYS_SYNCUSER1_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_SYNCUSER1_SYNCCH1_gc = (0x02<<0) ; Synchronous Event Channel 1\n\n\n;*************************************************************************\n;** FUSE - Fuses\n;*************************************************************************\n\n; FUSE_BODCFG masks\n.equ FUSE_ACTIVE_gm = 0x0C               ; BOD Operation in Active Mode group mask\n.equ FUSE_ACTIVE_gp = 2                  ; BOD Operation in Active Mode group position\n.equ FUSE_ACTIVE0_bm = (1<<2)            ; BOD Operation in Active Mode bit 0 mask\n.equ FUSE_ACTIVE0_bp = 2                 ; BOD Operation in Active Mode bit 0 position\n.equ FUSE_ACTIVE1_bm = (1<<3)            ; BOD Operation in Active Mode bit 1 mask\n.equ FUSE_ACTIVE1_bp = 3                 ; BOD Operation in Active Mode bit 1 position\n.equ FUSE_LVL_gm = 0xE0                  ; BOD Level group mask\n.equ FUSE_LVL_gp = 5                     ; BOD Level group position\n.equ FUSE_LVL0_bm = (1<<5)               ; BOD Level bit 0 mask\n.equ FUSE_LVL0_bp = 5                    ; BOD Level bit 0 position\n.equ FUSE_LVL1_bm = (1<<6)               ; BOD Level bit 1 mask\n.equ FUSE_LVL1_bp = 6                    ; BOD Level bit 1 position\n.equ FUSE_LVL2_bm = (1<<7)               ; BOD Level bit 2 mask\n.equ FUSE_LVL2_bp = 7                    ; BOD Level bit 2 position\n.equ FUSE_SAMPFREQ_bm = 0x10             ; BOD Sample Frequency bit mask\n.equ FUSE_SAMPFREQ_bp = 4                ; BOD Sample Frequency bit position\n.equ FUSE_SLEEP_gm = 0x03                ; BOD Operation in Sleep Mode group mask\n.equ FUSE_SLEEP_gp = 0                   ; BOD Operation in Sleep Mode group position\n.equ FUSE_SLEEP0_bm = (1<<0)             ; BOD Operation in Sleep Mode bit 0 mask\n.equ FUSE_SLEEP0_bp = 0                  ; BOD Operation in Sleep Mode bit 0 position\n.equ FUSE_SLEEP1_bm = (1<<1)             ; BOD Operation in Sleep Mode bit 1 mask\n.equ FUSE_SLEEP1_bp = 1                  ; BOD Operation in Sleep Mode bit 1 position\n\n; FUSE_OSCCFG masks\n.equ FUSE_FREQSEL_gm = 0x03              ; Frequency Select group mask\n.equ FUSE_FREQSEL_gp = 0                 ; Frequency Select group position\n.equ FUSE_FREQSEL0_bm = (1<<0)           ; Frequency Select bit 0 mask\n.equ FUSE_FREQSEL0_bp = 0                ; Frequency Select bit 0 position\n.equ FUSE_FREQSEL1_bm = (1<<1)           ; Frequency Select bit 1 mask\n.equ FUSE_FREQSEL1_bp = 1                ; Frequency Select bit 1 position\n.equ FUSE_OSCLOCK_bm = 0x80              ; Oscillator Lock bit mask\n.equ FUSE_OSCLOCK_bp = 7                 ; Oscillator Lock bit position\n\n; FUSE_SYSCFG0 masks\n.equ FUSE_CRCSRC_gm = 0xC0               ; CRC Source group mask\n.equ FUSE_CRCSRC_gp = 6                  ; CRC Source group position\n.equ FUSE_CRCSRC0_bm = (1<<6)            ; CRC Source bit 0 mask\n.equ FUSE_CRCSRC0_bp = 6                 ; CRC Source bit 0 position\n.equ FUSE_CRCSRC1_bm = (1<<7)            ; CRC Source bit 1 mask\n.equ FUSE_CRCSRC1_bp = 7                 ; CRC Source bit 1 position\n.equ FUSE_EESAVE_bm = 0x01               ; EEPROM Save bit mask\n.equ FUSE_EESAVE_bp = 0                  ; EEPROM Save bit position\n.equ FUSE_RSTPINCFG_gm = 0x0C            ; Reset Pin Configuration group mask\n.equ FUSE_RSTPINCFG_gp = 2               ; Reset Pin Configuration group position\n.equ FUSE_RSTPINCFG0_bm = (1<<2)         ; Reset Pin Configuration bit 0 mask\n.equ FUSE_RSTPINCFG0_bp = 2              ; Reset Pin Configuration bit 0 position\n.equ FUSE_RSTPINCFG1_bm = (1<<3)         ; Reset Pin Configuration bit 1 mask\n.equ FUSE_RSTPINCFG1_bp = 3              ; Reset Pin Configuration bit 1 position\n\n; FUSE_SYSCFG1 masks\n.equ FUSE_SUT_gm = 0x07                  ; Startup Time group mask\n.equ FUSE_SUT_gp = 0                     ; Startup Time group position\n.equ FUSE_SUT0_bm = (1<<0)               ; Startup Time bit 0 mask\n.equ FUSE_SUT0_bp = 0                    ; Startup Time bit 0 position\n.equ FUSE_SUT1_bm = (1<<1)               ; Startup Time bit 1 mask\n.equ FUSE_SUT1_bp = 1                    ; Startup Time bit 1 position\n.equ FUSE_SUT2_bm = (1<<2)               ; Startup Time bit 2 mask\n.equ FUSE_SUT2_bp = 2                    ; Startup Time bit 2 position\n\n; FUSE_TCD0CFG masks\n.equ FUSE_CMPA_bm = 0x01                 ; Compare A Default Output Value bit mask\n.equ FUSE_CMPA_bp = 0                    ; Compare A Default Output Value bit position\n.equ FUSE_CMPAEN_bm = 0x10               ; Compare A Output Enable bit mask\n.equ FUSE_CMPAEN_bp = 4                  ; Compare A Output Enable bit position\n.equ FUSE_CMPB_bm = 0x02                 ; Compare B Default Output Value bit mask\n.equ FUSE_CMPB_bp = 1                    ; Compare B Default Output Value bit position\n.equ FUSE_CMPBEN_bm = 0x20               ; Compare B Output Enable bit mask\n.equ FUSE_CMPBEN_bp = 5                  ; Compare B Output Enable bit position\n.equ FUSE_CMPC_bm = 0x04                 ; Compare C Default Output Value bit mask\n.equ FUSE_CMPC_bp = 2                    ; Compare C Default Output Value bit position\n.equ FUSE_CMPCEN_bm = 0x40               ; Compare C Output Enable bit mask\n.equ FUSE_CMPCEN_bp = 6                  ; Compare C Output Enable bit position\n.equ FUSE_CMPD_bm = 0x08                 ; Compare D Default Output Value bit mask\n.equ FUSE_CMPD_bp = 3                    ; Compare D Default Output Value bit position\n.equ FUSE_CMPDEN_bm = 0x80               ; Compare D Output Enable bit mask\n.equ FUSE_CMPDEN_bp = 7                  ; Compare D Output Enable bit position\n\n; FUSE_WDTCFG masks\n.equ FUSE_PERIOD_gm = 0x0F               ; Watchdog Timeout Period group mask\n.equ FUSE_PERIOD_gp = 0                  ; Watchdog Timeout Period group position\n.equ FUSE_PERIOD0_bm = (1<<0)            ; Watchdog Timeout Period bit 0 mask\n.equ FUSE_PERIOD0_bp = 0                 ; Watchdog Timeout Period bit 0 position\n.equ FUSE_PERIOD1_bm = (1<<1)            ; Watchdog Timeout Period bit 1 mask\n.equ FUSE_PERIOD1_bp = 1                 ; Watchdog Timeout Period bit 1 position\n.equ FUSE_PERIOD2_bm = (1<<2)            ; Watchdog Timeout Period bit 2 mask\n.equ FUSE_PERIOD2_bp = 2                 ; Watchdog Timeout Period bit 2 position\n.equ FUSE_PERIOD3_bm = (1<<3)            ; Watchdog Timeout Period bit 3 mask\n.equ FUSE_PERIOD3_bp = 3                 ; Watchdog Timeout Period bit 3 position\n.equ FUSE_WINDOW_gm = 0xF0               ; Watchdog Window Timeout Period group mask\n.equ FUSE_WINDOW_gp = 4                  ; Watchdog Window Timeout Period group position\n.equ FUSE_WINDOW0_bm = (1<<4)            ; Watchdog Window Timeout Period bit 0 mask\n.equ FUSE_WINDOW0_bp = 4                 ; Watchdog Window Timeout Period bit 0 position\n.equ FUSE_WINDOW1_bm = (1<<5)            ; Watchdog Window Timeout Period bit 1 mask\n.equ FUSE_WINDOW1_bp = 5                 ; Watchdog Window Timeout Period bit 1 position\n.equ FUSE_WINDOW2_bm = (1<<6)            ; Watchdog Window Timeout Period bit 2 mask\n.equ FUSE_WINDOW2_bp = 6                 ; Watchdog Window Timeout Period bit 2 position\n.equ FUSE_WINDOW3_bm = (1<<7)            ; Watchdog Window Timeout Period bit 3 mask\n.equ FUSE_WINDOW3_bp = 7                 ; Watchdog Window Timeout Period bit 3 position\n\n; BOD Operation in Active Mode select\n.equ FUSE_ACTIVE_DIS_gc = (0x00<<2)      ; Disabled\n.equ FUSE_ACTIVE_ENABLED_gc = (0x01<<2)  ; Enabled\n.equ FUSE_ACTIVE_SAMPLED_gc = (0x02<<2)  ; Sampled\n.equ FUSE_ACTIVE_ENWAKE_gc = (0x03<<2)   ; Enabled with wake-up halted until BOD is ready\n\n; BOD Level select\n.equ FUSE_LVL_BODLEVEL0_gc = (0x00<<5)   ; 1.8 V\n.equ FUSE_LVL_BODLEVEL2_gc = (0x02<<5)   ; 2.6 V\n.equ FUSE_LVL_BODLEVEL7_gc = (0x07<<5)   ; 4.2 V\n\n; BOD Sample Frequency select\n.equ FUSE_SAMPFREQ_1KHz_gc = (0x00<<4)   ; 1kHz sampling frequency\n.equ FUSE_SAMPFREQ_125Hz_gc = (0x01<<4)  ; 125Hz sampling frequency\n\n; BOD Operation in Sleep Mode select\n.equ FUSE_SLEEP_DIS_gc = (0x00<<0)       ; Disabled\n.equ FUSE_SLEEP_ENABLED_gc = (0x01<<0)   ; Enabled\n.equ FUSE_SLEEP_SAMPLED_gc = (0x02<<0)   ; Sampled\n\n; Frequency Select select\n.equ FUSE_FREQSEL_16MHZ_gc = (0x01<<0)   ; 16 MHz\n.equ FUSE_FREQSEL_20MHZ_gc = (0x02<<0)   ; 20 MHz\n\n; CRC Source select\n.equ FUSE_CRCSRC_FLASH_gc = (0x00<<6)    ; The CRC is performed on the entire Flash (boot, application code and application data section).\n.equ FUSE_CRCSRC_BOOT_gc = (0x01<<6)     ; The CRC is performed on the boot section of Flash\n.equ FUSE_CRCSRC_BOOTAPP_gc = (0x02<<6)  ; The CRC is performed on the boot and application code section of Flash\n.equ FUSE_CRCSRC_NOCRC_gc = (0x03<<6)    ; Disable CRC.\n\n; Reset Pin Configuration select\n.equ FUSE_RSTPINCFG_GPIO_gc = (0x00<<2)  ; GPIO mode\n.equ FUSE_RSTPINCFG_UPDI_gc = (0x01<<2)  ; UPDI mode\n.equ FUSE_RSTPINCFG_RST_gc = (0x02<<2)   ; Reset mode\n\n; Startup Time select\n.equ FUSE_SUT_0MS_gc = (0x00<<0)         ; 0 ms\n.equ FUSE_SUT_1MS_gc = (0x01<<0)         ; 1 ms\n.equ FUSE_SUT_2MS_gc = (0x02<<0)         ; 2 ms\n.equ FUSE_SUT_4MS_gc = (0x03<<0)         ; 4 ms\n.equ FUSE_SUT_8MS_gc = (0x04<<0)         ; 8 ms\n.equ FUSE_SUT_16MS_gc = (0x05<<0)        ; 16 ms\n.equ FUSE_SUT_32MS_gc = (0x06<<0)        ; 32 ms\n.equ FUSE_SUT_64MS_gc = (0x07<<0)        ; 64 ms\n\n; Watchdog Timeout Period select\n.equ FUSE_PERIOD_OFF_gc = (0x00<<0)      ; Watch-Dog timer Off\n.equ FUSE_PERIOD_8CLK_gc = (0x01<<0)     ; 8 cycles (8ms)\n.equ FUSE_PERIOD_16CLK_gc = (0x02<<0)    ; 16 cycles (16ms)\n.equ FUSE_PERIOD_32CLK_gc = (0x03<<0)    ; 32 cycles (32ms)\n.equ FUSE_PERIOD_64CLK_gc = (0x04<<0)    ; 64 cycles (64ms)\n.equ FUSE_PERIOD_128CLK_gc = (0x05<<0)   ; 128 cycles (0.128s)\n.equ FUSE_PERIOD_256CLK_gc = (0x06<<0)   ; 256 cycles (0.256s)\n.equ FUSE_PERIOD_512CLK_gc = (0x07<<0)   ; 512 cycles (0.512s)\n.equ FUSE_PERIOD_1KCLK_gc = (0x08<<0)    ; 1K cycles (1.0s)\n.equ FUSE_PERIOD_2KCLK_gc = (0x09<<0)    ; 2K cycles (2.0s)\n.equ FUSE_PERIOD_4KCLK_gc = (0x0A<<0)    ; 4K cycles (4.1s)\n.equ FUSE_PERIOD_8KCLK_gc = (0x0B<<0)    ; 8K cycles (8.2s)\n\n; Watchdog Window Timeout Period select\n.equ FUSE_WINDOW_OFF_gc = (0x00<<4)      ; Window mode off\n.equ FUSE_WINDOW_8CLK_gc = (0x01<<4)     ; 8 cycles (8ms)\n.equ FUSE_WINDOW_16CLK_gc = (0x02<<4)    ; 16 cycles (16ms)\n.equ FUSE_WINDOW_32CLK_gc = (0x03<<4)    ; 32 cycles (32ms)\n.equ FUSE_WINDOW_64CLK_gc = (0x04<<4)    ; 64 cycles (64ms)\n.equ FUSE_WINDOW_128CLK_gc = (0x05<<4)   ; 128 cycles (0.128s)\n.equ FUSE_WINDOW_256CLK_gc = (0x06<<4)   ; 256 cycles (0.256s)\n.equ FUSE_WINDOW_512CLK_gc = (0x07<<4)   ; 512 cycles (0.512s)\n.equ FUSE_WINDOW_1KCLK_gc = (0x08<<4)    ; 1K cycles (1.0s)\n.equ FUSE_WINDOW_2KCLK_gc = (0x09<<4)    ; 2K cycles (2.0s)\n.equ FUSE_WINDOW_4KCLK_gc = (0x0A<<4)    ; 4K cycles (4.1s)\n.equ FUSE_WINDOW_8KCLK_gc = (0x0B<<4)    ; 8K cycles (8.2s)\n\n\n;*************************************************************************\n;** GPIO - General Purpose IO\n;*************************************************************************\n\n\n;*************************************************************************\n;** LOCKBIT - Lockbit\n;*************************************************************************\n\n; LOCKBIT_LOCKBIT masks\n.equ LOCKBIT_LB_gm = 0xFF                ; Lock Bits group mask\n.equ LOCKBIT_LB_gp = 0                   ; Lock Bits group position\n.equ LOCKBIT_LB0_bm = (1<<0)             ; Lock Bits bit 0 mask\n.equ LOCKBIT_LB0_bp = 0                  ; Lock Bits bit 0 position\n.equ LOCKBIT_LB1_bm = (1<<1)             ; Lock Bits bit 1 mask\n.equ LOCKBIT_LB1_bp = 1                  ; Lock Bits bit 1 position\n.equ LOCKBIT_LB2_bm = (1<<2)             ; Lock Bits bit 2 mask\n.equ LOCKBIT_LB2_bp = 2                  ; Lock Bits bit 2 position\n.equ LOCKBIT_LB3_bm = (1<<3)             ; Lock Bits bit 3 mask\n.equ LOCKBIT_LB3_bp = 3                  ; Lock Bits bit 3 position\n.equ LOCKBIT_LB4_bm = (1<<4)             ; Lock Bits bit 4 mask\n.equ LOCKBIT_LB4_bp = 4                  ; Lock Bits bit 4 position\n.equ LOCKBIT_LB5_bm = (1<<5)             ; Lock Bits bit 5 mask\n.equ LOCKBIT_LB5_bp = 5                  ; Lock Bits bit 5 position\n.equ LOCKBIT_LB6_bm = (1<<6)             ; Lock Bits bit 6 mask\n.equ LOCKBIT_LB6_bp = 6                  ; Lock Bits bit 6 position\n.equ LOCKBIT_LB7_bm = (1<<7)             ; Lock Bits bit 7 mask\n.equ LOCKBIT_LB7_bp = 7                  ; Lock Bits bit 7 position\n\n; Lock Bits select\n.equ LOCKBIT_LB_RWLOCK_gc = (0x3A<<0)    ; Read and write lock\n.equ LOCKBIT_LB_NOLOCK_gc = (0xC5<<0)    ; No locks\n\n\n;*************************************************************************\n;** NVMCTRL - Non-volatile Memory Controller\n;*************************************************************************\n\n; NVMCTRL_CTRLA masks\n.equ NVMCTRL_CMD_gm = 0x07               ; Command group mask\n.equ NVMCTRL_CMD_gp = 0                  ; Command group position\n.equ NVMCTRL_CMD0_bm = (1<<0)            ; Command bit 0 mask\n.equ NVMCTRL_CMD0_bp = 0                 ; Command bit 0 position\n.equ NVMCTRL_CMD1_bm = (1<<1)            ; Command bit 1 mask\n.equ NVMCTRL_CMD1_bp = 1                 ; Command bit 1 position\n.equ NVMCTRL_CMD2_bm = (1<<2)            ; Command bit 2 mask\n.equ NVMCTRL_CMD2_bp = 2                 ; Command bit 2 position\n\n; NVMCTRL_CTRLB masks\n.equ NVMCTRL_APCWP_bm = 0x01             ; Application code write protect bit mask\n.equ NVMCTRL_APCWP_bp = 0                ; Application code write protect bit position\n.equ NVMCTRL_BOOTLOCK_bm = 0x02          ; Boot Lock bit mask\n.equ NVMCTRL_BOOTLOCK_bp = 1             ; Boot Lock bit position\n\n; NVMCTRL_INTCTRL masks\n.equ NVMCTRL_EEREADY_bm = 0x01           ; EEPROM Ready bit mask\n.equ NVMCTRL_EEREADY_bp = 0              ; EEPROM Ready bit position\n\n; NVMCTRL_INTFLAGS masks\n; Masks for NVMCTRL_EEREADY already defined\n\n; NVMCTRL_STATUS masks\n.equ NVMCTRL_EEBUSY_bm = 0x02            ; EEPROM busy bit mask\n.equ NVMCTRL_EEBUSY_bp = 1               ; EEPROM busy bit position\n.equ NVMCTRL_FBUSY_bm = 0x01             ; Flash busy bit mask\n.equ NVMCTRL_FBUSY_bp = 0                ; Flash busy bit position\n.equ NVMCTRL_WRERROR_bm = 0x04           ; Write error bit mask\n.equ NVMCTRL_WRERROR_bp = 2              ; Write error bit position\n\n; Command select\n.equ NVMCTRL_CMD_NONE_gc = (0x00<<0)     ; No Command\n.equ NVMCTRL_CMD_PAGEWRITE_gc = (0x01<<0) ; Write page\n.equ NVMCTRL_CMD_PAGEERASE_gc = (0x02<<0) ; Erase page\n.equ NVMCTRL_CMD_PAGEERASEWRITE_gc = (0x03<<0) ; Erase and write page\n.equ NVMCTRL_CMD_PAGEBUFCLR_gc = (0x04<<0) ; Page buffer clear\n.equ NVMCTRL_CMD_CHIPERASE_gc = (0x05<<0) ; Chip erase\n.equ NVMCTRL_CMD_EEERASE_gc = (0x06<<0)  ; EEPROM erase\n.equ NVMCTRL_CMD_FUSEWRITE_gc = (0x07<<0) ; Write fuse (PDI only)\n\n\n;*************************************************************************\n;** PORT - I/O Ports\n;*************************************************************************\n\n; PORT_INTFLAGS masks\n.equ PORT_INT_gm = 0xFF                  ; Pin Interrupt group mask\n.equ PORT_INT_gp = 0                     ; Pin Interrupt group position\n.equ PORT_INT0_bm = (1<<0)               ; Pin Interrupt bit 0 mask\n.equ PORT_INT0_bp = 0                    ; Pin Interrupt bit 0 position\n.equ PORT_INT1_bm = (1<<1)               ; Pin Interrupt bit 1 mask\n.equ PORT_INT1_bp = 1                    ; Pin Interrupt bit 1 position\n.equ PORT_INT2_bm = (1<<2)               ; Pin Interrupt bit 2 mask\n.equ PORT_INT2_bp = 2                    ; Pin Interrupt bit 2 position\n.equ PORT_INT3_bm = (1<<3)               ; Pin Interrupt bit 3 mask\n.equ PORT_INT3_bp = 3                    ; Pin Interrupt bit 3 position\n.equ PORT_INT4_bm = (1<<4)               ; Pin Interrupt bit 4 mask\n.equ PORT_INT4_bp = 4                    ; Pin Interrupt bit 4 position\n.equ PORT_INT5_bm = (1<<5)               ; Pin Interrupt bit 5 mask\n.equ PORT_INT5_bp = 5                    ; Pin Interrupt bit 5 position\n.equ PORT_INT6_bm = (1<<6)               ; Pin Interrupt bit 6 mask\n.equ PORT_INT6_bp = 6                    ; Pin Interrupt bit 6 position\n.equ PORT_INT7_bm = (1<<7)               ; Pin Interrupt bit 7 mask\n.equ PORT_INT7_bp = 7                    ; Pin Interrupt bit 7 position\n\n; PORT_PIN0CTRL masks\n.equ PORT_INVEN_bm = 0x80                ; Inverted I/O Enable bit mask\n.equ PORT_INVEN_bp = 7                   ; Inverted I/O Enable bit position\n.equ PORT_ISC_gm = 0x07                  ; Input/Sense Configuration group mask\n.equ PORT_ISC_gp = 0                     ; Input/Sense Configuration group position\n.equ PORT_ISC0_bm = (1<<0)               ; Input/Sense Configuration bit 0 mask\n.equ PORT_ISC0_bp = 0                    ; Input/Sense Configuration bit 0 position\n.equ PORT_ISC1_bm = (1<<1)               ; Input/Sense Configuration bit 1 mask\n.equ PORT_ISC1_bp = 1                    ; Input/Sense Configuration bit 1 position\n.equ PORT_ISC2_bm = (1<<2)               ; Input/Sense Configuration bit 2 mask\n.equ PORT_ISC2_bp = 2                    ; Input/Sense Configuration bit 2 position\n.equ PORT_PULLUPEN_bm = 0x08             ; Pullup enable bit mask\n.equ PORT_PULLUPEN_bp = 3                ; Pullup enable bit position\n\n; PORT_PIN1CTRL masks\n; Masks for PORT_INVEN already defined\n; Masks for PORT_ISC already defined\n; Masks for PORT_PULLUPEN already defined\n\n; PORT_PIN2CTRL masks\n; Masks for PORT_INVEN already defined\n; Masks for PORT_ISC already defined\n; Masks for PORT_PULLUPEN already defined\n\n; PORT_PIN3CTRL masks\n; Masks for PORT_INVEN already defined\n; Masks for PORT_ISC already defined\n; Masks for PORT_PULLUPEN already defined\n\n; PORT_PIN4CTRL masks\n; Masks for PORT_INVEN already defined\n; Masks for PORT_ISC already defined\n; Masks for PORT_PULLUPEN already defined\n\n; PORT_PIN5CTRL masks\n; Masks for PORT_INVEN already defined\n; Masks for PORT_ISC already defined\n; Masks for PORT_PULLUPEN already defined\n\n; PORT_PIN6CTRL masks\n; Masks for PORT_INVEN already defined\n; Masks for PORT_ISC already defined\n; Masks for PORT_PULLUPEN already defined\n\n; PORT_PIN7CTRL masks\n; Masks for PORT_INVEN already defined\n; Masks for PORT_ISC already defined\n; Masks for PORT_PULLUPEN already defined\n\n; Input/Sense Configuration select\n.equ PORT_ISC_INTDISABLE_gc = (0x00<<0)  ; Interrupt disabled but input buffer enabled\n.equ PORT_ISC_BOTHEDGES_gc = (0x01<<0)   ; Sense Both Edges\n.equ PORT_ISC_RISING_gc = (0x02<<0)      ; Sense Rising Edge\n.equ PORT_ISC_FALLING_gc = (0x03<<0)     ; Sense Falling Edge\n.equ PORT_ISC_INPUT_DISABLE_gc = (0x04<<0) ; Digital Input Buffer disabled\n.equ PORT_ISC_LEVEL_gc = (0x05<<0)       ; Sense low Level\n\n\n;*************************************************************************\n;** PORTMUX - Port Multiplexer\n;*************************************************************************\n\n; PORTMUX_CTRLA masks\n.equ PORTMUX_EVOUT0_bm = 0x01            ; Event Output 0 bit mask\n.equ PORTMUX_EVOUT0_bp = 0               ; Event Output 0 bit position\n.equ PORTMUX_EVOUT1_bm = 0x02            ; Event Output 1 bit mask\n.equ PORTMUX_EVOUT1_bp = 1               ; Event Output 1 bit position\n.equ PORTMUX_EVOUT2_bm = 0x04            ; Event Output 2 bit mask\n.equ PORTMUX_EVOUT2_bp = 2               ; Event Output 2 bit position\n.equ PORTMUX_LUT0_bm = 0x10              ; Configurable Custom Logic LUT0 bit mask\n.equ PORTMUX_LUT0_bp = 4                 ; Configurable Custom Logic LUT0 bit position\n.equ PORTMUX_LUT1_bm = 0x20              ; Configurable Custom Logic LUT1 bit mask\n.equ PORTMUX_LUT1_bp = 5                 ; Configurable Custom Logic LUT1 bit position\n\n; PORTMUX_CTRLB masks\n.equ PORTMUX_SPI0_bm = 0x04              ; Port Multiplexer SPI0 bit mask\n.equ PORTMUX_SPI0_bp = 2                 ; Port Multiplexer SPI0 bit position\n.equ PORTMUX_TWI0_bm = 0x10              ; Port Multiplexer TWI0 bit mask\n.equ PORTMUX_TWI0_bp = 4                 ; Port Multiplexer TWI0 bit position\n.equ PORTMUX_USART0_bm = 0x01            ; Port Multiplexer USART0 bit mask\n.equ PORTMUX_USART0_bp = 0               ; Port Multiplexer USART0 bit position\n\n; PORTMUX_CTRLC masks\n.equ PORTMUX_TCA00_bm = 0x01             ; Port Multiplexer TCA0 Output 0 bit mask\n.equ PORTMUX_TCA00_bp = 0                ; Port Multiplexer TCA0 Output 0 bit position\n.equ PORTMUX_TCA01_bm = 0x02             ; Port Multiplexer TCA0 Output 1 bit mask\n.equ PORTMUX_TCA01_bp = 1                ; Port Multiplexer TCA0 Output 1 bit position\n.equ PORTMUX_TCA02_bm = 0x04             ; Port Multiplexer TCA0 Output 2 bit mask\n.equ PORTMUX_TCA02_bp = 2                ; Port Multiplexer TCA0 Output 2 bit position\n.equ PORTMUX_TCA03_bm = 0x08             ; Port Multiplexer TCA0 Output 3 bit mask\n.equ PORTMUX_TCA03_bp = 3                ; Port Multiplexer TCA0 Output 3 bit position\n.equ PORTMUX_TCA04_bm = 0x10             ; Port Multiplexer TCA0 Output 4 bit mask\n.equ PORTMUX_TCA04_bp = 4                ; Port Multiplexer TCA0 Output 4 bit position\n.equ PORTMUX_TCA05_bm = 0x20             ; Port Multiplexer TCA0 Output 5 bit mask\n.equ PORTMUX_TCA05_bp = 5                ; Port Multiplexer TCA0 Output 5 bit position\n\n; PORTMUX_CTRLD masks\n.equ PORTMUX_TCB0_bm = 0x01              ; Port Multiplexer TCB bit mask\n.equ PORTMUX_TCB0_bp = 0                 ; Port Multiplexer TCB bit position\n\n; Configurable Custom Logic LUT0 select\n.equ PORTMUX_LUT0_DEFAULT_gc = (0x00<<4) ; Default pin\n.equ PORTMUX_LUT0_ALTERNATE_gc = (0x01<<4) ; Alternate pin\n\n; Configurable Custom Logic LUT1 select\n.equ PORTMUX_LUT1_DEFAULT_gc = (0x00<<5) ; Default pin\n.equ PORTMUX_LUT1_ALTERNATE_gc = (0x01<<5) ; Alternate pin\n\n; Port Multiplexer SPI0 select\n.equ PORTMUX_SPI0_DEFAULT_gc = (0x00<<2) ; Default pins\n.equ PORTMUX_SPI0_ALTERNATE_gc = (0x01<<2) ; Alternate pins\n\n; Port Multiplexer TWI0 select\n.equ PORTMUX_TWI0_DEFAULT_gc = (0x00<<4) ; Default pins\n.equ PORTMUX_TWI0_ALTERNATE_gc = (0x01<<4) ; Alternate pins\n\n; Port Multiplexer USART0 select\n.equ PORTMUX_USART0_DEFAULT_gc = (0x00<<0) ; Default pins\n.equ PORTMUX_USART0_ALTERNATE_gc = (0x01<<0) ; Alternate pins\n\n; Port Multiplexer TCA0 Output 0 select\n.equ PORTMUX_TCA00_DEFAULT_gc = (0x00<<0) ; Default pin\n.equ PORTMUX_TCA00_ALTERNATE_gc = (0x01<<0) ; Alternate pin\n\n; Port Multiplexer TCA0 Output 1 select\n.equ PORTMUX_TCA01_DEFAULT_gc = (0x00<<1) ; Default pin\n.equ PORTMUX_TCA01_ALTERNATE_gc = (0x01<<1) ; Alternate pin\n\n; Port Multiplexer TCA0 Output 2 select\n.equ PORTMUX_TCA02_DEFAULT_gc = (0x00<<2) ; Default pin\n.equ PORTMUX_TCA02_ALTERNATE_gc = (0x01<<2) ; Alternate pin\n\n; Port Multiplexer TCA0 Output 3 select\n.equ PORTMUX_TCA03_DEFAULT_gc = (0x00<<3) ; Default pin\n.equ PORTMUX_TCA03_ALTERNATE_gc = (0x01<<3) ; Alternate pin\n\n; Port Multiplexer TCA0 Output 4 select\n.equ PORTMUX_TCA04_DEFAULT_gc = (0x00<<4) ; Default pin\n.equ PORTMUX_TCA04_ALTERNATE_gc = (0x01<<4) ; Alternate pin\n\n; Port Multiplexer TCA0 Output 5 select\n.equ PORTMUX_TCA05_DEFAULT_gc = (0x00<<5) ; Default pin\n.equ PORTMUX_TCA05_ALTERNATE_gc = (0x01<<5) ; Alternate pin\n\n; Port Multiplexer TCB select\n.equ PORTMUX_TCB0_DEFAULT_gc = (0x00<<0) ; Default pin\n.equ PORTMUX_TCB0_ALTERNATE_gc = (0x01<<0) ; Alternate pin\n\n\n;*************************************************************************\n;** RSTCTRL - Reset controller\n;*************************************************************************\n\n; RSTCTRL_RSTFR masks\n.equ RSTCTRL_BORF_bm = 0x02              ; Brown out detector Reset flag bit mask\n.equ RSTCTRL_BORF_bp = 1                 ; Brown out detector Reset flag bit position\n.equ RSTCTRL_EXTRF_bm = 0x04             ; External Reset flag bit mask\n.equ RSTCTRL_EXTRF_bp = 2                ; External Reset flag bit position\n.equ RSTCTRL_PORF_bm = 0x01              ; Power on Reset flag bit mask\n.equ RSTCTRL_PORF_bp = 0                 ; Power on Reset flag bit position\n.equ RSTCTRL_SWRF_bm = 0x10              ; Software Reset flag bit mask\n.equ RSTCTRL_SWRF_bp = 4                 ; Software Reset flag bit position\n.equ RSTCTRL_UPDIRF_bm = 0x20            ; UPDI Reset flag bit mask\n.equ RSTCTRL_UPDIRF_bp = 5               ; UPDI Reset flag bit position\n.equ RSTCTRL_WDRF_bm = 0x08              ; Watch dog Reset flag bit mask\n.equ RSTCTRL_WDRF_bp = 3                 ; Watch dog Reset flag bit position\n\n; RSTCTRL_SWRR masks\n.equ RSTCTRL_SWRE_bm = 0x01              ; Software reset enable bit mask\n.equ RSTCTRL_SWRE_bp = 0                 ; Software reset enable bit position\n\n\n;*************************************************************************\n;** RTC - Real-Time Counter\n;*************************************************************************\n\n; RTC_CLKSEL masks\n.equ RTC_CLKSEL_gm = 0x03                ; Clock Select group mask\n.equ RTC_CLKSEL_gp = 0                   ; Clock Select group position\n.equ RTC_CLKSEL0_bm = (1<<0)             ; Clock Select bit 0 mask\n.equ RTC_CLKSEL0_bp = 0                  ; Clock Select bit 0 position\n.equ RTC_CLKSEL1_bm = (1<<1)             ; Clock Select bit 1 mask\n.equ RTC_CLKSEL1_bp = 1                  ; Clock Select bit 1 position\n\n; RTC_CTRLA masks\n.equ RTC_PRESCALER_gm = 0x78             ; Prescaling Factor group mask\n.equ RTC_PRESCALER_gp = 3                ; Prescaling Factor group position\n.equ RTC_PRESCALER0_bm = (1<<3)          ; Prescaling Factor bit 0 mask\n.equ RTC_PRESCALER0_bp = 3               ; Prescaling Factor bit 0 position\n.equ RTC_PRESCALER1_bm = (1<<4)          ; Prescaling Factor bit 1 mask\n.equ RTC_PRESCALER1_bp = 4               ; Prescaling Factor bit 1 position\n.equ RTC_PRESCALER2_bm = (1<<5)          ; Prescaling Factor bit 2 mask\n.equ RTC_PRESCALER2_bp = 5               ; Prescaling Factor bit 2 position\n.equ RTC_PRESCALER3_bm = (1<<6)          ; Prescaling Factor bit 3 mask\n.equ RTC_PRESCALER3_bp = 6               ; Prescaling Factor bit 3 position\n.equ RTC_RTCEN_bm = 0x01                 ; Enable bit mask\n.equ RTC_RTCEN_bp = 0                    ; Enable bit position\n.equ RTC_RUNSTDBY_bm = 0x80              ; Run In Standby bit mask\n.equ RTC_RUNSTDBY_bp = 7                 ; Run In Standby bit position\n\n; RTC_DBGCTRL masks\n.equ RTC_DBGRUN_bm = 0x01                ; Run in debug bit mask\n.equ RTC_DBGRUN_bp = 0                   ; Run in debug bit position\n\n; RTC_INTCTRL masks\n.equ RTC_CMP_bm = 0x02                   ; Compare Match Interrupt enable bit mask\n.equ RTC_CMP_bp = 1                      ; Compare Match Interrupt enable bit position\n.equ RTC_OVF_bm = 0x01                   ; Overflow Interrupt enable bit mask\n.equ RTC_OVF_bp = 0                      ; Overflow Interrupt enable bit position\n\n; RTC_INTFLAGS masks\n; Masks for RTC_CMP already defined\n; Masks for RTC_OVF already defined\n\n; RTC_PITCTRLA masks\n.equ RTC_PERIOD_gm = 0x78                ; Period group mask\n.equ RTC_PERIOD_gp = 3                   ; Period group position\n.equ RTC_PERIOD0_bm = (1<<3)             ; Period bit 0 mask\n.equ RTC_PERIOD0_bp = 3                  ; Period bit 0 position\n.equ RTC_PERIOD1_bm = (1<<4)             ; Period bit 1 mask\n.equ RTC_PERIOD1_bp = 4                  ; Period bit 1 position\n.equ RTC_PERIOD2_bm = (1<<5)             ; Period bit 2 mask\n.equ RTC_PERIOD2_bp = 5                  ; Period bit 2 position\n.equ RTC_PERIOD3_bm = (1<<6)             ; Period bit 3 mask\n.equ RTC_PERIOD3_bp = 6                  ; Period bit 3 position\n.equ RTC_PITEN_bm = 0x01                 ; Enable bit mask\n.equ RTC_PITEN_bp = 0                    ; Enable bit position\n\n; RTC_PITDBGCTRL masks\n; Masks for RTC_DBGRUN already defined\n\n; RTC_PITINTCTRL masks\n.equ RTC_PI_bm = 0x01                    ; Periodic Interrupt bit mask\n.equ RTC_PI_bp = 0                       ; Periodic Interrupt bit position\n\n; RTC_PITINTFLAGS masks\n; Masks for RTC_PI already defined\n\n; RTC_PITSTATUS masks\n.equ RTC_CTRLBUSY_bm = 0x01              ; CTRLA Synchronization Busy Flag bit mask\n.equ RTC_CTRLBUSY_bp = 0                 ; CTRLA Synchronization Busy Flag bit position\n\n; RTC_STATUS masks\n.equ RTC_CMPBUSY_bm = 0x08               ; Comparator Synchronization Busy Flag bit mask\n.equ RTC_CMPBUSY_bp = 3                  ; Comparator Synchronization Busy Flag bit position\n.equ RTC_CNTBUSY_bm = 0x02               ; Count Synchronization Busy Flag bit mask\n.equ RTC_CNTBUSY_bp = 1                  ; Count Synchronization Busy Flag bit position\n.equ RTC_CTRLABUSY_bm = 0x01             ; CTRLA Synchronization Busy Flag bit mask\n.equ RTC_CTRLABUSY_bp = 0                ; CTRLA Synchronization Busy Flag bit position\n.equ RTC_PERBUSY_bm = 0x04               ; Period Synchronization Busy Flag bit mask\n.equ RTC_PERBUSY_bp = 2                  ; Period Synchronization Busy Flag bit position\n\n; Clock Select select\n.equ RTC_CLKSEL_INT32K_gc = (0x00<<0)    ; Internal 32kHz OSC\n.equ RTC_CLKSEL_INT1K_gc = (0x01<<0)     ; Internal 1kHz OSC\n.equ RTC_CLKSEL_EXTCLK_gc = (0x03<<0)    ; External Clock\n\n; Prescaling Factor select\n.equ RTC_PRESCALER_DIV1_gc = (0x00<<3)   ; RTC Clock / 1\n.equ RTC_PRESCALER_DIV2_gc = (0x01<<3)   ; RTC Clock / 2\n.equ RTC_PRESCALER_DIV4_gc = (0x02<<3)   ; RTC Clock / 4\n.equ RTC_PRESCALER_DIV8_gc = (0x03<<3)   ; RTC Clock / 8\n.equ RTC_PRESCALER_DIV16_gc = (0x04<<3)  ; RTC Clock / 16\n.equ RTC_PRESCALER_DIV32_gc = (0x05<<3)  ; RTC Clock / 32\n.equ RTC_PRESCALER_DIV64_gc = (0x06<<3)  ; RTC Clock / 64\n.equ RTC_PRESCALER_DIV128_gc = (0x07<<3) ; RTC Clock / 128\n.equ RTC_PRESCALER_DIV256_gc = (0x08<<3) ; RTC Clock / 256\n.equ RTC_PRESCALER_DIV512_gc = (0x09<<3) ; RTC Clock / 512\n.equ RTC_PRESCALER_DIV1024_gc = (0x0A<<3) ; RTC Clock / 1024\n.equ RTC_PRESCALER_DIV2048_gc = (0x0B<<3) ; RTC Clock / 2048\n.equ RTC_PRESCALER_DIV4096_gc = (0x0C<<3) ; RTC Clock / 4096\n.equ RTC_PRESCALER_DIV8192_gc = (0x0D<<3) ; RTC Clock / 8192\n.equ RTC_PRESCALER_DIV16384_gc = (0x0E<<3) ; RTC Clock / 16384\n.equ RTC_PRESCALER_DIV32768_gc = (0x0F<<3) ; RTC Clock / 32768\n\n; Period select\n.equ RTC_PERIOD_OFF_gc = (0x00<<3)       ; Off\n.equ RTC_PERIOD_CYC4_gc = (0x01<<3)      ; RTC Clock Cycles 4\n.equ RTC_PERIOD_CYC8_gc = (0x02<<3)      ; RTC Clock Cycles 8\n.equ RTC_PERIOD_CYC16_gc = (0x03<<3)     ; RTC Clock Cycles 16\n.equ RTC_PERIOD_CYC32_gc = (0x04<<3)     ; RTC Clock Cycles 32\n.equ RTC_PERIOD_CYC64_gc = (0x05<<3)     ; RTC Clock Cycles 64\n.equ RTC_PERIOD_CYC128_gc = (0x06<<3)    ; RTC Clock Cycles 128\n.equ RTC_PERIOD_CYC256_gc = (0x07<<3)    ; RTC Clock Cycles 256\n.equ RTC_PERIOD_CYC512_gc = (0x08<<3)    ; RTC Clock Cycles 512\n.equ RTC_PERIOD_CYC1024_gc = (0x09<<3)   ; RTC Clock Cycles 1024\n.equ RTC_PERIOD_CYC2048_gc = (0x0A<<3)   ; RTC Clock Cycles 2048\n.equ RTC_PERIOD_CYC4096_gc = (0x0B<<3)   ; RTC Clock Cycles 4096\n.equ RTC_PERIOD_CYC8192_gc = (0x0C<<3)   ; RTC Clock Cycles 8192\n.equ RTC_PERIOD_CYC16384_gc = (0x0D<<3)  ; RTC Clock Cycles 16384\n.equ RTC_PERIOD_CYC32768_gc = (0x0E<<3)  ; RTC Clock Cycles 32768\n\n\n;*************************************************************************\n;** SIGROW - Signature row\n;*************************************************************************\n\n\n;*************************************************************************\n;** SLPCTRL - Sleep Controller\n;*************************************************************************\n\n; SLPCTRL_CTRLA masks\n.equ SLPCTRL_SEN_bm = 0x01               ; Sleep enable bit mask\n.equ SLPCTRL_SEN_bp = 0                  ; Sleep enable bit position\n.equ SLPCTRL_SMODE_gm = 0x06             ; Sleep mode group mask\n.equ SLPCTRL_SMODE_gp = 1                ; Sleep mode group position\n.equ SLPCTRL_SMODE0_bm = (1<<1)          ; Sleep mode bit 0 mask\n.equ SLPCTRL_SMODE0_bp = 1               ; Sleep mode bit 0 position\n.equ SLPCTRL_SMODE1_bm = (1<<2)          ; Sleep mode bit 1 mask\n.equ SLPCTRL_SMODE1_bp = 2               ; Sleep mode bit 1 position\n\n; Sleep mode select\n.equ SLPCTRL_SMODE_IDLE_gc = (0x00<<1)   ; Idle mode\n.equ SLPCTRL_SMODE_STDBY_gc = (0x01<<1)  ; Standby Mode\n.equ SLPCTRL_SMODE_PDOWN_gc = (0x02<<1)  ; Power-down Mode\n\n\n;*************************************************************************\n;** SPI - Serial Peripheral Interface\n;*************************************************************************\n\n; SPI_CTRLA masks\n.equ SPI_CLK2X_bm = 0x10                 ; Enable Double Speed bit mask\n.equ SPI_CLK2X_bp = 4                    ; Enable Double Speed bit position\n.equ SPI_DORD_bm = 0x40                  ; Data Order Setting bit mask\n.equ SPI_DORD_bp = 6                     ; Data Order Setting bit position\n.equ SPI_ENABLE_bm = 0x01                ; Enable Module bit mask\n.equ SPI_ENABLE_bp = 0                   ; Enable Module bit position\n.equ SPI_MASTER_bm = 0x20                ; Master Operation Enable bit mask\n.equ SPI_MASTER_bp = 5                   ; Master Operation Enable bit position\n.equ SPI_PRESC_gm = 0x06                 ; Prescaler group mask\n.equ SPI_PRESC_gp = 1                    ; Prescaler group position\n.equ SPI_PRESC0_bm = (1<<1)              ; Prescaler bit 0 mask\n.equ SPI_PRESC0_bp = 1                   ; Prescaler bit 0 position\n.equ SPI_PRESC1_bm = (1<<2)              ; Prescaler bit 1 mask\n.equ SPI_PRESC1_bp = 2                   ; Prescaler bit 1 position\n\n; SPI_CTRLB masks\n.equ SPI_BUFEN_bm = 0x80                 ; Buffer Mode Enable bit mask\n.equ SPI_BUFEN_bp = 7                    ; Buffer Mode Enable bit position\n.equ SPI_BUFWR_bm = 0x40                 ; Buffer Write Mode bit mask\n.equ SPI_BUFWR_bp = 6                    ; Buffer Write Mode bit position\n.equ SPI_MODE_gm = 0x03                  ; SPI Mode group mask\n.equ SPI_MODE_gp = 0                     ; SPI Mode group position\n.equ SPI_MODE0_bm = (1<<0)               ; SPI Mode bit 0 mask\n.equ SPI_MODE0_bp = 0                    ; SPI Mode bit 0 position\n.equ SPI_MODE1_bm = (1<<1)               ; SPI Mode bit 1 mask\n.equ SPI_MODE1_bp = 1                    ; SPI Mode bit 1 position\n.equ SPI_SSD_bm = 0x04                   ; Slave Select Disable bit mask\n.equ SPI_SSD_bp = 2                      ; Slave Select Disable bit position\n\n; SPI_INTCTRL masks\n.equ SPI_DREIE_bm = 0x20                 ; Data Register Empty Interrupt Enable bit mask\n.equ SPI_DREIE_bp = 5                    ; Data Register Empty Interrupt Enable bit position\n.equ SPI_IE_bm = 0x01                    ; Interrupt Enable bit mask\n.equ SPI_IE_bp = 0                       ; Interrupt Enable bit position\n.equ SPI_RXCIE_bm = 0x80                 ; Receive Complete Interrupt Enable bit mask\n.equ SPI_RXCIE_bp = 7                    ; Receive Complete Interrupt Enable bit position\n.equ SPI_SSIE_bm = 0x10                  ; Slave Select Trigger Interrupt Enable bit mask\n.equ SPI_SSIE_bp = 4                     ; Slave Select Trigger Interrupt Enable bit position\n.equ SPI_TXCIE_bm = 0x40                 ; Transfer Complete Interrupt Enable bit mask\n.equ SPI_TXCIE_bp = 6                    ; Transfer Complete Interrupt Enable bit position\n\n; SPI_INTFLAGS masks\n.equ SPI_BUFOVF_bm = 0x01                ; Buffer Overflow bit mask\n.equ SPI_BUFOVF_bp = 0                   ; Buffer Overflow bit position\n.equ SPI_DREIF_bm = 0x20                 ; Data Register Empty Interrupt Flag bit mask\n.equ SPI_DREIF_bp = 5                    ; Data Register Empty Interrupt Flag bit position\n.equ SPI_RXCIF_bm = 0x80                 ; Receive Complete Interrupt Flag bit mask\n.equ SPI_RXCIF_bp = 7                    ; Receive Complete Interrupt Flag bit position\n.equ SPI_SSIF_bm = 0x10                  ; Slave Select Trigger Interrupt Flag bit mask\n.equ SPI_SSIF_bp = 4                     ; Slave Select Trigger Interrupt Flag bit position\n.equ SPI_TXCIF_bm = 0x40                 ; Transfer Complete Interrupt Flag bit mask\n.equ SPI_TXCIF_bp = 6                    ; Transfer Complete Interrupt Flag bit position\n.equ SPI_IF_bm = 0x80                    ; Interrupt Flag bit mask\n.equ SPI_IF_bp = 7                       ; Interrupt Flag bit position\n.equ SPI_WRCOL_bm = 0x40                 ; Write Collision bit mask\n.equ SPI_WRCOL_bp = 6                    ; Write Collision bit position\n\n; Prescaler select\n.equ SPI_PRESC_DIV4_gc = (0x00<<1)       ; System Clock / 4\n.equ SPI_PRESC_DIV16_gc = (0x01<<1)      ; System Clock / 16\n.equ SPI_PRESC_DIV64_gc = (0x02<<1)      ; System Clock / 64\n.equ SPI_PRESC_DIV128_gc = (0x03<<1)     ; System Clock / 128\n\n; SPI Mode select\n.equ SPI_MODE_0_gc = (0x00<<0)           ; SPI Mode 0\n.equ SPI_MODE_1_gc = (0x01<<0)           ; SPI Mode 1\n.equ SPI_MODE_2_gc = (0x02<<0)           ; SPI Mode 2\n.equ SPI_MODE_3_gc = (0x03<<0)           ; SPI Mode 3\n\n\n;*************************************************************************\n;** SYSCFG - System Configuration Registers\n;*************************************************************************\n\n; SYSCFG_EXTBRK masks\n.equ SYSCFG_ENEXTBRK_bm = 0x01           ; External break enable bit mask\n.equ SYSCFG_ENEXTBRK_bp = 0              ; External break enable bit position\n\n\n;*************************************************************************\n;** TCA - 16-bit Timer/Counter Type A\n;*************************************************************************\n\n; TCA_SINGLE_CTRLA masks\n.equ TCA_SINGLE_CLKSEL_gm = 0x0E         ; Clock Selection group mask\n.equ TCA_SINGLE_CLKSEL_gp = 1            ; Clock Selection group position\n.equ TCA_SINGLE_CLKSEL0_bm = (1<<1)      ; Clock Selection bit 0 mask\n.equ TCA_SINGLE_CLKSEL0_bp = 1           ; Clock Selection bit 0 position\n.equ TCA_SINGLE_CLKSEL1_bm = (1<<2)      ; Clock Selection bit 1 mask\n.equ TCA_SINGLE_CLKSEL1_bp = 2           ; Clock Selection bit 1 position\n.equ TCA_SINGLE_CLKSEL2_bm = (1<<3)      ; Clock Selection bit 2 mask\n.equ TCA_SINGLE_CLKSEL2_bp = 3           ; Clock Selection bit 2 position\n.equ TCA_SINGLE_ENABLE_bm = 0x01         ; Module Enable bit mask\n.equ TCA_SINGLE_ENABLE_bp = 0            ; Module Enable bit position\n\n; TCA_SINGLE_CTRLB masks\n.equ TCA_SINGLE_ALUPD_bm = 0x08          ; Auto Lock Update bit mask\n.equ TCA_SINGLE_ALUPD_bp = 3             ; Auto Lock Update bit position\n.equ TCA_SINGLE_CMP0EN_bm = 0x10         ; Compare 0 Enable bit mask\n.equ TCA_SINGLE_CMP0EN_bp = 4            ; Compare 0 Enable bit position\n.equ TCA_SINGLE_CMP1EN_bm = 0x20         ; Compare 1 Enable bit mask\n.equ TCA_SINGLE_CMP1EN_bp = 5            ; Compare 1 Enable bit position\n.equ TCA_SINGLE_CMP2EN_bm = 0x40         ; Compare 2 Enable bit mask\n.equ TCA_SINGLE_CMP2EN_bp = 6            ; Compare 2 Enable bit position\n.equ TCA_SINGLE_WGMODE_gm = 0x07         ; Waveform generation mode group mask\n.equ TCA_SINGLE_WGMODE_gp = 0            ; Waveform generation mode group position\n.equ TCA_SINGLE_WGMODE0_bm = (1<<0)      ; Waveform generation mode bit 0 mask\n.equ TCA_SINGLE_WGMODE0_bp = 0           ; Waveform generation mode bit 0 position\n.equ TCA_SINGLE_WGMODE1_bm = (1<<1)      ; Waveform generation mode bit 1 mask\n.equ TCA_SINGLE_WGMODE1_bp = 1           ; Waveform generation mode bit 1 position\n.equ TCA_SINGLE_WGMODE2_bm = (1<<2)      ; Waveform generation mode bit 2 mask\n.equ TCA_SINGLE_WGMODE2_bp = 2           ; Waveform generation mode bit 2 position\n\n; TCA_SINGLE_CTRLC masks\n.equ TCA_SINGLE_CMP0OV_bm = 0x01         ; Compare 0 Waveform Output Value bit mask\n.equ TCA_SINGLE_CMP0OV_bp = 0            ; Compare 0 Waveform Output Value bit position\n.equ TCA_SINGLE_CMP1OV_bm = 0x02         ; Compare 1 Waveform Output Value bit mask\n.equ TCA_SINGLE_CMP1OV_bp = 1            ; Compare 1 Waveform Output Value bit position\n.equ TCA_SINGLE_CMP2OV_bm = 0x04         ; Compare 2 Waveform Output Value bit mask\n.equ TCA_SINGLE_CMP2OV_bp = 2            ; Compare 2 Waveform Output Value bit position\n\n; TCA_SINGLE_CTRLD masks\n.equ TCA_SINGLE_SPLITM_bm = 0x01         ; Split Mode Enable bit mask\n.equ TCA_SINGLE_SPLITM_bp = 0            ; Split Mode Enable bit position\n\n; TCA_SINGLE_CTRLECLR masks\n.equ TCA_SINGLE_CMD_gm = 0x0C            ; Command group mask\n.equ TCA_SINGLE_CMD_gp = 2               ; Command group position\n.equ TCA_SINGLE_CMD0_bm = (1<<2)         ; Command bit 0 mask\n.equ TCA_SINGLE_CMD0_bp = 2              ; Command bit 0 position\n.equ TCA_SINGLE_CMD1_bm = (1<<3)         ; Command bit 1 mask\n.equ TCA_SINGLE_CMD1_bp = 3              ; Command bit 1 position\n.equ TCA_SINGLE_DIR_bm = 0x01            ; Direction bit mask\n.equ TCA_SINGLE_DIR_bp = 0               ; Direction bit position\n.equ TCA_SINGLE_LUPD_bm = 0x02           ; Lock Update bit mask\n.equ TCA_SINGLE_LUPD_bp = 1              ; Lock Update bit position\n\n; TCA_SINGLE_CTRLESET masks\n; Masks for TCA_SINGLE_CMD already defined\n; Masks for TCA_SINGLE_DIR already defined\n; Masks for TCA_SINGLE_LUPD already defined\n\n; TCA_SINGLE_CTRLFCLR masks\n.equ TCA_SINGLE_CMP0BV_bm = 0x02         ; Compare 0 Buffer Valid bit mask\n.equ TCA_SINGLE_CMP0BV_bp = 1            ; Compare 0 Buffer Valid bit position\n.equ TCA_SINGLE_CMP1BV_bm = 0x04         ; Compare 1 Buffer Valid bit mask\n.equ TCA_SINGLE_CMP1BV_bp = 2            ; Compare 1 Buffer Valid bit position\n.equ TCA_SINGLE_CMP2BV_bm = 0x08         ; Compare 2 Buffer Valid bit mask\n.equ TCA_SINGLE_CMP2BV_bp = 3            ; Compare 2 Buffer Valid bit position\n.equ TCA_SINGLE_PERBV_bm = 0x01          ; Period Buffer Valid bit mask\n.equ TCA_SINGLE_PERBV_bp = 0             ; Period Buffer Valid bit position\n\n; TCA_SINGLE_CTRLFSET masks\n; Masks for TCA_SINGLE_CMP0BV already defined\n; Masks for TCA_SINGLE_CMP1BV already defined\n; Masks for TCA_SINGLE_CMP2BV already defined\n; Masks for TCA_SINGLE_PERBV already defined\n\n; TCA_SINGLE_DBGCTRL masks\n.equ TCA_SINGLE_DBGRUN_bm = 0x01         ; Debug Run bit mask\n.equ TCA_SINGLE_DBGRUN_bp = 0            ; Debug Run bit position\n\n; TCA_SINGLE_EVCTRL masks\n.equ TCA_SINGLE_CNTEI_bm = 0x01          ; Count on Event Input bit mask\n.equ TCA_SINGLE_CNTEI_bp = 0             ; Count on Event Input bit position\n.equ TCA_SINGLE_EVACT_gm = 0x06          ; Event Action group mask\n.equ TCA_SINGLE_EVACT_gp = 1             ; Event Action group position\n.equ TCA_SINGLE_EVACT0_bm = (1<<1)       ; Event Action bit 0 mask\n.equ TCA_SINGLE_EVACT0_bp = 1            ; Event Action bit 0 position\n.equ TCA_SINGLE_EVACT1_bm = (1<<2)       ; Event Action bit 1 mask\n.equ TCA_SINGLE_EVACT1_bp = 2            ; Event Action bit 1 position\n\n; TCA_SINGLE_INTCTRL masks\n.equ TCA_SINGLE_CMP0_bm = 0x10           ; Compare 0 Interrupt bit mask\n.equ TCA_SINGLE_CMP0_bp = 4              ; Compare 0 Interrupt bit position\n.equ TCA_SINGLE_CMP1_bm = 0x20           ; Compare 1 Interrupt bit mask\n.equ TCA_SINGLE_CMP1_bp = 5              ; Compare 1 Interrupt bit position\n.equ TCA_SINGLE_CMP2_bm = 0x40           ; Compare 2 Interrupt bit mask\n.equ TCA_SINGLE_CMP2_bp = 6              ; Compare 2 Interrupt bit position\n.equ TCA_SINGLE_OVF_bm = 0x01            ; Overflow Interrupt bit mask\n.equ TCA_SINGLE_OVF_bp = 0               ; Overflow Interrupt bit position\n\n; TCA_SINGLE_INTFLAGS masks\n; Masks for TCA_SINGLE_CMP0 already defined\n; Masks for TCA_SINGLE_CMP1 already defined\n; Masks for TCA_SINGLE_CMP2 already defined\n; Masks for TCA_SINGLE_OVF already defined\n\n; TCA_SPLIT_CTRLA masks\n.equ TCA_SPLIT_CLKSEL_gm = 0x0E          ; Clock Selection group mask\n.equ TCA_SPLIT_CLKSEL_gp = 1             ; Clock Selection group position\n.equ TCA_SPLIT_CLKSEL0_bm = (1<<1)       ; Clock Selection bit 0 mask\n.equ TCA_SPLIT_CLKSEL0_bp = 1            ; Clock Selection bit 0 position\n.equ TCA_SPLIT_CLKSEL1_bm = (1<<2)       ; Clock Selection bit 1 mask\n.equ TCA_SPLIT_CLKSEL1_bp = 2            ; Clock Selection bit 1 position\n.equ TCA_SPLIT_CLKSEL2_bm = (1<<3)       ; Clock Selection bit 2 mask\n.equ TCA_SPLIT_CLKSEL2_bp = 3            ; Clock Selection bit 2 position\n.equ TCA_SPLIT_ENABLE_bm = 0x01          ; Module Enable bit mask\n.equ TCA_SPLIT_ENABLE_bp = 0             ; Module Enable bit position\n\n; TCA_SPLIT_CTRLB masks\n.equ TCA_SPLIT_HCMP0EN_bm = 0x10         ; High Compare 0 Enable bit mask\n.equ TCA_SPLIT_HCMP0EN_bp = 4            ; High Compare 0 Enable bit position\n.equ TCA_SPLIT_HCMP1EN_bm = 0x20         ; High Compare 1 Enable bit mask\n.equ TCA_SPLIT_HCMP1EN_bp = 5            ; High Compare 1 Enable bit position\n.equ TCA_SPLIT_HCMP2EN_bm = 0x40         ; High Compare 2 Enable bit mask\n.equ TCA_SPLIT_HCMP2EN_bp = 6            ; High Compare 2 Enable bit position\n.equ TCA_SPLIT_LCMP0EN_bm = 0x01         ; Low Compare 0 Enable bit mask\n.equ TCA_SPLIT_LCMP0EN_bp = 0            ; Low Compare 0 Enable bit position\n.equ TCA_SPLIT_LCMP1EN_bm = 0x02         ; Low Compare 1 Enable bit mask\n.equ TCA_SPLIT_LCMP1EN_bp = 1            ; Low Compare 1 Enable bit position\n.equ TCA_SPLIT_LCMP2EN_bm = 0x04         ; Low Compare 2 Enable bit mask\n.equ TCA_SPLIT_LCMP2EN_bp = 2            ; Low Compare 2 Enable bit position\n\n; TCA_SPLIT_CTRLC masks\n.equ TCA_SPLIT_HCMP0OV_bm = 0x10         ; High Compare 0 Output Value bit mask\n.equ TCA_SPLIT_HCMP0OV_bp = 4            ; High Compare 0 Output Value bit position\n.equ TCA_SPLIT_HCMP1OV_bm = 0x20         ; High Compare 1 Output Value bit mask\n.equ TCA_SPLIT_HCMP1OV_bp = 5            ; High Compare 1 Output Value bit position\n.equ TCA_SPLIT_HCMP2OV_bm = 0x40         ; High Compare 2 Output Value bit mask\n.equ TCA_SPLIT_HCMP2OV_bp = 6            ; High Compare 2 Output Value bit position\n.equ TCA_SPLIT_LCMP0OV_bm = 0x01         ; Low Compare 0 Output Value bit mask\n.equ TCA_SPLIT_LCMP0OV_bp = 0            ; Low Compare 0 Output Value bit position\n.equ TCA_SPLIT_LCMP1OV_bm = 0x02         ; Low Compare 1 Output Value bit mask\n.equ TCA_SPLIT_LCMP1OV_bp = 1            ; Low Compare 1 Output Value bit position\n.equ TCA_SPLIT_LCMP2OV_bm = 0x04         ; Low Compare 2 Output Value bit mask\n.equ TCA_SPLIT_LCMP2OV_bp = 2            ; Low Compare 2 Output Value bit position\n\n; TCA_SPLIT_CTRLD masks\n.equ TCA_SPLIT_SPLITM_bm = 0x01          ; Split Mode Enable bit mask\n.equ TCA_SPLIT_SPLITM_bp = 0             ; Split Mode Enable bit position\n\n; TCA_SPLIT_CTRLECLR masks\n.equ TCA_SPLIT_CMD_gm = 0x0C             ; Command group mask\n.equ TCA_SPLIT_CMD_gp = 2                ; Command group position\n.equ TCA_SPLIT_CMD0_bm = (1<<2)          ; Command bit 0 mask\n.equ TCA_SPLIT_CMD0_bp = 2               ; Command bit 0 position\n.equ TCA_SPLIT_CMD1_bm = (1<<3)          ; Command bit 1 mask\n.equ TCA_SPLIT_CMD1_bp = 3               ; Command bit 1 position\n\n; TCA_SPLIT_CTRLESET masks\n; Masks for TCA_SPLIT_CMD already defined\n\n; TCA_SPLIT_DBGCTRL masks\n.equ TCA_SPLIT_DBGRUN_bm = 0x01          ; Debug Run bit mask\n.equ TCA_SPLIT_DBGRUN_bp = 0             ; Debug Run bit position\n\n; TCA_SPLIT_INTCTRL masks\n.equ TCA_SPLIT_HUNF_bm = 0x02            ; High Underflow Interrupt Enable bit mask\n.equ TCA_SPLIT_HUNF_bp = 1               ; High Underflow Interrupt Enable bit position\n.equ TCA_SPLIT_LCMP0_bm = 0x10           ; Low Compare 0 Interrupt Enable bit mask\n.equ TCA_SPLIT_LCMP0_bp = 4              ; Low Compare 0 Interrupt Enable bit position\n.equ TCA_SPLIT_LCMP1_bm = 0x20           ; Low Compare 1 Interrupt Enable bit mask\n.equ TCA_SPLIT_LCMP1_bp = 5              ; Low Compare 1 Interrupt Enable bit position\n.equ TCA_SPLIT_LCMP2_bm = 0x40           ; Low Compare 2 Interrupt Enable bit mask\n.equ TCA_SPLIT_LCMP2_bp = 6              ; Low Compare 2 Interrupt Enable bit position\n.equ TCA_SPLIT_LUNF_bm = 0x01            ; Low Underflow Interrupt Enable bit mask\n.equ TCA_SPLIT_LUNF_bp = 0               ; Low Underflow Interrupt Enable bit position\n\n; TCA_SPLIT_INTFLAGS masks\n; Masks for TCA_SPLIT_HUNF already defined\n; Masks for TCA_SPLIT_LCMP0 already defined\n; Masks for TCA_SPLIT_LCMP1 already defined\n; Masks for TCA_SPLIT_LCMP2 already defined\n; Masks for TCA_SPLIT_LUNF already defined\n\n; Clock Selection select\n.equ TCA_SINGLE_CLKSEL_DIV1_gc = (0x00<<1) ; System Clock\n.equ TCA_SINGLE_CLKSEL_DIV2_gc = (0x01<<1) ; System Clock / 2\n.equ TCA_SINGLE_CLKSEL_DIV4_gc = (0x02<<1) ; System Clock / 4\n.equ TCA_SINGLE_CLKSEL_DIV8_gc = (0x03<<1) ; System Clock / 8\n.equ TCA_SINGLE_CLKSEL_DIV16_gc = (0x04<<1) ; System Clock / 16\n.equ TCA_SINGLE_CLKSEL_DIV64_gc = (0x05<<1) ; System Clock / 64\n.equ TCA_SINGLE_CLKSEL_DIV256_gc = (0x06<<1) ; System Clock / 256\n.equ TCA_SINGLE_CLKSEL_DIV1024_gc = (0x07<<1) ; System Clock / 1024\n\n; Waveform generation mode select\n.equ TCA_SINGLE_WGMODE_NORMAL_gc = (0x00<<0) ; Normal Mode\n.equ TCA_SINGLE_WGMODE_FRQ_gc = (0x01<<0) ; Frequency Generation Mode\n.equ TCA_SINGLE_WGMODE_SINGLESLOPE_gc = (0x03<<0) ; Single Slope PWM\n.equ TCA_SINGLE_WGMODE_DSTOP_gc = (0x05<<0) ; Dual Slope PWM, overflow on TOP\n.equ TCA_SINGLE_WGMODE_DSBOTH_gc = (0x06<<0) ; Dual Slope PWM, overflow on TOP and BOTTOM\n.equ TCA_SINGLE_WGMODE_DSBOTTOM_gc = (0x07<<0) ; Dual Slope PWM, overflow on BOTTOM\n\n; Command select\n.equ TCA_SINGLE_CMD_NONE_gc = (0x00<<2)  ; No Command\n.equ TCA_SINGLE_CMD_UPDATE_gc = (0x01<<2) ; Force Update\n.equ TCA_SINGLE_CMD_RESTART_gc = (0x02<<2) ; Force Restart\n.equ TCA_SINGLE_CMD_RESET_gc = (0x03<<2) ; Force Hard Reset\n\n; Direction select\n.equ TCA_SINGLE_DIR_UP_gc = (0x00<<0)    ; Count up\n.equ TCA_SINGLE_DIR_DOWN_gc = (0x01<<0)  ; Count down\n\n; Event Action select\n.equ TCA_SINGLE_EVACT_POSEDGE_gc = (0x00<<1) ; Count on positive edge event\n.equ TCA_SINGLE_EVACT_ANYEDGE_gc = (0x01<<1) ; Count on any edge event\n.equ TCA_SINGLE_EVACT_HIGHLVL_gc = (0x02<<1) ; Count on prescaled clock while event line is 1.\n.equ TCA_SINGLE_EVACT_UPDOWN_gc = (0x03<<1) ; Count on prescaled clock. Event controls count direction. Up-count when event line is 0, down-count when event line is 1.\n\n; Clock Selection select\n.equ TCA_SPLIT_CLKSEL_DIV1_gc = (0x00<<1) ; System Clock\n.equ TCA_SPLIT_CLKSEL_DIV2_gc = (0x01<<1) ; System Clock / 2\n.equ TCA_SPLIT_CLKSEL_DIV4_gc = (0x02<<1) ; System Clock / 4\n.equ TCA_SPLIT_CLKSEL_DIV8_gc = (0x03<<1) ; System Clock / 8\n.equ TCA_SPLIT_CLKSEL_DIV16_gc = (0x04<<1) ; System Clock / 16\n.equ TCA_SPLIT_CLKSEL_DIV64_gc = (0x05<<1) ; System Clock / 64\n.equ TCA_SPLIT_CLKSEL_DIV256_gc = (0x06<<1) ; System Clock / 256\n.equ TCA_SPLIT_CLKSEL_DIV1024_gc = (0x07<<1) ; System Clock / 1024\n\n; Command select\n.equ TCA_SPLIT_CMD_NONE_gc = (0x00<<2)   ; No Command\n.equ TCA_SPLIT_CMD_UPDATE_gc = (0x01<<2) ; Force Update\n.equ TCA_SPLIT_CMD_RESTART_gc = (0x02<<2) ; Force Restart\n.equ TCA_SPLIT_CMD_RESET_gc = (0x03<<2)  ; Force Hard Reset\n\n\n;*************************************************************************\n;** TCB - 16-bit Timer Type B\n;*************************************************************************\n\n; TCB_CTRLA masks\n.equ TCB_CLKSEL_gm = 0x06                ; Clock Select group mask\n.equ TCB_CLKSEL_gp = 1                   ; Clock Select group position\n.equ TCB_CLKSEL0_bm = (1<<1)             ; Clock Select bit 0 mask\n.equ TCB_CLKSEL0_bp = 1                  ; Clock Select bit 0 position\n.equ TCB_CLKSEL1_bm = (1<<2)             ; Clock Select bit 1 mask\n.equ TCB_CLKSEL1_bp = 2                  ; Clock Select bit 1 position\n.equ TCB_ENABLE_bm = 0x01                ; Enable bit mask\n.equ TCB_ENABLE_bp = 0                   ; Enable bit position\n.equ TCB_RUNSTDBY_bm = 0x40              ; Run Standby bit mask\n.equ TCB_RUNSTDBY_bp = 6                 ; Run Standby bit position\n.equ TCB_SYNCUPD_bm = 0x10               ; Synchronize Update bit mask\n.equ TCB_SYNCUPD_bp = 4                  ; Synchronize Update bit position\n\n; TCB_CTRLB masks\n.equ TCB_ASYNC_bm = 0x40                 ; Asynchronous Enable bit mask\n.equ TCB_ASYNC_bp = 6                    ; Asynchronous Enable bit position\n.equ TCB_CCMPEN_bm = 0x10                ; Pin Output Enable bit mask\n.equ TCB_CCMPEN_bp = 4                   ; Pin Output Enable bit position\n.equ TCB_CCMPINIT_bm = 0x20              ; Pin Initial State bit mask\n.equ TCB_CCMPINIT_bp = 5                 ; Pin Initial State bit position\n.equ TCB_CNTMODE_gm = 0x07               ; Timer Mode group mask\n.equ TCB_CNTMODE_gp = 0                  ; Timer Mode group position\n.equ TCB_CNTMODE0_bm = (1<<0)            ; Timer Mode bit 0 mask\n.equ TCB_CNTMODE0_bp = 0                 ; Timer Mode bit 0 position\n.equ TCB_CNTMODE1_bm = (1<<1)            ; Timer Mode bit 1 mask\n.equ TCB_CNTMODE1_bp = 1                 ; Timer Mode bit 1 position\n.equ TCB_CNTMODE2_bm = (1<<2)            ; Timer Mode bit 2 mask\n.equ TCB_CNTMODE2_bp = 2                 ; Timer Mode bit 2 position\n\n; TCB_DBGCTRL masks\n.equ TCB_DBGRUN_bm = 0x01                ; Debug Run bit mask\n.equ TCB_DBGRUN_bp = 0                   ; Debug Run bit position\n\n; TCB_EVCTRL masks\n.equ TCB_CAPTEI_bm = 0x01                ; Event Input Enable bit mask\n.equ TCB_CAPTEI_bp = 0                   ; Event Input Enable bit position\n.equ TCB_EDGE_bm = 0x10                  ; Event Edge bit mask\n.equ TCB_EDGE_bp = 4                     ; Event Edge bit position\n.equ TCB_FILTER_bm = 0x40                ; Input Capture Noise Cancellation Filter bit mask\n.equ TCB_FILTER_bp = 6                   ; Input Capture Noise Cancellation Filter bit position\n\n; TCB_INTCTRL masks\n.equ TCB_CAPT_bm = 0x01                  ; Capture or Timeout bit mask\n.equ TCB_CAPT_bp = 0                     ; Capture or Timeout bit position\n\n; TCB_INTFLAGS masks\n; Masks for TCB_CAPT already defined\n\n; TCB_STATUS masks\n.equ TCB_RUN_bm = 0x01                   ; Run bit mask\n.equ TCB_RUN_bp = 0                      ; Run bit position\n\n; Clock Select select\n.equ TCB_CLKSEL_CLKDIV1_gc = (0x00<<1)   ; CLK_PER (No Prescaling)\n.equ TCB_CLKSEL_CLKDIV2_gc = (0x01<<1)   ; CLK_PER/2 (From Prescaler)\n.equ TCB_CLKSEL_CLKTCA_gc = (0x02<<1)    ; Use Clock from TCA\n\n; Timer Mode select\n.equ TCB_CNTMODE_INT_gc = (0x00<<0)      ; Periodic Interrupt\n.equ TCB_CNTMODE_TIMEOUT_gc = (0x01<<0)  ; Periodic Timeout\n.equ TCB_CNTMODE_CAPT_gc = (0x02<<0)     ; Input Capture Event\n.equ TCB_CNTMODE_FRQ_gc = (0x03<<0)      ; Input Capture Frequency measurement\n.equ TCB_CNTMODE_PW_gc = (0x04<<0)       ; Input Capture Pulse-Width measurement\n.equ TCB_CNTMODE_FRQPW_gc = (0x05<<0)    ; Input Capture Frequency and Pulse-Width measurement\n.equ TCB_CNTMODE_SINGLE_gc = (0x06<<0)   ; Single Shot\n.equ TCB_CNTMODE_PWM8_gc = (0x07<<0)     ; 8-bit PWM\n\n\n;*************************************************************************\n;** TWI - Two-Wire Interface\n;*************************************************************************\n\n; TWI_CTRLA masks\n.equ TWI_FMPEN_bm = 0x02                 ; FM Plus Enable bit mask\n.equ TWI_FMPEN_bp = 1                    ; FM Plus Enable bit position\n.equ TWI_SDAHOLD_gm = 0x0C               ; SDA Hold Time group mask\n.equ TWI_SDAHOLD_gp = 2                  ; SDA Hold Time group position\n.equ TWI_SDAHOLD0_bm = (1<<2)            ; SDA Hold Time bit 0 mask\n.equ TWI_SDAHOLD0_bp = 2                 ; SDA Hold Time bit 0 position\n.equ TWI_SDAHOLD1_bm = (1<<3)            ; SDA Hold Time bit 1 mask\n.equ TWI_SDAHOLD1_bp = 3                 ; SDA Hold Time bit 1 position\n.equ TWI_SDASETUP_bm = 0x10              ; SDA Setup Time bit mask\n.equ TWI_SDASETUP_bp = 4                 ; SDA Setup Time bit position\n\n; TWI_DBGCTRL masks\n.equ TWI_DBGRUN_bm = 0x01                ; Debug Run bit mask\n.equ TWI_DBGRUN_bp = 0                   ; Debug Run bit position\n\n; TWI_MCTRLA masks\n.equ TWI_ENABLE_bm = 0x01                ; Enable TWI Master bit mask\n.equ TWI_ENABLE_bp = 0                   ; Enable TWI Master bit position\n.equ TWI_QCEN_bm = 0x10                  ; Quick Command Enable bit mask\n.equ TWI_QCEN_bp = 4                     ; Quick Command Enable bit position\n.equ TWI_RIEN_bm = 0x80                  ; Read Interrupt Enable bit mask\n.equ TWI_RIEN_bp = 7                     ; Read Interrupt Enable bit position\n.equ TWI_SMEN_bm = 0x02                  ; Smart Mode Enable bit mask\n.equ TWI_SMEN_bp = 1                     ; Smart Mode Enable bit position\n.equ TWI_TIMEOUT_gm = 0x0C               ; Inactive Bus Timeout group mask\n.equ TWI_TIMEOUT_gp = 2                  ; Inactive Bus Timeout group position\n.equ TWI_TIMEOUT0_bm = (1<<2)            ; Inactive Bus Timeout bit 0 mask\n.equ TWI_TIMEOUT0_bp = 2                 ; Inactive Bus Timeout bit 0 position\n.equ TWI_TIMEOUT1_bm = (1<<3)            ; Inactive Bus Timeout bit 1 mask\n.equ TWI_TIMEOUT1_bp = 3                 ; Inactive Bus Timeout bit 1 position\n.equ TWI_WIEN_bm = 0x40                  ; Write Interrupt Enable bit mask\n.equ TWI_WIEN_bp = 6                     ; Write Interrupt Enable bit position\n\n; TWI_MCTRLB masks\n.equ TWI_ACKACT_bm = 0x04                ; Acknowledge Action bit mask\n.equ TWI_ACKACT_bp = 2                   ; Acknowledge Action bit position\n.equ TWI_FLUSH_bm = 0x08                 ; Flush bit mask\n.equ TWI_FLUSH_bp = 3                    ; Flush bit position\n.equ TWI_MCMD_gm = 0x03                  ; Command group mask\n.equ TWI_MCMD_gp = 0                     ; Command group position\n.equ TWI_MCMD0_bm = (1<<0)               ; Command bit 0 mask\n.equ TWI_MCMD0_bp = 0                    ; Command bit 0 position\n.equ TWI_MCMD1_bm = (1<<1)               ; Command bit 1 mask\n.equ TWI_MCMD1_bp = 1                    ; Command bit 1 position\n\n; TWI_MSTATUS masks\n.equ TWI_ARBLOST_bm = 0x08               ; Arbitration Lost bit mask\n.equ TWI_ARBLOST_bp = 3                  ; Arbitration Lost bit position\n.equ TWI_BUSERR_bm = 0x04                ; Bus Error bit mask\n.equ TWI_BUSERR_bp = 2                   ; Bus Error bit position\n.equ TWI_BUSSTATE_gm = 0x03              ; Bus State group mask\n.equ TWI_BUSSTATE_gp = 0                 ; Bus State group position\n.equ TWI_BUSSTATE0_bm = (1<<0)           ; Bus State bit 0 mask\n.equ TWI_BUSSTATE0_bp = 0                ; Bus State bit 0 position\n.equ TWI_BUSSTATE1_bm = (1<<1)           ; Bus State bit 1 mask\n.equ TWI_BUSSTATE1_bp = 1                ; Bus State bit 1 position\n.equ TWI_CLKHOLD_bm = 0x20               ; Clock Hold bit mask\n.equ TWI_CLKHOLD_bp = 5                  ; Clock Hold bit position\n.equ TWI_RIF_bm = 0x80                   ; Read Interrupt Flag bit mask\n.equ TWI_RIF_bp = 7                      ; Read Interrupt Flag bit position\n.equ TWI_RXACK_bm = 0x10                 ; Received Acknowledge bit mask\n.equ TWI_RXACK_bp = 4                    ; Received Acknowledge bit position\n.equ TWI_WIF_bm = 0x40                   ; Write Interrupt Flag bit mask\n.equ TWI_WIF_bp = 6                      ; Write Interrupt Flag bit position\n\n; TWI_SADDRMASK masks\n.equ TWI_ADDREN_bm = 0x01                ; Address Enable bit mask\n.equ TWI_ADDREN_bp = 0                   ; Address Enable bit position\n.equ TWI_ADDRMASK_gm = 0xFE              ; Address Mask group mask\n.equ TWI_ADDRMASK_gp = 1                 ; Address Mask group position\n.equ TWI_ADDRMASK0_bm = (1<<1)           ; Address Mask bit 0 mask\n.equ TWI_ADDRMASK0_bp = 1                ; Address Mask bit 0 position\n.equ TWI_ADDRMASK1_bm = (1<<2)           ; Address Mask bit 1 mask\n.equ TWI_ADDRMASK1_bp = 2                ; Address Mask bit 1 position\n.equ TWI_ADDRMASK2_bm = (1<<3)           ; Address Mask bit 2 mask\n.equ TWI_ADDRMASK2_bp = 3                ; Address Mask bit 2 position\n.equ TWI_ADDRMASK3_bm = (1<<4)           ; Address Mask bit 3 mask\n.equ TWI_ADDRMASK3_bp = 4                ; Address Mask bit 3 position\n.equ TWI_ADDRMASK4_bm = (1<<5)           ; Address Mask bit 4 mask\n.equ TWI_ADDRMASK4_bp = 5                ; Address Mask bit 4 position\n.equ TWI_ADDRMASK5_bm = (1<<6)           ; Address Mask bit 5 mask\n.equ TWI_ADDRMASK5_bp = 6                ; Address Mask bit 5 position\n.equ TWI_ADDRMASK6_bm = (1<<7)           ; Address Mask bit 6 mask\n.equ TWI_ADDRMASK6_bp = 7                ; Address Mask bit 6 position\n\n; TWI_SCTRLA masks\n.equ TWI_APIEN_bm = 0x40                 ; Address/Stop Interrupt Enable bit mask\n.equ TWI_APIEN_bp = 6                    ; Address/Stop Interrupt Enable bit position\n.equ TWI_DIEN_bm = 0x80                  ; Data Interrupt Enable bit mask\n.equ TWI_DIEN_bp = 7                     ; Data Interrupt Enable bit position\n; Masks for TWI_ENABLE already defined\n.equ TWI_PIEN_bm = 0x20                  ; Stop Interrupt Enable bit mask\n.equ TWI_PIEN_bp = 5                     ; Stop Interrupt Enable bit position\n.equ TWI_PMEN_bm = 0x04                  ; Promiscuous Mode Enable bit mask\n.equ TWI_PMEN_bp = 2                     ; Promiscuous Mode Enable bit position\n; Masks for TWI_SMEN already defined\n\n; TWI_SCTRLB masks\n; Masks for TWI_ACKACT already defined\n.equ TWI_SCMD_gm = 0x03                  ; Command group mask\n.equ TWI_SCMD_gp = 0                     ; Command group position\n.equ TWI_SCMD0_bm = (1<<0)               ; Command bit 0 mask\n.equ TWI_SCMD0_bp = 0                    ; Command bit 0 position\n.equ TWI_SCMD1_bm = (1<<1)               ; Command bit 1 mask\n.equ TWI_SCMD1_bp = 1                    ; Command bit 1 position\n\n; TWI_SSTATUS masks\n.equ TWI_AP_bm = 0x01                    ; Slave Address or Stop bit mask\n.equ TWI_AP_bp = 0                       ; Slave Address or Stop bit position\n.equ TWI_APIF_bm = 0x40                  ; Address/Stop Interrupt Flag bit mask\n.equ TWI_APIF_bp = 6                     ; Address/Stop Interrupt Flag bit position\n; Masks for TWI_BUSERR already defined\n; Masks for TWI_CLKHOLD already defined\n.equ TWI_COLL_bm = 0x08                  ; Collision bit mask\n.equ TWI_COLL_bp = 3                     ; Collision bit position\n.equ TWI_DIF_bm = 0x80                   ; Data Interrupt Flag bit mask\n.equ TWI_DIF_bp = 7                      ; Data Interrupt Flag bit position\n.equ TWI_DIR_bm = 0x02                   ; Read/Write Direction bit mask\n.equ TWI_DIR_bp = 1                      ; Read/Write Direction bit position\n; Masks for TWI_RXACK already defined\n\n; SDA Hold Time select\n.equ TWI_SDAHOLD_OFF_gc = (0x00<<2)      ; SDA hold time off\n.equ TWI_SDAHOLD_50NS_gc = (0x01<<2)     ; Typical 50ns hold time\n.equ TWI_SDAHOLD_300NS_gc = (0x02<<2)    ; Typical 300ns hold time\n.equ TWI_SDAHOLD_500NS_gc = (0x03<<2)    ; Typical 500ns hold time\n\n; SDA Setup Time select\n.equ TWI_SDASETUP_4CYC_gc = (0x00<<4)    ; SDA setup time is 4 clock cycles\n.equ TWI_SDASETUP_8CYC_gc = (0x01<<4)    ; SDA setup time is 8 clock cycles\n\n; Inactive Bus Timeout select\n.equ TWI_TIMEOUT_DISABLED_gc = (0x00<<2) ; Bus Timeout Disabled\n.equ TWI_TIMEOUT_50US_gc = (0x01<<2)     ; 50 Microseconds\n.equ TWI_TIMEOUT_100US_gc = (0x02<<2)    ; 100 Microseconds\n.equ TWI_TIMEOUT_200US_gc = (0x03<<2)    ; 200 Microseconds\n\n; Acknowledge Action select\n.equ TWI_ACKACT_ACK_gc = (0x00<<2)       ; Send ACK\n.equ TWI_ACKACT_NACK_gc = (0x01<<2)      ; Send NACK\n\n; Command select\n.equ TWI_MCMD_NOACT_gc = (0x00<<0)       ; No Action\n.equ TWI_MCMD_REPSTART_gc = (0x01<<0)    ; Issue Repeated Start Condition\n.equ TWI_MCMD_RECVTRANS_gc = (0x02<<0)   ; Receive or Transmit Data, depending on DIR\n.equ TWI_MCMD_STOP_gc = (0x03<<0)        ; Issue Stop Condition\n\n; Bus State select\n.equ TWI_BUSSTATE_UNKNOWN_gc = (0x00<<0) ; Unknown Bus State\n.equ TWI_BUSSTATE_IDLE_gc = (0x01<<0)    ; Bus is Idle\n.equ TWI_BUSSTATE_OWNER_gc = (0x02<<0)   ; This Module Controls The Bus\n.equ TWI_BUSSTATE_BUSY_gc = (0x03<<0)    ; The Bus is Busy\n\n; Command select\n.equ TWI_SCMD_NOACT_gc = (0x00<<0)       ; No Action\n.equ TWI_SCMD_COMPTRANS_gc = (0x02<<0)   ; Used To Complete a Transaction\n.equ TWI_SCMD_RESPONSE_gc = (0x03<<0)    ; Used in Response to Address/Data Interrupt\n\n; Slave Address or Stop select\n.equ TWI_AP_STOP_gc = (0x00<<0)          ; Stop condition generated APIF\n.equ TWI_AP_ADR_gc = (0x01<<0)           ; Address detection generated APIF\n\n\n;*************************************************************************\n;** USART - Universal Synchronous and Asynchronous Receiver and Transmitter\n;*************************************************************************\n\n; USART_CTRLA masks\n.equ USART_ABEIE_bm = 0x04               ; Auto-baud Error Interrupt Enable bit mask\n.equ USART_ABEIE_bp = 2                  ; Auto-baud Error Interrupt Enable bit position\n.equ USART_DREIE_bm = 0x20               ; Data Register Empty Interrupt Enable bit mask\n.equ USART_DREIE_bp = 5                  ; Data Register Empty Interrupt Enable bit position\n.equ USART_LBME_bm = 0x08                ; Loop-back Mode Enable bit mask\n.equ USART_LBME_bp = 3                   ; Loop-back Mode Enable bit position\n.equ USART_RS485_gm = 0x03               ; RS485 Mode internal transmitter group mask\n.equ USART_RS485_gp = 0                  ; RS485 Mode internal transmitter group position\n.equ USART_RS4850_bm = (1<<0)            ; RS485 Mode internal transmitter bit 0 mask\n.equ USART_RS4850_bp = 0                 ; RS485 Mode internal transmitter bit 0 position\n.equ USART_RS4851_bm = (1<<1)            ; RS485 Mode internal transmitter bit 1 mask\n.equ USART_RS4851_bp = 1                 ; RS485 Mode internal transmitter bit 1 position\n.equ USART_RXCIE_bm = 0x80               ; Receive Complete Interrupt Enable bit mask\n.equ USART_RXCIE_bp = 7                  ; Receive Complete Interrupt Enable bit position\n.equ USART_RXSIE_bm = 0x10               ; Receiver Start Frame Interrupt Enable bit mask\n.equ USART_RXSIE_bp = 4                  ; Receiver Start Frame Interrupt Enable bit position\n.equ USART_TXCIE_bm = 0x40               ; Transmit Complete Interrupt Enable bit mask\n.equ USART_TXCIE_bp = 6                  ; Transmit Complete Interrupt Enable bit position\n\n; USART_CTRLB masks\n.equ USART_MPCM_bm = 0x01                ; Multi-processor Communication Mode bit mask\n.equ USART_MPCM_bp = 0                   ; Multi-processor Communication Mode bit position\n.equ USART_ODME_bm = 0x08                ; Open Drain Mode Enable bit mask\n.equ USART_ODME_bp = 3                   ; Open Drain Mode Enable bit position\n.equ USART_RXEN_bm = 0x80                ; Reciever enable bit mask\n.equ USART_RXEN_bp = 7                   ; Reciever enable bit position\n.equ USART_RXMODE_gm = 0x06              ; Receiver Mode group mask\n.equ USART_RXMODE_gp = 1                 ; Receiver Mode group position\n.equ USART_RXMODE0_bm = (1<<1)           ; Receiver Mode bit 0 mask\n.equ USART_RXMODE0_bp = 1                ; Receiver Mode bit 0 position\n.equ USART_RXMODE1_bm = (1<<2)           ; Receiver Mode bit 1 mask\n.equ USART_RXMODE1_bp = 2                ; Receiver Mode bit 1 position\n.equ USART_SFDEN_bm = 0x10               ; Start Frame Detection Enable bit mask\n.equ USART_SFDEN_bp = 4                  ; Start Frame Detection Enable bit position\n.equ USART_TXEN_bm = 0x40                ; Transmitter Enable bit mask\n.equ USART_TXEN_bp = 6                   ; Transmitter Enable bit position\n\n; USART_CTRLC masks\n.equ USART_CMODE_gm = 0xC0               ; Communication Mode group mask\n.equ USART_CMODE_gp = 6                  ; Communication Mode group position\n.equ USART_CMODE0_bm = (1<<6)            ; Communication Mode bit 0 mask\n.equ USART_CMODE0_bp = 6                 ; Communication Mode bit 0 position\n.equ USART_CMODE1_bm = (1<<7)            ; Communication Mode bit 1 mask\n.equ USART_CMODE1_bp = 7                 ; Communication Mode bit 1 position\n.equ USART_UCPHA_bm = 0x02               ; SPI Master Mode, Clock Phase bit mask\n.equ USART_UCPHA_bp = 1                  ; SPI Master Mode, Clock Phase bit position\n.equ USART_UDORD_bm = 0x04               ; SPI Master Mode, Data Order bit mask\n.equ USART_UDORD_bp = 2                  ; SPI Master Mode, Data Order bit position\n.equ USART_CHSIZE_gm = 0x07              ; Character Size group mask\n.equ USART_CHSIZE_gp = 0                 ; Character Size group position\n.equ USART_CHSIZE0_bm = (1<<0)           ; Character Size bit 0 mask\n.equ USART_CHSIZE0_bp = 0                ; Character Size bit 0 position\n.equ USART_CHSIZE1_bm = (1<<1)           ; Character Size bit 1 mask\n.equ USART_CHSIZE1_bp = 1                ; Character Size bit 1 position\n.equ USART_CHSIZE2_bm = (1<<2)           ; Character Size bit 2 mask\n.equ USART_CHSIZE2_bp = 2                ; Character Size bit 2 position\n; Masks for USART_CMODE already defined\n.equ USART_PMODE_gm = 0x30               ; Parity Mode group mask\n.equ USART_PMODE_gp = 4                  ; Parity Mode group position\n.equ USART_PMODE0_bm = (1<<4)            ; Parity Mode bit 0 mask\n.equ USART_PMODE0_bp = 4                 ; Parity Mode bit 0 position\n.equ USART_PMODE1_bm = (1<<5)            ; Parity Mode bit 1 mask\n.equ USART_PMODE1_bp = 5                 ; Parity Mode bit 1 position\n.equ USART_SBMODE_bm = 0x08              ; Stop Bit Mode bit mask\n.equ USART_SBMODE_bp = 3                 ; Stop Bit Mode bit position\n\n; USART_DBGCTRL masks\n.equ USART_DBGRUN_bm = 0x01              ; Debug Run bit mask\n.equ USART_DBGRUN_bp = 0                 ; Debug Run bit position\n\n; USART_EVCTRL masks\n.equ USART_IREI_bm = 0x01                ; IrDA Event Input Enable bit mask\n.equ USART_IREI_bp = 0                   ; IrDA Event Input Enable bit position\n\n; USART_RXDATAH masks\n.equ USART_BUFOVF_bm = 0x40              ; Buffer Overflow bit mask\n.equ USART_BUFOVF_bp = 6                 ; Buffer Overflow bit position\n.equ USART_DATA8_bm = 0x01               ; Receiver Data Register bit mask\n.equ USART_DATA8_bp = 0                  ; Receiver Data Register bit position\n.equ USART_FERR_bm = 0x04                ; Frame Error bit mask\n.equ USART_FERR_bp = 2                   ; Frame Error bit position\n.equ USART_PERR_bm = 0x02                ; Parity Error bit mask\n.equ USART_PERR_bp = 1                   ; Parity Error bit position\n.equ USART_RXCIF_bm = 0x80               ; Receive Complete Interrupt Flag bit mask\n.equ USART_RXCIF_bp = 7                  ; Receive Complete Interrupt Flag bit position\n\n; USART_RXDATAL masks\n.equ USART_DATA_gm = 0xFF                ; RX Data group mask\n.equ USART_DATA_gp = 0                   ; RX Data group position\n.equ USART_DATA0_bm = (1<<0)             ; RX Data bit 0 mask\n.equ USART_DATA0_bp = 0                  ; RX Data bit 0 position\n.equ USART_DATA1_bm = (1<<1)             ; RX Data bit 1 mask\n.equ USART_DATA1_bp = 1                  ; RX Data bit 1 position\n.equ USART_DATA2_bm = (1<<2)             ; RX Data bit 2 mask\n.equ USART_DATA2_bp = 2                  ; RX Data bit 2 position\n.equ USART_DATA3_bm = (1<<3)             ; RX Data bit 3 mask\n.equ USART_DATA3_bp = 3                  ; RX Data bit 3 position\n.equ USART_DATA4_bm = (1<<4)             ; RX Data bit 4 mask\n.equ USART_DATA4_bp = 4                  ; RX Data bit 4 position\n.equ USART_DATA5_bm = (1<<5)             ; RX Data bit 5 mask\n.equ USART_DATA5_bp = 5                  ; RX Data bit 5 position\n.equ USART_DATA6_bm = (1<<6)             ; RX Data bit 6 mask\n.equ USART_DATA6_bp = 6                  ; RX Data bit 6 position\n.equ USART_DATA7_bm = (1<<7)             ; RX Data bit 7 mask\n.equ USART_DATA7_bp = 7                  ; RX Data bit 7 position\n\n; USART_RXPLCTRL masks\n.equ USART_RXPL_gm = 0x7F                ; Receiver Pulse Lenght group mask\n.equ USART_RXPL_gp = 0                   ; Receiver Pulse Lenght group position\n.equ USART_RXPL0_bm = (1<<0)             ; Receiver Pulse Lenght bit 0 mask\n.equ USART_RXPL0_bp = 0                  ; Receiver Pulse Lenght bit 0 position\n.equ USART_RXPL1_bm = (1<<1)             ; Receiver Pulse Lenght bit 1 mask\n.equ USART_RXPL1_bp = 1                  ; Receiver Pulse Lenght bit 1 position\n.equ USART_RXPL2_bm = (1<<2)             ; Receiver Pulse Lenght bit 2 mask\n.equ USART_RXPL2_bp = 2                  ; Receiver Pulse Lenght bit 2 position\n.equ USART_RXPL3_bm = (1<<3)             ; Receiver Pulse Lenght bit 3 mask\n.equ USART_RXPL3_bp = 3                  ; Receiver Pulse Lenght bit 3 position\n.equ USART_RXPL4_bm = (1<<4)             ; Receiver Pulse Lenght bit 4 mask\n.equ USART_RXPL4_bp = 4                  ; Receiver Pulse Lenght bit 4 position\n.equ USART_RXPL5_bm = (1<<5)             ; Receiver Pulse Lenght bit 5 mask\n.equ USART_RXPL5_bp = 5                  ; Receiver Pulse Lenght bit 5 position\n.equ USART_RXPL6_bm = (1<<6)             ; Receiver Pulse Lenght bit 6 mask\n.equ USART_RXPL6_bp = 6                  ; Receiver Pulse Lenght bit 6 position\n\n; USART_STATUS masks\n.equ USART_BDF_bm = 0x02                 ; Break Detected Flag bit mask\n.equ USART_BDF_bp = 1                    ; Break Detected Flag bit position\n.equ USART_DREIF_bm = 0x20               ; Data Register Empty Flag bit mask\n.equ USART_DREIF_bp = 5                  ; Data Register Empty Flag bit position\n.equ USART_ISFIF_bm = 0x08               ; Inconsistent Sync Field Interrupt Flag bit mask\n.equ USART_ISFIF_bp = 3                  ; Inconsistent Sync Field Interrupt Flag bit position\n; Masks for USART_RXCIF already defined\n.equ USART_RXSIF_bm = 0x10               ; Receive Start Interrupt bit mask\n.equ USART_RXSIF_bp = 4                  ; Receive Start Interrupt bit position\n.equ USART_TXCIF_bm = 0x40               ; Transmit Interrupt Flag bit mask\n.equ USART_TXCIF_bp = 6                  ; Transmit Interrupt Flag bit position\n.equ USART_WFB_bm = 0x01                 ; Wait For Break bit mask\n.equ USART_WFB_bp = 0                    ; Wait For Break bit position\n\n; USART_TXDATAH masks\n; Masks for USART_DATA8 already defined\n\n; USART_TXDATAL masks\n; Masks for USART_DATA already defined\n\n; USART_TXPLCTRL masks\n.equ USART_TXPL_gm = 0xFF                ; Transmit pulse length group mask\n.equ USART_TXPL_gp = 0                   ; Transmit pulse length group position\n.equ USART_TXPL0_bm = (1<<0)             ; Transmit pulse length bit 0 mask\n.equ USART_TXPL0_bp = 0                  ; Transmit pulse length bit 0 position\n.equ USART_TXPL1_bm = (1<<1)             ; Transmit pulse length bit 1 mask\n.equ USART_TXPL1_bp = 1                  ; Transmit pulse length bit 1 position\n.equ USART_TXPL2_bm = (1<<2)             ; Transmit pulse length bit 2 mask\n.equ USART_TXPL2_bp = 2                  ; Transmit pulse length bit 2 position\n.equ USART_TXPL3_bm = (1<<3)             ; Transmit pulse length bit 3 mask\n.equ USART_TXPL3_bp = 3                  ; Transmit pulse length bit 3 position\n.equ USART_TXPL4_bm = (1<<4)             ; Transmit pulse length bit 4 mask\n.equ USART_TXPL4_bp = 4                  ; Transmit pulse length bit 4 position\n.equ USART_TXPL5_bm = (1<<5)             ; Transmit pulse length bit 5 mask\n.equ USART_TXPL5_bp = 5                  ; Transmit pulse length bit 5 position\n.equ USART_TXPL6_bm = (1<<6)             ; Transmit pulse length bit 6 mask\n.equ USART_TXPL6_bp = 6                  ; Transmit pulse length bit 6 position\n.equ USART_TXPL7_bm = (1<<7)             ; Transmit pulse length bit 7 mask\n.equ USART_TXPL7_bp = 7                  ; Transmit pulse length bit 7 position\n\n; RS485 Mode internal transmitter select\n.equ USART_RS485_OFF_gc = (0x00<<0)      ; RS485 Mode disabled\n.equ USART_RS485_EXT_gc = (0x01<<0)      ; RS485 Mode External drive\n.equ USART_RS485_INT_gc = (0x02<<0)      ; RS485 Mode Internal drive\n\n; Receiver Mode select\n.equ USART_RXMODE_NORMAL_gc = (0x00<<1)  ; Normal mode\n.equ USART_RXMODE_CLK2X_gc = (0x01<<1)   ; CLK2x mode\n.equ USART_RXMODE_GENAUTO_gc = (0x02<<1) ; Generic autobaud mode\n.equ USART_RXMODE_LINAUTO_gc = (0x03<<1) ; LIN constrained autobaud mode\n\n; Communication Mode select\n.equ USART_MSPI_CMODE_ASYNCHRONOUS_gc = (0x00<<6) ; Asynchronous Mode\n.equ USART_MSPI_CMODE_SYNCHRONOUS_gc = (0x01<<6) ; Synchronous Mode\n.equ USART_MSPI_CMODE_IRCOM_gc = (0x02<<6) ; Infrared Communication\n.equ USART_MSPI_CMODE_MSPI_gc = (0x03<<6) ; Master SPI Mode\n\n; Character Size select\n.equ USART_NORMAL_CHSIZE_5BIT_gc = (0x00<<0) ; Character size: 5 bit\n.equ USART_NORMAL_CHSIZE_6BIT_gc = (0x01<<0) ; Character size: 6 bit\n.equ USART_NORMAL_CHSIZE_7BIT_gc = (0x02<<0) ; Character size: 7 bit\n.equ USART_NORMAL_CHSIZE_8BIT_gc = (0x03<<0) ; Character size: 8 bit\n.equ USART_NORMAL_CHSIZE_9BITL_gc = (0x06<<0) ; Character size: 9 bit read low byte first\n.equ USART_NORMAL_CHSIZE_9BITH_gc = (0x07<<0) ; Character size: 9 bit read high byte first\n\n; Communication Mode select\n.equ USART_NORMAL_CMODE_ASYNCHRONOUS_gc = (0x00<<6) ; Asynchronous Mode\n.equ USART_NORMAL_CMODE_SYNCHRONOUS_gc = (0x01<<6) ; Synchronous Mode\n.equ USART_NORMAL_CMODE_IRCOM_gc = (0x02<<6) ; Infrared Communication\n.equ USART_NORMAL_CMODE_MSPI_gc = (0x03<<6) ; Master SPI Mode\n\n; Parity Mode select\n.equ USART_NORMAL_PMODE_DISABLED_gc = (0x00<<4) ; No Parity\n.equ USART_NORMAL_PMODE_EVEN_gc = (0x02<<4) ; Even Parity\n.equ USART_NORMAL_PMODE_ODD_gc = (0x03<<4) ; Odd Parity\n\n; Stop Bit Mode select\n.equ USART_NORMAL_SBMODE_1BIT_gc = (0x00<<3) ; 1 stop bit\n.equ USART_NORMAL_SBMODE_2BIT_gc = (0x01<<3) ; 2 stop bits\n\n\n;*************************************************************************\n;** USERROW - User Row\n;*************************************************************************\n\n\n;*************************************************************************\n;** VPORT - Virtual Ports\n;*************************************************************************\n\n; VPORT_INTFLAGS masks\n.equ VPORT_INT_gm = 0xFF                 ; Pin Interrupt group mask\n.equ VPORT_INT_gp = 0                    ; Pin Interrupt group position\n.equ VPORT_INT0_bm = (1<<0)              ; Pin Interrupt bit 0 mask\n.equ VPORT_INT0_bp = 0                   ; Pin Interrupt bit 0 position\n.equ VPORT_INT1_bm = (1<<1)              ; Pin Interrupt bit 1 mask\n.equ VPORT_INT1_bp = 1                   ; Pin Interrupt bit 1 position\n.equ VPORT_INT2_bm = (1<<2)              ; Pin Interrupt bit 2 mask\n.equ VPORT_INT2_bp = 2                   ; Pin Interrupt bit 2 position\n.equ VPORT_INT3_bm = (1<<3)              ; Pin Interrupt bit 3 mask\n.equ VPORT_INT3_bp = 3                   ; Pin Interrupt bit 3 position\n.equ VPORT_INT4_bm = (1<<4)              ; Pin Interrupt bit 4 mask\n.equ VPORT_INT4_bp = 4                   ; Pin Interrupt bit 4 position\n.equ VPORT_INT5_bm = (1<<5)              ; Pin Interrupt bit 5 mask\n.equ VPORT_INT5_bp = 5                   ; Pin Interrupt bit 5 position\n.equ VPORT_INT6_bm = (1<<6)              ; Pin Interrupt bit 6 mask\n.equ VPORT_INT6_bp = 6                   ; Pin Interrupt bit 6 position\n.equ VPORT_INT7_bm = (1<<7)              ; Pin Interrupt bit 7 mask\n.equ VPORT_INT7_bp = 7                   ; Pin Interrupt bit 7 position\n\n\n;*************************************************************************\n;** VREF - Voltage reference\n;*************************************************************************\n\n; VREF_CTRLA masks\n.equ VREF_ADC0REFSEL_gm = 0x70           ; ADC0 reference select group mask\n.equ VREF_ADC0REFSEL_gp = 4              ; ADC0 reference select group position\n.equ VREF_ADC0REFSEL0_bm = (1<<4)        ; ADC0 reference select bit 0 mask\n.equ VREF_ADC0REFSEL0_bp = 4             ; ADC0 reference select bit 0 position\n.equ VREF_ADC0REFSEL1_bm = (1<<5)        ; ADC0 reference select bit 1 mask\n.equ VREF_ADC0REFSEL1_bp = 5             ; ADC0 reference select bit 1 position\n.equ VREF_ADC0REFSEL2_bm = (1<<6)        ; ADC0 reference select bit 2 mask\n.equ VREF_ADC0REFSEL2_bp = 6             ; ADC0 reference select bit 2 position\n.equ VREF_DAC0REFSEL_gm = 0x07           ; DAC0/AC0 reference select group mask\n.equ VREF_DAC0REFSEL_gp = 0              ; DAC0/AC0 reference select group position\n.equ VREF_DAC0REFSEL0_bm = (1<<0)        ; DAC0/AC0 reference select bit 0 mask\n.equ VREF_DAC0REFSEL0_bp = 0             ; DAC0/AC0 reference select bit 0 position\n.equ VREF_DAC0REFSEL1_bm = (1<<1)        ; DAC0/AC0 reference select bit 1 mask\n.equ VREF_DAC0REFSEL1_bp = 1             ; DAC0/AC0 reference select bit 1 position\n.equ VREF_DAC0REFSEL2_bm = (1<<2)        ; DAC0/AC0 reference select bit 2 mask\n.equ VREF_DAC0REFSEL2_bp = 2             ; DAC0/AC0 reference select bit 2 position\n\n; VREF_CTRLB masks\n.equ VREF_ADC0REFEN_bm = 0x02            ; ADC0 reference enable bit mask\n.equ VREF_ADC0REFEN_bp = 1               ; ADC0 reference enable bit position\n.equ VREF_DAC0REFEN_bm = 0x01            ; DAC0/AC0 reference enable bit mask\n.equ VREF_DAC0REFEN_bp = 0               ; DAC0/AC0 reference enable bit position\n\n; ADC0 reference select select\n.equ VREF_ADC0REFSEL_0V55_gc = (0x00<<4) ; Voltage reference at 0.55V\n.equ VREF_ADC0REFSEL_1V1_gc = (0x01<<4)  ; Voltage reference at 1.1V\n.equ VREF_ADC0REFSEL_2V5_gc = (0x02<<4)  ; Voltage reference at 2.5V\n.equ VREF_ADC0REFSEL_4V34_gc = (0x03<<4) ; Voltage reference at 4.34V\n.equ VREF_ADC0REFSEL_1V5_gc = (0x04<<4)  ; Voltage reference at 1.5V\n\n; DAC0/AC0 reference select select\n.equ VREF_DAC0REFSEL_0V55_gc = (0x00<<0) ; Voltage reference at 0.55V\n.equ VREF_DAC0REFSEL_1V1_gc = (0x01<<0)  ; Voltage reference at 1.1V\n.equ VREF_DAC0REFSEL_2V5_gc = (0x02<<0)  ; Voltage reference at 2.5V\n.equ VREF_DAC0REFSEL_4V34_gc = (0x03<<0) ; Voltage reference at 4.34V\n.equ VREF_DAC0REFSEL_1V5_gc = (0x04<<0)  ; Voltage reference at 1.5V\n\n\n;*************************************************************************\n;** WDT - Watch-Dog Timer\n;*************************************************************************\n\n; WDT_CTRLA masks\n.equ WDT_PERIOD_gm = 0x0F                ; Period group mask\n.equ WDT_PERIOD_gp = 0                   ; Period group position\n.equ WDT_PERIOD0_bm = (1<<0)             ; Period bit 0 mask\n.equ WDT_PERIOD0_bp = 0                  ; Period bit 0 position\n.equ WDT_PERIOD1_bm = (1<<1)             ; Period bit 1 mask\n.equ WDT_PERIOD1_bp = 1                  ; Period bit 1 position\n.equ WDT_PERIOD2_bm = (1<<2)             ; Period bit 2 mask\n.equ WDT_PERIOD2_bp = 2                  ; Period bit 2 position\n.equ WDT_PERIOD3_bm = (1<<3)             ; Period bit 3 mask\n.equ WDT_PERIOD3_bp = 3                  ; Period bit 3 position\n.equ WDT_WINDOW_gm = 0xF0                ; Window group mask\n.equ WDT_WINDOW_gp = 4                   ; Window group position\n.equ WDT_WINDOW0_bm = (1<<4)             ; Window bit 0 mask\n.equ WDT_WINDOW0_bp = 4                  ; Window bit 0 position\n.equ WDT_WINDOW1_bm = (1<<5)             ; Window bit 1 mask\n.equ WDT_WINDOW1_bp = 5                  ; Window bit 1 position\n.equ WDT_WINDOW2_bm = (1<<6)             ; Window bit 2 mask\n.equ WDT_WINDOW2_bp = 6                  ; Window bit 2 position\n.equ WDT_WINDOW3_bm = (1<<7)             ; Window bit 3 mask\n.equ WDT_WINDOW3_bp = 7                  ; Window bit 3 position\n\n; WDT_STATUS masks\n.equ WDT_LOCK_bm = 0x80                  ; Lock enable bit mask\n.equ WDT_LOCK_bp = 7                     ; Lock enable bit position\n.equ WDT_SYNCBUSY_bm = 0x01              ; Syncronization busy bit mask\n.equ WDT_SYNCBUSY_bp = 0                 ; Syncronization busy bit position\n\n; Period select\n.equ WDT_PERIOD_OFF_gc = (0x00<<0)       ; Watch-Dog timer Off\n.equ WDT_PERIOD_8CLK_gc = (0x01<<0)      ; 8 cycles (8ms)\n.equ WDT_PERIOD_16CLK_gc = (0x02<<0)     ; 16 cycles (16ms)\n.equ WDT_PERIOD_32CLK_gc = (0x03<<0)     ; 32 cycles (32ms)\n.equ WDT_PERIOD_64CLK_gc = (0x04<<0)     ; 64 cycles (64ms)\n.equ WDT_PERIOD_128CLK_gc = (0x05<<0)    ; 128 cycles (0.128s)\n.equ WDT_PERIOD_256CLK_gc = (0x06<<0)    ; 256 cycles (0.256s)\n.equ WDT_PERIOD_512CLK_gc = (0x07<<0)    ; 512 cycles (0.512s)\n.equ WDT_PERIOD_1KCLK_gc = (0x08<<0)     ; 1K cycles (1.0s)\n.equ WDT_PERIOD_2KCLK_gc = (0x09<<0)     ; 2K cycles (2.0s)\n.equ WDT_PERIOD_4KCLK_gc = (0x0A<<0)     ; 4K cycles (4.1s)\n.equ WDT_PERIOD_8KCLK_gc = (0x0B<<0)     ; 8K cycles (8.2s)\n\n; Window select\n.equ WDT_WINDOW_OFF_gc = (0x00<<4)       ; Window mode off\n.equ WDT_WINDOW_8CLK_gc = (0x01<<4)      ; 8 cycles (8ms)\n.equ WDT_WINDOW_16CLK_gc = (0x02<<4)     ; 16 cycles (16ms)\n.equ WDT_WINDOW_32CLK_gc = (0x03<<4)     ; 32 cycles (32ms)\n.equ WDT_WINDOW_64CLK_gc = (0x04<<4)     ; 64 cycles (64ms)\n.equ WDT_WINDOW_128CLK_gc = (0x05<<4)    ; 128 cycles (0.128s)\n.equ WDT_WINDOW_256CLK_gc = (0x06<<4)    ; 256 cycles (0.256s)\n.equ WDT_WINDOW_512CLK_gc = (0x07<<4)    ; 512 cycles (0.512s)\n.equ WDT_WINDOW_1KCLK_gc = (0x08<<4)     ; 1K cycles (1.0s)\n.equ WDT_WINDOW_2KCLK_gc = (0x09<<4)     ; 2K cycles (2.0s)\n.equ WDT_WINDOW_4KCLK_gc = (0x0A<<4)     ; 4K cycles (4.1s)\n.equ WDT_WINDOW_8KCLK_gc = (0x0B<<4)     ; 8K cycles (8.2s)\n\n\n\n\n; ***** CPU REGISTER DEFINITIONS *****************************************\n.def\tXH\t= r27\n.def\tXL\t= r26\n.def\tYH\t= r29\n.def\tYL\t= r28\n.def\tZH\t= r31\n.def\tZL\t= r30\n\n\n; ***** DATA MEMORY DECLARATIONS *****************************************\n\n\n#define DATAMEM_START 0x0000\n#define DATAMEM_SIZE 0x9000\n#define DATAMEM_END (0x0000 + 0x9000 - 1)\n\n#define EEPROM_START 0x1400\n#define EEPROM_SIZE 0x0080\n#define EEPROM_END (0x1400 + 0x0080 - 1)\n#define EEPROM_PAGE_SIZE 0x20\n\n#define FUSES_START 0x1280\n#define FUSES_SIZE 0x000A\n#define FUSES_END (0x1280 + 0x000A - 1)\n#define FUSES_PAGE_SIZE 0x20\n\n#define INTERNAL_SRAM_START 0x3F00\n#define INTERNAL_SRAM_SIZE 0x0100\n#define INTERNAL_SRAM_END (0x3F00 + 0x0100 - 1)\n\n#define IO_START 0x0000\n#define IO_SIZE 0x1100\n#define IO_END (0x0000 + 0x1100 - 1)\n\n#define LOCKBITS_START 0x128A\n#define LOCKBITS_SIZE 0x0001\n#define LOCKBITS_END (0x128A + 0x0001 - 1)\n#define LOCKBITS_PAGE_SIZE 0x20\n\n#define MAPPED_PROGMEM_START 0x8000\n#define MAPPED_PROGMEM_SIZE 0x1000\n#define MAPPED_PROGMEM_END (0x8000 + 0x1000 - 1)\n#define MAPPED_PROGMEM_PAGE_SIZE 0x40\n\n#define PROD_SIGNATURES_START 0x1103\n#define PROD_SIGNATURES_SIZE 0x003D\n#define PROD_SIGNATURES_END (0x1103 + 0x003D - 1)\n#define PROD_SIGNATURES_PAGE_SIZE 0x40\n\n#define SIGNATURES_START 0x1100\n#define SIGNATURES_SIZE 0x0003\n#define SIGNATURES_END (0x1100 + 0x0003 - 1)\n#define SIGNATURES_PAGE_SIZE 0x40\n\n#define USER_SIGNATURES_START 0x1300\n#define USER_SIGNATURES_SIZE 0x0020\n#define USER_SIGNATURES_END (0x1300 + 0x0020 - 1)\n#define USER_SIGNATURES_PAGE_SIZE 0x20\n\n#define PROGMEM_START 0x0000\n#define PROGMEM_SIZE 0x1000\n#define PROGMEM_END (0x0000 + 0x1000 - 1)\n#define PROGMEM_PAGE_SIZE 0x40\n\n\n; Legacy definitions\n.equ    FLASHSTART    = (PROGMEM_START / 2) ; Note: Word address\n.equ    FLASHEND      = (PROGMEM_END / 2) ; Note: Word address\n.equ    IOEND         = IO_END\n.equ    SRAM_START    = INTERNAL_SRAM_START\n.equ    SRAM_SIZE     = INTERNAL_SRAM_SIZE\n.equ    RAMEND        = INTERNAL_SRAM_END\n.equ    E2END         = EEPROM_END\n.equ    EEPROMEND     = EEPROM_END\n\n\n; Definitions used by the assembler\n#pragma AVRPART MEMORY PROG_FLASH 0x1000\n#pragma AVRPART MEMORY EEPROM 0x0080\n#pragma AVRPART MEMORY INT_SRAM SIZE 0x0100\n#pragma AVRPART MEMORY INT_SRAM START_ADDR 0x3F00\n\n; ***** INTERRUPT VECTORS, ABSOLUTE ADDRESSES ****************************\n\n; CRCSCAN interrupt vectors\n.equ CRCSCAN_NMI_vect = 0x0001           ; \n\n; BOD interrupt vectors\n.equ BOD_VLM_vect = 0x0002               ; \n\n; PORTA interrupt vectors\n.equ PORTA_PORT_vect = 0x0003            ; \n\n; PORTB interrupt vectors\n.equ PORTB_PORT_vect = 0x0004            ; \n\n; RTC interrupt vectors\n.equ RTC_CNT_vect = 0x0006               ; \n.equ RTC_PIT_vect = 0x0007               ; \n\n; TCA0 interrupt vectors\n.equ TCA0_LUNF_vect = 0x0008             ; \n.equ TCA0_OVF_vect = 0x0008              ; \n.equ TCA0_HUNF_vect = 0x0009             ; \n.equ TCA0_CMP0_vect = 0x000A             ; \n.equ TCA0_LCMP0_vect = 0x000A            ; \n.equ TCA0_CMP1_vect = 0x000B             ; \n.equ TCA0_LCMP1_vect = 0x000B            ; \n.equ TCA0_CMP2_vect = 0x000C             ; \n.equ TCA0_LCMP2_vect = 0x000C            ; \n\n; TCB0 interrupt vectors\n.equ TCB0_INT_vect = 0x000D              ; \n\n; AC0 interrupt vectors\n.equ AC0_AC_vect = 0x0010                ; \n\n; ADC0 interrupt vectors\n.equ ADC0_RESRDY_vect = 0x0011           ; \n.equ ADC0_WCOMP_vect = 0x0012            ; \n\n; TWI0 interrupt vectors\n.equ TWI0_TWIS_vect = 0x0013             ; \n.equ TWI0_TWIM_vect = 0x0014             ; \n\n; SPI0 interrupt vectors\n.equ SPI0_INT_vect = 0x0015              ; \n\n; USART0 interrupt vectors\n.equ USART0_RXC_vect = 0x0016            ; \n.equ USART0_DRE_vect = 0x0017            ; \n.equ USART0_TXC_vect = 0x0018            ; \n\n; NVMCTRL interrupt vectors\n.equ NVMCTRL_EE_vect = 0x0019            ; \n\n\n\n; ***** INTERRUPT VECTORS, MODULE BASES **********************************\n\n.equ CRCSCAN_vbase = 0x0001\n.equ BOD_vbase = 0x0002\n.equ PORTA_vbase = 0x0003\n.equ PORTB_vbase = 0x0004\n.equ RTC_vbase = 0x0006\n.equ TCA0_vbase = 0x0008\n.equ TCB0_vbase = 0x000D\n.equ AC0_vbase = 0x0010\n.equ ADC0_vbase = 0x0011\n.equ TWI0_vbase = 0x0013\n.equ SPI0_vbase = 0x0015\n.equ USART0_vbase = 0x0016\n.equ NVMCTRL_vbase = 0x0019\n\n\n; ***** INTERRUPT VECTORS, VECTOR OFFSETS ********************************\n\n; CRCSCAN interrupt vector offsets\n\n.equ CRCSCAN_NMI_voffset = 0\n\n; BOD interrupt vector offsets\n\n.equ BOD_VLM_voffset = 0\n\n; PORTA interrupt vector offsets\n\n.equ PORTA_PORT_voffset = 0\n\n; PORTB interrupt vector offsets\n\n.equ PORTB_PORT_voffset = 0\n\n; RTC interrupt vector offsets\n\n.equ RTC_CNT_voffset = 0\n.equ RTC_PIT_voffset = 1\n\n; TCA0 interrupt vector offsets\n\n.equ TCA0_LUNF_voffset = 0\n.equ TCA0_OVF_voffset = 0\n.equ TCA0_HUNF_voffset = 1\n.equ TCA0_CMP0_voffset = 2\n.equ TCA0_LCMP0_voffset = 2\n.equ TCA0_CMP1_voffset = 3\n.equ TCA0_LCMP1_voffset = 3\n.equ TCA0_CMP2_voffset = 4\n.equ TCA0_LCMP2_voffset = 4\n\n; TCB0 interrupt vector offsets\n\n.equ TCB0_INT_voffset = 0\n\n; AC0 interrupt vector offsets\n\n.equ AC0_AC_voffset = 0\n\n; ADC0 interrupt vector offsets\n\n.equ ADC0_RESRDY_voffset = 0\n.equ ADC0_WCOMP_voffset = 1\n\n; TWI0 interrupt vector offsets\n\n.equ TWI0_TWIS_voffset = 0\n.equ TWI0_TWIM_voffset = 1\n\n; SPI0 interrupt vector offsets\n\n.equ SPI0_INT_voffset = 0\n\n; USART0 interrupt vector offsets\n\n.equ USART0_RXC_voffset = 0\n.equ USART0_DRE_voffset = 1\n.equ USART0_TXC_voffset = 2\n\n; NVMCTRL interrupt vector offsets\n\n.equ NVMCTRL_EE_voffset = 0\n\n\n\n.equ INT_VECTORS_SIZE = 26 ; size in words\n\n\n#endif /* _TN404DEF_INC_ */\n\n; ***** END OF FILE ******************************************************\n\n\n\n","inc/tn412def.inc":";***** THIS IS A MACHINE GENERATED FILE - DO NOT EDIT ********************\n\n;*************************************************************************\n;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y\n;*\n;* Number            : AVR000\n;* File Name         : tn412def.inc\n;* Title             : Register/Bit Definitions for the ATtiny412\n;* Created           : 2021-07-13 10:42\n;* Version           : 1.00\n;* Support e-mail    : avr@atmel.com\n;* Target MCU        : ATtiny412\n;*\n;* DESCRIPTION\n;* When including this file in the assembly program file, all I/O register\n;* names and I/O register bit names appearing in the data book can be used.\n;* In addition, the six registers forming the three data pointers X, Y and\n;* Z have been assigned names XL - ZH. Highest RAM address for Internal\n;* SRAM is also defined\n;*\n;*************************************************************************\n\n#ifndef _TN412DEF_INC_\n#define _TN412DEF_INC_\n\n\n#pragma partinc 0\n\n; ***** SPECIFY DEVICE ***************************************************\n.device\tATtiny412\n\n#pragma AVRPART ADMIN PART_NAME ATtiny412\n\n.equ\tSIGNATURE_000\t= 0x1E\n.equ\tSIGNATURE_001\t= 0x92\n.equ\tSIGNATURE_002\t= 0x23\n\n#pragma AVRPART CORE CORE_VERSION V4\n\n\n; ***** ABSOLUTE I/O REGISTER LOCATIONS **********************************\n\n\n;*************************************************************************\n;** AC0 - Analog Comparator\n;*************************************************************************\n\n.equ AC0_CTRLA = 0x0670                  ; Control A\n.equ AC0_MUXCTRLA = 0x0672               ; Mux Control A\n.equ AC0_INTCTRL = 0x0676                ; Interrupt Control\n.equ AC0_STATUS = 0x0677                 ; Status\n\n;*************************************************************************\n;** ADC0 - Analog to Digital Converter\n;*************************************************************************\n\n.equ ADC0_CTRLA = 0x0600                 ; Control A\n.equ ADC0_CTRLB = 0x0601                 ; Control B\n.equ ADC0_CTRLC = 0x0602                 ; Control C\n.equ ADC0_CTRLD = 0x0603                 ; Control D\n.equ ADC0_CTRLE = 0x0604                 ; Control E\n.equ ADC0_SAMPCTRL = 0x0605              ; Sample Control\n.equ ADC0_MUXPOS = 0x0606                ; Positive mux input\n.equ ADC0_COMMAND = 0x0608               ; Command\n.equ ADC0_EVCTRL = 0x0609                ; Event Control\n.equ ADC0_INTCTRL = 0x060A               ; Interrupt Control\n.equ ADC0_INTFLAGS = 0x060B              ; Interrupt Flags\n.equ ADC0_DBGCTRL = 0x060C               ; Debug Control\n.equ ADC0_TEMP = 0x060D                  ; Temporary Data\n.equ ADC0_RES = 0x0610                   ; ADC Accumulator Result\n.equ ADC0_RESL = 0x0610                  ; ADC Accumulator Result low byte\n.equ ADC0_RESH = 0x0611                  ; ADC Accumulator Result hi byte\n.equ ADC0_WINLT = 0x0612                 ; Window comparator low threshold\n.equ ADC0_WINLTL = 0x0612                ; Window comparator low threshold low byte\n.equ ADC0_WINLTH = 0x0613                ; Window comparator low threshold hi byte\n.equ ADC0_WINHT = 0x0614                 ; Window comparator high threshold\n.equ ADC0_WINHTL = 0x0614                ; Window comparator high threshold low byte\n.equ ADC0_WINHTH = 0x0615                ; Window comparator high threshold hi byte\n.equ ADC0_CALIB = 0x0616                 ; Calibration\n\n;*************************************************************************\n;** BOD - Bod interface\n;*************************************************************************\n\n.equ BOD_CTRLA = 0x0080                  ; Control A\n.equ BOD_CTRLB = 0x0081                  ; Control B\n.equ BOD_VLMCTRLA = 0x0088               ; Voltage level monitor Control\n.equ BOD_INTCTRL = 0x0089                ; Voltage level monitor interrupt Control\n.equ BOD_INTFLAGS = 0x008A               ; Voltage level monitor interrupt Flags\n.equ BOD_STATUS = 0x008B                 ; Voltage level monitor status\n\n;*************************************************************************\n;** CCL - Configurable Custom Logic\n;*************************************************************************\n\n.equ CCL_CTRLA = 0x01C0                  ; Control Register A\n.equ CCL_SEQCTRL0 = 0x01C1               ; Sequential Control 0\n.equ CCL_LUT0CTRLA = 0x01C5              ; LUT Control 0 A\n.equ CCL_LUT0CTRLB = 0x01C6              ; LUT Control 0 B\n.equ CCL_LUT0CTRLC = 0x01C7              ; LUT Control 0 C\n.equ CCL_TRUTH0 = 0x01C8                 ; Truth 0\n.equ CCL_LUT1CTRLA = 0x01C9              ; LUT Control 1 A\n.equ CCL_LUT1CTRLB = 0x01CA              ; LUT Control 1 B\n.equ CCL_LUT1CTRLC = 0x01CB              ; LUT Control 1 C\n.equ CCL_TRUTH1 = 0x01CC                 ; Truth 1\n\n;*************************************************************************\n;** CLKCTRL - Clock controller\n;*************************************************************************\n\n.equ CLKCTRL_MCLKCTRLA = 0x0060          ; MCLK Control A\n.equ CLKCTRL_MCLKCTRLB = 0x0061          ; MCLK Control B\n.equ CLKCTRL_MCLKLOCK = 0x0062           ; MCLK Lock\n.equ CLKCTRL_MCLKSTATUS = 0x0063         ; MCLK Status\n.equ CLKCTRL_OSC20MCTRLA = 0x0070        ; OSC20M Control A\n.equ CLKCTRL_OSC20MCALIBA = 0x0071       ; OSC20M Calibration A\n.equ CLKCTRL_OSC20MCALIBB = 0x0072       ; OSC20M Calibration B\n.equ CLKCTRL_OSC32KCTRLA = 0x0078        ; OSC32K Control A\n.equ CLKCTRL_XOSC32KCTRLA = 0x007C       ; XOSC32K Control A\n\n;*************************************************************************\n;** CPU - CPU\n;*************************************************************************\n\n.equ CPU_CCP = 0x0034                    ; Configuration Change Protection\n.equ CPU_SPL = 0x003D                    ; Stack Pointer Low\n.equ CPU_SPH = 0x003E                    ; Stack Pointer High\n.equ CPU_SREG = 0x003F                   ; Status Register\n\n;*************************************************************************\n;** CPUINT - Interrupt Controller\n;*************************************************************************\n\n.equ CPUINT_CTRLA = 0x0110               ; Control A\n.equ CPUINT_STATUS = 0x0111              ; Status\n.equ CPUINT_LVL0PRI = 0x0112             ; Interrupt Level 0 Priority\n.equ CPUINT_LVL1VEC = 0x0113             ; Interrupt Level 1 Priority Vector\n\n;*************************************************************************\n;** CRCSCAN - CRCSCAN\n;*************************************************************************\n\n.equ CRCSCAN_CTRLA = 0x0120              ; Control A\n.equ CRCSCAN_CTRLB = 0x0121              ; Control B\n.equ CRCSCAN_STATUS = 0x0122             ; Status\n\n;*************************************************************************\n;** DAC0 - Digital to Analog Converter\n;*************************************************************************\n\n.equ DAC0_CTRLA = 0x0680                 ; Control Register A\n.equ DAC0_DATA = 0x0681                  ; DATA Register\n\n;*************************************************************************\n;** EVSYS - Event System\n;*************************************************************************\n\n.equ EVSYS_ASYNCSTROBE = 0x0180          ; Asynchronous Channel Strobe\n.equ EVSYS_SYNCSTROBE = 0x0181           ; Synchronous Channel Strobe\n.equ EVSYS_ASYNCCH0 = 0x0182             ; Asynchronous Channel 0 Generator Selection\n.equ EVSYS_ASYNCCH1 = 0x0183             ; Asynchronous Channel 1 Generator Selection\n.equ EVSYS_ASYNCCH2 = 0x0184             ; Asynchronous Channel 2 Generator Selection\n.equ EVSYS_ASYNCCH3 = 0x0185             ; Asynchronous Channel 3 Generator Selection\n.equ EVSYS_SYNCCH0 = 0x018A              ; Synchronous Channel 0 Generator Selection\n.equ EVSYS_SYNCCH1 = 0x018B              ; Synchronous Channel 1 Generator Selection\n.equ EVSYS_ASYNCUSER0 = 0x0192           ; Asynchronous User Ch 0 Input Selection - TCB0\n.equ EVSYS_ASYNCUSER1 = 0x0193           ; Asynchronous User Ch 1 Input Selection - ADC0\n.equ EVSYS_ASYNCUSER2 = 0x0194           ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0\n.equ EVSYS_ASYNCUSER3 = 0x0195           ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0\n.equ EVSYS_ASYNCUSER4 = 0x0196           ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1\n.equ EVSYS_ASYNCUSER5 = 0x0197           ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1\n.equ EVSYS_ASYNCUSER6 = 0x0198           ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0\n.equ EVSYS_ASYNCUSER7 = 0x0199           ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1\n.equ EVSYS_ASYNCUSER8 = 0x019A           ; Asynchronous User Ch 8 Input Selection - Event Out 0\n.equ EVSYS_ASYNCUSER9 = 0x019B           ; Asynchronous User Ch 9 Input Selection - Event Out 1\n.equ EVSYS_ASYNCUSER10 = 0x019C          ; Asynchronous User Ch 10 Input Selection - Event Out 2\n.equ EVSYS_SYNCUSER0 = 0x01A2            ; Synchronous User Ch 0 Input Selection - TCA0\n.equ EVSYS_SYNCUSER1 = 0x01A3            ; Synchronous User Ch 1 Input Selection - USART0\n\n;*************************************************************************\n;** FUSE - Fuses\n;*************************************************************************\n\n.equ FUSE_WDTCFG = 0x1280                ; Watchdog Configuration\n.equ FUSE_BODCFG = 0x1281                ; BOD Configuration\n.equ FUSE_OSCCFG = 0x1282                ; Oscillator Configuration\n.equ FUSE_TCD0CFG = 0x1284               ; TCD0 Configuration\n.equ FUSE_SYSCFG0 = 0x1285               ; System Configuration 0\n.equ FUSE_SYSCFG1 = 0x1286               ; System Configuration 1\n.equ FUSE_APPEND = 0x1287                ; Application Code Section End\n.equ FUSE_BOOTEND = 0x1288               ; Boot Section End\n\n;*************************************************************************\n;** GPIO - General Purpose IO\n;*************************************************************************\n\n.equ GPIO_GPIOR0 = 0x001C                ; General Purpose IO Register 0\n.equ GPIO_GPIOR1 = 0x001D                ; General Purpose IO Register 1\n.equ GPIO_GPIOR2 = 0x001E                ; General Purpose IO Register 2\n.equ GPIO_GPIOR3 = 0x001F                ; General Purpose IO Register 3\n\n;*************************************************************************\n;** LOCKBIT - Lockbit\n;*************************************************************************\n\n.equ LOCKBIT_LOCKBIT = 0x128A            ; Lock bits\n\n;*************************************************************************\n;** NVMCTRL - Non-volatile Memory Controller\n;*************************************************************************\n\n.equ NVMCTRL_CTRLA = 0x1000              ; Control A\n.equ NVMCTRL_CTRLB = 0x1001              ; Control B\n.equ NVMCTRL_STATUS = 0x1002             ; Status\n.equ NVMCTRL_INTCTRL = 0x1003            ; Interrupt Control\n.equ NVMCTRL_INTFLAGS = 0x1004           ; Interrupt Flags\n.equ NVMCTRL_DATA = 0x1006               ; Data\n.equ NVMCTRL_DATAL = 0x1006              ; Data low byte\n.equ NVMCTRL_DATAH = 0x1007              ; Data hi byte\n.equ NVMCTRL_ADDR = 0x1008               ; Address\n.equ NVMCTRL_ADDRL = 0x1008              ; Address low byte\n.equ NVMCTRL_ADDRH = 0x1009              ; Address hi byte\n\n;*************************************************************************\n;** PORTA - I/O Ports\n;*************************************************************************\n\n.equ PORTA_DIR = 0x0400                  ; Data Direction\n.equ PORTA_DIRSET = 0x0401               ; Data Direction Set\n.equ PORTA_DIRCLR = 0x0402               ; Data Direction Clear\n.equ PORTA_DIRTGL = 0x0403               ; Data Direction Toggle\n.equ PORTA_OUT = 0x0404                  ; Output Value\n.equ PORTA_OUTSET = 0x0405               ; Output Value Set\n.equ PORTA_OUTCLR = 0x0406               ; Output Value Clear\n.equ PORTA_OUTTGL = 0x0407               ; Output Value Toggle\n.equ PORTA_IN = 0x0408                   ; Input Value\n.equ PORTA_INTFLAGS = 0x0409             ; Interrupt Flags\n.equ PORTA_PIN0CTRL = 0x0410             ; Pin 0 Control\n.equ PORTA_PIN1CTRL = 0x0411             ; Pin 1 Control\n.equ PORTA_PIN2CTRL = 0x0412             ; Pin 2 Control\n.equ PORTA_PIN3CTRL = 0x0413             ; Pin 3 Control\n.equ PORTA_PIN4CTRL = 0x0414             ; Pin 4 Control\n.equ PORTA_PIN5CTRL = 0x0415             ; Pin 5 Control\n.equ PORTA_PIN6CTRL = 0x0416             ; Pin 6 Control\n.equ PORTA_PIN7CTRL = 0x0417             ; Pin 7 Control\n\n;*************************************************************************\n;** PORTMUX - Port Multiplexer\n;*************************************************************************\n\n.equ PORTMUX_CTRLA = 0x0200              ; Port Multiplexer Control A\n.equ PORTMUX_CTRLB = 0x0201              ; Port Multiplexer Control B\n.equ PORTMUX_CTRLC = 0x0202              ; Port Multiplexer Control C\n.equ PORTMUX_CTRLD = 0x0203              ; Port Multiplexer Control D\n\n;*************************************************************************\n;** RSTCTRL - Reset controller\n;*************************************************************************\n\n.equ RSTCTRL_RSTFR = 0x0040              ; Reset Flags\n.equ RSTCTRL_SWRR = 0x0041               ; Software Reset\n\n;*************************************************************************\n;** RTC - Real-Time Counter\n;*************************************************************************\n\n.equ RTC_CTRLA = 0x0140                  ; Control A\n.equ RTC_STATUS = 0x0141                 ; Status\n.equ RTC_INTCTRL = 0x0142                ; Interrupt Control\n.equ RTC_INTFLAGS = 0x0143               ; Interrupt Flags\n.equ RTC_TEMP = 0x0144                   ; Temporary\n.equ RTC_DBGCTRL = 0x0145                ; Debug control\n.equ RTC_CLKSEL = 0x0147                 ; Clock Select\n.equ RTC_CNT = 0x0148                    ; Counter\n.equ RTC_CNTL = 0x0148                   ; Counter low byte\n.equ RTC_CNTH = 0x0149                   ; Counter hi byte\n.equ RTC_PER = 0x014A                    ; Period\n.equ RTC_PERL = 0x014A                   ; Period low byte\n.equ RTC_PERH = 0x014B                   ; Period hi byte\n.equ RTC_CMP = 0x014C                    ; Compare\n.equ RTC_CMPL = 0x014C                   ; Compare low byte\n.equ RTC_CMPH = 0x014D                   ; Compare hi byte\n.equ RTC_PITCTRLA = 0x0150               ; PIT Control A\n.equ RTC_PITSTATUS = 0x0151              ; PIT Status\n.equ RTC_PITINTCTRL = 0x0152             ; PIT Interrupt Control\n.equ RTC_PITINTFLAGS = 0x0153            ; PIT Interrupt Flags\n.equ RTC_PITDBGCTRL = 0x0155             ; PIT Debug control\n\n;*************************************************************************\n;** SIGROW - Signature row\n;*************************************************************************\n\n.equ SIGROW_DEVICEID0 = 0x1100           ; Device ID Byte 0\n.equ SIGROW_DEVICEID1 = 0x1101           ; Device ID Byte 1\n.equ SIGROW_DEVICEID2 = 0x1102           ; Device ID Byte 2\n.equ SIGROW_SERNUM0 = 0x1103             ; Serial Number Byte 0\n.equ SIGROW_SERNUM1 = 0x1104             ; Serial Number Byte 1\n.equ SIGROW_SERNUM2 = 0x1105             ; Serial Number Byte 2\n.equ SIGROW_SERNUM3 = 0x1106             ; Serial Number Byte 3\n.equ SIGROW_SERNUM4 = 0x1107             ; Serial Number Byte 4\n.equ SIGROW_SERNUM5 = 0x1108             ; Serial Number Byte 5\n.equ SIGROW_SERNUM6 = 0x1109             ; Serial Number Byte 6\n.equ SIGROW_SERNUM7 = 0x110A             ; Serial Number Byte 7\n.equ SIGROW_SERNUM8 = 0x110B             ; Serial Number Byte 8\n.equ SIGROW_SERNUM9 = 0x110C             ; Serial Number Byte 9\n.equ SIGROW_TEMPSENSE0 = 0x1120          ; Temperature Sensor Calibration Byte 0\n.equ SIGROW_TEMPSENSE1 = 0x1121          ; Temperature Sensor Calibration Byte 1\n.equ SIGROW_OSC16ERR3V = 0x1122          ; OSC16 error at 3V\n.equ SIGROW_OSC16ERR5V = 0x1123          ; OSC16 error at 5V\n.equ SIGROW_OSC20ERR3V = 0x1124          ; OSC20 error at 3V\n.equ SIGROW_OSC20ERR5V = 0x1125          ; OSC20 error at 5V\n\n;*************************************************************************\n;** SLPCTRL - Sleep Controller\n;*************************************************************************\n\n.equ SLPCTRL_CTRLA = 0x0050              ; Control\n\n;*************************************************************************\n;** SPI0 - Serial Peripheral Interface\n;*************************************************************************\n\n.equ SPI0_CTRLA = 0x0820                 ; Control A\n.equ SPI0_CTRLB = 0x0821                 ; Control B\n.equ SPI0_INTCTRL = 0x0822               ; Interrupt Control\n.equ SPI0_INTFLAGS = 0x0823              ; Interrupt Flags\n.equ SPI0_DATA = 0x0824                  ; Data\n\n;*************************************************************************\n;** SYSCFG - System Configuration Registers\n;*************************************************************************\n\n.equ SYSCFG_REVID = 0x0F01               ; Revision ID\n.equ SYSCFG_EXTBRK = 0x0F02              ; External Break\n\n;*************************************************************************\n;** TCA0 - 16-bit Timer/Counter Type A\n;*************************************************************************\n\n.equ TCA0_SINGLE_CTRLA = 0x0A00          ; SINGLE Control A\n.equ TCA0_SINGLE_CTRLB = 0x0A01          ; SINGLE Control B\n.equ TCA0_SINGLE_CTRLC = 0x0A02          ; SINGLE Control C\n.equ TCA0_SINGLE_CTRLD = 0x0A03          ; SINGLE Control D\n.equ TCA0_SINGLE_CTRLECLR = 0x0A04       ; SINGLE Control E Clear\n.equ TCA0_SINGLE_CTRLESET = 0x0A05       ; SINGLE Control E Set\n.equ TCA0_SINGLE_CTRLFCLR = 0x0A06       ; SINGLE Control F Clear\n.equ TCA0_SINGLE_CTRLFSET = 0x0A07       ; SINGLE Control F Set\n.equ TCA0_SINGLE_EVCTRL = 0x0A09         ; SINGLE Event Control\n.equ TCA0_SINGLE_INTCTRL = 0x0A0A        ; SINGLE Interrupt Control\n.equ TCA0_SINGLE_INTFLAGS = 0x0A0B       ; SINGLE Interrupt Flags\n.equ TCA0_SINGLE_DBGCTRL = 0x0A0E        ; SINGLE Degbug Control\n.equ TCA0_SINGLE_TEMP = 0x0A0F           ; SINGLE Temporary data for 16-bit Access\n.equ TCA0_SINGLE_CNT = 0x0A20            ; SINGLE Count\n.equ TCA0_SINGLE_PER = 0x0A26            ; SINGLE Period\n.equ TCA0_SINGLE_CMP0 = 0x0A28           ; SINGLE Compare 0\n.equ TCA0_SINGLE_CMP1 = 0x0A2A           ; SINGLE Compare 1\n.equ TCA0_SINGLE_CMP2 = 0x0A2C           ; SINGLE Compare 2\n.equ TCA0_SINGLE_PERBUF = 0x0A36         ; SINGLE Period Buffer\n.equ TCA0_SINGLE_CMP0BUF = 0x0A38        ; SINGLE Compare 0 Buffer\n.equ TCA0_SINGLE_CMP1BUF = 0x0A3A        ; SINGLE Compare 1 Buffer\n.equ TCA0_SINGLE_CMP2BUF = 0x0A3C        ; SINGLE Compare 2 Buffer\n.equ TCA0_SPLIT_CTRLA = 0x0A00           ; SPLIT Control A\n.equ TCA0_SPLIT_CTRLB = 0x0A01           ; SPLIT Control B\n.equ TCA0_SPLIT_CTRLC = 0x0A02           ; SPLIT Control C\n.equ TCA0_SPLIT_CTRLD = 0x0A03           ; SPLIT Control D\n.equ TCA0_SPLIT_CTRLECLR = 0x0A04        ; SPLIT Control E Clear\n.equ TCA0_SPLIT_CTRLESET = 0x0A05        ; SPLIT Control E Set\n.equ TCA0_SPLIT_INTCTRL = 0x0A0A         ; SPLIT Interrupt Control\n.equ TCA0_SPLIT_INTFLAGS = 0x0A0B        ; SPLIT Interrupt Flags\n.equ TCA0_SPLIT_DBGCTRL = 0x0A0E         ; SPLIT Degbug Control\n.equ TCA0_SPLIT_LCNT = 0x0A20            ; SPLIT Low Count\n.equ TCA0_SPLIT_HCNT = 0x0A21            ; SPLIT High Count\n.equ TCA0_SPLIT_LPER = 0x0A26            ; SPLIT Low Period\n.equ TCA0_SPLIT_HPER = 0x0A27            ; SPLIT High Period\n.equ TCA0_SPLIT_LCMP0 = 0x0A28           ; SPLIT Low Compare\n.equ TCA0_SPLIT_HCMP0 = 0x0A29           ; SPLIT High Compare\n.equ TCA0_SPLIT_LCMP1 = 0x0A2A           ; SPLIT Low Compare\n.equ TCA0_SPLIT_HCMP1 = 0x0A2B           ; SPLIT High Compare\n.equ TCA0_SPLIT_LCMP2 = 0x0A2C           ; SPLIT Low Compare\n.equ TCA0_SPLIT_HCMP2 = 0x0A2D           ; SPLIT High Compare\n\n;*************************************************************************\n;** TCB0 - 16-bit Timer Type B\n;*************************************************************************\n\n.equ TCB0_CTRLA = 0x0A40                 ; Control A\n.equ TCB0_CTRLB = 0x0A41                 ; Control Register B\n.equ TCB0_EVCTRL = 0x0A44                ; Event Control\n.equ TCB0_INTCTRL = 0x0A45               ; Interrupt Control\n.equ TCB0_INTFLAGS = 0x0A46              ; Interrupt Flags\n.equ TCB0_STATUS = 0x0A47                ; Status\n.equ TCB0_DBGCTRL = 0x0A48               ; Debug Control\n.equ TCB0_TEMP = 0x0A49                  ; Temporary Value\n.equ TCB0_CNT = 0x0A4A                   ; Count\n.equ TCB0_CNTL = 0x0A4A                  ; Count low byte\n.equ TCB0_CNTH = 0x0A4B                  ; Count hi byte\n.equ TCB0_CCMP = 0x0A4C                  ; Compare or Capture\n.equ TCB0_CCMPL = 0x0A4C                 ; Compare or Capture low byte\n.equ TCB0_CCMPH = 0x0A4D                 ; Compare or Capture hi byte\n\n;*************************************************************************\n;** TCD0 - Timer Counter D\n;*************************************************************************\n\n.equ TCD0_CTRLA = 0x0A80                 ; Control A\n.equ TCD0_CTRLB = 0x0A81                 ; Control B\n.equ TCD0_CTRLC = 0x0A82                 ; Control C\n.equ TCD0_CTRLD = 0x0A83                 ; Control D\n.equ TCD0_CTRLE = 0x0A84                 ; Control E\n.equ TCD0_EVCTRLA = 0x0A88               ; EVCTRLA\n.equ TCD0_EVCTRLB = 0x0A89               ; EVCTRLB\n.equ TCD0_INTCTRL = 0x0A8C               ; Interrupt Control\n.equ TCD0_INTFLAGS = 0x0A8D              ; Interrupt Flags\n.equ TCD0_STATUS = 0x0A8E                ; Status\n.equ TCD0_INPUTCTRLA = 0x0A90            ; Input Control A\n.equ TCD0_INPUTCTRLB = 0x0A91            ; Input Control B\n.equ TCD0_FAULTCTRL = 0x0A92             ; Fault Control\n.equ TCD0_DLYCTRL = 0x0A94               ; Delay Control\n.equ TCD0_DLYVAL = 0x0A95                ; Delay value\n.equ TCD0_DITCTRL = 0x0A98               ; Dither Control A\n.equ TCD0_DITVAL = 0x0A99                ; Dither value\n.equ TCD0_DBGCTRL = 0x0A9E               ; Debug Control\n.equ TCD0_CAPTUREA = 0x0AA2              ; Capture A\n.equ TCD0_CAPTUREAL = 0x0AA2             ; Capture A low byte\n.equ TCD0_CAPTUREAH = 0x0AA3             ; Capture A hi byte\n.equ TCD0_CAPTUREB = 0x0AA4              ; Capture B\n.equ TCD0_CAPTUREBL = 0x0AA4             ; Capture B low byte\n.equ TCD0_CAPTUREBH = 0x0AA5             ; Capture B hi byte\n.equ TCD0_CMPASET = 0x0AA8               ; Compare A Set\n.equ TCD0_CMPASETL = 0x0AA8              ; Compare A Set low byte\n.equ TCD0_CMPASETH = 0x0AA9              ; Compare A Set hi byte\n.equ TCD0_CMPACLR = 0x0AAA               ; Compare A Clear\n.equ TCD0_CMPACLRL = 0x0AAA              ; Compare A Clear low byte\n.equ TCD0_CMPACLRH = 0x0AAB              ; Compare A Clear hi byte\n.equ TCD0_CMPBSET = 0x0AAC               ; Compare B Set\n.equ TCD0_CMPBSETL = 0x0AAC              ; Compare B Set low byte\n.equ TCD0_CMPBSETH = 0x0AAD              ; Compare B Set hi byte\n.equ TCD0_CMPBCLR = 0x0AAE               ; Compare B Clear\n.equ TCD0_CMPBCLRL = 0x0AAE              ; Compare B Clear low byte\n.equ TCD0_CMPBCLRH = 0x0AAF              ; Compare B Clear hi byte\n\n;*************************************************************************\n;** TWI0 - Two-Wire Interface\n;*************************************************************************\n\n.equ TWI0_CTRLA = 0x0810                 ; Control A\n.equ TWI0_DBGCTRL = 0x0812               ; Debug Control Register\n.equ TWI0_MCTRLA = 0x0813                ; Master Control A\n.equ TWI0_MCTRLB = 0x0814                ; Master Control B\n.equ TWI0_MSTATUS = 0x0815               ; Master Status\n.equ TWI0_MBAUD = 0x0816                 ; Master Baurd Rate Control\n.equ TWI0_MADDR = 0x0817                 ; Master Address\n.equ TWI0_MDATA = 0x0818                 ; Master Data\n.equ TWI0_SCTRLA = 0x0819                ; Slave Control A\n.equ TWI0_SCTRLB = 0x081A                ; Slave Control B\n.equ TWI0_SSTATUS = 0x081B               ; Slave Status\n.equ TWI0_SADDR = 0x081C                 ; Slave Address\n.equ TWI0_SDATA = 0x081D                 ; Slave Data\n.equ TWI0_SADDRMASK = 0x081E             ; Slave Address Mask\n\n;*************************************************************************\n;** USART0 - Universal Synchronous and Asynchronous Receiver and Transmitter\n;*************************************************************************\n\n.equ USART0_RXDATAL = 0x0800             ; Receive Data Low Byte\n.equ USART0_RXDATAH = 0x0801             ; Receive Data High Byte\n.equ USART0_TXDATAL = 0x0802             ; Transmit Data Low Byte\n.equ USART0_TXDATAH = 0x0803             ; Transmit Data High Byte\n.equ USART0_STATUS = 0x0804              ; Status\n.equ USART0_CTRLA = 0x0805               ; Control A\n.equ USART0_CTRLB = 0x0806               ; Control B\n.equ USART0_CTRLC = 0x0807               ; Control C\n.equ USART0_BAUD = 0x0808                ; Baud Rate\n.equ USART0_BAUDL = 0x0808               ; Baud Rate low byte\n.equ USART0_BAUDH = 0x0809               ; Baud Rate hi byte\n.equ USART0_DBGCTRL = 0x080B             ; Debug Control\n.equ USART0_EVCTRL = 0x080C              ; Event Control\n.equ USART0_TXPLCTRL = 0x080D            ; IRCOM Transmitter Pulse Length Control\n.equ USART0_RXPLCTRL = 0x080E            ; IRCOM Receiver Pulse Length Control\n\n;*************************************************************************\n;** USERROW - User Row\n;*************************************************************************\n\n.equ USERROW_USERROW0 = 0x1300           ; User Row Byte 0\n.equ USERROW_USERROW1 = 0x1301           ; User Row Byte 1\n.equ USERROW_USERROW2 = 0x1302           ; User Row Byte 2\n.equ USERROW_USERROW3 = 0x1303           ; User Row Byte 3\n.equ USERROW_USERROW4 = 0x1304           ; User Row Byte 4\n.equ USERROW_USERROW5 = 0x1305           ; User Row Byte 5\n.equ USERROW_USERROW6 = 0x1306           ; User Row Byte 6\n.equ USERROW_USERROW7 = 0x1307           ; User Row Byte 7\n.equ USERROW_USERROW8 = 0x1308           ; User Row Byte 8\n.equ USERROW_USERROW9 = 0x1309           ; User Row Byte 9\n.equ USERROW_USERROW10 = 0x130A          ; User Row Byte 10\n.equ USERROW_USERROW11 = 0x130B          ; User Row Byte 11\n.equ USERROW_USERROW12 = 0x130C          ; User Row Byte 12\n.equ USERROW_USERROW13 = 0x130D          ; User Row Byte 13\n.equ USERROW_USERROW14 = 0x130E          ; User Row Byte 14\n.equ USERROW_USERROW15 = 0x130F          ; User Row Byte 15\n.equ USERROW_USERROW16 = 0x1310          ; User Row Byte 16\n.equ USERROW_USERROW17 = 0x1311          ; User Row Byte 17\n.equ USERROW_USERROW18 = 0x1312          ; User Row Byte 18\n.equ USERROW_USERROW19 = 0x1313          ; User Row Byte 19\n.equ USERROW_USERROW20 = 0x1314          ; User Row Byte 20\n.equ USERROW_USERROW21 = 0x1315          ; User Row Byte 21\n.equ USERROW_USERROW22 = 0x1316          ; User Row Byte 22\n.equ USERROW_USERROW23 = 0x1317          ; User Row Byte 23\n.equ USERROW_USERROW24 = 0x1318          ; User Row Byte 24\n.equ USERROW_USERROW25 = 0x1319          ; User Row Byte 25\n.equ USERROW_USERROW26 = 0x131A          ; User Row Byte 26\n.equ USERROW_USERROW27 = 0x131B          ; User Row Byte 27\n.equ USERROW_USERROW28 = 0x131C          ; User Row Byte 28\n.equ USERROW_USERROW29 = 0x131D          ; User Row Byte 29\n.equ USERROW_USERROW30 = 0x131E          ; User Row Byte 30\n.equ USERROW_USERROW31 = 0x131F          ; User Row Byte 31\n\n;*************************************************************************\n;** VPORTA - Virtual Ports\n;*************************************************************************\n\n.equ VPORTA_DIR = 0x0000                 ; Data Direction\n.equ VPORTA_OUT = 0x0001                 ; Output Value\n.equ VPORTA_IN = 0x0002                  ; Input Value\n.equ VPORTA_INTFLAGS = 0x0003            ; Interrupt Flags\n\n;*************************************************************************\n;** VPORTB - Virtual Ports\n;*************************************************************************\n\n.equ VPORTB_DIR = 0x0004                 ; Data Direction\n.equ VPORTB_OUT = 0x0005                 ; Output Value\n.equ VPORTB_IN = 0x0006                  ; Input Value\n.equ VPORTB_INTFLAGS = 0x0007            ; Interrupt Flags\n\n;*************************************************************************\n;** VPORTC - Virtual Ports\n;*************************************************************************\n\n.equ VPORTC_DIR = 0x0008                 ; Data Direction\n.equ VPORTC_OUT = 0x0009                 ; Output Value\n.equ VPORTC_IN = 0x000A                  ; Input Value\n.equ VPORTC_INTFLAGS = 0x000B            ; Interrupt Flags\n\n;*************************************************************************\n;** VREF - Voltage reference\n;*************************************************************************\n\n.equ VREF_CTRLA = 0x00A0                 ; Control A\n.equ VREF_CTRLB = 0x00A1                 ; Control B\n\n;*************************************************************************\n;** WDT - Watch-Dog Timer\n;*************************************************************************\n\n.equ WDT_CTRLA = 0x0100                  ; Control A\n.equ WDT_STATUS = 0x0101                 ; Status\n\n\n; ***** ALL MODULE BASE ADRESSES *****************************************\n\n.equ AC0_base = 0x0670                   ; Analog Comparator\n.equ ADC0_base = 0x0600                  ; Analog to Digital Converter\n.equ BOD_base = 0x0080                   ; Bod interface\n.equ CCL_base = 0x01C0                   ; Configurable Custom Logic\n.equ CLKCTRL_base = 0x0060               ; Clock controller\n.equ CPU_base = 0x0030                   ; CPU\n.equ CPUINT_base = 0x0110                ; Interrupt Controller\n.equ CRCSCAN_base = 0x0120               ; CRCSCAN\n.equ DAC0_base = 0x0680                  ; Digital to Analog Converter\n.equ EVSYS_base = 0x0180                 ; Event System\n.equ FUSE_base = 0x1280                  ; Fuses\n.equ GPIO_base = 0x001C                  ; General Purpose IO\n.equ LOCKBIT_base = 0x128A               ; Lockbit\n.equ NVMCTRL_base = 0x1000               ; Non-volatile Memory Controller\n.equ PORTA_base = 0x0400                 ; I/O Ports\n.equ PORTMUX_base = 0x0200               ; Port Multiplexer\n.equ RSTCTRL_base = 0x0040               ; Reset controller\n.equ RTC_base = 0x0140                   ; Real-Time Counter\n.equ SIGROW_base = 0x1100                ; Signature row\n.equ SLPCTRL_base = 0x0050               ; Sleep Controller\n.equ SPI0_base = 0x0820                  ; Serial Peripheral Interface\n.equ SYSCFG_base = 0x0F00                ; System Configuration Registers\n.equ TCA0_base = 0x0A00                  ; 16-bit Timer/Counter Type A\n.equ TCB0_base = 0x0A40                  ; 16-bit Timer Type B\n.equ TCD0_base = 0x0A80                  ; Timer Counter D\n.equ TWI0_base = 0x0810                  ; Two-Wire Interface\n.equ USART0_base = 0x0800                ; Universal Synchronous and Asynchronous Receiver and Transmitter\n.equ USERROW_base = 0x1300               ; User Row\n.equ VPORTA_base = 0x0000                ; Virtual Ports\n.equ VPORTB_base = 0x0004                ; Virtual Ports\n.equ VPORTC_base = 0x0008                ; Virtual Ports\n.equ VREF_base = 0x00A0                  ; Voltage reference\n.equ WDT_base = 0x0100                   ; Watch-Dog Timer\n\n\n; ***** IO REGISTER OFFSETS **********************************************\n\n\n;*************************************************************************\n;** AC - Analog Comparator\n;*************************************************************************\n.equ AC_CTRLA_offset = 0x00              ; Control A\n.equ AC_MUXCTRLA_offset = 0x02           ; Mux Control A\n.equ AC_INTCTRL_offset = 0x06            ; Interrupt Control\n.equ AC_STATUS_offset = 0x07             ; Status\n\n;*************************************************************************\n;** ADC - Analog to Digital Converter\n;*************************************************************************\n.equ ADC_CTRLA_offset = 0x00             ; Control A\n.equ ADC_CTRLB_offset = 0x01             ; Control B\n.equ ADC_CTRLC_offset = 0x02             ; Control C\n.equ ADC_CTRLD_offset = 0x03             ; Control D\n.equ ADC_CTRLE_offset = 0x04             ; Control E\n.equ ADC_SAMPCTRL_offset = 0x05          ; Sample Control\n.equ ADC_MUXPOS_offset = 0x06            ; Positive mux input\n.equ ADC_COMMAND_offset = 0x08           ; Command\n.equ ADC_EVCTRL_offset = 0x09            ; Event Control\n.equ ADC_INTCTRL_offset = 0x0A           ; Interrupt Control\n.equ ADC_INTFLAGS_offset = 0x0B          ; Interrupt Flags\n.equ ADC_DBGCTRL_offset = 0x0C           ; Debug Control\n.equ ADC_TEMP_offset = 0x0D              ; Temporary Data\n.equ ADC_RES_offset = 0x10               ; ADC Accumulator Result\n.equ ADC_WINLT_offset = 0x12             ; Window comparator low threshold\n.equ ADC_WINHT_offset = 0x14             ; Window comparator high threshold\n.equ ADC_CALIB_offset = 0x16             ; Calibration\n\n;*************************************************************************\n;** BOD - Bod interface\n;*************************************************************************\n.equ BOD_CTRLA_offset = 0x00             ; Control A\n.equ BOD_CTRLB_offset = 0x01             ; Control B\n.equ BOD_VLMCTRLA_offset = 0x08          ; Voltage level monitor Control\n.equ BOD_INTCTRL_offset = 0x09           ; Voltage level monitor interrupt Control\n.equ BOD_INTFLAGS_offset = 0x0A          ; Voltage level monitor interrupt Flags\n.equ BOD_STATUS_offset = 0x0B            ; Voltage level monitor status\n\n;*************************************************************************\n;** CCL - Configurable Custom Logic\n;*************************************************************************\n.equ CCL_CTRLA_offset = 0x00             ; Control Register A\n.equ CCL_SEQCTRL0_offset = 0x01          ; Sequential Control 0\n.equ CCL_LUT0CTRLA_offset = 0x05         ; LUT Control 0 A\n.equ CCL_LUT0CTRLB_offset = 0x06         ; LUT Control 0 B\n.equ CCL_LUT0CTRLC_offset = 0x07         ; LUT Control 0 C\n.equ CCL_TRUTH0_offset = 0x08            ; Truth 0\n.equ CCL_LUT1CTRLA_offset = 0x09         ; LUT Control 1 A\n.equ CCL_LUT1CTRLB_offset = 0x0A         ; LUT Control 1 B\n.equ CCL_LUT1CTRLC_offset = 0x0B         ; LUT Control 1 C\n.equ CCL_TRUTH1_offset = 0x0C            ; Truth 1\n\n;*************************************************************************\n;** CLKCTRL - Clock controller\n;*************************************************************************\n.equ CLKCTRL_MCLKCTRLA_offset = 0x00     ; MCLK Control A\n.equ CLKCTRL_MCLKCTRLB_offset = 0x01     ; MCLK Control B\n.equ CLKCTRL_MCLKLOCK_offset = 0x02      ; MCLK Lock\n.equ CLKCTRL_MCLKSTATUS_offset = 0x03    ; MCLK Status\n.equ CLKCTRL_OSC20MCTRLA_offset = 0x10   ; OSC20M Control A\n.equ CLKCTRL_OSC20MCALIBA_offset = 0x11  ; OSC20M Calibration A\n.equ CLKCTRL_OSC20MCALIBB_offset = 0x12  ; OSC20M Calibration B\n.equ CLKCTRL_OSC32KCTRLA_offset = 0x18   ; OSC32K Control A\n.equ CLKCTRL_XOSC32KCTRLA_offset = 0x1C  ; XOSC32K Control A\n\n;*************************************************************************\n;** CPU - CPU\n;*************************************************************************\n.equ CPU_CCP_offset = 0x04               ; Configuration Change Protection\n.equ CPU_SPL_offset = 0x0D               ; Stack Pointer Low\n.equ CPU_SPH_offset = 0x0E               ; Stack Pointer High\n.equ CPU_SREG_offset = 0x0F              ; Status Register\n\n;*************************************************************************\n;** CPUINT - Interrupt Controller\n;*************************************************************************\n.equ CPUINT_CTRLA_offset = 0x00          ; Control A\n.equ CPUINT_STATUS_offset = 0x01         ; Status\n.equ CPUINT_LVL0PRI_offset = 0x02        ; Interrupt Level 0 Priority\n.equ CPUINT_LVL1VEC_offset = 0x03        ; Interrupt Level 1 Priority Vector\n\n;*************************************************************************\n;** CRCSCAN - CRCSCAN\n;*************************************************************************\n.equ CRCSCAN_CTRLA_offset = 0x00         ; Control A\n.equ CRCSCAN_CTRLB_offset = 0x01         ; Control B\n.equ CRCSCAN_STATUS_offset = 0x02        ; Status\n\n;*************************************************************************\n;** DAC - Digital to Analog Converter\n;*************************************************************************\n.equ DAC_CTRLA_offset = 0x00             ; Control Register A\n.equ DAC_DATA_offset = 0x01              ; DATA Register\n\n;*************************************************************************\n;** EVSYS - Event System\n;*************************************************************************\n.equ EVSYS_ASYNCSTROBE_offset = 0x00     ; Asynchronous Channel Strobe\n.equ EVSYS_SYNCSTROBE_offset = 0x01      ; Synchronous Channel Strobe\n.equ EVSYS_ASYNCCH0_offset = 0x02        ; Asynchronous Channel 0 Generator Selection\n.equ EVSYS_ASYNCCH1_offset = 0x03        ; Asynchronous Channel 1 Generator Selection\n.equ EVSYS_ASYNCCH2_offset = 0x04        ; Asynchronous Channel 2 Generator Selection\n.equ EVSYS_ASYNCCH3_offset = 0x05        ; Asynchronous Channel 3 Generator Selection\n.equ EVSYS_SYNCCH0_offset = 0x0A         ; Synchronous Channel 0 Generator Selection\n.equ EVSYS_SYNCCH1_offset = 0x0B         ; Synchronous Channel 1 Generator Selection\n.equ EVSYS_ASYNCUSER0_offset = 0x12      ; Asynchronous User Ch 0 Input Selection - TCB0\n.equ EVSYS_ASYNCUSER1_offset = 0x13      ; Asynchronous User Ch 1 Input Selection - ADC0\n.equ EVSYS_ASYNCUSER2_offset = 0x14      ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0\n.equ EVSYS_ASYNCUSER3_offset = 0x15      ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0\n.equ EVSYS_ASYNCUSER4_offset = 0x16      ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1\n.equ EVSYS_ASYNCUSER5_offset = 0x17      ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1\n.equ EVSYS_ASYNCUSER6_offset = 0x18      ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0\n.equ EVSYS_ASYNCUSER7_offset = 0x19      ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1\n.equ EVSYS_ASYNCUSER8_offset = 0x1A      ; Asynchronous User Ch 8 Input Selection - Event Out 0\n.equ EVSYS_ASYNCUSER9_offset = 0x1B      ; Asynchronous User Ch 9 Input Selection - Event Out 1\n.equ EVSYS_ASYNCUSER10_offset = 0x1C     ; Asynchronous User Ch 10 Input Selection - Event Out 2\n.equ EVSYS_SYNCUSER0_offset = 0x22       ; Synchronous User Ch 0 Input Selection - TCA0\n.equ EVSYS_SYNCUSER1_offset = 0x23       ; Synchronous User Ch 1 Input Selection - USART0\n\n;*************************************************************************\n;** FUSE - Fuses\n;*************************************************************************\n.equ FUSE_WDTCFG_offset = 0x00           ; Watchdog Configuration\n.equ FUSE_BODCFG_offset = 0x01           ; BOD Configuration\n.equ FUSE_OSCCFG_offset = 0x02           ; Oscillator Configuration\n.equ FUSE_TCD0CFG_offset = 0x04          ; TCD0 Configuration\n.equ FUSE_SYSCFG0_offset = 0x05          ; System Configuration 0\n.equ FUSE_SYSCFG1_offset = 0x06          ; System Configuration 1\n.equ FUSE_APPEND_offset = 0x07           ; Application Code Section End\n.equ FUSE_BOOTEND_offset = 0x08          ; Boot Section End\n\n;*************************************************************************\n;** GPIO - General Purpose IO\n;*************************************************************************\n.equ GPIO_GPIOR0_offset = 0x00           ; General Purpose IO Register 0\n.equ GPIO_GPIOR1_offset = 0x01           ; General Purpose IO Register 1\n.equ GPIO_GPIOR2_offset = 0x02           ; General Purpose IO Register 2\n.equ GPIO_GPIOR3_offset = 0x03           ; General Purpose IO Register 3\n\n;*************************************************************************\n;** LOCKBIT - Lockbit\n;*************************************************************************\n.equ LOCKBIT_LOCKBIT_offset = 0x00       ; Lock bits\n\n;*************************************************************************\n;** NVMCTRL - Non-volatile Memory Controller\n;*************************************************************************\n.equ NVMCTRL_CTRLA_offset = 0x00         ; Control A\n.equ NVMCTRL_CTRLB_offset = 0x01         ; Control B\n.equ NVMCTRL_STATUS_offset = 0x02        ; Status\n.equ NVMCTRL_INTCTRL_offset = 0x03       ; Interrupt Control\n.equ NVMCTRL_INTFLAGS_offset = 0x04      ; Interrupt Flags\n.equ NVMCTRL_DATA_offset = 0x06          ; Data\n.equ NVMCTRL_ADDR_offset = 0x08          ; Address\n\n;*************************************************************************\n;** PORT - I/O Ports\n;*************************************************************************\n.equ PORT_DIR_offset = 0x00              ; Data Direction\n.equ PORT_DIRSET_offset = 0x01           ; Data Direction Set\n.equ PORT_DIRCLR_offset = 0x02           ; Data Direction Clear\n.equ PORT_DIRTGL_offset = 0x03           ; Data Direction Toggle\n.equ PORT_OUT_offset = 0x04              ; Output Value\n.equ PORT_OUTSET_offset = 0x05           ; Output Value Set\n.equ PORT_OUTCLR_offset = 0x06           ; Output Value Clear\n.equ PORT_OUTTGL_offset = 0x07           ; Output Value Toggle\n.equ PORT_IN_offset = 0x08               ; Input Value\n.equ PORT_INTFLAGS_offset = 0x09         ; Interrupt Flags\n.equ PORT_PIN0CTRL_offset = 0x10         ; Pin 0 Control\n.equ PORT_PIN1CTRL_offset = 0x11         ; Pin 1 Control\n.equ PORT_PIN2CTRL_offset = 0x12         ; Pin 2 Control\n.equ PORT_PIN3CTRL_offset = 0x13         ; Pin 3 Control\n.equ PORT_PIN4CTRL_offset = 0x14         ; Pin 4 Control\n.equ PORT_PIN5CTRL_offset = 0x15         ; Pin 5 Control\n.equ PORT_PIN6CTRL_offset = 0x16         ; Pin 6 Control\n.equ PORT_PIN7CTRL_offset = 0x17         ; Pin 7 Control\n\n;*************************************************************************\n;** PORTMUX - Port Multiplexer\n;*************************************************************************\n.equ PORTMUX_CTRLA_offset = 0x00         ; Port Multiplexer Control A\n.equ PORTMUX_CTRLB_offset = 0x01         ; Port Multiplexer Control B\n.equ PORTMUX_CTRLC_offset = 0x02         ; Port Multiplexer Control C\n.equ PORTMUX_CTRLD_offset = 0x03         ; Port Multiplexer Control D\n\n;*************************************************************************\n;** RSTCTRL - Reset controller\n;*************************************************************************\n.equ RSTCTRL_RSTFR_offset = 0x00         ; Reset Flags\n.equ RSTCTRL_SWRR_offset = 0x01          ; Software Reset\n\n;*************************************************************************\n;** RTC - Real-Time Counter\n;*************************************************************************\n.equ RTC_CTRLA_offset = 0x00             ; Control A\n.equ RTC_STATUS_offset = 0x01            ; Status\n.equ RTC_INTCTRL_offset = 0x02           ; Interrupt Control\n.equ RTC_INTFLAGS_offset = 0x03          ; Interrupt Flags\n.equ RTC_TEMP_offset = 0x04              ; Temporary\n.equ RTC_DBGCTRL_offset = 0x05           ; Debug control\n.equ RTC_CLKSEL_offset = 0x07            ; Clock Select\n.equ RTC_CNT_offset = 0x08               ; Counter\n.equ RTC_PER_offset = 0x0A               ; Period\n.equ RTC_CMP_offset = 0x0C               ; Compare\n.equ RTC_PITCTRLA_offset = 0x10          ; PIT Control A\n.equ RTC_PITSTATUS_offset = 0x11         ; PIT Status\n.equ RTC_PITINTCTRL_offset = 0x12        ; PIT Interrupt Control\n.equ RTC_PITINTFLAGS_offset = 0x13       ; PIT Interrupt Flags\n.equ RTC_PITDBGCTRL_offset = 0x15        ; PIT Debug control\n\n;*************************************************************************\n;** SIGROW - Signature row\n;*************************************************************************\n.equ SIGROW_DEVICEID0_offset = 0x00      ; Device ID Byte 0\n.equ SIGROW_DEVICEID1_offset = 0x01      ; Device ID Byte 1\n.equ SIGROW_DEVICEID2_offset = 0x02      ; Device ID Byte 2\n.equ SIGROW_SERNUM0_offset = 0x03        ; Serial Number Byte 0\n.equ SIGROW_SERNUM1_offset = 0x04        ; Serial Number Byte 1\n.equ SIGROW_SERNUM2_offset = 0x05        ; Serial Number Byte 2\n.equ SIGROW_SERNUM3_offset = 0x06        ; Serial Number Byte 3\n.equ SIGROW_SERNUM4_offset = 0x07        ; Serial Number Byte 4\n.equ SIGROW_SERNUM5_offset = 0x08        ; Serial Number Byte 5\n.equ SIGROW_SERNUM6_offset = 0x09        ; Serial Number Byte 6\n.equ SIGROW_SERNUM7_offset = 0x0A        ; Serial Number Byte 7\n.equ SIGROW_SERNUM8_offset = 0x0B        ; Serial Number Byte 8\n.equ SIGROW_SERNUM9_offset = 0x0C        ; Serial Number Byte 9\n.equ SIGROW_TEMPSENSE0_offset = 0x20     ; Temperature Sensor Calibration Byte 0\n.equ SIGROW_TEMPSENSE1_offset = 0x21     ; Temperature Sensor Calibration Byte 1\n.equ SIGROW_OSC16ERR3V_offset = 0x22     ; OSC16 error at 3V\n.equ SIGROW_OSC16ERR5V_offset = 0x23     ; OSC16 error at 5V\n.equ SIGROW_OSC20ERR3V_offset = 0x24     ; OSC20 error at 3V\n.equ SIGROW_OSC20ERR5V_offset = 0x25     ; OSC20 error at 5V\n\n;*************************************************************************\n;** SLPCTRL - Sleep Controller\n;*************************************************************************\n.equ SLPCTRL_CTRLA_offset = 0x00         ; Control\n\n;*************************************************************************\n;** SPI - Serial Peripheral Interface\n;*************************************************************************\n.equ SPI_CTRLA_offset = 0x00             ; Control A\n.equ SPI_CTRLB_offset = 0x01             ; Control B\n.equ SPI_INTCTRL_offset = 0x02           ; Interrupt Control\n.equ SPI_INTFLAGS_offset = 0x03          ; Interrupt Flags\n.equ SPI_DATA_offset = 0x04              ; Data\n\n;*************************************************************************\n;** SYSCFG - System Configuration Registers\n;*************************************************************************\n.equ SYSCFG_REVID_offset = 0x01          ; Revision ID\n.equ SYSCFG_EXTBRK_offset = 0x02         ; External Break\n\n;*************************************************************************\n;** TCA - 16-bit Timer/Counter Type A\n;*************************************************************************\n.equ TCA_SINGLE_CTRLA_offset = 0x00      ; Control A\n.equ TCA_SINGLE_CTRLB_offset = 0x01      ; Control B\n.equ TCA_SINGLE_CTRLC_offset = 0x02      ; Control C\n.equ TCA_SINGLE_CTRLD_offset = 0x03      ; Control D\n.equ TCA_SINGLE_CTRLECLR_offset = 0x04   ; Control E Clear\n.equ TCA_SINGLE_CTRLESET_offset = 0x05   ; Control E Set\n.equ TCA_SINGLE_CTRLFCLR_offset = 0x06   ; Control F Clear\n.equ TCA_SINGLE_CTRLFSET_offset = 0x07   ; Control F Set\n.equ TCA_SINGLE_EVCTRL_offset = 0x09     ; Event Control\n.equ TCA_SINGLE_INTCTRL_offset = 0x0A    ; Interrupt Control\n.equ TCA_SINGLE_INTFLAGS_offset = 0x0B   ; Interrupt Flags\n.equ TCA_SINGLE_DBGCTRL_offset = 0x0E    ; Degbug Control\n.equ TCA_SINGLE_TEMP_offset = 0x0F       ; Temporary data for 16-bit Access\n.equ TCA_SINGLE_CNT_offset = 0x20        ; Count\n.equ TCA_SINGLE_PER_offset = 0x26        ; Period\n.equ TCA_SINGLE_CMP0_offset = 0x28       ; Compare 0\n.equ TCA_SINGLE_CMP1_offset = 0x2A       ; Compare 1\n.equ TCA_SINGLE_CMP2_offset = 0x2C       ; Compare 2\n.equ TCA_SINGLE_PERBUF_offset = 0x36     ; Period Buffer\n.equ TCA_SINGLE_CMP0BUF_offset = 0x38    ; Compare 0 Buffer\n.equ TCA_SINGLE_CMP1BUF_offset = 0x3A    ; Compare 1 Buffer\n.equ TCA_SINGLE_CMP2BUF_offset = 0x3C    ; Compare 2 Buffer\n.equ TCA_SPLIT_CTRLA_offset = 0x00       ; Control A\n.equ TCA_SPLIT_CTRLB_offset = 0x01       ; Control B\n.equ TCA_SPLIT_CTRLC_offset = 0x02       ; Control C\n.equ TCA_SPLIT_CTRLD_offset = 0x03       ; Control D\n.equ TCA_SPLIT_CTRLECLR_offset = 0x04    ; Control E Clear\n.equ TCA_SPLIT_CTRLESET_offset = 0x05    ; Control E Set\n.equ TCA_SPLIT_INTCTRL_offset = 0x0A     ; Interrupt Control\n.equ TCA_SPLIT_INTFLAGS_offset = 0x0B    ; Interrupt Flags\n.equ TCA_SPLIT_DBGCTRL_offset = 0x0E     ; Degbug Control\n.equ TCA_SPLIT_LCNT_offset = 0x20        ; Low Count\n.equ TCA_SPLIT_HCNT_offset = 0x21        ; High Count\n.equ TCA_SPLIT_LPER_offset = 0x26        ; Low Period\n.equ TCA_SPLIT_HPER_offset = 0x27        ; High Period\n.equ TCA_SPLIT_LCMP0_offset = 0x28       ; Low Compare\n.equ TCA_SPLIT_HCMP0_offset = 0x29       ; High Compare\n.equ TCA_SPLIT_LCMP1_offset = 0x2A       ; Low Compare\n.equ TCA_SPLIT_HCMP1_offset = 0x2B       ; High Compare\n.equ TCA_SPLIT_LCMP2_offset = 0x2C       ; Low Compare\n.equ TCA_SPLIT_HCMP2_offset = 0x2D       ; High Compare\n.equ TCA_SINGLE_offset = 0x00            ; \n.equ TCA_SPLIT_offset = 0x00             ; \n\n;*************************************************************************\n;** TCB - 16-bit Timer Type B\n;*************************************************************************\n.equ TCB_CTRLA_offset = 0x00             ; Control A\n.equ TCB_CTRLB_offset = 0x01             ; Control Register B\n.equ TCB_EVCTRL_offset = 0x04            ; Event Control\n.equ TCB_INTCTRL_offset = 0x05           ; Interrupt Control\n.equ TCB_INTFLAGS_offset = 0x06          ; Interrupt Flags\n.equ TCB_STATUS_offset = 0x07            ; Status\n.equ TCB_DBGCTRL_offset = 0x08           ; Debug Control\n.equ TCB_TEMP_offset = 0x09              ; Temporary Value\n.equ TCB_CNT_offset = 0x0A               ; Count\n.equ TCB_CCMP_offset = 0x0C              ; Compare or Capture\n\n;*************************************************************************\n;** TCD - Timer Counter D\n;*************************************************************************\n.equ TCD_CTRLA_offset = 0x00             ; Control A\n.equ TCD_CTRLB_offset = 0x01             ; Control B\n.equ TCD_CTRLC_offset = 0x02             ; Control C\n.equ TCD_CTRLD_offset = 0x03             ; Control D\n.equ TCD_CTRLE_offset = 0x04             ; Control E\n.equ TCD_EVCTRLA_offset = 0x08           ; EVCTRLA\n.equ TCD_EVCTRLB_offset = 0x09           ; EVCTRLB\n.equ TCD_INTCTRL_offset = 0x0C           ; Interrupt Control\n.equ TCD_INTFLAGS_offset = 0x0D          ; Interrupt Flags\n.equ TCD_STATUS_offset = 0x0E            ; Status\n.equ TCD_INPUTCTRLA_offset = 0x10        ; Input Control A\n.equ TCD_INPUTCTRLB_offset = 0x11        ; Input Control B\n.equ TCD_FAULTCTRL_offset = 0x12         ; Fault Control\n.equ TCD_DLYCTRL_offset = 0x14           ; Delay Control\n.equ TCD_DLYVAL_offset = 0x15            ; Delay value\n.equ TCD_DITCTRL_offset = 0x18           ; Dither Control A\n.equ TCD_DITVAL_offset = 0x19            ; Dither value\n.equ TCD_DBGCTRL_offset = 0x1E           ; Debug Control\n.equ TCD_CAPTUREA_offset = 0x22          ; Capture A\n.equ TCD_CAPTUREB_offset = 0x24          ; Capture B\n.equ TCD_CMPASET_offset = 0x28           ; Compare A Set\n.equ TCD_CMPACLR_offset = 0x2A           ; Compare A Clear\n.equ TCD_CMPBSET_offset = 0x2C           ; Compare B Set\n.equ TCD_CMPBCLR_offset = 0x2E           ; Compare B Clear\n\n;*************************************************************************\n;** TWI - Two-Wire Interface\n;*************************************************************************\n.equ TWI_CTRLA_offset = 0x00             ; Control A\n.equ TWI_DBGCTRL_offset = 0x02           ; Debug Control Register\n.equ TWI_MCTRLA_offset = 0x03            ; Master Control A\n.equ TWI_MCTRLB_offset = 0x04            ; Master Control B\n.equ TWI_MSTATUS_offset = 0x05           ; Master Status\n.equ TWI_MBAUD_offset = 0x06             ; Master Baurd Rate Control\n.equ TWI_MADDR_offset = 0x07             ; Master Address\n.equ TWI_MDATA_offset = 0x08             ; Master Data\n.equ TWI_SCTRLA_offset = 0x09            ; Slave Control A\n.equ TWI_SCTRLB_offset = 0x0A            ; Slave Control B\n.equ TWI_SSTATUS_offset = 0x0B           ; Slave Status\n.equ TWI_SADDR_offset = 0x0C             ; Slave Address\n.equ TWI_SDATA_offset = 0x0D             ; Slave Data\n.equ TWI_SADDRMASK_offset = 0x0E         ; Slave Address Mask\n\n;*************************************************************************\n;** USART - Universal Synchronous and Asynchronous Receiver and Transmitter\n;*************************************************************************\n.equ USART_RXDATAL_offset = 0x00         ; Receive Data Low Byte\n.equ USART_RXDATAH_offset = 0x01         ; Receive Data High Byte\n.equ USART_TXDATAL_offset = 0x02         ; Transmit Data Low Byte\n.equ USART_TXDATAH_offset = 0x03         ; Transmit Data High Byte\n.equ USART_STATUS_offset = 0x04          ; Status\n.equ USART_CTRLA_offset = 0x05           ; Control A\n.equ USART_CTRLB_offset = 0x06           ; Control B\n.equ USART_CTRLC_offset = 0x07           ; Control C\n.equ USART_BAUD_offset = 0x08            ; Baud Rate\n.equ USART_DBGCTRL_offset = 0x0B         ; Debug Control\n.equ USART_EVCTRL_offset = 0x0C          ; Event Control\n.equ USART_TXPLCTRL_offset = 0x0D        ; IRCOM Transmitter Pulse Length Control\n.equ USART_RXPLCTRL_offset = 0x0E        ; IRCOM Receiver Pulse Length Control\n\n;*************************************************************************\n;** USERROW - User Row\n;*************************************************************************\n.equ USERROW_USERROW0_offset = 0x00      ; User Row Byte 0\n.equ USERROW_USERROW1_offset = 0x01      ; User Row Byte 1\n.equ USERROW_USERROW2_offset = 0x02      ; User Row Byte 2\n.equ USERROW_USERROW3_offset = 0x03      ; User Row Byte 3\n.equ USERROW_USERROW4_offset = 0x04      ; User Row Byte 4\n.equ USERROW_USERROW5_offset = 0x05      ; User Row Byte 5\n.equ USERROW_USERROW6_offset = 0x06      ; User Row Byte 6\n.equ USERROW_USERROW7_offset = 0x07      ; User Row Byte 7\n.equ USERROW_USERROW8_offset = 0x08      ; User Row Byte 8\n.equ USERROW_USERROW9_offset = 0x09      ; User Row Byte 9\n.equ USERROW_USERROW10_offset = 0x0A     ; User Row Byte 10\n.equ USERROW_USERROW11_offset = 0x0B     ; User Row Byte 11\n.equ USERROW_USERROW12_offset = 0x0C     ; User Row Byte 12\n.equ USERROW_USERROW13_offset = 0x0D     ; User Row Byte 13\n.equ USERROW_USERROW14_offset = 0x0E     ; User Row Byte 14\n.equ USERROW_USERROW15_offset = 0x0F     ; User Row Byte 15\n.equ USERROW_USERROW16_offset = 0x10     ; User Row Byte 16\n.equ USERROW_USERROW17_offset = 0x11     ; User Row Byte 17\n.equ USERROW_USERROW18_offset = 0x12     ; User Row Byte 18\n.equ USERROW_USERROW19_offset = 0x13     ; User Row Byte 19\n.equ USERROW_USERROW20_offset = 0x14     ; User Row Byte 20\n.equ USERROW_USERROW21_offset = 0x15     ; User Row Byte 21\n.equ USERROW_USERROW22_offset = 0x16     ; User Row Byte 22\n.equ USERROW_USERROW23_offset = 0x17     ; User Row Byte 23\n.equ USERROW_USERROW24_offset = 0x18     ; User Row Byte 24\n.equ USERROW_USERROW25_offset = 0x19     ; User Row Byte 25\n.equ USERROW_USERROW26_offset = 0x1A     ; User Row Byte 26\n.equ USERROW_USERROW27_offset = 0x1B     ; User Row Byte 27\n.equ USERROW_USERROW28_offset = 0x1C     ; User Row Byte 28\n.equ USERROW_USERROW29_offset = 0x1D     ; User Row Byte 29\n.equ USERROW_USERROW30_offset = 0x1E     ; User Row Byte 30\n.equ USERROW_USERROW31_offset = 0x1F     ; User Row Byte 31\n\n;*************************************************************************\n;** VPORT - Virtual Ports\n;*************************************************************************\n.equ VPORT_DIR_offset = 0x00             ; Data Direction\n.equ VPORT_OUT_offset = 0x01             ; Output Value\n.equ VPORT_IN_offset = 0x02              ; Input Value\n.equ VPORT_INTFLAGS_offset = 0x03        ; Interrupt Flags\n\n;*************************************************************************\n;** VREF - Voltage reference\n;*************************************************************************\n.equ VREF_CTRLA_offset = 0x00            ; Control A\n.equ VREF_CTRLB_offset = 0x01            ; Control B\n\n;*************************************************************************\n;** WDT - Watch-Dog Timer\n;*************************************************************************\n.equ WDT_CTRLA_offset = 0x00             ; Control A\n.equ WDT_STATUS_offset = 0x01            ; Status\n\n\n; ***** LOCKBIT REGISTER LOCATIONS ***************************************\n\n\n\n\n; ***** FUSE REGISTER LOCATIONS ******************************************\n\n\n\n\n; ***** BIT AND VALUE DEFINITIONS ****************************************\n\n\n;*************************************************************************\n;** AC - Analog Comparator\n;*************************************************************************\n\n; AC_CTRLA masks\n.equ AC_ENABLE_bm = 0x01                 ; Enable bit mask\n.equ AC_ENABLE_bp = 0                    ; Enable bit position\n.equ AC_HYSMODE_gm = 0x06                ; Hysteresis Mode group mask\n.equ AC_HYSMODE_gp = 1                   ; Hysteresis Mode group position\n.equ AC_HYSMODE0_bm = (1<<1)             ; Hysteresis Mode bit 0 mask\n.equ AC_HYSMODE0_bp = 1                  ; Hysteresis Mode bit 0 position\n.equ AC_HYSMODE1_bm = (1<<2)             ; Hysteresis Mode bit 1 mask\n.equ AC_HYSMODE1_bp = 2                  ; Hysteresis Mode bit 1 position\n.equ AC_INTMODE_gm = 0x30                ; Interrupt Mode group mask\n.equ AC_INTMODE_gp = 4                   ; Interrupt Mode group position\n.equ AC_INTMODE0_bm = (1<<4)             ; Interrupt Mode bit 0 mask\n.equ AC_INTMODE0_bp = 4                  ; Interrupt Mode bit 0 position\n.equ AC_INTMODE1_bm = (1<<5)             ; Interrupt Mode bit 1 mask\n.equ AC_INTMODE1_bp = 5                  ; Interrupt Mode bit 1 position\n.equ AC_LPMODE_bm = 0x08                 ; Low Power Mode bit mask\n.equ AC_LPMODE_bp = 3                    ; Low Power Mode bit position\n.equ AC_OUTEN_bm = 0x40                  ; Output Buffer Enable bit mask\n.equ AC_OUTEN_bp = 6                     ; Output Buffer Enable bit position\n.equ AC_RUNSTDBY_bm = 0x80               ; Run in Standby Mode bit mask\n.equ AC_RUNSTDBY_bp = 7                  ; Run in Standby Mode bit position\n\n; AC_INTCTRL masks\n.equ AC_CMP_bm = 0x01                    ; Analog Comparator 0 Interrupt Enable bit mask\n.equ AC_CMP_bp = 0                       ; Analog Comparator 0 Interrupt Enable bit position\n\n; AC_MUXCTRLA masks\n.equ AC_INVERT_bm = 0x80                 ; Invert AC Output bit mask\n.equ AC_INVERT_bp = 7                    ; Invert AC Output bit position\n.equ AC_MUXNEG_gm = 0x03                 ; Negative Input MUX Selection group mask\n.equ AC_MUXNEG_gp = 0                    ; Negative Input MUX Selection group position\n.equ AC_MUXNEG0_bm = (1<<0)              ; Negative Input MUX Selection bit 0 mask\n.equ AC_MUXNEG0_bp = 0                   ; Negative Input MUX Selection bit 0 position\n.equ AC_MUXNEG1_bm = (1<<1)              ; Negative Input MUX Selection bit 1 mask\n.equ AC_MUXNEG1_bp = 1                   ; Negative Input MUX Selection bit 1 position\n.equ AC_MUXPOS_gm = 0x18                 ; Positive Input MUX Selection group mask\n.equ AC_MUXPOS_gp = 3                    ; Positive Input MUX Selection group position\n.equ AC_MUXPOS0_bm = (1<<3)              ; Positive Input MUX Selection bit 0 mask\n.equ AC_MUXPOS0_bp = 3                   ; Positive Input MUX Selection bit 0 position\n.equ AC_MUXPOS1_bm = (1<<4)              ; Positive Input MUX Selection bit 1 mask\n.equ AC_MUXPOS1_bp = 4                   ; Positive Input MUX Selection bit 1 position\n\n; AC_STATUS masks\n; Masks for AC_CMP already defined\n.equ AC_STATE_bm = 0x10                  ; Analog Comparator State bit mask\n.equ AC_STATE_bp = 4                     ; Analog Comparator State bit position\n\n; Hysteresis Mode select\n.equ AC_HYSMODE_OFF_gc = (0x00<<1)       ; No hysteresis\n.equ AC_HYSMODE_10mV_gc = (0x01<<1)      ; 10mV hysteresis\n.equ AC_HYSMODE_25mV_gc = (0x02<<1)      ; 25mV hysteresis\n.equ AC_HYSMODE_50mV_gc = (0x03<<1)      ; 50mV hysteresis\n\n; Interrupt Mode select\n.equ AC_INTMODE_BOTHEDGE_gc = (0x00<<4)  ; Any Edge\n.equ AC_INTMODE_NEGEDGE_gc = (0x02<<4)   ; Negative Edge\n.equ AC_INTMODE_POSEDGE_gc = (0x03<<4)   ; Positive Edge\n\n; Low Power Mode select\n.equ AC_LPMODE_DIS_gc = (0x00<<3)        ; Low power mode disabled\n.equ AC_LPMODE_EN_gc = (0x01<<3)         ; Low power mode enabled\n\n; Negative Input MUX Selection select\n.equ AC_MUXNEG_PIN0_gc = (0x00<<0)       ; Negative Pin 0\n.equ AC_MUXNEG_VREF_gc = (0x02<<0)       ; Voltage Reference\n.equ AC_MUXNEG_DAC_gc = (0x03<<0)        ; DAC output\n\n; Positive Input MUX Selection select\n.equ AC_MUXPOS_PIN0_gc = (0x00<<3)       ; Positive Pin 0\n\n\n;*************************************************************************\n;** ADC - Analog to Digital Converter\n;*************************************************************************\n\n; ADC_CALIB masks\n.equ ADC_DUTYCYC_bm = 0x01               ; Duty Cycle bit mask\n.equ ADC_DUTYCYC_bp = 0                  ; Duty Cycle bit position\n\n; ADC_COMMAND masks\n.equ ADC_STCONV_bm = 0x01                ; Start Conversion Operation bit mask\n.equ ADC_STCONV_bp = 0                   ; Start Conversion Operation bit position\n\n; ADC_CTRLA masks\n.equ ADC_ENABLE_bm = 0x01                ; ADC Enable bit mask\n.equ ADC_ENABLE_bp = 0                   ; ADC Enable bit position\n.equ ADC_FREERUN_bm = 0x02               ; ADC Freerun mode bit mask\n.equ ADC_FREERUN_bp = 1                  ; ADC Freerun mode bit position\n.equ ADC_RESSEL_bm = 0x04                ; ADC Resolution bit mask\n.equ ADC_RESSEL_bp = 2                   ; ADC Resolution bit position\n.equ ADC_RUNSTBY_bm = 0x80               ; Run standby mode bit mask\n.equ ADC_RUNSTBY_bp = 7                  ; Run standby mode bit position\n\n; ADC_CTRLB masks\n.equ ADC_SAMPNUM_gm = 0x07               ; Accumulation Samples group mask\n.equ ADC_SAMPNUM_gp = 0                  ; Accumulation Samples group position\n.equ ADC_SAMPNUM0_bm = (1<<0)            ; Accumulation Samples bit 0 mask\n.equ ADC_SAMPNUM0_bp = 0                 ; Accumulation Samples bit 0 position\n.equ ADC_SAMPNUM1_bm = (1<<1)            ; Accumulation Samples bit 1 mask\n.equ ADC_SAMPNUM1_bp = 1                 ; Accumulation Samples bit 1 position\n.equ ADC_SAMPNUM2_bm = (1<<2)            ; Accumulation Samples bit 2 mask\n.equ ADC_SAMPNUM2_bp = 2                 ; Accumulation Samples bit 2 position\n\n; ADC_CTRLC masks\n.equ ADC_PRESC_gm = 0x07                 ; Clock Pre-scaler group mask\n.equ ADC_PRESC_gp = 0                    ; Clock Pre-scaler group position\n.equ ADC_PRESC0_bm = (1<<0)              ; Clock Pre-scaler bit 0 mask\n.equ ADC_PRESC0_bp = 0                   ; Clock Pre-scaler bit 0 position\n.equ ADC_PRESC1_bm = (1<<1)              ; Clock Pre-scaler bit 1 mask\n.equ ADC_PRESC1_bp = 1                   ; Clock Pre-scaler bit 1 position\n.equ ADC_PRESC2_bm = (1<<2)              ; Clock Pre-scaler bit 2 mask\n.equ ADC_PRESC2_bp = 2                   ; Clock Pre-scaler bit 2 position\n.equ ADC_REFSEL_gm = 0x30                ; Reference Selection group mask\n.equ ADC_REFSEL_gp = 4                   ; Reference Selection group position\n.equ ADC_REFSEL0_bm = (1<<4)             ; Reference Selection bit 0 mask\n.equ ADC_REFSEL0_bp = 4                  ; Reference Selection bit 0 position\n.equ ADC_REFSEL1_bm = (1<<5)             ; Reference Selection bit 1 mask\n.equ ADC_REFSEL1_bp = 5                  ; Reference Selection bit 1 position\n.equ ADC_SAMPCAP_bm = 0x40               ; Sample Capacitance Selection bit mask\n.equ ADC_SAMPCAP_bp = 6                  ; Sample Capacitance Selection bit position\n\n; ADC_CTRLD masks\n.equ ADC_ASDV_bm = 0x10                  ; Automatic Sampling Delay Variation bit mask\n.equ ADC_ASDV_bp = 4                     ; Automatic Sampling Delay Variation bit position\n.equ ADC_INITDLY_gm = 0xE0               ; Initial Delay Selection group mask\n.equ ADC_INITDLY_gp = 5                  ; Initial Delay Selection group position\n.equ ADC_INITDLY0_bm = (1<<5)            ; Initial Delay Selection bit 0 mask\n.equ ADC_INITDLY0_bp = 5                 ; Initial Delay Selection bit 0 position\n.equ ADC_INITDLY1_bm = (1<<6)            ; Initial Delay Selection bit 1 mask\n.equ ADC_INITDLY1_bp = 6                 ; Initial Delay Selection bit 1 position\n.equ ADC_INITDLY2_bm = (1<<7)            ; Initial Delay Selection bit 2 mask\n.equ ADC_INITDLY2_bp = 7                 ; Initial Delay Selection bit 2 position\n.equ ADC_SAMPDLY_gm = 0x0F               ; Sampling Delay Selection group mask\n.equ ADC_SAMPDLY_gp = 0                  ; Sampling Delay Selection group position\n.equ ADC_SAMPDLY0_bm = (1<<0)            ; Sampling Delay Selection bit 0 mask\n.equ ADC_SAMPDLY0_bp = 0                 ; Sampling Delay Selection bit 0 position\n.equ ADC_SAMPDLY1_bm = (1<<1)            ; Sampling Delay Selection bit 1 mask\n.equ ADC_SAMPDLY1_bp = 1                 ; Sampling Delay Selection bit 1 position\n.equ ADC_SAMPDLY2_bm = (1<<2)            ; Sampling Delay Selection bit 2 mask\n.equ ADC_SAMPDLY2_bp = 2                 ; Sampling Delay Selection bit 2 position\n.equ ADC_SAMPDLY3_bm = (1<<3)            ; Sampling Delay Selection bit 3 mask\n.equ ADC_SAMPDLY3_bp = 3                 ; Sampling Delay Selection bit 3 position\n\n; ADC_CTRLE masks\n.equ ADC_WINCM_gm = 0x07                 ; Window Comparator Mode group mask\n.equ ADC_WINCM_gp = 0                    ; Window Comparator Mode group position\n.equ ADC_WINCM0_bm = (1<<0)              ; Window Comparator Mode bit 0 mask\n.equ ADC_WINCM0_bp = 0                   ; Window Comparator Mode bit 0 position\n.equ ADC_WINCM1_bm = (1<<1)              ; Window Comparator Mode bit 1 mask\n.equ ADC_WINCM1_bp = 1                   ; Window Comparator Mode bit 1 position\n.equ ADC_WINCM2_bm = (1<<2)              ; Window Comparator Mode bit 2 mask\n.equ ADC_WINCM2_bp = 2                   ; Window Comparator Mode bit 2 position\n\n; ADC_DBGCTRL masks\n.equ ADC_DBGRUN_bm = 0x01                ; Debug run bit mask\n.equ ADC_DBGRUN_bp = 0                   ; Debug run bit position\n\n; ADC_EVCTRL masks\n.equ ADC_STARTEI_bm = 0x01               ; Start Event Input Enable bit mask\n.equ ADC_STARTEI_bp = 0                  ; Start Event Input Enable bit position\n\n; ADC_INTCTRL masks\n.equ ADC_RESRDY_bm = 0x01                ; Result Ready Interrupt Enable bit mask\n.equ ADC_RESRDY_bp = 0                   ; Result Ready Interrupt Enable bit position\n.equ ADC_WCMP_bm = 0x02                  ; Window Comparator Interrupt Enable bit mask\n.equ ADC_WCMP_bp = 1                     ; Window Comparator Interrupt Enable bit position\n\n; ADC_INTFLAGS masks\n; Masks for ADC_RESRDY already defined\n; Masks for ADC_WCMP already defined\n\n; ADC_MUXPOS masks\n.equ ADC_MUXPOS_gm = 0x1F                ; Analog Channel Selection Bits group mask\n.equ ADC_MUXPOS_gp = 0                   ; Analog Channel Selection Bits group position\n.equ ADC_MUXPOS0_bm = (1<<0)             ; Analog Channel Selection Bits bit 0 mask\n.equ ADC_MUXPOS0_bp = 0                  ; Analog Channel Selection Bits bit 0 position\n.equ ADC_MUXPOS1_bm = (1<<1)             ; Analog Channel Selection Bits bit 1 mask\n.equ ADC_MUXPOS1_bp = 1                  ; Analog Channel Selection Bits bit 1 position\n.equ ADC_MUXPOS2_bm = (1<<2)             ; Analog Channel Selection Bits bit 2 mask\n.equ ADC_MUXPOS2_bp = 2                  ; Analog Channel Selection Bits bit 2 position\n.equ ADC_MUXPOS3_bm = (1<<3)             ; Analog Channel Selection Bits bit 3 mask\n.equ ADC_MUXPOS3_bp = 3                  ; Analog Channel Selection Bits bit 3 position\n.equ ADC_MUXPOS4_bm = (1<<4)             ; Analog Channel Selection Bits bit 4 mask\n.equ ADC_MUXPOS4_bp = 4                  ; Analog Channel Selection Bits bit 4 position\n\n; ADC_SAMPCTRL masks\n.equ ADC_SAMPLEN_gm = 0x1F               ; Sample lenght group mask\n.equ ADC_SAMPLEN_gp = 0                  ; Sample lenght group position\n.equ ADC_SAMPLEN0_bm = (1<<0)            ; Sample lenght bit 0 mask\n.equ ADC_SAMPLEN0_bp = 0                 ; Sample lenght bit 0 position\n.equ ADC_SAMPLEN1_bm = (1<<1)            ; Sample lenght bit 1 mask\n.equ ADC_SAMPLEN1_bp = 1                 ; Sample lenght bit 1 position\n.equ ADC_SAMPLEN2_bm = (1<<2)            ; Sample lenght bit 2 mask\n.equ ADC_SAMPLEN2_bp = 2                 ; Sample lenght bit 2 position\n.equ ADC_SAMPLEN3_bm = (1<<3)            ; Sample lenght bit 3 mask\n.equ ADC_SAMPLEN3_bp = 3                 ; Sample lenght bit 3 position\n.equ ADC_SAMPLEN4_bm = (1<<4)            ; Sample lenght bit 4 mask\n.equ ADC_SAMPLEN4_bp = 4                 ; Sample lenght bit 4 position\n\n; ADC_TEMP masks\n.equ ADC_TEMP_gm = 0xFF                  ; Temporary group mask\n.equ ADC_TEMP_gp = 0                     ; Temporary group position\n.equ ADC_TEMP0_bm = (1<<0)               ; Temporary bit 0 mask\n.equ ADC_TEMP0_bp = 0                    ; Temporary bit 0 position\n.equ ADC_TEMP1_bm = (1<<1)               ; Temporary bit 1 mask\n.equ ADC_TEMP1_bp = 1                    ; Temporary bit 1 position\n.equ ADC_TEMP2_bm = (1<<2)               ; Temporary bit 2 mask\n.equ ADC_TEMP2_bp = 2                    ; Temporary bit 2 position\n.equ ADC_TEMP3_bm = (1<<3)               ; Temporary bit 3 mask\n.equ ADC_TEMP3_bp = 3                    ; Temporary bit 3 position\n.equ ADC_TEMP4_bm = (1<<4)               ; Temporary bit 4 mask\n.equ ADC_TEMP4_bp = 4                    ; Temporary bit 4 position\n.equ ADC_TEMP5_bm = (1<<5)               ; Temporary bit 5 mask\n.equ ADC_TEMP5_bp = 5                    ; Temporary bit 5 position\n.equ ADC_TEMP6_bm = (1<<6)               ; Temporary bit 6 mask\n.equ ADC_TEMP6_bp = 6                    ; Temporary bit 6 position\n.equ ADC_TEMP7_bm = (1<<7)               ; Temporary bit 7 mask\n.equ ADC_TEMP7_bp = 7                    ; Temporary bit 7 position\n\n; Duty Cycle select\n.equ ADC_DUTYCYC_DUTY50_gc = (0x00<<0)   ; 50% Duty cycle\n.equ ADC_DUTYCYC_DUTY25_gc = (0x01<<0)   ; 25% Duty cycle\n\n; ADC Resolution select\n.equ ADC_RESSEL_10BIT_gc = (0x00<<2)     ; 10-bit mode\n.equ ADC_RESSEL_8BIT_gc = (0x01<<2)      ; 8-bit mode\n\n; Accumulation Samples select\n.equ ADC_SAMPNUM_ACC1_gc = (0x00<<0)     ; 1 ADC sample\n.equ ADC_SAMPNUM_ACC2_gc = (0x01<<0)     ; Accumulate 2 samples\n.equ ADC_SAMPNUM_ACC4_gc = (0x02<<0)     ; Accumulate 4 samples\n.equ ADC_SAMPNUM_ACC8_gc = (0x03<<0)     ; Accumulate 8 samples\n.equ ADC_SAMPNUM_ACC16_gc = (0x04<<0)    ; Accumulate 16 samples\n.equ ADC_SAMPNUM_ACC32_gc = (0x05<<0)    ; Accumulate 32 samples\n.equ ADC_SAMPNUM_ACC64_gc = (0x06<<0)    ; Accumulate 64 samples\n\n; Clock Pre-scaler select\n.equ ADC_PRESC_DIV2_gc = (0x00<<0)       ; CLK_PER divided by 2\n.equ ADC_PRESC_DIV4_gc = (0x01<<0)       ; CLK_PER divided by 4\n.equ ADC_PRESC_DIV8_gc = (0x02<<0)       ; CLK_PER divided by 8\n.equ ADC_PRESC_DIV16_gc = (0x03<<0)      ; CLK_PER divided by 16\n.equ ADC_PRESC_DIV32_gc = (0x04<<0)      ; CLK_PER divided by 32\n.equ ADC_PRESC_DIV64_gc = (0x05<<0)      ; CLK_PER divided by 64\n.equ ADC_PRESC_DIV128_gc = (0x06<<0)     ; CLK_PER divided by 128\n.equ ADC_PRESC_DIV256_gc = (0x07<<0)     ; CLK_PER divided by 256\n\n; Reference Selection select\n.equ ADC_REFSEL_INTREF_gc = (0x00<<4)    ; Internal reference\n.equ ADC_REFSEL_VDDREF_gc = (0x01<<4)    ; VDD\n\n; Automatic Sampling Delay Variation select\n.equ ADC_ASDV_ASVOFF_gc = (0x00<<4)      ; The Automatic Sampling Delay Variation is disabled\n.equ ADC_ASDV_ASVON_gc = (0x01<<4)       ; The Automatic Sampling Delay Variation is enabled\n\n; Initial Delay Selection select\n.equ ADC_INITDLY_DLY0_gc = (0x00<<5)     ; Delay 0 CLK_ADC cycles\n.equ ADC_INITDLY_DLY16_gc = (0x01<<5)    ; Delay 16 CLK_ADC cycles\n.equ ADC_INITDLY_DLY32_gc = (0x02<<5)    ; Delay 32 CLK_ADC cycles\n.equ ADC_INITDLY_DLY64_gc = (0x03<<5)    ; Delay 64 CLK_ADC cycles\n.equ ADC_INITDLY_DLY128_gc = (0x04<<5)   ; Delay 128 CLK_ADC cycles\n.equ ADC_INITDLY_DLY256_gc = (0x05<<5)   ; Delay 256 CLK_ADC cycles\n\n; Window Comparator Mode select\n.equ ADC_WINCM_NONE_gc = (0x00<<0)       ; No Window Comparison\n.equ ADC_WINCM_BELOW_gc = (0x01<<0)      ; Below Window\n.equ ADC_WINCM_ABOVE_gc = (0x02<<0)      ; Above Window\n.equ ADC_WINCM_INSIDE_gc = (0x03<<0)     ; Inside Window\n.equ ADC_WINCM_OUTSIDE_gc = (0x04<<0)    ; Outside Window\n\n; Analog Channel Selection Bits select\n.equ ADC_MUXPOS_AIN0_gc = (0x00<<0)      ; ADC input pin 0\n.equ ADC_MUXPOS_AIN1_gc = (0x01<<0)      ; ADC input pin 1\n.equ ADC_MUXPOS_AIN2_gc = (0x02<<0)      ; ADC input pin 2\n.equ ADC_MUXPOS_AIN3_gc = (0x03<<0)      ; ADC input pin 3\n.equ ADC_MUXPOS_AIN4_gc = (0x04<<0)      ; ADC input pin 4\n.equ ADC_MUXPOS_AIN5_gc = (0x05<<0)      ; ADC input pin 5\n.equ ADC_MUXPOS_AIN6_gc = (0x06<<0)      ; ADC input pin 6\n.equ ADC_MUXPOS_AIN7_gc = (0x07<<0)      ; ADC input pin 7\n.equ ADC_MUXPOS_AIN8_gc = (0x08<<0)      ; ADC input pin 8\n.equ ADC_MUXPOS_AIN9_gc = (0x09<<0)      ; ADC input pin 9\n.equ ADC_MUXPOS_AIN10_gc = (0x0A<<0)     ; ADC input pin 10\n.equ ADC_MUXPOS_AIN11_gc = (0x0B<<0)     ; ADC input pin 11\n.equ ADC_MUXPOS_DAC0_gc = (0x1C<<0)      ; DAC0\n.equ ADC_MUXPOS_INTREF_gc = (0x1D<<0)    ; Internal Ref\n.equ ADC_MUXPOS_TEMPSENSE_gc = (0x1E<<0) ; Temp sensor\n.equ ADC_MUXPOS_GND_gc = (0x1F<<0)       ; GND\n\n\n;*************************************************************************\n;** BOD - Bod interface\n;*************************************************************************\n\n; BOD_CTRLA masks\n.equ BOD_ACTIVE_gm = 0x0C                ; Operation in active mode group mask\n.equ BOD_ACTIVE_gp = 2                   ; Operation in active mode group position\n.equ BOD_ACTIVE0_bm = (1<<2)             ; Operation in active mode bit 0 mask\n.equ BOD_ACTIVE0_bp = 2                  ; Operation in active mode bit 0 position\n.equ BOD_ACTIVE1_bm = (1<<3)             ; Operation in active mode bit 1 mask\n.equ BOD_ACTIVE1_bp = 3                  ; Operation in active mode bit 1 position\n.equ BOD_SAMPFREQ_bm = 0x10              ; Sample frequency bit mask\n.equ BOD_SAMPFREQ_bp = 4                 ; Sample frequency bit position\n.equ BOD_SLEEP_gm = 0x03                 ; Operation in sleep mode group mask\n.equ BOD_SLEEP_gp = 0                    ; Operation in sleep mode group position\n.equ BOD_SLEEP0_bm = (1<<0)              ; Operation in sleep mode bit 0 mask\n.equ BOD_SLEEP0_bp = 0                   ; Operation in sleep mode bit 0 position\n.equ BOD_SLEEP1_bm = (1<<1)              ; Operation in sleep mode bit 1 mask\n.equ BOD_SLEEP1_bp = 1                   ; Operation in sleep mode bit 1 position\n\n; BOD_CTRLB masks\n.equ BOD_LVL_gm = 0x07                   ; Bod level group mask\n.equ BOD_LVL_gp = 0                      ; Bod level group position\n.equ BOD_LVL0_bm = (1<<0)                ; Bod level bit 0 mask\n.equ BOD_LVL0_bp = 0                     ; Bod level bit 0 position\n.equ BOD_LVL1_bm = (1<<1)                ; Bod level bit 1 mask\n.equ BOD_LVL1_bp = 1                     ; Bod level bit 1 position\n.equ BOD_LVL2_bm = (1<<2)                ; Bod level bit 2 mask\n.equ BOD_LVL2_bp = 2                     ; Bod level bit 2 position\n\n; BOD_INTCTRL masks\n.equ BOD_VLMCFG_gm = 0x06                ; Configuration group mask\n.equ BOD_VLMCFG_gp = 1                   ; Configuration group position\n.equ BOD_VLMCFG0_bm = (1<<1)             ; Configuration bit 0 mask\n.equ BOD_VLMCFG0_bp = 1                  ; Configuration bit 0 position\n.equ BOD_VLMCFG1_bm = (1<<2)             ; Configuration bit 1 mask\n.equ BOD_VLMCFG1_bp = 2                  ; Configuration bit 1 position\n.equ BOD_VLMIE_bm = 0x01                 ; voltage level monitor interrrupt enable bit mask\n.equ BOD_VLMIE_bp = 0                    ; voltage level monitor interrrupt enable bit position\n\n; BOD_INTFLAGS masks\n.equ BOD_VLMIF_bm = 0x01                 ; Voltage level monitor interrupt flag bit mask\n.equ BOD_VLMIF_bp = 0                    ; Voltage level monitor interrupt flag bit position\n\n; BOD_STATUS masks\n.equ BOD_VLMS_bm = 0x01                  ; Voltage level monitor status bit mask\n.equ BOD_VLMS_bp = 0                     ; Voltage level monitor status bit position\n\n; BOD_VLMCTRLA masks\n.equ BOD_VLMLVL_gm = 0x03                ; voltage level monitor level group mask\n.equ BOD_VLMLVL_gp = 0                   ; voltage level monitor level group position\n.equ BOD_VLMLVL0_bm = (1<<0)             ; voltage level monitor level bit 0 mask\n.equ BOD_VLMLVL0_bp = 0                  ; voltage level monitor level bit 0 position\n.equ BOD_VLMLVL1_bm = (1<<1)             ; voltage level monitor level bit 1 mask\n.equ BOD_VLMLVL1_bp = 1                  ; voltage level monitor level bit 1 position\n\n; Operation in active mode select\n.equ BOD_ACTIVE_DIS_gc = (0x00<<2)       ; Disabled\n.equ BOD_ACTIVE_ENABLED_gc = (0x01<<2)   ; Enabled\n.equ BOD_ACTIVE_SAMPLED_gc = (0x02<<2)   ; Sampled\n.equ BOD_ACTIVE_ENWAKE_gc = (0x03<<2)    ; Enabled with wakeup halt\n\n; Sample frequency select\n.equ BOD_SAMPFREQ_1KHZ_gc = (0x00<<4)    ; 1kHz sampling\n.equ BOD_SAMPFREQ_125Hz_gc = (0x01<<4)   ; 125Hz sampling\n\n; Operation in sleep mode select\n.equ BOD_SLEEP_DIS_gc = (0x00<<0)        ; Disabled\n.equ BOD_SLEEP_ENABLED_gc = (0x01<<0)    ; Enabled\n.equ BOD_SLEEP_SAMPLED_gc = (0x02<<0)    ; Sampled\n\n; Bod level select\n.equ BOD_LVL_BODLEVEL0_gc = (0x00<<0)    ; 1.8 V\n.equ BOD_LVL_BODLEVEL2_gc = (0x02<<0)    ; 2.6 V\n.equ BOD_LVL_BODLEVEL7_gc = (0x07<<0)    ; 4.2 V\n\n; Configuration select\n.equ BOD_VLMCFG_BELOW_gc = (0x00<<1)     ; Interrupt when supply goes below VLM level\n.equ BOD_VLMCFG_ABOVE_gc = (0x01<<1)     ; Interrupt when supply goes above VLM level\n.equ BOD_VLMCFG_CROSS_gc = (0x02<<1)     ; Interrupt when supply crosses VLM level\n\n; voltage level monitor level select\n.equ BOD_VLMLVL_5ABOVE_gc = (0x00<<0)    ; VLM threshold 5% above BOD level\n.equ BOD_VLMLVL_15ABOVE_gc = (0x01<<0)   ; VLM threshold 15% above BOD level\n.equ BOD_VLMLVL_25ABOVE_gc = (0x02<<0)   ; VLM threshold 25% above BOD level\n\n\n;*************************************************************************\n;** CCL - Configurable Custom Logic\n;*************************************************************************\n\n; CCL_CTRLA masks\n.equ CCL_ENABLE_bm = 0x01                ; Enable bit mask\n.equ CCL_ENABLE_bp = 0                   ; Enable bit position\n.equ CCL_RUNSTDBY_bm = 0x40              ; Run in Standby bit mask\n.equ CCL_RUNSTDBY_bp = 6                 ; Run in Standby bit position\n\n; CCL_LUT0CTRLA masks\n.equ CCL_CLKSRC_bm = 0x40                ; Clock Source Selection bit mask\n.equ CCL_CLKSRC_bp = 6                   ; Clock Source Selection bit position\n.equ CCL_EDGEDET_bm = 0x80               ; Edge Detection Enable bit mask\n.equ CCL_EDGEDET_bp = 7                  ; Edge Detection Enable bit position\n; Masks for CCL_ENABLE already defined\n.equ CCL_FILTSEL_gm = 0x30               ; Filter Selection group mask\n.equ CCL_FILTSEL_gp = 4                  ; Filter Selection group position\n.equ CCL_FILTSEL0_bm = (1<<4)            ; Filter Selection bit 0 mask\n.equ CCL_FILTSEL0_bp = 4                 ; Filter Selection bit 0 position\n.equ CCL_FILTSEL1_bm = (1<<5)            ; Filter Selection bit 1 mask\n.equ CCL_FILTSEL1_bp = 5                 ; Filter Selection bit 1 position\n.equ CCL_OUTEN_bm = 0x08                 ; Output Enable bit mask\n.equ CCL_OUTEN_bp = 3                    ; Output Enable bit position\n\n; CCL_LUT0CTRLB masks\n.equ CCL_INSEL0_gm = 0x0F                ; LUT Input 0 Source Selection group mask\n.equ CCL_INSEL0_gp = 0                   ; LUT Input 0 Source Selection group position\n.equ CCL_INSEL00_bm = (1<<0)             ; LUT Input 0 Source Selection bit 0 mask\n.equ CCL_INSEL00_bp = 0                  ; LUT Input 0 Source Selection bit 0 position\n.equ CCL_INSEL01_bm = (1<<1)             ; LUT Input 0 Source Selection bit 1 mask\n.equ CCL_INSEL01_bp = 1                  ; LUT Input 0 Source Selection bit 1 position\n.equ CCL_INSEL02_bm = (1<<2)             ; LUT Input 0 Source Selection bit 2 mask\n.equ CCL_INSEL02_bp = 2                  ; LUT Input 0 Source Selection bit 2 position\n.equ CCL_INSEL03_bm = (1<<3)             ; LUT Input 0 Source Selection bit 3 mask\n.equ CCL_INSEL03_bp = 3                  ; LUT Input 0 Source Selection bit 3 position\n.equ CCL_INSEL1_gm = 0xF0                ; LUT Input 1 Source Selection group mask\n.equ CCL_INSEL1_gp = 4                   ; LUT Input 1 Source Selection group position\n.equ CCL_INSEL10_bm = (1<<4)             ; LUT Input 1 Source Selection bit 0 mask\n.equ CCL_INSEL10_bp = 4                  ; LUT Input 1 Source Selection bit 0 position\n.equ CCL_INSEL11_bm = (1<<5)             ; LUT Input 1 Source Selection bit 1 mask\n.equ CCL_INSEL11_bp = 5                  ; LUT Input 1 Source Selection bit 1 position\n.equ CCL_INSEL12_bm = (1<<6)             ; LUT Input 1 Source Selection bit 2 mask\n.equ CCL_INSEL12_bp = 6                  ; LUT Input 1 Source Selection bit 2 position\n.equ CCL_INSEL13_bm = (1<<7)             ; LUT Input 1 Source Selection bit 3 mask\n.equ CCL_INSEL13_bp = 7                  ; LUT Input 1 Source Selection bit 3 position\n\n; CCL_LUT0CTRLC masks\n.equ CCL_INSEL2_gm = 0x0F                ; LUT Input 2 Source Selection group mask\n.equ CCL_INSEL2_gp = 0                   ; LUT Input 2 Source Selection group position\n.equ CCL_INSEL20_bm = (1<<0)             ; LUT Input 2 Source Selection bit 0 mask\n.equ CCL_INSEL20_bp = 0                  ; LUT Input 2 Source Selection bit 0 position\n.equ CCL_INSEL21_bm = (1<<1)             ; LUT Input 2 Source Selection bit 1 mask\n.equ CCL_INSEL21_bp = 1                  ; LUT Input 2 Source Selection bit 1 position\n.equ CCL_INSEL22_bm = (1<<2)             ; LUT Input 2 Source Selection bit 2 mask\n.equ CCL_INSEL22_bp = 2                  ; LUT Input 2 Source Selection bit 2 position\n.equ CCL_INSEL23_bm = (1<<3)             ; LUT Input 2 Source Selection bit 3 mask\n.equ CCL_INSEL23_bp = 3                  ; LUT Input 2 Source Selection bit 3 position\n\n; CCL_LUT1CTRLA masks\n; Masks for CCL_CLKSRC already defined\n; Masks for CCL_EDGEDET already defined\n; Masks for CCL_ENABLE already defined\n; Masks for CCL_FILTSEL already defined\n; Masks for CCL_OUTEN already defined\n\n; CCL_LUT1CTRLB masks\n; Masks for CCL_INSEL0 already defined\n; Masks for CCL_INSEL1 already defined\n\n; CCL_LUT1CTRLC masks\n; Masks for CCL_INSEL2 already defined\n\n; CCL_SEQCTRL0 masks\n.equ CCL_SEQSEL_gm = 0x07                ; Sequential Selection group mask\n.equ CCL_SEQSEL_gp = 0                   ; Sequential Selection group position\n.equ CCL_SEQSEL0_bm = (1<<0)             ; Sequential Selection bit 0 mask\n.equ CCL_SEQSEL0_bp = 0                  ; Sequential Selection bit 0 position\n.equ CCL_SEQSEL1_bm = (1<<1)             ; Sequential Selection bit 1 mask\n.equ CCL_SEQSEL1_bp = 1                  ; Sequential Selection bit 1 position\n.equ CCL_SEQSEL2_bm = (1<<2)             ; Sequential Selection bit 2 mask\n.equ CCL_SEQSEL2_bp = 2                  ; Sequential Selection bit 2 position\n\n; CCL_TRUTH0 masks\n.equ CCL_TRUTH_gm = 0xFF                 ; Truth Table group mask\n.equ CCL_TRUTH_gp = 0                    ; Truth Table group position\n.equ CCL_TRUTH0_bm = (1<<0)              ; Truth Table bit 0 mask\n.equ CCL_TRUTH0_bp = 0                   ; Truth Table bit 0 position\n.equ CCL_TRUTH1_bm = (1<<1)              ; Truth Table bit 1 mask\n.equ CCL_TRUTH1_bp = 1                   ; Truth Table bit 1 position\n.equ CCL_TRUTH2_bm = (1<<2)              ; Truth Table bit 2 mask\n.equ CCL_TRUTH2_bp = 2                   ; Truth Table bit 2 position\n.equ CCL_TRUTH3_bm = (1<<3)              ; Truth Table bit 3 mask\n.equ CCL_TRUTH3_bp = 3                   ; Truth Table bit 3 position\n.equ CCL_TRUTH4_bm = (1<<4)              ; Truth Table bit 4 mask\n.equ CCL_TRUTH4_bp = 4                   ; Truth Table bit 4 position\n.equ CCL_TRUTH5_bm = (1<<5)              ; Truth Table bit 5 mask\n.equ CCL_TRUTH5_bp = 5                   ; Truth Table bit 5 position\n.equ CCL_TRUTH6_bm = (1<<6)              ; Truth Table bit 6 mask\n.equ CCL_TRUTH6_bp = 6                   ; Truth Table bit 6 position\n.equ CCL_TRUTH7_bm = (1<<7)              ; Truth Table bit 7 mask\n.equ CCL_TRUTH7_bp = 7                   ; Truth Table bit 7 position\n\n; CCL_TRUTH1 masks\n; Masks for CCL_TRUTH already defined\n\n; Edge Detection Enable select\n.equ CCL_EDGEDET_DIS_gc = (0x00<<7)      ; Edge detector is disabled\n.equ CCL_EDGEDET_EN_gc = (0x01<<7)       ; Edge detector is enabled\n\n; Filter Selection select\n.equ CCL_FILTSEL_DISABLE_gc = (0x00<<4)  ; Filter disabled\n.equ CCL_FILTSEL_SYNCH_gc = (0x01<<4)    ; Synchronizer enabled\n.equ CCL_FILTSEL_FILTER_gc = (0x02<<4)   ; Filter enabled\n\n; LUT Input 0 Source Selection select\n.equ CCL_INSEL0_MASK_gc = (0x00<<0)      ; Masked input\n.equ CCL_INSEL0_FEEDBACK_gc = (0x01<<0)  ; Feedback input source\n.equ CCL_INSEL0_LINK_gc = (0x02<<0)      ; Linked LUT input source\n.equ CCL_INSEL0_EVENT0_gc = (0x03<<0)    ; Event input source 0\n.equ CCL_INSEL0_EVENT1_gc = (0x04<<0)    ; Event input source 1\n.equ CCL_INSEL0_IO_gc = (0x05<<0)        ; IO pin LUTn-IN0 input source\n.equ CCL_INSEL0_AC0_gc = (0x06<<0)       ; AC0 OUT input source\n.equ CCL_INSEL0_TCB0_gc = (0x07<<0)      ; TCB0 WO input source\n.equ CCL_INSEL0_TCA0_gc = (0x08<<0)      ; TCA0 WO0 input source\n.equ CCL_INSEL0_TCD0_gc = (0x09<<0)      ; TCD0 WOA input source\n.equ CCL_INSEL0_USART0_gc = (0x0A<<0)    ; USART0 XCK input source\n.equ CCL_INSEL0_SPI0_gc = (0x0B<<0)      ; SPI0 SCK source\n\n; LUT Input 1 Source Selection select\n.equ CCL_INSEL1_MASK_gc = (0x00<<4)      ; Masked input\n.equ CCL_INSEL1_FEEDBACK_gc = (0x01<<4)  ; Feedback input source\n.equ CCL_INSEL1_LINK_gc = (0x02<<4)      ; Linked LUT input source\n.equ CCL_INSEL1_EVENT0_gc = (0x03<<4)    ; Event input source 0\n.equ CCL_INSEL1_EVENT1_gc = (0x04<<4)    ; Event input source 1\n.equ CCL_INSEL1_IO_gc = (0x05<<4)        ; IO pin LUTn-N1 input source\n.equ CCL_INSEL1_AC0_gc = (0x06<<4)       ; AC0 OUT input source\n.equ CCL_INSEL1_TCB0_gc = (0x07<<4)      ; TCB0 WO input source\n.equ CCL_INSEL1_TCA0_gc = (0x08<<4)      ; TCA0 WO1 input source\n.equ CCL_INSEL1_TCD0_gc = (0x09<<4)      ; TCD0 WOB input source\n.equ CCL_INSEL1_USART0_gc = (0x0A<<4)    ; USART0 TXD input source\n.equ CCL_INSEL1_SPI0_gc = (0x0B<<4)      ; SPI0 MOSI input source\n\n; LUT Input 2 Source Selection select\n.equ CCL_INSEL2_MASK_gc = (0x00<<0)      ; Masked input\n.equ CCL_INSEL2_FEEDBACK_gc = (0x01<<0)  ; Feedback input source\n.equ CCL_INSEL2_LINK_gc = (0x02<<0)      ; Linked LUT input source\n.equ CCL_INSEL2_EVENT0_gc = (0x03<<0)    ; Event input source 0\n.equ CCL_INSEL2_EVENT1_gc = (0x04<<0)    ; Event input source 1\n.equ CCL_INSEL2_IO_gc = (0x05<<0)        ; IO pin LUTn-IN2 input source\n.equ CCL_INSEL2_AC0_gc = (0x06<<0)       ; AC0 OUT input source\n.equ CCL_INSEL2_TCB0_gc = (0x07<<0)      ; TCB0 WO input source\n.equ CCL_INSEL2_TCA0_gc = (0x08<<0)      ; TCA0 WO2 input source\n.equ CCL_INSEL2_TCD0_gc = (0x09<<0)      ; TCD0 WOA input source\n.equ CCL_INSEL2_SPI0_gc = (0x0B<<0)      ; SPI0 MISO source\n\n; Sequential Selection select\n.equ CCL_SEQSEL_DISABLE_gc = (0x00<<0)   ; Sequential logic disabled\n.equ CCL_SEQSEL_DFF_gc = (0x01<<0)       ; D FlipFlop\n.equ CCL_SEQSEL_JK_gc = (0x02<<0)        ; JK FlipFlop\n.equ CCL_SEQSEL_LATCH_gc = (0x03<<0)     ; D Latch\n.equ CCL_SEQSEL_RS_gc = (0x04<<0)        ; RS Latch\n\n\n;*************************************************************************\n;** CLKCTRL - Clock controller\n;*************************************************************************\n\n; CLKCTRL_MCLKCTRLA masks\n.equ CLKCTRL_CLKOUT_bm = 0x80            ; System clock out bit mask\n.equ CLKCTRL_CLKOUT_bp = 7               ; System clock out bit position\n.equ CLKCTRL_CLKSEL_gm = 0x03            ; clock select group mask\n.equ CLKCTRL_CLKSEL_gp = 0               ; clock select group position\n.equ CLKCTRL_CLKSEL0_bm = (1<<0)         ; clock select bit 0 mask\n.equ CLKCTRL_CLKSEL0_bp = 0              ; clock select bit 0 position\n.equ CLKCTRL_CLKSEL1_bm = (1<<1)         ; clock select bit 1 mask\n.equ CLKCTRL_CLKSEL1_bp = 1              ; clock select bit 1 position\n\n; CLKCTRL_MCLKCTRLB masks\n.equ CLKCTRL_PDIV_gm = 0x1E              ; Prescaler division group mask\n.equ CLKCTRL_PDIV_gp = 1                 ; Prescaler division group position\n.equ CLKCTRL_PDIV0_bm = (1<<1)           ; Prescaler division bit 0 mask\n.equ CLKCTRL_PDIV0_bp = 1                ; Prescaler division bit 0 position\n.equ CLKCTRL_PDIV1_bm = (1<<2)           ; Prescaler division bit 1 mask\n.equ CLKCTRL_PDIV1_bp = 2                ; Prescaler division bit 1 position\n.equ CLKCTRL_PDIV2_bm = (1<<3)           ; Prescaler division bit 2 mask\n.equ CLKCTRL_PDIV2_bp = 3                ; Prescaler division bit 2 position\n.equ CLKCTRL_PDIV3_bm = (1<<4)           ; Prescaler division bit 3 mask\n.equ CLKCTRL_PDIV3_bp = 4                ; Prescaler division bit 3 position\n.equ CLKCTRL_PEN_bm = 0x01               ; Prescaler enable bit mask\n.equ CLKCTRL_PEN_bp = 0                  ; Prescaler enable bit position\n\n; CLKCTRL_MCLKLOCK masks\n.equ CLKCTRL_LOCKEN_bm = 0x01            ; lock ebable bit mask\n.equ CLKCTRL_LOCKEN_bp = 0               ; lock ebable bit position\n\n; CLKCTRL_MCLKSTATUS masks\n.equ CLKCTRL_EXTS_bm = 0x80              ; External Clock status bit mask\n.equ CLKCTRL_EXTS_bp = 7                 ; External Clock status bit position\n.equ CLKCTRL_OSC20MS_bm = 0x10           ; 20MHz oscillator status bit mask\n.equ CLKCTRL_OSC20MS_bp = 4              ; 20MHz oscillator status bit position\n.equ CLKCTRL_OSC32KS_bm = 0x20           ; 32KHz oscillator status bit mask\n.equ CLKCTRL_OSC32KS_bp = 5              ; 32KHz oscillator status bit position\n.equ CLKCTRL_SOSC_bm = 0x01              ; System Oscillator changing bit mask\n.equ CLKCTRL_SOSC_bp = 0                 ; System Oscillator changing bit position\n.equ CLKCTRL_XOSC32KS_bm = 0x40          ; 32.768 kHz Crystal Oscillator status bit mask\n.equ CLKCTRL_XOSC32KS_bp = 6             ; 32.768 kHz Crystal Oscillator status bit position\n\n; CLKCTRL_OSC20MCALIBA masks\n.equ CLKCTRL_CAL20M_gm = 0x3F            ; Calibration group mask\n.equ CLKCTRL_CAL20M_gp = 0               ; Calibration group position\n.equ CLKCTRL_CAL20M0_bm = (1<<0)         ; Calibration bit 0 mask\n.equ CLKCTRL_CAL20M0_bp = 0              ; Calibration bit 0 position\n.equ CLKCTRL_CAL20M1_bm = (1<<1)         ; Calibration bit 1 mask\n.equ CLKCTRL_CAL20M1_bp = 1              ; Calibration bit 1 position\n.equ CLKCTRL_CAL20M2_bm = (1<<2)         ; Calibration bit 2 mask\n.equ CLKCTRL_CAL20M2_bp = 2              ; Calibration bit 2 position\n.equ CLKCTRL_CAL20M3_bm = (1<<3)         ; Calibration bit 3 mask\n.equ CLKCTRL_CAL20M3_bp = 3              ; Calibration bit 3 position\n.equ CLKCTRL_CAL20M4_bm = (1<<4)         ; Calibration bit 4 mask\n.equ CLKCTRL_CAL20M4_bp = 4              ; Calibration bit 4 position\n.equ CLKCTRL_CAL20M5_bm = (1<<5)         ; Calibration bit 5 mask\n.equ CLKCTRL_CAL20M5_bp = 5              ; Calibration bit 5 position\n\n; CLKCTRL_OSC20MCALIBB masks\n.equ CLKCTRL_LOCK_bm = 0x80              ; Lock bit mask\n.equ CLKCTRL_LOCK_bp = 7                 ; Lock bit position\n.equ CLKCTRL_TEMPCAL20M_gm = 0x0F        ; Oscillator temperature coefficient group mask\n.equ CLKCTRL_TEMPCAL20M_gp = 0           ; Oscillator temperature coefficient group position\n.equ CLKCTRL_TEMPCAL20M0_bm = (1<<0)     ; Oscillator temperature coefficient bit 0 mask\n.equ CLKCTRL_TEMPCAL20M0_bp = 0          ; Oscillator temperature coefficient bit 0 position\n.equ CLKCTRL_TEMPCAL20M1_bm = (1<<1)     ; Oscillator temperature coefficient bit 1 mask\n.equ CLKCTRL_TEMPCAL20M1_bp = 1          ; Oscillator temperature coefficient bit 1 position\n.equ CLKCTRL_TEMPCAL20M2_bm = (1<<2)     ; Oscillator temperature coefficient bit 2 mask\n.equ CLKCTRL_TEMPCAL20M2_bp = 2          ; Oscillator temperature coefficient bit 2 position\n.equ CLKCTRL_TEMPCAL20M3_bm = (1<<3)     ; Oscillator temperature coefficient bit 3 mask\n.equ CLKCTRL_TEMPCAL20M3_bp = 3          ; Oscillator temperature coefficient bit 3 position\n\n; CLKCTRL_OSC20MCTRLA masks\n.equ CLKCTRL_RUNSTDBY_bm = 0x02          ; Run standby bit mask\n.equ CLKCTRL_RUNSTDBY_bp = 1             ; Run standby bit position\n\n; CLKCTRL_OSC32KCTRLA masks\n; Masks for CLKCTRL_RUNSTDBY already defined\n\n; CLKCTRL_XOSC32KCTRLA masks\n.equ CLKCTRL_CSUT_gm = 0x30              ; Crystal startup time group mask\n.equ CLKCTRL_CSUT_gp = 4                 ; Crystal startup time group position\n.equ CLKCTRL_CSUT0_bm = (1<<4)           ; Crystal startup time bit 0 mask\n.equ CLKCTRL_CSUT0_bp = 4                ; Crystal startup time bit 0 position\n.equ CLKCTRL_CSUT1_bm = (1<<5)           ; Crystal startup time bit 1 mask\n.equ CLKCTRL_CSUT1_bp = 5                ; Crystal startup time bit 1 position\n.equ CLKCTRL_ENABLE_bm = 0x01            ; Enable bit mask\n.equ CLKCTRL_ENABLE_bp = 0               ; Enable bit position\n; Masks for CLKCTRL_RUNSTDBY already defined\n.equ CLKCTRL_SEL_bm = 0x04               ; Select bit mask\n.equ CLKCTRL_SEL_bp = 2                  ; Select bit position\n\n; clock select select\n.equ CLKCTRL_CLKSEL_OSC20M_gc = (0x00<<0) ; 20MHz internal oscillator\n.equ CLKCTRL_CLKSEL_OSCULP32K_gc = (0x01<<0) ; 32KHz internal Ultra Low Power oscillator\n.equ CLKCTRL_CLKSEL_XOSC32K_gc = (0x02<<0) ; 32.768kHz external crystal oscillator\n.equ CLKCTRL_CLKSEL_EXTCLK_gc = (0x03<<0) ; External clock\n\n; Prescaler division select\n.equ CLKCTRL_PDIV_2X_gc = (0x00<<1)      ; 2X\n.equ CLKCTRL_PDIV_4X_gc = (0x01<<1)      ; 4X\n.equ CLKCTRL_PDIV_8X_gc = (0x02<<1)      ; 8X\n.equ CLKCTRL_PDIV_16X_gc = (0x03<<1)     ; 16X\n.equ CLKCTRL_PDIV_32X_gc = (0x04<<1)     ; 32X\n.equ CLKCTRL_PDIV_64X_gc = (0x05<<1)     ; 64X\n.equ CLKCTRL_PDIV_6X_gc = (0x08<<1)      ; 6X\n.equ CLKCTRL_PDIV_10X_gc = (0x09<<1)     ; 10X\n.equ CLKCTRL_PDIV_12X_gc = (0x0A<<1)     ; 12X\n.equ CLKCTRL_PDIV_24X_gc = (0x0B<<1)     ; 24X\n.equ CLKCTRL_PDIV_48X_gc = (0x0C<<1)     ; 48X\n\n; Crystal startup time select\n.equ CLKCTRL_CSUT_1K_gc = (0x00<<4)      ; 1K cycles\n.equ CLKCTRL_CSUT_16K_gc = (0x01<<4)     ; 16K cycles\n.equ CLKCTRL_CSUT_32K_gc = (0x02<<4)     ; 32K cycles\n.equ CLKCTRL_CSUT_64K_gc = (0x03<<4)     ; 64K cycles\n\n\n;*************************************************************************\n;** CPU - CPU\n;*************************************************************************\n\n; CPU_CCP masks\n.equ CPU_CCP_gm = 0xFF                   ; CCP signature group mask\n.equ CPU_CCP_gp = 0                      ; CCP signature group position\n.equ CPU_CCP0_bm = (1<<0)                ; CCP signature bit 0 mask\n.equ CPU_CCP0_bp = 0                     ; CCP signature bit 0 position\n.equ CPU_CCP1_bm = (1<<1)                ; CCP signature bit 1 mask\n.equ CPU_CCP1_bp = 1                     ; CCP signature bit 1 position\n.equ CPU_CCP2_bm = (1<<2)                ; CCP signature bit 2 mask\n.equ CPU_CCP2_bp = 2                     ; CCP signature bit 2 position\n.equ CPU_CCP3_bm = (1<<3)                ; CCP signature bit 3 mask\n.equ CPU_CCP3_bp = 3                     ; CCP signature bit 3 position\n.equ CPU_CCP4_bm = (1<<4)                ; CCP signature bit 4 mask\n.equ CPU_CCP4_bp = 4                     ; CCP signature bit 4 position\n.equ CPU_CCP5_bm = (1<<5)                ; CCP signature bit 5 mask\n.equ CPU_CCP5_bp = 5                     ; CCP signature bit 5 position\n.equ CPU_CCP6_bm = (1<<6)                ; CCP signature bit 6 mask\n.equ CPU_CCP6_bp = 6                     ; CCP signature bit 6 position\n.equ CPU_CCP7_bm = (1<<7)                ; CCP signature bit 7 mask\n.equ CPU_CCP7_bp = 7                     ; CCP signature bit 7 position\n\n; CPU_SREG masks\n.equ CPU_C_bm = 0x01                     ; Carry Flag bit mask\n.equ CPU_C_bp = 0                        ; Carry Flag bit position\n.equ CPU_H_bm = 0x20                     ; Half Carry Flag bit mask\n.equ CPU_H_bp = 5                        ; Half Carry Flag bit position\n.equ CPU_I_bm = 0x80                     ; Global Interrupt Enable Flag bit mask\n.equ CPU_I_bp = 7                        ; Global Interrupt Enable Flag bit position\n.equ CPU_N_bm = 0x04                     ; Negative Flag bit mask\n.equ CPU_N_bp = 2                        ; Negative Flag bit position\n.equ CPU_S_bm = 0x10                     ; N Exclusive Or V Flag bit mask\n.equ CPU_S_bp = 4                        ; N Exclusive Or V Flag bit position\n.equ CPU_T_bm = 0x40                     ; Transfer Bit bit mask\n.equ CPU_T_bp = 6                        ; Transfer Bit bit position\n.equ CPU_V_bm = 0x08                     ; Two's Complement Overflow Flag bit mask\n.equ CPU_V_bp = 3                        ; Two's Complement Overflow Flag bit position\n.equ CPU_Z_bm = 0x02                     ; Zero Flag bit mask\n.equ CPU_Z_bp = 1                        ; Zero Flag bit position\n\n; CCP signature select\n.equ CPU_CCP_SPM_gc = (0x9D<<0)          ; SPM Instruction Protection\n.equ CPU_CCP_IOREG_gc = (0xD8<<0)        ; IO Register Protection\n\n\n;*************************************************************************\n;** CPUINT - Interrupt Controller\n;*************************************************************************\n\n; CPUINT_CTRLA masks\n.equ CPUINT_CVT_bm = 0x20                ; Compact Vector Table bit mask\n.equ CPUINT_CVT_bp = 5                   ; Compact Vector Table bit position\n.equ CPUINT_IVSEL_bm = 0x40              ; Interrupt Vector Select bit mask\n.equ CPUINT_IVSEL_bp = 6                 ; Interrupt Vector Select bit position\n.equ CPUINT_LVL0RR_bm = 0x01             ; Round-robin Scheduling Enable bit mask\n.equ CPUINT_LVL0RR_bp = 0                ; Round-robin Scheduling Enable bit position\n\n; CPUINT_LVL0PRI masks\n.equ CPUINT_LVL0PRI_gm = 0xFF            ; Interrupt Level Priority group mask\n.equ CPUINT_LVL0PRI_gp = 0               ; Interrupt Level Priority group position\n.equ CPUINT_LVL0PRI0_bm = (1<<0)         ; Interrupt Level Priority bit 0 mask\n.equ CPUINT_LVL0PRI0_bp = 0              ; Interrupt Level Priority bit 0 position\n.equ CPUINT_LVL0PRI1_bm = (1<<1)         ; Interrupt Level Priority bit 1 mask\n.equ CPUINT_LVL0PRI1_bp = 1              ; Interrupt Level Priority bit 1 position\n.equ CPUINT_LVL0PRI2_bm = (1<<2)         ; Interrupt Level Priority bit 2 mask\n.equ CPUINT_LVL0PRI2_bp = 2              ; Interrupt Level Priority bit 2 position\n.equ CPUINT_LVL0PRI3_bm = (1<<3)         ; Interrupt Level Priority bit 3 mask\n.equ CPUINT_LVL0PRI3_bp = 3              ; Interrupt Level Priority bit 3 position\n.equ CPUINT_LVL0PRI4_bm = (1<<4)         ; Interrupt Level Priority bit 4 mask\n.equ CPUINT_LVL0PRI4_bp = 4              ; Interrupt Level Priority bit 4 position\n.equ CPUINT_LVL0PRI5_bm = (1<<5)         ; Interrupt Level Priority bit 5 mask\n.equ CPUINT_LVL0PRI5_bp = 5              ; Interrupt Level Priority bit 5 position\n.equ CPUINT_LVL0PRI6_bm = (1<<6)         ; Interrupt Level Priority bit 6 mask\n.equ CPUINT_LVL0PRI6_bp = 6              ; Interrupt Level Priority bit 6 position\n.equ CPUINT_LVL0PRI7_bm = (1<<7)         ; Interrupt Level Priority bit 7 mask\n.equ CPUINT_LVL0PRI7_bp = 7              ; Interrupt Level Priority bit 7 position\n\n; CPUINT_LVL1VEC masks\n.equ CPUINT_LVL1VEC_gm = 0xFF            ; Interrupt Vector with High Priority group mask\n.equ CPUINT_LVL1VEC_gp = 0               ; Interrupt Vector with High Priority group position\n.equ CPUINT_LVL1VEC0_bm = (1<<0)         ; Interrupt Vector with High Priority bit 0 mask\n.equ CPUINT_LVL1VEC0_bp = 0              ; Interrupt Vector with High Priority bit 0 position\n.equ CPUINT_LVL1VEC1_bm = (1<<1)         ; Interrupt Vector with High Priority bit 1 mask\n.equ CPUINT_LVL1VEC1_bp = 1              ; Interrupt Vector with High Priority bit 1 position\n.equ CPUINT_LVL1VEC2_bm = (1<<2)         ; Interrupt Vector with High Priority bit 2 mask\n.equ CPUINT_LVL1VEC2_bp = 2              ; Interrupt Vector with High Priority bit 2 position\n.equ CPUINT_LVL1VEC3_bm = (1<<3)         ; Interrupt Vector with High Priority bit 3 mask\n.equ CPUINT_LVL1VEC3_bp = 3              ; Interrupt Vector with High Priority bit 3 position\n.equ CPUINT_LVL1VEC4_bm = (1<<4)         ; Interrupt Vector with High Priority bit 4 mask\n.equ CPUINT_LVL1VEC4_bp = 4              ; Interrupt Vector with High Priority bit 4 position\n.equ CPUINT_LVL1VEC5_bm = (1<<5)         ; Interrupt Vector with High Priority bit 5 mask\n.equ CPUINT_LVL1VEC5_bp = 5              ; Interrupt Vector with High Priority bit 5 position\n.equ CPUINT_LVL1VEC6_bm = (1<<6)         ; Interrupt Vector with High Priority bit 6 mask\n.equ CPUINT_LVL1VEC6_bp = 6              ; Interrupt Vector with High Priority bit 6 position\n.equ CPUINT_LVL1VEC7_bm = (1<<7)         ; Interrupt Vector with High Priority bit 7 mask\n.equ CPUINT_LVL1VEC7_bp = 7              ; Interrupt Vector with High Priority bit 7 position\n\n; CPUINT_STATUS masks\n.equ CPUINT_LVL0EX_bm = 0x01             ; Level 0 Interrupt Executing bit mask\n.equ CPUINT_LVL0EX_bp = 0                ; Level 0 Interrupt Executing bit position\n.equ CPUINT_LVL1EX_bm = 0x02             ; Level 1 Interrupt Executing bit mask\n.equ CPUINT_LVL1EX_bp = 1                ; Level 1 Interrupt Executing bit position\n.equ CPUINT_NMIEX_bm = 0x80              ; Non-maskable Interrupt Executing bit mask\n.equ CPUINT_NMIEX_bp = 7                 ; Non-maskable Interrupt Executing bit position\n\n\n;*************************************************************************\n;** CRCSCAN - CRCSCAN\n;*************************************************************************\n\n; CRCSCAN_CTRLA masks\n.equ CRCSCAN_ENABLE_bm = 0x01            ; Enable CRC scan bit mask\n.equ CRCSCAN_ENABLE_bp = 0               ; Enable CRC scan bit position\n.equ CRCSCAN_NMIEN_bm = 0x02             ; Enable NMI Trigger bit mask\n.equ CRCSCAN_NMIEN_bp = 1                ; Enable NMI Trigger bit position\n.equ CRCSCAN_RESET_bm = 0x80             ; Reset CRC scan bit mask\n.equ CRCSCAN_RESET_bp = 7                ; Reset CRC scan bit position\n\n; CRCSCAN_CTRLB masks\n.equ CRCSCAN_MODE_gm = 0x30              ; CRC Flash Access Mode group mask\n.equ CRCSCAN_MODE_gp = 4                 ; CRC Flash Access Mode group position\n.equ CRCSCAN_MODE0_bm = (1<<4)           ; CRC Flash Access Mode bit 0 mask\n.equ CRCSCAN_MODE0_bp = 4                ; CRC Flash Access Mode bit 0 position\n.equ CRCSCAN_MODE1_bm = (1<<5)           ; CRC Flash Access Mode bit 1 mask\n.equ CRCSCAN_MODE1_bp = 5                ; CRC Flash Access Mode bit 1 position\n.equ CRCSCAN_SRC_gm = 0x03               ; CRC Source group mask\n.equ CRCSCAN_SRC_gp = 0                  ; CRC Source group position\n.equ CRCSCAN_SRC0_bm = (1<<0)            ; CRC Source bit 0 mask\n.equ CRCSCAN_SRC0_bp = 0                 ; CRC Source bit 0 position\n.equ CRCSCAN_SRC1_bm = (1<<1)            ; CRC Source bit 1 mask\n.equ CRCSCAN_SRC1_bp = 1                 ; CRC Source bit 1 position\n\n; CRCSCAN_STATUS masks\n.equ CRCSCAN_BUSY_bm = 0x01              ; CRC Busy bit mask\n.equ CRCSCAN_BUSY_bp = 0                 ; CRC Busy bit position\n.equ CRCSCAN_OK_bm = 0x02                ; CRC Ok bit mask\n.equ CRCSCAN_OK_bp = 1                   ; CRC Ok bit position\n\n; CRC Flash Access Mode select\n.equ CRCSCAN_MODE_PRIORITY_gc = (0x00<<4) ; Priority to flash\n.equ CRCSCAN_MODE_RESERVED_gc = (0x01<<4) ; Reserved\n.equ CRCSCAN_MODE_BACKGROUND_gc = (0x02<<4) ; Lowest priority to flash\n.equ CRCSCAN_MODE_CONTINUOUS_gc = (0x03<<4) ; Continuous checks in background\n\n; CRC Source select\n.equ CRCSCAN_SRC_FLASH_gc = (0x00<<0)    ; CRC on entire flash\n.equ CRCSCAN_SRC_APPLICATION_gc = (0x01<<0) ; CRC on boot and appl section of flash\n.equ CRCSCAN_SRC_BOOT_gc = (0x02<<0)     ; CRC on boot section of flash\n\n\n;*************************************************************************\n;** DAC - Digital to Analog Converter\n;*************************************************************************\n\n; DAC_CTRLA masks\n.equ DAC_ENABLE_bm = 0x01                ; DAC Enable bit mask\n.equ DAC_ENABLE_bp = 0                   ; DAC Enable bit position\n.equ DAC_OUTEN_bm = 0x40                 ; Output Buffer Enable bit mask\n.equ DAC_OUTEN_bp = 6                    ; Output Buffer Enable bit position\n.equ DAC_RUNSTDBY_bm = 0x80              ; Run in Standby Mode bit mask\n.equ DAC_RUNSTDBY_bp = 7                 ; Run in Standby Mode bit position\n\n\n;*************************************************************************\n;** EVSYS - Event System\n;*************************************************************************\n\n; EVSYS_ASYNCCH0 masks\n.equ EVSYS_ASYNCCH0_gm = 0xFF            ; Asynchronous Channel 0 Generator Selection group mask\n.equ EVSYS_ASYNCCH0_gp = 0               ; Asynchronous Channel 0 Generator Selection group position\n.equ EVSYS_ASYNCCH00_bm = (1<<0)         ; Asynchronous Channel 0 Generator Selection bit 0 mask\n.equ EVSYS_ASYNCCH00_bp = 0              ; Asynchronous Channel 0 Generator Selection bit 0 position\n.equ EVSYS_ASYNCCH01_bm = (1<<1)         ; Asynchronous Channel 0 Generator Selection bit 1 mask\n.equ EVSYS_ASYNCCH01_bp = 1              ; Asynchronous Channel 0 Generator Selection bit 1 position\n.equ EVSYS_ASYNCCH02_bm = (1<<2)         ; Asynchronous Channel 0 Generator Selection bit 2 mask\n.equ EVSYS_ASYNCCH02_bp = 2              ; Asynchronous Channel 0 Generator Selection bit 2 position\n.equ EVSYS_ASYNCCH03_bm = (1<<3)         ; Asynchronous Channel 0 Generator Selection bit 3 mask\n.equ EVSYS_ASYNCCH03_bp = 3              ; Asynchronous Channel 0 Generator Selection bit 3 position\n.equ EVSYS_ASYNCCH04_bm = (1<<4)         ; Asynchronous Channel 0 Generator Selection bit 4 mask\n.equ EVSYS_ASYNCCH04_bp = 4              ; Asynchronous Channel 0 Generator Selection bit 4 position\n.equ EVSYS_ASYNCCH05_bm = (1<<5)         ; Asynchronous Channel 0 Generator Selection bit 5 mask\n.equ EVSYS_ASYNCCH05_bp = 5              ; Asynchronous Channel 0 Generator Selection bit 5 position\n.equ EVSYS_ASYNCCH06_bm = (1<<6)         ; Asynchronous Channel 0 Generator Selection bit 6 mask\n.equ EVSYS_ASYNCCH06_bp = 6              ; Asynchronous Channel 0 Generator Selection bit 6 position\n.equ EVSYS_ASYNCCH07_bm = (1<<7)         ; Asynchronous Channel 0 Generator Selection bit 7 mask\n.equ EVSYS_ASYNCCH07_bp = 7              ; Asynchronous Channel 0 Generator Selection bit 7 position\n\n; EVSYS_ASYNCCH1 masks\n.equ EVSYS_ASYNCCH1_gm = 0xFF            ; Asynchronous Channel 1 Generator Selection group mask\n.equ EVSYS_ASYNCCH1_gp = 0               ; Asynchronous Channel 1 Generator Selection group position\n.equ EVSYS_ASYNCCH10_bm = (1<<0)         ; Asynchronous Channel 1 Generator Selection bit 0 mask\n.equ EVSYS_ASYNCCH10_bp = 0              ; Asynchronous Channel 1 Generator Selection bit 0 position\n.equ EVSYS_ASYNCCH11_bm = (1<<1)         ; Asynchronous Channel 1 Generator Selection bit 1 mask\n.equ EVSYS_ASYNCCH11_bp = 1              ; Asynchronous Channel 1 Generator Selection bit 1 position\n.equ EVSYS_ASYNCCH12_bm = (1<<2)         ; Asynchronous Channel 1 Generator Selection bit 2 mask\n.equ EVSYS_ASYNCCH12_bp = 2              ; Asynchronous Channel 1 Generator Selection bit 2 position\n.equ EVSYS_ASYNCCH13_bm = (1<<3)         ; Asynchronous Channel 1 Generator Selection bit 3 mask\n.equ EVSYS_ASYNCCH13_bp = 3              ; Asynchronous Channel 1 Generator Selection bit 3 position\n.equ EVSYS_ASYNCCH14_bm = (1<<4)         ; Asynchronous Channel 1 Generator Selection bit 4 mask\n.equ EVSYS_ASYNCCH14_bp = 4              ; Asynchronous Channel 1 Generator Selection bit 4 position\n.equ EVSYS_ASYNCCH15_bm = (1<<5)         ; Asynchronous Channel 1 Generator Selection bit 5 mask\n.equ EVSYS_ASYNCCH15_bp = 5              ; Asynchronous Channel 1 Generator Selection bit 5 position\n.equ EVSYS_ASYNCCH16_bm = (1<<6)         ; Asynchronous Channel 1 Generator Selection bit 6 mask\n.equ EVSYS_ASYNCCH16_bp = 6              ; Asynchronous Channel 1 Generator Selection bit 6 position\n.equ EVSYS_ASYNCCH17_bm = (1<<7)         ; Asynchronous Channel 1 Generator Selection bit 7 mask\n.equ EVSYS_ASYNCCH17_bp = 7              ; Asynchronous Channel 1 Generator Selection bit 7 position\n\n; EVSYS_ASYNCCH2 masks\n.equ EVSYS_ASYNCCH2_gm = 0xFF            ; Asynchronous Channel 2 Generator Selection group mask\n.equ EVSYS_ASYNCCH2_gp = 0               ; Asynchronous Channel 2 Generator Selection group position\n.equ EVSYS_ASYNCCH20_bm = (1<<0)         ; Asynchronous Channel 2 Generator Selection bit 0 mask\n.equ EVSYS_ASYNCCH20_bp = 0              ; Asynchronous Channel 2 Generator Selection bit 0 position\n.equ EVSYS_ASYNCCH21_bm = (1<<1)         ; Asynchronous Channel 2 Generator Selection bit 1 mask\n.equ EVSYS_ASYNCCH21_bp = 1              ; Asynchronous Channel 2 Generator Selection bit 1 position\n.equ EVSYS_ASYNCCH22_bm = (1<<2)         ; Asynchronous Channel 2 Generator Selection bit 2 mask\n.equ EVSYS_ASYNCCH22_bp = 2              ; Asynchronous Channel 2 Generator Selection bit 2 position\n.equ EVSYS_ASYNCCH23_bm = (1<<3)         ; Asynchronous Channel 2 Generator Selection bit 3 mask\n.equ EVSYS_ASYNCCH23_bp = 3              ; Asynchronous Channel 2 Generator Selection bit 3 position\n.equ EVSYS_ASYNCCH24_bm = (1<<4)         ; Asynchronous Channel 2 Generator Selection bit 4 mask\n.equ EVSYS_ASYNCCH24_bp = 4              ; Asynchronous Channel 2 Generator Selection bit 4 position\n.equ EVSYS_ASYNCCH25_bm = (1<<5)         ; Asynchronous Channel 2 Generator Selection bit 5 mask\n.equ EVSYS_ASYNCCH25_bp = 5              ; Asynchronous Channel 2 Generator Selection bit 5 position\n.equ EVSYS_ASYNCCH26_bm = (1<<6)         ; Asynchronous Channel 2 Generator Selection bit 6 mask\n.equ EVSYS_ASYNCCH26_bp = 6              ; Asynchronous Channel 2 Generator Selection bit 6 position\n.equ EVSYS_ASYNCCH27_bm = (1<<7)         ; Asynchronous Channel 2 Generator Selection bit 7 mask\n.equ EVSYS_ASYNCCH27_bp = 7              ; Asynchronous Channel 2 Generator Selection bit 7 position\n\n; EVSYS_ASYNCCH3 masks\n.equ EVSYS_ASYNCCH3_gm = 0xFF            ; Asynchronous Channel 3 Generator Selection group mask\n.equ EVSYS_ASYNCCH3_gp = 0               ; Asynchronous Channel 3 Generator Selection group position\n.equ EVSYS_ASYNCCH30_bm = (1<<0)         ; Asynchronous Channel 3 Generator Selection bit 0 mask\n.equ EVSYS_ASYNCCH30_bp = 0              ; Asynchronous Channel 3 Generator Selection bit 0 position\n.equ EVSYS_ASYNCCH31_bm = (1<<1)         ; Asynchronous Channel 3 Generator Selection bit 1 mask\n.equ EVSYS_ASYNCCH31_bp = 1              ; Asynchronous Channel 3 Generator Selection bit 1 position\n.equ EVSYS_ASYNCCH32_bm = (1<<2)         ; Asynchronous Channel 3 Generator Selection bit 2 mask\n.equ EVSYS_ASYNCCH32_bp = 2              ; Asynchronous Channel 3 Generator Selection bit 2 position\n.equ EVSYS_ASYNCCH33_bm = (1<<3)         ; Asynchronous Channel 3 Generator Selection bit 3 mask\n.equ EVSYS_ASYNCCH33_bp = 3              ; Asynchronous Channel 3 Generator Selection bit 3 position\n.equ EVSYS_ASYNCCH34_bm = (1<<4)         ; Asynchronous Channel 3 Generator Selection bit 4 mask\n.equ EVSYS_ASYNCCH34_bp = 4              ; Asynchronous Channel 3 Generator Selection bit 4 position\n.equ EVSYS_ASYNCCH35_bm = (1<<5)         ; Asynchronous Channel 3 Generator Selection bit 5 mask\n.equ EVSYS_ASYNCCH35_bp = 5              ; Asynchronous Channel 3 Generator Selection bit 5 position\n.equ EVSYS_ASYNCCH36_bm = (1<<6)         ; Asynchronous Channel 3 Generator Selection bit 6 mask\n.equ EVSYS_ASYNCCH36_bp = 6              ; Asynchronous Channel 3 Generator Selection bit 6 position\n.equ EVSYS_ASYNCCH37_bm = (1<<7)         ; Asynchronous Channel 3 Generator Selection bit 7 mask\n.equ EVSYS_ASYNCCH37_bp = 7              ; Asynchronous Channel 3 Generator Selection bit 7 position\n\n; EVSYS_ASYNCUSER0 masks\n.equ EVSYS_ASYNCUSER0_gm = 0xFF          ; Asynchronous User Ch 0 Input Selection - TCB0 group mask\n.equ EVSYS_ASYNCUSER0_gp = 0             ; Asynchronous User Ch 0 Input Selection - TCB0 group position\n.equ EVSYS_ASYNCUSER00_bm = (1<<0)       ; Asynchronous User Ch 0 Input Selection - TCB0 bit 0 mask\n.equ EVSYS_ASYNCUSER00_bp = 0            ; Asynchronous User Ch 0 Input Selection - TCB0 bit 0 position\n.equ EVSYS_ASYNCUSER01_bm = (1<<1)       ; Asynchronous User Ch 0 Input Selection - TCB0 bit 1 mask\n.equ EVSYS_ASYNCUSER01_bp = 1            ; Asynchronous User Ch 0 Input Selection - TCB0 bit 1 position\n.equ EVSYS_ASYNCUSER02_bm = (1<<2)       ; Asynchronous User Ch 0 Input Selection - TCB0 bit 2 mask\n.equ EVSYS_ASYNCUSER02_bp = 2            ; Asynchronous User Ch 0 Input Selection - TCB0 bit 2 position\n.equ EVSYS_ASYNCUSER03_bm = (1<<3)       ; Asynchronous User Ch 0 Input Selection - TCB0 bit 3 mask\n.equ EVSYS_ASYNCUSER03_bp = 3            ; Asynchronous User Ch 0 Input Selection - TCB0 bit 3 position\n.equ EVSYS_ASYNCUSER04_bm = (1<<4)       ; Asynchronous User Ch 0 Input Selection - TCB0 bit 4 mask\n.equ EVSYS_ASYNCUSER04_bp = 4            ; Asynchronous User Ch 0 Input Selection - TCB0 bit 4 position\n.equ EVSYS_ASYNCUSER05_bm = (1<<5)       ; Asynchronous User Ch 0 Input Selection - TCB0 bit 5 mask\n.equ EVSYS_ASYNCUSER05_bp = 5            ; Asynchronous User Ch 0 Input Selection - TCB0 bit 5 position\n.equ EVSYS_ASYNCUSER06_bm = (1<<6)       ; Asynchronous User Ch 0 Input Selection - TCB0 bit 6 mask\n.equ EVSYS_ASYNCUSER06_bp = 6            ; Asynchronous User Ch 0 Input Selection - TCB0 bit 6 position\n.equ EVSYS_ASYNCUSER07_bm = (1<<7)       ; Asynchronous User Ch 0 Input Selection - TCB0 bit 7 mask\n.equ EVSYS_ASYNCUSER07_bp = 7            ; Asynchronous User Ch 0 Input Selection - TCB0 bit 7 position\n\n; EVSYS_ASYNCUSER1 masks\n.equ EVSYS_ASYNCUSER1_gm = 0xFF          ; Asynchronous User Ch 1 Input Selection - ADC0 group mask\n.equ EVSYS_ASYNCUSER1_gp = 0             ; Asynchronous User Ch 1 Input Selection - ADC0 group position\n.equ EVSYS_ASYNCUSER10_bm = (1<<0)       ; Asynchronous User Ch 1 Input Selection - ADC0 bit 0 mask\n.equ EVSYS_ASYNCUSER10_bp = 0            ; Asynchronous User Ch 1 Input Selection - ADC0 bit 0 position\n.equ EVSYS_ASYNCUSER11_bm = (1<<1)       ; Asynchronous User Ch 1 Input Selection - ADC0 bit 1 mask\n.equ EVSYS_ASYNCUSER11_bp = 1            ; Asynchronous User Ch 1 Input Selection - ADC0 bit 1 position\n.equ EVSYS_ASYNCUSER12_bm = (1<<2)       ; Asynchronous User Ch 1 Input Selection - ADC0 bit 2 mask\n.equ EVSYS_ASYNCUSER12_bp = 2            ; Asynchronous User Ch 1 Input Selection - ADC0 bit 2 position\n.equ EVSYS_ASYNCUSER13_bm = (1<<3)       ; Asynchronous User Ch 1 Input Selection - ADC0 bit 3 mask\n.equ EVSYS_ASYNCUSER13_bp = 3            ; Asynchronous User Ch 1 Input Selection - ADC0 bit 3 position\n.equ EVSYS_ASYNCUSER14_bm = (1<<4)       ; Asynchronous User Ch 1 Input Selection - ADC0 bit 4 mask\n.equ EVSYS_ASYNCUSER14_bp = 4            ; Asynchronous User Ch 1 Input Selection - ADC0 bit 4 position\n.equ EVSYS_ASYNCUSER15_bm = (1<<5)       ; Asynchronous User Ch 1 Input Selection - ADC0 bit 5 mask\n.equ EVSYS_ASYNCUSER15_bp = 5            ; Asynchronous User Ch 1 Input Selection - ADC0 bit 5 position\n.equ EVSYS_ASYNCUSER16_bm = (1<<6)       ; Asynchronous User Ch 1 Input Selection - ADC0 bit 6 mask\n.equ EVSYS_ASYNCUSER16_bp = 6            ; Asynchronous User Ch 1 Input Selection - ADC0 bit 6 position\n.equ EVSYS_ASYNCUSER17_bm = (1<<7)       ; Asynchronous User Ch 1 Input Selection - ADC0 bit 7 mask\n.equ EVSYS_ASYNCUSER17_bp = 7            ; Asynchronous User Ch 1 Input Selection - ADC0 bit 7 position\n\n; EVSYS_ASYNCUSER2 masks\n.equ EVSYS_ASYNCUSER2_gm = 0xFF          ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 group mask\n.equ EVSYS_ASYNCUSER2_gp = 0             ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 group position\n.equ EVSYS_ASYNCUSER20_bm = (1<<0)       ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 0 mask\n.equ EVSYS_ASYNCUSER20_bp = 0            ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 0 position\n.equ EVSYS_ASYNCUSER21_bm = (1<<1)       ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 1 mask\n.equ EVSYS_ASYNCUSER21_bp = 1            ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 1 position\n.equ EVSYS_ASYNCUSER22_bm = (1<<2)       ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 2 mask\n.equ EVSYS_ASYNCUSER22_bp = 2            ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 2 position\n.equ EVSYS_ASYNCUSER23_bm = (1<<3)       ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 3 mask\n.equ EVSYS_ASYNCUSER23_bp = 3            ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 3 position\n.equ EVSYS_ASYNCUSER24_bm = (1<<4)       ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 4 mask\n.equ EVSYS_ASYNCUSER24_bp = 4            ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 4 position\n.equ EVSYS_ASYNCUSER25_bm = (1<<5)       ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 5 mask\n.equ EVSYS_ASYNCUSER25_bp = 5            ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 5 position\n.equ EVSYS_ASYNCUSER26_bm = (1<<6)       ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 6 mask\n.equ EVSYS_ASYNCUSER26_bp = 6            ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 6 position\n.equ EVSYS_ASYNCUSER27_bm = (1<<7)       ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 7 mask\n.equ EVSYS_ASYNCUSER27_bp = 7            ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 7 position\n\n; EVSYS_ASYNCUSER3 masks\n.equ EVSYS_ASYNCUSER3_gm = 0xFF          ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 group mask\n.equ EVSYS_ASYNCUSER3_gp = 0             ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 group position\n.equ EVSYS_ASYNCUSER30_bm = (1<<0)       ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 0 mask\n.equ EVSYS_ASYNCUSER30_bp = 0            ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 0 position\n.equ EVSYS_ASYNCUSER31_bm = (1<<1)       ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 1 mask\n.equ EVSYS_ASYNCUSER31_bp = 1            ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 1 position\n.equ EVSYS_ASYNCUSER32_bm = (1<<2)       ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 2 mask\n.equ EVSYS_ASYNCUSER32_bp = 2            ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 2 position\n.equ EVSYS_ASYNCUSER33_bm = (1<<3)       ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 3 mask\n.equ EVSYS_ASYNCUSER33_bp = 3            ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 3 position\n.equ EVSYS_ASYNCUSER34_bm = (1<<4)       ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 4 mask\n.equ EVSYS_ASYNCUSER34_bp = 4            ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 4 position\n.equ EVSYS_ASYNCUSER35_bm = (1<<5)       ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 5 mask\n.equ EVSYS_ASYNCUSER35_bp = 5            ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 5 position\n.equ EVSYS_ASYNCUSER36_bm = (1<<6)       ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 6 mask\n.equ EVSYS_ASYNCUSER36_bp = 6            ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 6 position\n.equ EVSYS_ASYNCUSER37_bm = (1<<7)       ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 7 mask\n.equ EVSYS_ASYNCUSER37_bp = 7            ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 7 position\n\n; EVSYS_ASYNCUSER4 masks\n.equ EVSYS_ASYNCUSER4_gm = 0xFF          ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 group mask\n.equ EVSYS_ASYNCUSER4_gp = 0             ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 group position\n.equ EVSYS_ASYNCUSER40_bm = (1<<0)       ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 0 mask\n.equ EVSYS_ASYNCUSER40_bp = 0            ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 0 position\n.equ EVSYS_ASYNCUSER41_bm = (1<<1)       ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 1 mask\n.equ EVSYS_ASYNCUSER41_bp = 1            ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 1 position\n.equ EVSYS_ASYNCUSER42_bm = (1<<2)       ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 2 mask\n.equ EVSYS_ASYNCUSER42_bp = 2            ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 2 position\n.equ EVSYS_ASYNCUSER43_bm = (1<<3)       ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 3 mask\n.equ EVSYS_ASYNCUSER43_bp = 3            ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 3 position\n.equ EVSYS_ASYNCUSER44_bm = (1<<4)       ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 4 mask\n.equ EVSYS_ASYNCUSER44_bp = 4            ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 4 position\n.equ EVSYS_ASYNCUSER45_bm = (1<<5)       ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 5 mask\n.equ EVSYS_ASYNCUSER45_bp = 5            ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 5 position\n.equ EVSYS_ASYNCUSER46_bm = (1<<6)       ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 6 mask\n.equ EVSYS_ASYNCUSER46_bp = 6            ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 6 position\n.equ EVSYS_ASYNCUSER47_bm = (1<<7)       ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 7 mask\n.equ EVSYS_ASYNCUSER47_bp = 7            ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 7 position\n\n; EVSYS_ASYNCUSER5 masks\n.equ EVSYS_ASYNCUSER5_gm = 0xFF          ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 group mask\n.equ EVSYS_ASYNCUSER5_gp = 0             ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 group position\n.equ EVSYS_ASYNCUSER50_bm = (1<<0)       ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 0 mask\n.equ EVSYS_ASYNCUSER50_bp = 0            ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 0 position\n.equ EVSYS_ASYNCUSER51_bm = (1<<1)       ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 1 mask\n.equ EVSYS_ASYNCUSER51_bp = 1            ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 1 position\n.equ EVSYS_ASYNCUSER52_bm = (1<<2)       ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 2 mask\n.equ EVSYS_ASYNCUSER52_bp = 2            ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 2 position\n.equ EVSYS_ASYNCUSER53_bm = (1<<3)       ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 3 mask\n.equ EVSYS_ASYNCUSER53_bp = 3            ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 3 position\n.equ EVSYS_ASYNCUSER54_bm = (1<<4)       ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 4 mask\n.equ EVSYS_ASYNCUSER54_bp = 4            ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 4 position\n.equ EVSYS_ASYNCUSER55_bm = (1<<5)       ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 5 mask\n.equ EVSYS_ASYNCUSER55_bp = 5            ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 5 position\n.equ EVSYS_ASYNCUSER56_bm = (1<<6)       ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 6 mask\n.equ EVSYS_ASYNCUSER56_bp = 6            ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 6 position\n.equ EVSYS_ASYNCUSER57_bm = (1<<7)       ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 7 mask\n.equ EVSYS_ASYNCUSER57_bp = 7            ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 7 position\n\n; EVSYS_ASYNCUSER6 masks\n.equ EVSYS_ASYNCUSER6_gm = 0xFF          ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 group mask\n.equ EVSYS_ASYNCUSER6_gp = 0             ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 group position\n.equ EVSYS_ASYNCUSER60_bm = (1<<0)       ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 0 mask\n.equ EVSYS_ASYNCUSER60_bp = 0            ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 0 position\n.equ EVSYS_ASYNCUSER61_bm = (1<<1)       ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 1 mask\n.equ EVSYS_ASYNCUSER61_bp = 1            ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 1 position\n.equ EVSYS_ASYNCUSER62_bm = (1<<2)       ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 2 mask\n.equ EVSYS_ASYNCUSER62_bp = 2            ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 2 position\n.equ EVSYS_ASYNCUSER63_bm = (1<<3)       ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 3 mask\n.equ EVSYS_ASYNCUSER63_bp = 3            ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 3 position\n.equ EVSYS_ASYNCUSER64_bm = (1<<4)       ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 4 mask\n.equ EVSYS_ASYNCUSER64_bp = 4            ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 4 position\n.equ EVSYS_ASYNCUSER65_bm = (1<<5)       ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 5 mask\n.equ EVSYS_ASYNCUSER65_bp = 5            ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 5 position\n.equ EVSYS_ASYNCUSER66_bm = (1<<6)       ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 6 mask\n.equ EVSYS_ASYNCUSER66_bp = 6            ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 6 position\n.equ EVSYS_ASYNCUSER67_bm = (1<<7)       ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 7 mask\n.equ EVSYS_ASYNCUSER67_bp = 7            ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 7 position\n\n; EVSYS_ASYNCUSER7 masks\n.equ EVSYS_ASYNCUSER7_gm = 0xFF          ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 group mask\n.equ EVSYS_ASYNCUSER7_gp = 0             ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 group position\n.equ EVSYS_ASYNCUSER70_bm = (1<<0)       ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 0 mask\n.equ EVSYS_ASYNCUSER70_bp = 0            ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 0 position\n.equ EVSYS_ASYNCUSER71_bm = (1<<1)       ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 1 mask\n.equ EVSYS_ASYNCUSER71_bp = 1            ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 1 position\n.equ EVSYS_ASYNCUSER72_bm = (1<<2)       ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 2 mask\n.equ EVSYS_ASYNCUSER72_bp = 2            ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 2 position\n.equ EVSYS_ASYNCUSER73_bm = (1<<3)       ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 3 mask\n.equ EVSYS_ASYNCUSER73_bp = 3            ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 3 position\n.equ EVSYS_ASYNCUSER74_bm = (1<<4)       ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 4 mask\n.equ EVSYS_ASYNCUSER74_bp = 4            ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 4 position\n.equ EVSYS_ASYNCUSER75_bm = (1<<5)       ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 5 mask\n.equ EVSYS_ASYNCUSER75_bp = 5            ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 5 position\n.equ EVSYS_ASYNCUSER76_bm = (1<<6)       ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 6 mask\n.equ EVSYS_ASYNCUSER76_bp = 6            ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 6 position\n.equ EVSYS_ASYNCUSER77_bm = (1<<7)       ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 7 mask\n.equ EVSYS_ASYNCUSER77_bp = 7            ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 7 position\n\n; EVSYS_ASYNCUSER8 masks\n.equ EVSYS_ASYNCUSER8_gm = 0xFF          ; Asynchronous User Ch 8 Input Selection - Event Out 0 group mask\n.equ EVSYS_ASYNCUSER8_gp = 0             ; Asynchronous User Ch 8 Input Selection - Event Out 0 group position\n.equ EVSYS_ASYNCUSER80_bm = (1<<0)       ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 0 mask\n.equ EVSYS_ASYNCUSER80_bp = 0            ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 0 position\n.equ EVSYS_ASYNCUSER81_bm = (1<<1)       ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 1 mask\n.equ EVSYS_ASYNCUSER81_bp = 1            ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 1 position\n.equ EVSYS_ASYNCUSER82_bm = (1<<2)       ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 2 mask\n.equ EVSYS_ASYNCUSER82_bp = 2            ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 2 position\n.equ EVSYS_ASYNCUSER83_bm = (1<<3)       ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 3 mask\n.equ EVSYS_ASYNCUSER83_bp = 3            ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 3 position\n.equ EVSYS_ASYNCUSER84_bm = (1<<4)       ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 4 mask\n.equ EVSYS_ASYNCUSER84_bp = 4            ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 4 position\n.equ EVSYS_ASYNCUSER85_bm = (1<<5)       ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 5 mask\n.equ EVSYS_ASYNCUSER85_bp = 5            ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 5 position\n.equ EVSYS_ASYNCUSER86_bm = (1<<6)       ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 6 mask\n.equ EVSYS_ASYNCUSER86_bp = 6            ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 6 position\n.equ EVSYS_ASYNCUSER87_bm = (1<<7)       ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 7 mask\n.equ EVSYS_ASYNCUSER87_bp = 7            ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 7 position\n\n; EVSYS_ASYNCUSER9 masks\n.equ EVSYS_ASYNCUSER9_gm = 0xFF          ; Asynchronous User Ch 9 Input Selection - Event Out 1 group mask\n.equ EVSYS_ASYNCUSER9_gp = 0             ; Asynchronous User Ch 9 Input Selection - Event Out 1 group position\n.equ EVSYS_ASYNCUSER90_bm = (1<<0)       ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 0 mask\n.equ EVSYS_ASYNCUSER90_bp = 0            ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 0 position\n.equ EVSYS_ASYNCUSER91_bm = (1<<1)       ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 1 mask\n.equ EVSYS_ASYNCUSER91_bp = 1            ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 1 position\n.equ EVSYS_ASYNCUSER92_bm = (1<<2)       ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 2 mask\n.equ EVSYS_ASYNCUSER92_bp = 2            ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 2 position\n.equ EVSYS_ASYNCUSER93_bm = (1<<3)       ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 3 mask\n.equ EVSYS_ASYNCUSER93_bp = 3            ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 3 position\n.equ EVSYS_ASYNCUSER94_bm = (1<<4)       ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 4 mask\n.equ EVSYS_ASYNCUSER94_bp = 4            ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 4 position\n.equ EVSYS_ASYNCUSER95_bm = (1<<5)       ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 5 mask\n.equ EVSYS_ASYNCUSER95_bp = 5            ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 5 position\n.equ EVSYS_ASYNCUSER96_bm = (1<<6)       ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 6 mask\n.equ EVSYS_ASYNCUSER96_bp = 6            ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 6 position\n.equ EVSYS_ASYNCUSER97_bm = (1<<7)       ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 7 mask\n.equ EVSYS_ASYNCUSER97_bp = 7            ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 7 position\n\n; EVSYS_ASYNCUSER10 masks\n.equ EVSYS_ASYNCUSER10_gm = 0xFF         ; Asynchronous User Ch 10 Input Selection - Event Out 2 group mask\n.equ EVSYS_ASYNCUSER10_gp = 0            ; Asynchronous User Ch 10 Input Selection - Event Out 2 group position\n.equ EVSYS_ASYNCUSER100_bm = (1<<0)      ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 0 mask\n.equ EVSYS_ASYNCUSER100_bp = 0           ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 0 position\n.equ EVSYS_ASYNCUSER101_bm = (1<<1)      ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 1 mask\n.equ EVSYS_ASYNCUSER101_bp = 1           ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 1 position\n.equ EVSYS_ASYNCUSER102_bm = (1<<2)      ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 2 mask\n.equ EVSYS_ASYNCUSER102_bp = 2           ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 2 position\n.equ EVSYS_ASYNCUSER103_bm = (1<<3)      ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 3 mask\n.equ EVSYS_ASYNCUSER103_bp = 3           ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 3 position\n.equ EVSYS_ASYNCUSER104_bm = (1<<4)      ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 4 mask\n.equ EVSYS_ASYNCUSER104_bp = 4           ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 4 position\n.equ EVSYS_ASYNCUSER105_bm = (1<<5)      ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 5 mask\n.equ EVSYS_ASYNCUSER105_bp = 5           ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 5 position\n.equ EVSYS_ASYNCUSER106_bm = (1<<6)      ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 6 mask\n.equ EVSYS_ASYNCUSER106_bp = 6           ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 6 position\n.equ EVSYS_ASYNCUSER107_bm = (1<<7)      ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 7 mask\n.equ EVSYS_ASYNCUSER107_bp = 7           ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 7 position\n\n; EVSYS_SYNCCH0 masks\n.equ EVSYS_SYNCCH0_gm = 0xFF             ; Synchronous Channel 0 Generator Selection group mask\n.equ EVSYS_SYNCCH0_gp = 0                ; Synchronous Channel 0 Generator Selection group position\n.equ EVSYS_SYNCCH00_bm = (1<<0)          ; Synchronous Channel 0 Generator Selection bit 0 mask\n.equ EVSYS_SYNCCH00_bp = 0               ; Synchronous Channel 0 Generator Selection bit 0 position\n.equ EVSYS_SYNCCH01_bm = (1<<1)          ; Synchronous Channel 0 Generator Selection bit 1 mask\n.equ EVSYS_SYNCCH01_bp = 1               ; Synchronous Channel 0 Generator Selection bit 1 position\n.equ EVSYS_SYNCCH02_bm = (1<<2)          ; Synchronous Channel 0 Generator Selection bit 2 mask\n.equ EVSYS_SYNCCH02_bp = 2               ; Synchronous Channel 0 Generator Selection bit 2 position\n.equ EVSYS_SYNCCH03_bm = (1<<3)          ; Synchronous Channel 0 Generator Selection bit 3 mask\n.equ EVSYS_SYNCCH03_bp = 3               ; Synchronous Channel 0 Generator Selection bit 3 position\n.equ EVSYS_SYNCCH04_bm = (1<<4)          ; Synchronous Channel 0 Generator Selection bit 4 mask\n.equ EVSYS_SYNCCH04_bp = 4               ; Synchronous Channel 0 Generator Selection bit 4 position\n.equ EVSYS_SYNCCH05_bm = (1<<5)          ; Synchronous Channel 0 Generator Selection bit 5 mask\n.equ EVSYS_SYNCCH05_bp = 5               ; Synchronous Channel 0 Generator Selection bit 5 position\n.equ EVSYS_SYNCCH06_bm = (1<<6)          ; Synchronous Channel 0 Generator Selection bit 6 mask\n.equ EVSYS_SYNCCH06_bp = 6               ; Synchronous Channel 0 Generator Selection bit 6 position\n.equ EVSYS_SYNCCH07_bm = (1<<7)          ; Synchronous Channel 0 Generator Selection bit 7 mask\n.equ EVSYS_SYNCCH07_bp = 7               ; Synchronous Channel 0 Generator Selection bit 7 position\n\n; EVSYS_SYNCCH1 masks\n.equ EVSYS_SYNCCH1_gm = 0xFF             ; Synchronous Channel 1 Generator Selection group mask\n.equ EVSYS_SYNCCH1_gp = 0                ; Synchronous Channel 1 Generator Selection group position\n.equ EVSYS_SYNCCH10_bm = (1<<0)          ; Synchronous Channel 1 Generator Selection bit 0 mask\n.equ EVSYS_SYNCCH10_bp = 0               ; Synchronous Channel 1 Generator Selection bit 0 position\n.equ EVSYS_SYNCCH11_bm = (1<<1)          ; Synchronous Channel 1 Generator Selection bit 1 mask\n.equ EVSYS_SYNCCH11_bp = 1               ; Synchronous Channel 1 Generator Selection bit 1 position\n.equ EVSYS_SYNCCH12_bm = (1<<2)          ; Synchronous Channel 1 Generator Selection bit 2 mask\n.equ EVSYS_SYNCCH12_bp = 2               ; Synchronous Channel 1 Generator Selection bit 2 position\n.equ EVSYS_SYNCCH13_bm = (1<<3)          ; Synchronous Channel 1 Generator Selection bit 3 mask\n.equ EVSYS_SYNCCH13_bp = 3               ; Synchronous Channel 1 Generator Selection bit 3 position\n.equ EVSYS_SYNCCH14_bm = (1<<4)          ; Synchronous Channel 1 Generator Selection bit 4 mask\n.equ EVSYS_SYNCCH14_bp = 4               ; Synchronous Channel 1 Generator Selection bit 4 position\n.equ EVSYS_SYNCCH15_bm = (1<<5)          ; Synchronous Channel 1 Generator Selection bit 5 mask\n.equ EVSYS_SYNCCH15_bp = 5               ; Synchronous Channel 1 Generator Selection bit 5 position\n.equ EVSYS_SYNCCH16_bm = (1<<6)          ; Synchronous Channel 1 Generator Selection bit 6 mask\n.equ EVSYS_SYNCCH16_bp = 6               ; Synchronous Channel 1 Generator Selection bit 6 position\n.equ EVSYS_SYNCCH17_bm = (1<<7)          ; Synchronous Channel 1 Generator Selection bit 7 mask\n.equ EVSYS_SYNCCH17_bp = 7               ; Synchronous Channel 1 Generator Selection bit 7 position\n\n; EVSYS_SYNCUSER0 masks\n.equ EVSYS_SYNCUSER0_gm = 0xFF           ; Synchronous User Ch 0 Input Selection - TCA0 group mask\n.equ EVSYS_SYNCUSER0_gp = 0              ; Synchronous User Ch 0 Input Selection - TCA0 group position\n.equ EVSYS_SYNCUSER00_bm = (1<<0)        ; Synchronous User Ch 0 Input Selection - TCA0 bit 0 mask\n.equ EVSYS_SYNCUSER00_bp = 0             ; Synchronous User Ch 0 Input Selection - TCA0 bit 0 position\n.equ EVSYS_SYNCUSER01_bm = (1<<1)        ; Synchronous User Ch 0 Input Selection - TCA0 bit 1 mask\n.equ EVSYS_SYNCUSER01_bp = 1             ; Synchronous User Ch 0 Input Selection - TCA0 bit 1 position\n.equ EVSYS_SYNCUSER02_bm = (1<<2)        ; Synchronous User Ch 0 Input Selection - TCA0 bit 2 mask\n.equ EVSYS_SYNCUSER02_bp = 2             ; Synchronous User Ch 0 Input Selection - TCA0 bit 2 position\n.equ EVSYS_SYNCUSER03_bm = (1<<3)        ; Synchronous User Ch 0 Input Selection - TCA0 bit 3 mask\n.equ EVSYS_SYNCUSER03_bp = 3             ; Synchronous User Ch 0 Input Selection - TCA0 bit 3 position\n.equ EVSYS_SYNCUSER04_bm = (1<<4)        ; Synchronous User Ch 0 Input Selection - TCA0 bit 4 mask\n.equ EVSYS_SYNCUSER04_bp = 4             ; Synchronous User Ch 0 Input Selection - TCA0 bit 4 position\n.equ EVSYS_SYNCUSER05_bm = (1<<5)        ; Synchronous User Ch 0 Input Selection - TCA0 bit 5 mask\n.equ EVSYS_SYNCUSER05_bp = 5             ; Synchronous User Ch 0 Input Selection - TCA0 bit 5 position\n.equ EVSYS_SYNCUSER06_bm = (1<<6)        ; Synchronous User Ch 0 Input Selection - TCA0 bit 6 mask\n.equ EVSYS_SYNCUSER06_bp = 6             ; Synchronous User Ch 0 Input Selection - TCA0 bit 6 position\n.equ EVSYS_SYNCUSER07_bm = (1<<7)        ; Synchronous User Ch 0 Input Selection - TCA0 bit 7 mask\n.equ EVSYS_SYNCUSER07_bp = 7             ; Synchronous User Ch 0 Input Selection - TCA0 bit 7 position\n\n; EVSYS_SYNCUSER1 masks\n.equ EVSYS_SYNCUSER1_gm = 0xFF           ; Synchronous User Ch 1 Input Selection - USART0 group mask\n.equ EVSYS_SYNCUSER1_gp = 0              ; Synchronous User Ch 1 Input Selection - USART0 group position\n.equ EVSYS_SYNCUSER10_bm = (1<<0)        ; Synchronous User Ch 1 Input Selection - USART0 bit 0 mask\n.equ EVSYS_SYNCUSER10_bp = 0             ; Synchronous User Ch 1 Input Selection - USART0 bit 0 position\n.equ EVSYS_SYNCUSER11_bm = (1<<1)        ; Synchronous User Ch 1 Input Selection - USART0 bit 1 mask\n.equ EVSYS_SYNCUSER11_bp = 1             ; Synchronous User Ch 1 Input Selection - USART0 bit 1 position\n.equ EVSYS_SYNCUSER12_bm = (1<<2)        ; Synchronous User Ch 1 Input Selection - USART0 bit 2 mask\n.equ EVSYS_SYNCUSER12_bp = 2             ; Synchronous User Ch 1 Input Selection - USART0 bit 2 position\n.equ EVSYS_SYNCUSER13_bm = (1<<3)        ; Synchronous User Ch 1 Input Selection - USART0 bit 3 mask\n.equ EVSYS_SYNCUSER13_bp = 3             ; Synchronous User Ch 1 Input Selection - USART0 bit 3 position\n.equ EVSYS_SYNCUSER14_bm = (1<<4)        ; Synchronous User Ch 1 Input Selection - USART0 bit 4 mask\n.equ EVSYS_SYNCUSER14_bp = 4             ; Synchronous User Ch 1 Input Selection - USART0 bit 4 position\n.equ EVSYS_SYNCUSER15_bm = (1<<5)        ; Synchronous User Ch 1 Input Selection - USART0 bit 5 mask\n.equ EVSYS_SYNCUSER15_bp = 5             ; Synchronous User Ch 1 Input Selection - USART0 bit 5 position\n.equ EVSYS_SYNCUSER16_bm = (1<<6)        ; Synchronous User Ch 1 Input Selection - USART0 bit 6 mask\n.equ EVSYS_SYNCUSER16_bp = 6             ; Synchronous User Ch 1 Input Selection - USART0 bit 6 position\n.equ EVSYS_SYNCUSER17_bm = (1<<7)        ; Synchronous User Ch 1 Input Selection - USART0 bit 7 mask\n.equ EVSYS_SYNCUSER17_bp = 7             ; Synchronous User Ch 1 Input Selection - USART0 bit 7 position\n\n; Asynchronous Channel 0 Generator Selection select\n.equ EVSYS_ASYNCCH0_OFF_gc = (0x00<<0)   ; Off\n.equ EVSYS_ASYNCCH0_CCL_LUT0_gc = (0x01<<0) ; Configurable Custom Logic LUT0\n.equ EVSYS_ASYNCCH0_CCL_LUT1_gc = (0x02<<0) ; Configurable Custom Logic LUT1\n.equ EVSYS_ASYNCCH0_AC0_OUT_gc = (0x03<<0) ; Analog Comparator 0 out\n.equ EVSYS_ASYNCCH0_TCD0_CMPBCLR_gc = (0x04<<0) ; Timer/Counter D0 compare B clear\n.equ EVSYS_ASYNCCH0_TCD0_CMPASET_gc = (0x05<<0) ; Timer/Counter D0 compare A set\n.equ EVSYS_ASYNCCH0_TCD0_CMPBSET_gc = (0x06<<0) ; Timer/Counter D0 compare B set\n.equ EVSYS_ASYNCCH0_TCD0_PROGEV_gc = (0x07<<0) ; Timer/Counter D0 program event\n.equ EVSYS_ASYNCCH0_RTC_OVF_gc = (0x08<<0) ; Real Time Counter overflow\n.equ EVSYS_ASYNCCH0_RTC_CMP_gc = (0x09<<0) ; Real Time Counter compare\n.equ EVSYS_ASYNCCH0_PORTA_PIN0_gc = (0x0A<<0) ; Asynchronous Event from Pin PA0\n.equ EVSYS_ASYNCCH0_PORTA_PIN1_gc = (0x0B<<0) ; Asynchronous Event from Pin PA1\n.equ EVSYS_ASYNCCH0_PORTA_PIN2_gc = (0x0C<<0) ; Asynchronous Event from Pin PA2\n.equ EVSYS_ASYNCCH0_PORTA_PIN3_gc = (0x0D<<0) ; Asynchronous Event from Pin PA3\n.equ EVSYS_ASYNCCH0_PORTA_PIN4_gc = (0x0E<<0) ; Asynchronous Event from Pin PA4\n.equ EVSYS_ASYNCCH0_PORTA_PIN5_gc = (0x0F<<0) ; Asynchronous Event from Pin PA5\n.equ EVSYS_ASYNCCH0_PORTA_PIN6_gc = (0x10<<0) ; Asynchronous Event from Pin PA6\n.equ EVSYS_ASYNCCH0_PORTA_PIN7_gc = (0x11<<0) ; Asynchronous Event from Pin PA7\n.equ EVSYS_ASYNCCH0_UPDI_gc = (0x12<<0)  ; Unified Program and debug interface\n\n; Asynchronous Channel 1 Generator Selection select\n.equ EVSYS_ASYNCCH1_OFF_gc = (0x00<<0)   ; Off\n.equ EVSYS_ASYNCCH1_CCL_LUT0_gc = (0x01<<0) ; Configurable custom logic LUT0\n.equ EVSYS_ASYNCCH1_CCL_LUT1_gc = (0x02<<0) ; Configurable custom logic LUT1\n.equ EVSYS_ASYNCCH1_AC0_OUT_gc = (0x03<<0) ; Analog Comparator 0 out\n.equ EVSYS_ASYNCCH1_TCD0_CMPBCLR_gc = (0x04<<0) ; Timer/Counter D0 compare B clear\n.equ EVSYS_ASYNCCH1_TCD0_CMPASET_gc = (0x05<<0) ; Timer/Counter D0 compare A set\n.equ EVSYS_ASYNCCH1_TCD0_CMPBSET_gc = (0x06<<0) ; Timer/Counter D0 compare B set\n.equ EVSYS_ASYNCCH1_TCD0_PROGEV_gc = (0x07<<0) ; Timer/Counter D0 program event\n.equ EVSYS_ASYNCCH1_RTC_OVF_gc = (0x08<<0) ; Real Time Counter overflow\n.equ EVSYS_ASYNCCH1_RTC_CMP_gc = (0x09<<0) ; Real Time Counter compare\n.equ EVSYS_ASYNCCH1_PORTB_PIN0_gc = (0x0A<<0) ; Asynchronous Event from Pin PB0\n.equ EVSYS_ASYNCCH1_PORTB_PIN1_gc = (0x0B<<0) ; Asynchronous Event from Pin PB1\n.equ EVSYS_ASYNCCH1_PORTB_PIN2_gc = (0x0C<<0) ; Asynchronous Event from Pin PB2\n.equ EVSYS_ASYNCCH1_PORTB_PIN3_gc = (0x0D<<0) ; Asynchronous Event from Pin PB3\n.equ EVSYS_ASYNCCH1_PORTB_PIN4_gc = (0x0E<<0) ; Asynchronous Event from Pin PB4\n.equ EVSYS_ASYNCCH1_PORTB_PIN5_gc = (0x0F<<0) ; Asynchronous Event from Pin PB5\n.equ EVSYS_ASYNCCH1_PORTB_PIN6_gc = (0x10<<0) ; Asynchronous Event from Pin PB6\n.equ EVSYS_ASYNCCH1_PORTB_PIN7_gc = (0x11<<0) ; Asynchronous Event from Pin PB7\n\n; Asynchronous Channel 2 Generator Selection select\n.equ EVSYS_ASYNCCH2_OFF_gc = (0x00<<0)   ; Off\n.equ EVSYS_ASYNCCH2_CCL_LUT0_gc = (0x01<<0) ; Configurable Custom Logic LUT0\n.equ EVSYS_ASYNCCH2_CCL_LUT1_gc = (0x02<<0) ; Configurable Custom Logic LUT1\n.equ EVSYS_ASYNCCH2_AC0_OUT_gc = (0x03<<0) ; Analog Comparator 0 out\n.equ EVSYS_ASYNCCH2_TCD0_CMPBCLR_gc = (0x04<<0) ; Timer/Counter D0 compare B clear\n.equ EVSYS_ASYNCCH2_TCD0_CMPASET_gc = (0x05<<0) ; Timer/Counter D0 compare A set\n.equ EVSYS_ASYNCCH2_TCD0_CMPBSET_gc = (0x06<<0) ; Timer/Counter D0 compare B set\n.equ EVSYS_ASYNCCH2_TCD0_PROGEV_gc = (0x07<<0) ; Timer/Counter D0 program event\n.equ EVSYS_ASYNCCH2_RTC_OVF_gc = (0x08<<0) ; Real Time Counter overflow\n.equ EVSYS_ASYNCCH2_RTC_CMP_gc = (0x09<<0) ; Real Time Counter compare\n.equ EVSYS_ASYNCCH2_PORTC_PIN0_gc = (0x0A<<0) ; Asynchronous Event from Pin PC0\n.equ EVSYS_ASYNCCH2_PORTC_PIN1_gc = (0x0B<<0) ; Asynchronous Event from Pin PC1\n.equ EVSYS_ASYNCCH2_PORTC_PIN2_gc = (0x0C<<0) ; Asynchronous Event from Pin PC2\n.equ EVSYS_ASYNCCH2_PORTC_PIN3_gc = (0x0D<<0) ; Asynchronous Event from Pin PC3\n.equ EVSYS_ASYNCCH2_PORTC_PIN4_gc = (0x0E<<0) ; Asynchronous Event from Pin PC4\n.equ EVSYS_ASYNCCH2_PORTC_PIN5_gc = (0x0F<<0) ; Asynchronous Event from Pin PC5\n\n; Asynchronous Channel 3 Generator Selection select\n.equ EVSYS_ASYNCCH3_OFF_gc = (0x00<<0)   ; Off\n.equ EVSYS_ASYNCCH3_CCL_LUT0_gc = (0x01<<0) ; Configurable custom logic LUT0\n.equ EVSYS_ASYNCCH3_CCL_LUT1_gc = (0x02<<0) ; Configurable custom logic LUT1\n.equ EVSYS_ASYNCCH3_AC0_OUT_gc = (0x03<<0) ; Analog Comparator 0 out\n.equ EVSYS_ASYNCCH3_TCD0_CMPBCLR_gc = (0x04<<0) ; Timer/Counter type D compare B clear\n.equ EVSYS_ASYNCCH3_TCD0_CMPASET_gc = (0x05<<0) ; Timer/Counter type D compare A set\n.equ EVSYS_ASYNCCH3_TCD0_CMPBSET_gc = (0x06<<0) ; Timer/Counter type D compare B set\n.equ EVSYS_ASYNCCH3_TCD0_PROGEV_gc = (0x07<<0) ; Timer/Counter type D program event\n.equ EVSYS_ASYNCCH3_RTC_OVF_gc = (0x08<<0) ; Real Time Counter overflow\n.equ EVSYS_ASYNCCH3_RTC_CMP_gc = (0x09<<0) ; Real Time Counter compare\n.equ EVSYS_ASYNCCH3_PIT_DIV8192_gc = (0x0A<<0) ; Periodic Interrupt CLK_RTC div 8192\n.equ EVSYS_ASYNCCH3_PIT_DIV4096_gc = (0x0B<<0) ; Periodic Interrupt CLK_RTC div 4096\n.equ EVSYS_ASYNCCH3_PIT_DIV2048_gc = (0x0C<<0) ; Periodic Interrupt CLK_RTC div 2048\n.equ EVSYS_ASYNCCH3_PIT_DIV1024_gc = (0x0D<<0) ; Periodic Interrupt CLK_RTC div 1024\n.equ EVSYS_ASYNCCH3_PIT_DIV512_gc = (0x0E<<0) ; Periodic Interrupt CLK_RTC div 512\n.equ EVSYS_ASYNCCH3_PIT_DIV256_gc = (0x0F<<0) ; Periodic Interrupt CLK_RTC div 256\n.equ EVSYS_ASYNCCH3_PIT_DIV128_gc = (0x10<<0) ; Periodic Interrupt CLK_RTC div 128\n.equ EVSYS_ASYNCCH3_PIT_DIV64_gc = (0x11<<0) ; Periodic Interrupt CLK_RTC div 64\n\n; Asynchronous User Ch 0 Input Selection - TCB0 select\n.equ EVSYS_ASYNCUSER0_OFF_gc = (0x00<<0) ; Off\n.equ EVSYS_ASYNCUSER0_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_ASYNCUSER0_SYNCCH1_gc = (0x02<<0) ; Synchronous Event Channel 1\n.equ EVSYS_ASYNCUSER0_ASYNCCH0_gc = (0x03<<0) ; Asynchronous Event Channel 0\n.equ EVSYS_ASYNCUSER0_ASYNCCH1_gc = (0x04<<0) ; Asynchronous Event Channel 1\n.equ EVSYS_ASYNCUSER0_ASYNCCH2_gc = (0x05<<0) ; Asynchronous Event Channel 2\n.equ EVSYS_ASYNCUSER0_ASYNCCH3_gc = (0x06<<0) ; Asynchronous Event Channel 3\n\n; Asynchronous User Ch 1 Input Selection - ADC0 select\n.equ EVSYS_ASYNCUSER1_OFF_gc = (0x00<<0) ; Off\n.equ EVSYS_ASYNCUSER1_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_ASYNCUSER1_SYNCCH1_gc = (0x02<<0) ; Synchronous Event Channel 1\n.equ EVSYS_ASYNCUSER1_ASYNCCH0_gc = (0x03<<0) ; Asynchronous Event Channel 0\n.equ EVSYS_ASYNCUSER1_ASYNCCH1_gc = (0x04<<0) ; Asynchronous Event Channel 1\n.equ EVSYS_ASYNCUSER1_ASYNCCH2_gc = (0x05<<0) ; Asynchronous Event Channel 2\n.equ EVSYS_ASYNCUSER1_ASYNCCH3_gc = (0x06<<0) ; Asynchronous Event Channel 3\n\n; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 select\n.equ EVSYS_ASYNCUSER2_OFF_gc = (0x00<<0) ; Off\n.equ EVSYS_ASYNCUSER2_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_ASYNCUSER2_SYNCCH1_gc = (0x02<<0) ; Synchronous Event Channel 1\n.equ EVSYS_ASYNCUSER2_ASYNCCH0_gc = (0x03<<0) ; Asynchronous Event Channel 0\n.equ EVSYS_ASYNCUSER2_ASYNCCH1_gc = (0x04<<0) ; Asynchronous Event Channel 1\n.equ EVSYS_ASYNCUSER2_ASYNCCH2_gc = (0x05<<0) ; Asynchronous Event Channel 2\n.equ EVSYS_ASYNCUSER2_ASYNCCH3_gc = (0x06<<0) ; Asynchronous Event Channel 3\n\n; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 select\n.equ EVSYS_ASYNCUSER3_OFF_gc = (0x00<<0) ; Off\n.equ EVSYS_ASYNCUSER3_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_ASYNCUSER3_SYNCCH1_gc = (0x02<<0) ; Synchronous Event Channel 1\n.equ EVSYS_ASYNCUSER3_ASYNCCH0_gc = (0x03<<0) ; Asynchronous Event Channel 0\n.equ EVSYS_ASYNCUSER3_ASYNCCH1_gc = (0x04<<0) ; Asynchronous Event Channel 1\n.equ EVSYS_ASYNCUSER3_ASYNCCH2_gc = (0x05<<0) ; Asynchronous Event Channel 2\n.equ EVSYS_ASYNCUSER3_ASYNCCH3_gc = (0x06<<0) ; Asynchronous Event Channel 3\n\n; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 select\n.equ EVSYS_ASYNCUSER4_OFF_gc = (0x00<<0) ; Off\n.equ EVSYS_ASYNCUSER4_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_ASYNCUSER4_SYNCCH1_gc = (0x02<<0) ; Synchronous Event Channel 1\n.equ EVSYS_ASYNCUSER4_ASYNCCH0_gc = (0x03<<0) ; Asynchronous Event Channel 0\n.equ EVSYS_ASYNCUSER4_ASYNCCH1_gc = (0x04<<0) ; Asynchronous Event Channel 1\n.equ EVSYS_ASYNCUSER4_ASYNCCH2_gc = (0x05<<0) ; Asynchronous Event Channel 2\n.equ EVSYS_ASYNCUSER4_ASYNCCH3_gc = (0x06<<0) ; Asynchronous Event Channel 3\n\n; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 select\n.equ EVSYS_ASYNCUSER5_OFF_gc = (0x00<<0) ; Off\n.equ EVSYS_ASYNCUSER5_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_ASYNCUSER5_SYNCCH1_gc = (0x02<<0) ; Synchronous Event Channel 1\n.equ EVSYS_ASYNCUSER5_ASYNCCH0_gc = (0x03<<0) ; Asynchronous Event Channel 0\n.equ EVSYS_ASYNCUSER5_ASYNCCH1_gc = (0x04<<0) ; Asynchronous Event Channel 1\n.equ EVSYS_ASYNCUSER5_ASYNCCH2_gc = (0x05<<0) ; Asynchronous Event Channel 2\n.equ EVSYS_ASYNCUSER5_ASYNCCH3_gc = (0x06<<0) ; Asynchronous Event Channel 3\n\n; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 select\n.equ EVSYS_ASYNCUSER6_OFF_gc = (0x00<<0) ; Off\n.equ EVSYS_ASYNCUSER6_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_ASYNCUSER6_SYNCCH1_gc = (0x02<<0) ; Synchronous Event Channel 1\n.equ EVSYS_ASYNCUSER6_ASYNCCH0_gc = (0x03<<0) ; Asynchronous Event Channel 0\n.equ EVSYS_ASYNCUSER6_ASYNCCH1_gc = (0x04<<0) ; Asynchronous Event Channel 1\n.equ EVSYS_ASYNCUSER6_ASYNCCH2_gc = (0x05<<0) ; Asynchronous Event Channel 2\n.equ EVSYS_ASYNCUSER6_ASYNCCH3_gc = (0x06<<0) ; Asynchronous Event Channel 3\n\n; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 select\n.equ EVSYS_ASYNCUSER7_OFF_gc = (0x00<<0) ; Off\n.equ EVSYS_ASYNCUSER7_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_ASYNCUSER7_SYNCCH1_gc = (0x02<<0) ; Synchronous Event Channel 1\n.equ EVSYS_ASYNCUSER7_ASYNCCH0_gc = (0x03<<0) ; Asynchronous Event Channel 0\n.equ EVSYS_ASYNCUSER7_ASYNCCH1_gc = (0x04<<0) ; Asynchronous Event Channel 1\n.equ EVSYS_ASYNCUSER7_ASYNCCH2_gc = (0x05<<0) ; Asynchronous Event Channel 2\n.equ EVSYS_ASYNCUSER7_ASYNCCH3_gc = (0x06<<0) ; Asynchronous Event Channel 3\n\n; Asynchronous User Ch 8 Input Selection - Event Out 0 select\n.equ EVSYS_ASYNCUSER8_OFF_gc = (0x00<<0) ; Off\n.equ EVSYS_ASYNCUSER8_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_ASYNCUSER8_SYNCCH1_gc = (0x02<<0) ; Synchronous Event Channel 1\n.equ EVSYS_ASYNCUSER8_ASYNCCH0_gc = (0x03<<0) ; Asynchronous Event Channel 0\n.equ EVSYS_ASYNCUSER8_ASYNCCH1_gc = (0x04<<0) ; Asynchronous Event Channel 1\n.equ EVSYS_ASYNCUSER8_ASYNCCH2_gc = (0x05<<0) ; Asynchronous Event Channel 2\n.equ EVSYS_ASYNCUSER8_ASYNCCH3_gc = (0x06<<0) ; Asynchronous Event Channel 3\n\n; Asynchronous User Ch 9 Input Selection - Event Out 1 select\n.equ EVSYS_ASYNCUSER9_OFF_gc = (0x00<<0) ; Off\n.equ EVSYS_ASYNCUSER9_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_ASYNCUSER9_SYNCCH1_gc = (0x02<<0) ; Synchronous Event Channel 1\n.equ EVSYS_ASYNCUSER9_ASYNCCH0_gc = (0x03<<0) ; Asynchronous Event Channel 0\n.equ EVSYS_ASYNCUSER9_ASYNCCH1_gc = (0x04<<0) ; Asynchronous Event Channel 1\n.equ EVSYS_ASYNCUSER9_ASYNCCH2_gc = (0x05<<0) ; Asynchronous Event Channel 2\n.equ EVSYS_ASYNCUSER9_ASYNCCH3_gc = (0x06<<0) ; Asynchronous Event Channel 3\n\n; Asynchronous User Ch 10 Input Selection - Event Out 2 select\n.equ EVSYS_ASYNCUSER10_OFF_gc = (0x00<<0) ; Off\n.equ EVSYS_ASYNCUSER10_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_ASYNCUSER10_SYNCCH1_gc = (0x02<<0) ; Synchronous Event Channel 1\n.equ EVSYS_ASYNCUSER10_ASYNCCH0_gc = (0x03<<0) ; Asynchronous Event Channel 0\n.equ EVSYS_ASYNCUSER10_ASYNCCH1_gc = (0x04<<0) ; Asynchronous Event Channel 1\n.equ EVSYS_ASYNCUSER10_ASYNCCH2_gc = (0x05<<0) ; Asynchronous Event Channel 2\n.equ EVSYS_ASYNCUSER10_ASYNCCH3_gc = (0x06<<0) ; Asynchronous Event Channel 3\n\n; Synchronous Channel 0 Generator Selection select\n.equ EVSYS_SYNCCH0_OFF_gc = (0x00<<0)    ; Off\n.equ EVSYS_SYNCCH0_TCB0_gc = (0x01<<0)   ; Timer/Counter B0\n.equ EVSYS_SYNCCH0_TCA0_OVF_LUNF_gc = (0x02<<0) ; Timer/Counter A0 overflow\n.equ EVSYS_SYNCCH0_TCA0_HUNF_gc = (0x03<<0) ; Timer/Counter A0 underflow high byte (split mode)\n.equ EVSYS_SYNCCH0_TCA0_CMP0_gc = (0x04<<0) ; Timer/Counter A0 compare 0\n.equ EVSYS_SYNCCH0_TCA0_CMP1_gc = (0x05<<0) ; Timer/Counter A0 compare 1\n.equ EVSYS_SYNCCH0_TCA0_CMP2_gc = (0x06<<0) ; Timer/Counter A0 compare 2\n.equ EVSYS_SYNCCH0_PORTC_PIN0_gc = (0x07<<0) ; Synchronous Event from Pin PC0\n.equ EVSYS_SYNCCH0_PORTC_PIN1_gc = (0x08<<0) ; Synchronous Event from Pin PC1\n.equ EVSYS_SYNCCH0_PORTC_PIN2_gc = (0x09<<0) ; Synchronous Event from Pin PC2\n.equ EVSYS_SYNCCH0_PORTC_PIN3_gc = (0x0A<<0) ; Synchronous Event from Pin PC3\n.equ EVSYS_SYNCCH0_PORTC_PIN4_gc = (0x0B<<0) ; Synchronous Event from Pin PC4\n.equ EVSYS_SYNCCH0_PORTC_PIN5_gc = (0x0C<<0) ; Synchronous Event from Pin PC5\n.equ EVSYS_SYNCCH0_PORTA_PIN0_gc = (0x0D<<0) ; Synchronous Event from Pin PA0\n.equ EVSYS_SYNCCH0_PORTA_PIN1_gc = (0x0E<<0) ; Synchronous Event from Pin PA1\n.equ EVSYS_SYNCCH0_PORTA_PIN2_gc = (0x0F<<0) ; Synchronous Event from Pin PA2\n.equ EVSYS_SYNCCH0_PORTA_PIN3_gc = (0x10<<0) ; Synchronous Event from Pin PA3\n.equ EVSYS_SYNCCH0_PORTA_PIN4_gc = (0x11<<0) ; Synchronous Event from Pin PA4\n.equ EVSYS_SYNCCH0_PORTA_PIN5_gc = (0x12<<0) ; Synchronous Event from Pin PA5\n.equ EVSYS_SYNCCH0_PORTA_PIN6_gc = (0x13<<0) ; Synchronous Event from Pin PA6\n.equ EVSYS_SYNCCH0_PORTA_PIN7_gc = (0x14<<0) ; Synchronous Event from Pin PA7\n\n; Synchronous Channel 1 Generator Selection select\n.equ EVSYS_SYNCCH1_OFF_gc = (0x00<<0)    ; Off\n.equ EVSYS_SYNCCH1_TCB0_gc = (0x01<<0)   ; Timer/Counter B0\n.equ EVSYS_SYNCCH1_TCA0_OVF_LUNF_gc = (0x02<<0) ; Timer/Counter A0 overflow\n.equ EVSYS_SYNCCH1_TCA0_HUNF_gc = (0x03<<0) ; Timer/Counter A0 underflow high byte (split mode)\n.equ EVSYS_SYNCCH1_TCA0_CMP0_gc = (0x04<<0) ; Timer/Counter A0 compare 0\n.equ EVSYS_SYNCCH1_TCA0_CMP1_gc = (0x05<<0) ; Timer/Counter A0 compare 1\n.equ EVSYS_SYNCCH1_TCA0_CMP2_gc = (0x06<<0) ; Timer/Counter A0 compare 2\n.equ EVSYS_SYNCCH1_PORTB_PIN0_gc = (0x08<<0) ; Synchronous Event from Pin PB0\n.equ EVSYS_SYNCCH1_PORTB_PIN1_gc = (0x09<<0) ; Synchronous Event from Pin PB1\n.equ EVSYS_SYNCCH1_PORTB_PIN2_gc = (0x0A<<0) ; Synchronous Event from Pin PB2\n.equ EVSYS_SYNCCH1_PORTB_PIN3_gc = (0x0B<<0) ; Synchronous Event from Pin PB3\n.equ EVSYS_SYNCCH1_PORTB_PIN4_gc = (0x0C<<0) ; Synchronous Event from Pin PB4\n.equ EVSYS_SYNCCH1_PORTB_PIN5_gc = (0x0D<<0) ; Synchronous Event from Pin PB5\n.equ EVSYS_SYNCCH1_PORTB_PIN6_gc = (0x0E<<0) ; Synchronous Event from Pin PB6\n.equ EVSYS_SYNCCH1_PORTB_PIN7_gc = (0x0F<<0) ; Synchronous Event from Pin PB7\n\n; Synchronous User Ch 0 Input Selection - TCA0 select\n.equ EVSYS_SYNCUSER0_OFF_gc = (0x00<<0)  ; Off\n.equ EVSYS_SYNCUSER0_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_SYNCUSER0_SYNCCH1_gc = (0x02<<0) ; Synchronous Event Channel 1\n\n; Synchronous User Ch 1 Input Selection - USART0 select\n.equ EVSYS_SYNCUSER1_OFF_gc = (0x00<<0)  ; Off\n.equ EVSYS_SYNCUSER1_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_SYNCUSER1_SYNCCH1_gc = (0x02<<0) ; Synchronous Event Channel 1\n\n\n;*************************************************************************\n;** FUSE - Fuses\n;*************************************************************************\n\n; FUSE_BODCFG masks\n.equ FUSE_ACTIVE_gm = 0x0C               ; BOD Operation in Active Mode group mask\n.equ FUSE_ACTIVE_gp = 2                  ; BOD Operation in Active Mode group position\n.equ FUSE_ACTIVE0_bm = (1<<2)            ; BOD Operation in Active Mode bit 0 mask\n.equ FUSE_ACTIVE0_bp = 2                 ; BOD Operation in Active Mode bit 0 position\n.equ FUSE_ACTIVE1_bm = (1<<3)            ; BOD Operation in Active Mode bit 1 mask\n.equ FUSE_ACTIVE1_bp = 3                 ; BOD Operation in Active Mode bit 1 position\n.equ FUSE_LVL_gm = 0xE0                  ; BOD Level group mask\n.equ FUSE_LVL_gp = 5                     ; BOD Level group position\n.equ FUSE_LVL0_bm = (1<<5)               ; BOD Level bit 0 mask\n.equ FUSE_LVL0_bp = 5                    ; BOD Level bit 0 position\n.equ FUSE_LVL1_bm = (1<<6)               ; BOD Level bit 1 mask\n.equ FUSE_LVL1_bp = 6                    ; BOD Level bit 1 position\n.equ FUSE_LVL2_bm = (1<<7)               ; BOD Level bit 2 mask\n.equ FUSE_LVL2_bp = 7                    ; BOD Level bit 2 position\n.equ FUSE_SAMPFREQ_bm = 0x10             ; BOD Sample Frequency bit mask\n.equ FUSE_SAMPFREQ_bp = 4                ; BOD Sample Frequency bit position\n.equ FUSE_SLEEP_gm = 0x03                ; BOD Operation in Sleep Mode group mask\n.equ FUSE_SLEEP_gp = 0                   ; BOD Operation in Sleep Mode group position\n.equ FUSE_SLEEP0_bm = (1<<0)             ; BOD Operation in Sleep Mode bit 0 mask\n.equ FUSE_SLEEP0_bp = 0                  ; BOD Operation in Sleep Mode bit 0 position\n.equ FUSE_SLEEP1_bm = (1<<1)             ; BOD Operation in Sleep Mode bit 1 mask\n.equ FUSE_SLEEP1_bp = 1                  ; BOD Operation in Sleep Mode bit 1 position\n\n; FUSE_OSCCFG masks\n.equ FUSE_FREQSEL_gm = 0x03              ; Frequency Select group mask\n.equ FUSE_FREQSEL_gp = 0                 ; Frequency Select group position\n.equ FUSE_FREQSEL0_bm = (1<<0)           ; Frequency Select bit 0 mask\n.equ FUSE_FREQSEL0_bp = 0                ; Frequency Select bit 0 position\n.equ FUSE_FREQSEL1_bm = (1<<1)           ; Frequency Select bit 1 mask\n.equ FUSE_FREQSEL1_bp = 1                ; Frequency Select bit 1 position\n.equ FUSE_OSCLOCK_bm = 0x80              ; Oscillator Lock bit mask\n.equ FUSE_OSCLOCK_bp = 7                 ; Oscillator Lock bit position\n\n; FUSE_SYSCFG0 masks\n.equ FUSE_CRCSRC_gm = 0xC0               ; CRC Source group mask\n.equ FUSE_CRCSRC_gp = 6                  ; CRC Source group position\n.equ FUSE_CRCSRC0_bm = (1<<6)            ; CRC Source bit 0 mask\n.equ FUSE_CRCSRC0_bp = 6                 ; CRC Source bit 0 position\n.equ FUSE_CRCSRC1_bm = (1<<7)            ; CRC Source bit 1 mask\n.equ FUSE_CRCSRC1_bp = 7                 ; CRC Source bit 1 position\n.equ FUSE_EESAVE_bm = 0x01               ; EEPROM Save bit mask\n.equ FUSE_EESAVE_bp = 0                  ; EEPROM Save bit position\n.equ FUSE_RSTPINCFG_gm = 0x0C            ; Reset Pin Configuration group mask\n.equ FUSE_RSTPINCFG_gp = 2               ; Reset Pin Configuration group position\n.equ FUSE_RSTPINCFG0_bm = (1<<2)         ; Reset Pin Configuration bit 0 mask\n.equ FUSE_RSTPINCFG0_bp = 2              ; Reset Pin Configuration bit 0 position\n.equ FUSE_RSTPINCFG1_bm = (1<<3)         ; Reset Pin Configuration bit 1 mask\n.equ FUSE_RSTPINCFG1_bp = 3              ; Reset Pin Configuration bit 1 position\n\n; FUSE_SYSCFG1 masks\n.equ FUSE_SUT_gm = 0x07                  ; Startup Time group mask\n.equ FUSE_SUT_gp = 0                     ; Startup Time group position\n.equ FUSE_SUT0_bm = (1<<0)               ; Startup Time bit 0 mask\n.equ FUSE_SUT0_bp = 0                    ; Startup Time bit 0 position\n.equ FUSE_SUT1_bm = (1<<1)               ; Startup Time bit 1 mask\n.equ FUSE_SUT1_bp = 1                    ; Startup Time bit 1 position\n.equ FUSE_SUT2_bm = (1<<2)               ; Startup Time bit 2 mask\n.equ FUSE_SUT2_bp = 2                    ; Startup Time bit 2 position\n\n; FUSE_TCD0CFG masks\n.equ FUSE_CMPA_bm = 0x01                 ; Compare A Default Output Value bit mask\n.equ FUSE_CMPA_bp = 0                    ; Compare A Default Output Value bit position\n.equ FUSE_CMPAEN_bm = 0x10               ; Compare A Output Enable bit mask\n.equ FUSE_CMPAEN_bp = 4                  ; Compare A Output Enable bit position\n.equ FUSE_CMPB_bm = 0x02                 ; Compare B Default Output Value bit mask\n.equ FUSE_CMPB_bp = 1                    ; Compare B Default Output Value bit position\n.equ FUSE_CMPBEN_bm = 0x20               ; Compare B Output Enable bit mask\n.equ FUSE_CMPBEN_bp = 5                  ; Compare B Output Enable bit position\n.equ FUSE_CMPC_bm = 0x04                 ; Compare C Default Output Value bit mask\n.equ FUSE_CMPC_bp = 2                    ; Compare C Default Output Value bit position\n.equ FUSE_CMPCEN_bm = 0x40               ; Compare C Output Enable bit mask\n.equ FUSE_CMPCEN_bp = 6                  ; Compare C Output Enable bit position\n.equ FUSE_CMPD_bm = 0x08                 ; Compare D Default Output Value bit mask\n.equ FUSE_CMPD_bp = 3                    ; Compare D Default Output Value bit position\n.equ FUSE_CMPDEN_bm = 0x80               ; Compare D Output Enable bit mask\n.equ FUSE_CMPDEN_bp = 7                  ; Compare D Output Enable bit position\n\n; FUSE_WDTCFG masks\n.equ FUSE_PERIOD_gm = 0x0F               ; Watchdog Timeout Period group mask\n.equ FUSE_PERIOD_gp = 0                  ; Watchdog Timeout Period group position\n.equ FUSE_PERIOD0_bm = (1<<0)            ; Watchdog Timeout Period bit 0 mask\n.equ FUSE_PERIOD0_bp = 0                 ; Watchdog Timeout Period bit 0 position\n.equ FUSE_PERIOD1_bm = (1<<1)            ; Watchdog Timeout Period bit 1 mask\n.equ FUSE_PERIOD1_bp = 1                 ; Watchdog Timeout Period bit 1 position\n.equ FUSE_PERIOD2_bm = (1<<2)            ; Watchdog Timeout Period bit 2 mask\n.equ FUSE_PERIOD2_bp = 2                 ; Watchdog Timeout Period bit 2 position\n.equ FUSE_PERIOD3_bm = (1<<3)            ; Watchdog Timeout Period bit 3 mask\n.equ FUSE_PERIOD3_bp = 3                 ; Watchdog Timeout Period bit 3 position\n.equ FUSE_WINDOW_gm = 0xF0               ; Watchdog Window Timeout Period group mask\n.equ FUSE_WINDOW_gp = 4                  ; Watchdog Window Timeout Period group position\n.equ FUSE_WINDOW0_bm = (1<<4)            ; Watchdog Window Timeout Period bit 0 mask\n.equ FUSE_WINDOW0_bp = 4                 ; Watchdog Window Timeout Period bit 0 position\n.equ FUSE_WINDOW1_bm = (1<<5)            ; Watchdog Window Timeout Period bit 1 mask\n.equ FUSE_WINDOW1_bp = 5                 ; Watchdog Window Timeout Period bit 1 position\n.equ FUSE_WINDOW2_bm = (1<<6)            ; Watchdog Window Timeout Period bit 2 mask\n.equ FUSE_WINDOW2_bp = 6                 ; Watchdog Window Timeout Period bit 2 position\n.equ FUSE_WINDOW3_bm = (1<<7)            ; Watchdog Window Timeout Period bit 3 mask\n.equ FUSE_WINDOW3_bp = 7                 ; Watchdog Window Timeout Period bit 3 position\n\n; BOD Operation in Active Mode select\n.equ FUSE_ACTIVE_DIS_gc = (0x00<<2)      ; Disabled\n.equ FUSE_ACTIVE_ENABLED_gc = (0x01<<2)  ; Enabled\n.equ FUSE_ACTIVE_SAMPLED_gc = (0x02<<2)  ; Sampled\n.equ FUSE_ACTIVE_ENWAKE_gc = (0x03<<2)   ; Enabled with wake-up halted until BOD is ready\n\n; BOD Level select\n.equ FUSE_LVL_BODLEVEL0_gc = (0x00<<5)   ; 1.8 V\n.equ FUSE_LVL_BODLEVEL2_gc = (0x02<<5)   ; 2.6 V\n.equ FUSE_LVL_BODLEVEL7_gc = (0x07<<5)   ; 4.2 V\n\n; BOD Sample Frequency select\n.equ FUSE_SAMPFREQ_1KHz_gc = (0x00<<4)   ; 1kHz sampling frequency\n.equ FUSE_SAMPFREQ_125Hz_gc = (0x01<<4)  ; 125Hz sampling frequency\n\n; BOD Operation in Sleep Mode select\n.equ FUSE_SLEEP_DIS_gc = (0x00<<0)       ; Disabled\n.equ FUSE_SLEEP_ENABLED_gc = (0x01<<0)   ; Enabled\n.equ FUSE_SLEEP_SAMPLED_gc = (0x02<<0)   ; Sampled\n\n; Frequency Select select\n.equ FUSE_FREQSEL_16MHZ_gc = (0x01<<0)   ; 16 MHz\n.equ FUSE_FREQSEL_20MHZ_gc = (0x02<<0)   ; 20 MHz\n\n; CRC Source select\n.equ FUSE_CRCSRC_FLASH_gc = (0x00<<6)    ; The CRC is performed on the entire Flash (boot, application code and application data section).\n.equ FUSE_CRCSRC_BOOT_gc = (0x01<<6)     ; The CRC is performed on the boot section of Flash\n.equ FUSE_CRCSRC_BOOTAPP_gc = (0x02<<6)  ; The CRC is performed on the boot and application code section of Flash\n.equ FUSE_CRCSRC_NOCRC_gc = (0x03<<6)    ; Disable CRC.\n\n; Reset Pin Configuration select\n.equ FUSE_RSTPINCFG_GPIO_gc = (0x00<<2)  ; GPIO mode\n.equ FUSE_RSTPINCFG_UPDI_gc = (0x01<<2)  ; UPDI mode\n.equ FUSE_RSTPINCFG_RST_gc = (0x02<<2)   ; Reset mode\n\n; Startup Time select\n.equ FUSE_SUT_0MS_gc = (0x00<<0)         ; 0 ms\n.equ FUSE_SUT_1MS_gc = (0x01<<0)         ; 1 ms\n.equ FUSE_SUT_2MS_gc = (0x02<<0)         ; 2 ms\n.equ FUSE_SUT_4MS_gc = (0x03<<0)         ; 4 ms\n.equ FUSE_SUT_8MS_gc = (0x04<<0)         ; 8 ms\n.equ FUSE_SUT_16MS_gc = (0x05<<0)        ; 16 ms\n.equ FUSE_SUT_32MS_gc = (0x06<<0)        ; 32 ms\n.equ FUSE_SUT_64MS_gc = (0x07<<0)        ; 64 ms\n\n; Watchdog Timeout Period select\n.equ FUSE_PERIOD_OFF_gc = (0x00<<0)      ; Watch-Dog timer Off\n.equ FUSE_PERIOD_8CLK_gc = (0x01<<0)     ; 8 cycles (8ms)\n.equ FUSE_PERIOD_16CLK_gc = (0x02<<0)    ; 16 cycles (16ms)\n.equ FUSE_PERIOD_32CLK_gc = (0x03<<0)    ; 32 cycles (32ms)\n.equ FUSE_PERIOD_64CLK_gc = (0x04<<0)    ; 64 cycles (64ms)\n.equ FUSE_PERIOD_128CLK_gc = (0x05<<0)   ; 128 cycles (0.128s)\n.equ FUSE_PERIOD_256CLK_gc = (0x06<<0)   ; 256 cycles (0.256s)\n.equ FUSE_PERIOD_512CLK_gc = (0x07<<0)   ; 512 cycles (0.512s)\n.equ FUSE_PERIOD_1KCLK_gc = (0x08<<0)    ; 1K cycles (1.0s)\n.equ FUSE_PERIOD_2KCLK_gc = (0x09<<0)    ; 2K cycles (2.0s)\n.equ FUSE_PERIOD_4KCLK_gc = (0x0A<<0)    ; 4K cycles (4.1s)\n.equ FUSE_PERIOD_8KCLK_gc = (0x0B<<0)    ; 8K cycles (8.2s)\n\n; Watchdog Window Timeout Period select\n.equ FUSE_WINDOW_OFF_gc = (0x00<<4)      ; Window mode off\n.equ FUSE_WINDOW_8CLK_gc = (0x01<<4)     ; 8 cycles (8ms)\n.equ FUSE_WINDOW_16CLK_gc = (0x02<<4)    ; 16 cycles (16ms)\n.equ FUSE_WINDOW_32CLK_gc = (0x03<<4)    ; 32 cycles (32ms)\n.equ FUSE_WINDOW_64CLK_gc = (0x04<<4)    ; 64 cycles (64ms)\n.equ FUSE_WINDOW_128CLK_gc = (0x05<<4)   ; 128 cycles (0.128s)\n.equ FUSE_WINDOW_256CLK_gc = (0x06<<4)   ; 256 cycles (0.256s)\n.equ FUSE_WINDOW_512CLK_gc = (0x07<<4)   ; 512 cycles (0.512s)\n.equ FUSE_WINDOW_1KCLK_gc = (0x08<<4)    ; 1K cycles (1.0s)\n.equ FUSE_WINDOW_2KCLK_gc = (0x09<<4)    ; 2K cycles (2.0s)\n.equ FUSE_WINDOW_4KCLK_gc = (0x0A<<4)    ; 4K cycles (4.1s)\n.equ FUSE_WINDOW_8KCLK_gc = (0x0B<<4)    ; 8K cycles (8.2s)\n\n\n;*************************************************************************\n;** GPIO - General Purpose IO\n;*************************************************************************\n\n\n;*************************************************************************\n;** LOCKBIT - Lockbit\n;*************************************************************************\n\n; LOCKBIT_LOCKBIT masks\n.equ LOCKBIT_LB_gm = 0xFF                ; Lock Bits group mask\n.equ LOCKBIT_LB_gp = 0                   ; Lock Bits group position\n.equ LOCKBIT_LB0_bm = (1<<0)             ; Lock Bits bit 0 mask\n.equ LOCKBIT_LB0_bp = 0                  ; Lock Bits bit 0 position\n.equ LOCKBIT_LB1_bm = (1<<1)             ; Lock Bits bit 1 mask\n.equ LOCKBIT_LB1_bp = 1                  ; Lock Bits bit 1 position\n.equ LOCKBIT_LB2_bm = (1<<2)             ; Lock Bits bit 2 mask\n.equ LOCKBIT_LB2_bp = 2                  ; Lock Bits bit 2 position\n.equ LOCKBIT_LB3_bm = (1<<3)             ; Lock Bits bit 3 mask\n.equ LOCKBIT_LB3_bp = 3                  ; Lock Bits bit 3 position\n.equ LOCKBIT_LB4_bm = (1<<4)             ; Lock Bits bit 4 mask\n.equ LOCKBIT_LB4_bp = 4                  ; Lock Bits bit 4 position\n.equ LOCKBIT_LB5_bm = (1<<5)             ; Lock Bits bit 5 mask\n.equ LOCKBIT_LB5_bp = 5                  ; Lock Bits bit 5 position\n.equ LOCKBIT_LB6_bm = (1<<6)             ; Lock Bits bit 6 mask\n.equ LOCKBIT_LB6_bp = 6                  ; Lock Bits bit 6 position\n.equ LOCKBIT_LB7_bm = (1<<7)             ; Lock Bits bit 7 mask\n.equ LOCKBIT_LB7_bp = 7                  ; Lock Bits bit 7 position\n\n; Lock Bits select\n.equ LOCKBIT_LB_RWLOCK_gc = (0x3A<<0)    ; Read and write lock\n.equ LOCKBIT_LB_NOLOCK_gc = (0xC5<<0)    ; No locks\n\n\n;*************************************************************************\n;** NVMCTRL - Non-volatile Memory Controller\n;*************************************************************************\n\n; NVMCTRL_CTRLA masks\n.equ NVMCTRL_CMD_gm = 0x07               ; Command group mask\n.equ NVMCTRL_CMD_gp = 0                  ; Command group position\n.equ NVMCTRL_CMD0_bm = (1<<0)            ; Command bit 0 mask\n.equ NVMCTRL_CMD0_bp = 0                 ; Command bit 0 position\n.equ NVMCTRL_CMD1_bm = (1<<1)            ; Command bit 1 mask\n.equ NVMCTRL_CMD1_bp = 1                 ; Command bit 1 position\n.equ NVMCTRL_CMD2_bm = (1<<2)            ; Command bit 2 mask\n.equ NVMCTRL_CMD2_bp = 2                 ; Command bit 2 position\n\n; NVMCTRL_CTRLB masks\n.equ NVMCTRL_APCWP_bm = 0x01             ; Application code write protect bit mask\n.equ NVMCTRL_APCWP_bp = 0                ; Application code write protect bit position\n.equ NVMCTRL_BOOTLOCK_bm = 0x02          ; Boot Lock bit mask\n.equ NVMCTRL_BOOTLOCK_bp = 1             ; Boot Lock bit position\n\n; NVMCTRL_INTCTRL masks\n.equ NVMCTRL_EEREADY_bm = 0x01           ; EEPROM Ready bit mask\n.equ NVMCTRL_EEREADY_bp = 0              ; EEPROM Ready bit position\n\n; NVMCTRL_INTFLAGS masks\n; Masks for NVMCTRL_EEREADY already defined\n\n; NVMCTRL_STATUS masks\n.equ NVMCTRL_EEBUSY_bm = 0x02            ; EEPROM busy bit mask\n.equ NVMCTRL_EEBUSY_bp = 1               ; EEPROM busy bit position\n.equ NVMCTRL_FBUSY_bm = 0x01             ; Flash busy bit mask\n.equ NVMCTRL_FBUSY_bp = 0                ; Flash busy bit position\n.equ NVMCTRL_WRERROR_bm = 0x04           ; Write error bit mask\n.equ NVMCTRL_WRERROR_bp = 2              ; Write error bit position\n\n; Command select\n.equ NVMCTRL_CMD_NONE_gc = (0x00<<0)     ; No Command\n.equ NVMCTRL_CMD_PAGEWRITE_gc = (0x01<<0) ; Write page\n.equ NVMCTRL_CMD_PAGEERASE_gc = (0x02<<0) ; Erase page\n.equ NVMCTRL_CMD_PAGEERASEWRITE_gc = (0x03<<0) ; Erase and write page\n.equ NVMCTRL_CMD_PAGEBUFCLR_gc = (0x04<<0) ; Page buffer clear\n.equ NVMCTRL_CMD_CHIPERASE_gc = (0x05<<0) ; Chip erase\n.equ NVMCTRL_CMD_EEERASE_gc = (0x06<<0)  ; EEPROM erase\n.equ NVMCTRL_CMD_FUSEWRITE_gc = (0x07<<0) ; Write fuse (PDI only)\n\n\n;*************************************************************************\n;** PORT - I/O Ports\n;*************************************************************************\n\n; PORT_INTFLAGS masks\n.equ PORT_INT_gm = 0xFF                  ; Pin Interrupt group mask\n.equ PORT_INT_gp = 0                     ; Pin Interrupt group position\n.equ PORT_INT0_bm = (1<<0)               ; Pin Interrupt bit 0 mask\n.equ PORT_INT0_bp = 0                    ; Pin Interrupt bit 0 position\n.equ PORT_INT1_bm = (1<<1)               ; Pin Interrupt bit 1 mask\n.equ PORT_INT1_bp = 1                    ; Pin Interrupt bit 1 position\n.equ PORT_INT2_bm = (1<<2)               ; Pin Interrupt bit 2 mask\n.equ PORT_INT2_bp = 2                    ; Pin Interrupt bit 2 position\n.equ PORT_INT3_bm = (1<<3)               ; Pin Interrupt bit 3 mask\n.equ PORT_INT3_bp = 3                    ; Pin Interrupt bit 3 position\n.equ PORT_INT4_bm = (1<<4)               ; Pin Interrupt bit 4 mask\n.equ PORT_INT4_bp = 4                    ; Pin Interrupt bit 4 position\n.equ PORT_INT5_bm = (1<<5)               ; Pin Interrupt bit 5 mask\n.equ PORT_INT5_bp = 5                    ; Pin Interrupt bit 5 position\n.equ PORT_INT6_bm = (1<<6)               ; Pin Interrupt bit 6 mask\n.equ PORT_INT6_bp = 6                    ; Pin Interrupt bit 6 position\n.equ PORT_INT7_bm = (1<<7)               ; Pin Interrupt bit 7 mask\n.equ PORT_INT7_bp = 7                    ; Pin Interrupt bit 7 position\n\n; PORT_PIN0CTRL masks\n.equ PORT_INVEN_bm = 0x80                ; Inverted I/O Enable bit mask\n.equ PORT_INVEN_bp = 7                   ; Inverted I/O Enable bit position\n.equ PORT_ISC_gm = 0x07                  ; Input/Sense Configuration group mask\n.equ PORT_ISC_gp = 0                     ; Input/Sense Configuration group position\n.equ PORT_ISC0_bm = (1<<0)               ; Input/Sense Configuration bit 0 mask\n.equ PORT_ISC0_bp = 0                    ; Input/Sense Configuration bit 0 position\n.equ PORT_ISC1_bm = (1<<1)               ; Input/Sense Configuration bit 1 mask\n.equ PORT_ISC1_bp = 1                    ; Input/Sense Configuration bit 1 position\n.equ PORT_ISC2_bm = (1<<2)               ; Input/Sense Configuration bit 2 mask\n.equ PORT_ISC2_bp = 2                    ; Input/Sense Configuration bit 2 position\n.equ PORT_PULLUPEN_bm = 0x08             ; Pullup enable bit mask\n.equ PORT_PULLUPEN_bp = 3                ; Pullup enable bit position\n\n; PORT_PIN1CTRL masks\n; Masks for PORT_INVEN already defined\n; Masks for PORT_ISC already defined\n; Masks for PORT_PULLUPEN already defined\n\n; PORT_PIN2CTRL masks\n; Masks for PORT_INVEN already defined\n; Masks for PORT_ISC already defined\n; Masks for PORT_PULLUPEN already defined\n\n; PORT_PIN3CTRL masks\n; Masks for PORT_INVEN already defined\n; Masks for PORT_ISC already defined\n; Masks for PORT_PULLUPEN already defined\n\n; PORT_PIN4CTRL masks\n; Masks for PORT_INVEN already defined\n; Masks for PORT_ISC already defined\n; Masks for PORT_PULLUPEN already defined\n\n; PORT_PIN5CTRL masks\n; Masks for PORT_INVEN already defined\n; Masks for PORT_ISC already defined\n; Masks for PORT_PULLUPEN already defined\n\n; PORT_PIN6CTRL masks\n; Masks for PORT_INVEN already defined\n; Masks for PORT_ISC already defined\n; Masks for PORT_PULLUPEN already defined\n\n; PORT_PIN7CTRL masks\n; Masks for PORT_INVEN already defined\n; Masks for PORT_ISC already defined\n; Masks for PORT_PULLUPEN already defined\n\n; Input/Sense Configuration select\n.equ PORT_ISC_INTDISABLE_gc = (0x00<<0)  ; Interrupt disabled but input buffer enabled\n.equ PORT_ISC_BOTHEDGES_gc = (0x01<<0)   ; Sense Both Edges\n.equ PORT_ISC_RISING_gc = (0x02<<0)      ; Sense Rising Edge\n.equ PORT_ISC_FALLING_gc = (0x03<<0)     ; Sense Falling Edge\n.equ PORT_ISC_INPUT_DISABLE_gc = (0x04<<0) ; Digital Input Buffer disabled\n.equ PORT_ISC_LEVEL_gc = (0x05<<0)       ; Sense low Level\n\n\n;*************************************************************************\n;** PORTMUX - Port Multiplexer\n;*************************************************************************\n\n; PORTMUX_CTRLA masks\n.equ PORTMUX_EVOUT0_bm = 0x01            ; Event Output 0 bit mask\n.equ PORTMUX_EVOUT0_bp = 0               ; Event Output 0 bit position\n.equ PORTMUX_EVOUT1_bm = 0x02            ; Event Output 1 bit mask\n.equ PORTMUX_EVOUT1_bp = 1               ; Event Output 1 bit position\n.equ PORTMUX_EVOUT2_bm = 0x04            ; Event Output 2 bit mask\n.equ PORTMUX_EVOUT2_bp = 2               ; Event Output 2 bit position\n.equ PORTMUX_LUT0_bm = 0x10              ; Configurable Custom Logic LUT0 bit mask\n.equ PORTMUX_LUT0_bp = 4                 ; Configurable Custom Logic LUT0 bit position\n.equ PORTMUX_LUT1_bm = 0x20              ; Configurable Custom Logic LUT1 bit mask\n.equ PORTMUX_LUT1_bp = 5                 ; Configurable Custom Logic LUT1 bit position\n\n; PORTMUX_CTRLB masks\n.equ PORTMUX_SPI0_bm = 0x04              ; Port Multiplexer SPI0 bit mask\n.equ PORTMUX_SPI0_bp = 2                 ; Port Multiplexer SPI0 bit position\n.equ PORTMUX_USART0_bm = 0x01            ; Port Multiplexer USART0 bit mask\n.equ PORTMUX_USART0_bp = 0               ; Port Multiplexer USART0 bit position\n\n; PORTMUX_CTRLC masks\n.equ PORTMUX_TCA00_bm = 0x01             ; Port Multiplexer TCA0 Output 0 bit mask\n.equ PORTMUX_TCA00_bp = 0                ; Port Multiplexer TCA0 Output 0 bit position\n.equ PORTMUX_TCA01_bm = 0x02             ; Port Multiplexer TCA0 Output 1 bit mask\n.equ PORTMUX_TCA01_bp = 1                ; Port Multiplexer TCA0 Output 1 bit position\n.equ PORTMUX_TCA02_bm = 0x04             ; Port Multiplexer TCA0 Output 2 bit mask\n.equ PORTMUX_TCA02_bp = 2                ; Port Multiplexer TCA0 Output 2 bit position\n.equ PORTMUX_TCA03_bm = 0x08             ; Port Multiplexer TCA0 Output 3 bit mask\n.equ PORTMUX_TCA03_bp = 3                ; Port Multiplexer TCA0 Output 3 bit position\n\n; PORTMUX_CTRLD masks\n.equ PORTMUX_TCB0_bm = 0x01              ; Port Multiplexer TCB bit mask\n.equ PORTMUX_TCB0_bp = 0                 ; Port Multiplexer TCB bit position\n\n; Configurable Custom Logic LUT0 select\n.equ PORTMUX_LUT0_DEFAULT_gc = (0x00<<4) ; Default pin\n.equ PORTMUX_LUT0_ALTERNATE_gc = (0x01<<4) ; Alternate pin\n\n; Configurable Custom Logic LUT1 select\n.equ PORTMUX_LUT1_DEFAULT_gc = (0x00<<5) ; Default pin\n.equ PORTMUX_LUT1_ALTERNATE_gc = (0x01<<5) ; Alternate pin\n\n; Port Multiplexer SPI0 select\n.equ PORTMUX_SPI0_DEFAULT_gc = (0x00<<2) ; Default pins\n.equ PORTMUX_SPI0_ALTERNATE_gc = (0x01<<2) ; Alternate pins\n\n; Port Multiplexer USART0 select\n.equ PORTMUX_USART0_DEFAULT_gc = (0x00<<0) ; Default pins\n.equ PORTMUX_USART0_ALTERNATE_gc = (0x01<<0) ; Alternate pins\n\n; Port Multiplexer TCA0 Output 0 select\n.equ PORTMUX_TCA00_DEFAULT_gc = (0x00<<0) ; Default pin\n.equ PORTMUX_TCA00_ALTERNATE_gc = (0x01<<0) ; Alternate pin\n\n; Port Multiplexer TCA0 Output 1 select\n.equ PORTMUX_TCA01_DEFAULT_gc = (0x00<<1) ; Default pin\n.equ PORTMUX_TCA01_ALTERNATE_gc = (0x01<<1) ; Alternate pin\n\n; Port Multiplexer TCA0 Output 2 select\n.equ PORTMUX_TCA02_DEFAULT_gc = (0x00<<2) ; Default pin\n.equ PORTMUX_TCA02_ALTERNATE_gc = (0x01<<2) ; Alternate pin\n\n; Port Multiplexer TCA0 Output 3 select\n.equ PORTMUX_TCA03_DEFAULT_gc = (0x00<<3) ; Default pin\n.equ PORTMUX_TCA03_ALTERNATE_gc = (0x01<<3) ; Alternate pin\n\n; Port Multiplexer TCB select\n.equ PORTMUX_TCB0_DEFAULT_gc = (0x00<<0) ; Default pin\n.equ PORTMUX_TCB0_ALTERNATE_gc = (0x01<<0) ; Alternate pin\n\n\n;*************************************************************************\n;** RSTCTRL - Reset controller\n;*************************************************************************\n\n; RSTCTRL_RSTFR masks\n.equ RSTCTRL_BORF_bm = 0x02              ; Brown out detector Reset flag bit mask\n.equ RSTCTRL_BORF_bp = 1                 ; Brown out detector Reset flag bit position\n.equ RSTCTRL_EXTRF_bm = 0x04             ; External Reset flag bit mask\n.equ RSTCTRL_EXTRF_bp = 2                ; External Reset flag bit position\n.equ RSTCTRL_PORF_bm = 0x01              ; Power on Reset flag bit mask\n.equ RSTCTRL_PORF_bp = 0                 ; Power on Reset flag bit position\n.equ RSTCTRL_SWRF_bm = 0x10              ; Software Reset flag bit mask\n.equ RSTCTRL_SWRF_bp = 4                 ; Software Reset flag bit position\n.equ RSTCTRL_UPDIRF_bm = 0x20            ; UPDI Reset flag bit mask\n.equ RSTCTRL_UPDIRF_bp = 5               ; UPDI Reset flag bit position\n.equ RSTCTRL_WDRF_bm = 0x08              ; Watch dog Reset flag bit mask\n.equ RSTCTRL_WDRF_bp = 3                 ; Watch dog Reset flag bit position\n\n; RSTCTRL_SWRR masks\n.equ RSTCTRL_SWRE_bm = 0x01              ; Software reset enable bit mask\n.equ RSTCTRL_SWRE_bp = 0                 ; Software reset enable bit position\n\n\n;*************************************************************************\n;** RTC - Real-Time Counter\n;*************************************************************************\n\n; RTC_CLKSEL masks\n.equ RTC_CLKSEL_gm = 0x03                ; Clock Select group mask\n.equ RTC_CLKSEL_gp = 0                   ; Clock Select group position\n.equ RTC_CLKSEL0_bm = (1<<0)             ; Clock Select bit 0 mask\n.equ RTC_CLKSEL0_bp = 0                  ; Clock Select bit 0 position\n.equ RTC_CLKSEL1_bm = (1<<1)             ; Clock Select bit 1 mask\n.equ RTC_CLKSEL1_bp = 1                  ; Clock Select bit 1 position\n\n; RTC_CTRLA masks\n.equ RTC_PRESCALER_gm = 0x78             ; Prescaling Factor group mask\n.equ RTC_PRESCALER_gp = 3                ; Prescaling Factor group position\n.equ RTC_PRESCALER0_bm = (1<<3)          ; Prescaling Factor bit 0 mask\n.equ RTC_PRESCALER0_bp = 3               ; Prescaling Factor bit 0 position\n.equ RTC_PRESCALER1_bm = (1<<4)          ; Prescaling Factor bit 1 mask\n.equ RTC_PRESCALER1_bp = 4               ; Prescaling Factor bit 1 position\n.equ RTC_PRESCALER2_bm = (1<<5)          ; Prescaling Factor bit 2 mask\n.equ RTC_PRESCALER2_bp = 5               ; Prescaling Factor bit 2 position\n.equ RTC_PRESCALER3_bm = (1<<6)          ; Prescaling Factor bit 3 mask\n.equ RTC_PRESCALER3_bp = 6               ; Prescaling Factor bit 3 position\n.equ RTC_RTCEN_bm = 0x01                 ; Enable bit mask\n.equ RTC_RTCEN_bp = 0                    ; Enable bit position\n.equ RTC_RUNSTDBY_bm = 0x80              ; Run In Standby bit mask\n.equ RTC_RUNSTDBY_bp = 7                 ; Run In Standby bit position\n\n; RTC_DBGCTRL masks\n.equ RTC_DBGRUN_bm = 0x01                ; Run in debug bit mask\n.equ RTC_DBGRUN_bp = 0                   ; Run in debug bit position\n\n; RTC_INTCTRL masks\n.equ RTC_CMP_bm = 0x02                   ; Compare Match Interrupt enable bit mask\n.equ RTC_CMP_bp = 1                      ; Compare Match Interrupt enable bit position\n.equ RTC_OVF_bm = 0x01                   ; Overflow Interrupt enable bit mask\n.equ RTC_OVF_bp = 0                      ; Overflow Interrupt enable bit position\n\n; RTC_INTFLAGS masks\n; Masks for RTC_CMP already defined\n; Masks for RTC_OVF already defined\n\n; RTC_PITCTRLA masks\n.equ RTC_PERIOD_gm = 0x78                ; Period group mask\n.equ RTC_PERIOD_gp = 3                   ; Period group position\n.equ RTC_PERIOD0_bm = (1<<3)             ; Period bit 0 mask\n.equ RTC_PERIOD0_bp = 3                  ; Period bit 0 position\n.equ RTC_PERIOD1_bm = (1<<4)             ; Period bit 1 mask\n.equ RTC_PERIOD1_bp = 4                  ; Period bit 1 position\n.equ RTC_PERIOD2_bm = (1<<5)             ; Period bit 2 mask\n.equ RTC_PERIOD2_bp = 5                  ; Period bit 2 position\n.equ RTC_PERIOD3_bm = (1<<6)             ; Period bit 3 mask\n.equ RTC_PERIOD3_bp = 6                  ; Period bit 3 position\n.equ RTC_PITEN_bm = 0x01                 ; Enable bit mask\n.equ RTC_PITEN_bp = 0                    ; Enable bit position\n\n; RTC_PITDBGCTRL masks\n; Masks for RTC_DBGRUN already defined\n\n; RTC_PITINTCTRL masks\n.equ RTC_PI_bm = 0x01                    ; Periodic Interrupt bit mask\n.equ RTC_PI_bp = 0                       ; Periodic Interrupt bit position\n\n; RTC_PITINTFLAGS masks\n; Masks for RTC_PI already defined\n\n; RTC_PITSTATUS masks\n.equ RTC_CTRLBUSY_bm = 0x01              ; CTRLA Synchronization Busy Flag bit mask\n.equ RTC_CTRLBUSY_bp = 0                 ; CTRLA Synchronization Busy Flag bit position\n\n; RTC_STATUS masks\n.equ RTC_CMPBUSY_bm = 0x08               ; Comparator Synchronization Busy Flag bit mask\n.equ RTC_CMPBUSY_bp = 3                  ; Comparator Synchronization Busy Flag bit position\n.equ RTC_CNTBUSY_bm = 0x02               ; Count Synchronization Busy Flag bit mask\n.equ RTC_CNTBUSY_bp = 1                  ; Count Synchronization Busy Flag bit position\n.equ RTC_CTRLABUSY_bm = 0x01             ; CTRLA Synchronization Busy Flag bit mask\n.equ RTC_CTRLABUSY_bp = 0                ; CTRLA Synchronization Busy Flag bit position\n.equ RTC_PERBUSY_bm = 0x04               ; Period Synchronization Busy Flag bit mask\n.equ RTC_PERBUSY_bp = 2                  ; Period Synchronization Busy Flag bit position\n\n; Clock Select select\n.equ RTC_CLKSEL_INT32K_gc = (0x00<<0)    ; Internal 32kHz OSC\n.equ RTC_CLKSEL_INT1K_gc = (0x01<<0)     ; Internal 1kHz OSC\n.equ RTC_CLKSEL_TOSC32K_gc = (0x02<<0)   ; 32KHz Crystal OSC\n.equ RTC_CLKSEL_EXTCLK_gc = (0x03<<0)    ; External Clock\n\n; Prescaling Factor select\n.equ RTC_PRESCALER_DIV1_gc = (0x00<<3)   ; RTC Clock / 1\n.equ RTC_PRESCALER_DIV2_gc = (0x01<<3)   ; RTC Clock / 2\n.equ RTC_PRESCALER_DIV4_gc = (0x02<<3)   ; RTC Clock / 4\n.equ RTC_PRESCALER_DIV8_gc = (0x03<<3)   ; RTC Clock / 8\n.equ RTC_PRESCALER_DIV16_gc = (0x04<<3)  ; RTC Clock / 16\n.equ RTC_PRESCALER_DIV32_gc = (0x05<<3)  ; RTC Clock / 32\n.equ RTC_PRESCALER_DIV64_gc = (0x06<<3)  ; RTC Clock / 64\n.equ RTC_PRESCALER_DIV128_gc = (0x07<<3) ; RTC Clock / 128\n.equ RTC_PRESCALER_DIV256_gc = (0x08<<3) ; RTC Clock / 256\n.equ RTC_PRESCALER_DIV512_gc = (0x09<<3) ; RTC Clock / 512\n.equ RTC_PRESCALER_DIV1024_gc = (0x0A<<3) ; RTC Clock / 1024\n.equ RTC_PRESCALER_DIV2048_gc = (0x0B<<3) ; RTC Clock / 2048\n.equ RTC_PRESCALER_DIV4096_gc = (0x0C<<3) ; RTC Clock / 4096\n.equ RTC_PRESCALER_DIV8192_gc = (0x0D<<3) ; RTC Clock / 8192\n.equ RTC_PRESCALER_DIV16384_gc = (0x0E<<3) ; RTC Clock / 16384\n.equ RTC_PRESCALER_DIV32768_gc = (0x0F<<3) ; RTC Clock / 32768\n\n; Period select\n.equ RTC_PERIOD_OFF_gc = (0x00<<3)       ; Off\n.equ RTC_PERIOD_CYC4_gc = (0x01<<3)      ; RTC Clock Cycles 4\n.equ RTC_PERIOD_CYC8_gc = (0x02<<3)      ; RTC Clock Cycles 8\n.equ RTC_PERIOD_CYC16_gc = (0x03<<3)     ; RTC Clock Cycles 16\n.equ RTC_PERIOD_CYC32_gc = (0x04<<3)     ; RTC Clock Cycles 32\n.equ RTC_PERIOD_CYC64_gc = (0x05<<3)     ; RTC Clock Cycles 64\n.equ RTC_PERIOD_CYC128_gc = (0x06<<3)    ; RTC Clock Cycles 128\n.equ RTC_PERIOD_CYC256_gc = (0x07<<3)    ; RTC Clock Cycles 256\n.equ RTC_PERIOD_CYC512_gc = (0x08<<3)    ; RTC Clock Cycles 512\n.equ RTC_PERIOD_CYC1024_gc = (0x09<<3)   ; RTC Clock Cycles 1024\n.equ RTC_PERIOD_CYC2048_gc = (0x0A<<3)   ; RTC Clock Cycles 2048\n.equ RTC_PERIOD_CYC4096_gc = (0x0B<<3)   ; RTC Clock Cycles 4096\n.equ RTC_PERIOD_CYC8192_gc = (0x0C<<3)   ; RTC Clock Cycles 8192\n.equ RTC_PERIOD_CYC16384_gc = (0x0D<<3)  ; RTC Clock Cycles 16384\n.equ RTC_PERIOD_CYC32768_gc = (0x0E<<3)  ; RTC Clock Cycles 32768\n\n\n;*************************************************************************\n;** SIGROW - Signature row\n;*************************************************************************\n\n\n;*************************************************************************\n;** SLPCTRL - Sleep Controller\n;*************************************************************************\n\n; SLPCTRL_CTRLA masks\n.equ SLPCTRL_SEN_bm = 0x01               ; Sleep enable bit mask\n.equ SLPCTRL_SEN_bp = 0                  ; Sleep enable bit position\n.equ SLPCTRL_SMODE_gm = 0x06             ; Sleep mode group mask\n.equ SLPCTRL_SMODE_gp = 1                ; Sleep mode group position\n.equ SLPCTRL_SMODE0_bm = (1<<1)          ; Sleep mode bit 0 mask\n.equ SLPCTRL_SMODE0_bp = 1               ; Sleep mode bit 0 position\n.equ SLPCTRL_SMODE1_bm = (1<<2)          ; Sleep mode bit 1 mask\n.equ SLPCTRL_SMODE1_bp = 2               ; Sleep mode bit 1 position\n\n; Sleep mode select\n.equ SLPCTRL_SMODE_IDLE_gc = (0x00<<1)   ; Idle mode\n.equ SLPCTRL_SMODE_STDBY_gc = (0x01<<1)  ; Standby Mode\n.equ SLPCTRL_SMODE_PDOWN_gc = (0x02<<1)  ; Power-down Mode\n\n\n;*************************************************************************\n;** SPI - Serial Peripheral Interface\n;*************************************************************************\n\n; SPI_CTRLA masks\n.equ SPI_CLK2X_bm = 0x10                 ; Enable Double Speed bit mask\n.equ SPI_CLK2X_bp = 4                    ; Enable Double Speed bit position\n.equ SPI_DORD_bm = 0x40                  ; Data Order Setting bit mask\n.equ SPI_DORD_bp = 6                     ; Data Order Setting bit position\n.equ SPI_ENABLE_bm = 0x01                ; Enable Module bit mask\n.equ SPI_ENABLE_bp = 0                   ; Enable Module bit position\n.equ SPI_MASTER_bm = 0x20                ; Master Operation Enable bit mask\n.equ SPI_MASTER_bp = 5                   ; Master Operation Enable bit position\n.equ SPI_PRESC_gm = 0x06                 ; Prescaler group mask\n.equ SPI_PRESC_gp = 1                    ; Prescaler group position\n.equ SPI_PRESC0_bm = (1<<1)              ; Prescaler bit 0 mask\n.equ SPI_PRESC0_bp = 1                   ; Prescaler bit 0 position\n.equ SPI_PRESC1_bm = (1<<2)              ; Prescaler bit 1 mask\n.equ SPI_PRESC1_bp = 2                   ; Prescaler bit 1 position\n\n; SPI_CTRLB masks\n.equ SPI_BUFEN_bm = 0x80                 ; Buffer Mode Enable bit mask\n.equ SPI_BUFEN_bp = 7                    ; Buffer Mode Enable bit position\n.equ SPI_BUFWR_bm = 0x40                 ; Buffer Write Mode bit mask\n.equ SPI_BUFWR_bp = 6                    ; Buffer Write Mode bit position\n.equ SPI_MODE_gm = 0x03                  ; SPI Mode group mask\n.equ SPI_MODE_gp = 0                     ; SPI Mode group position\n.equ SPI_MODE0_bm = (1<<0)               ; SPI Mode bit 0 mask\n.equ SPI_MODE0_bp = 0                    ; SPI Mode bit 0 position\n.equ SPI_MODE1_bm = (1<<1)               ; SPI Mode bit 1 mask\n.equ SPI_MODE1_bp = 1                    ; SPI Mode bit 1 position\n.equ SPI_SSD_bm = 0x04                   ; Slave Select Disable bit mask\n.equ SPI_SSD_bp = 2                      ; Slave Select Disable bit position\n\n; SPI_INTCTRL masks\n.equ SPI_DREIE_bm = 0x20                 ; Data Register Empty Interrupt Enable bit mask\n.equ SPI_DREIE_bp = 5                    ; Data Register Empty Interrupt Enable bit position\n.equ SPI_IE_bm = 0x01                    ; Interrupt Enable bit mask\n.equ SPI_IE_bp = 0                       ; Interrupt Enable bit position\n.equ SPI_RXCIE_bm = 0x80                 ; Receive Complete Interrupt Enable bit mask\n.equ SPI_RXCIE_bp = 7                    ; Receive Complete Interrupt Enable bit position\n.equ SPI_SSIE_bm = 0x10                  ; Slave Select Trigger Interrupt Enable bit mask\n.equ SPI_SSIE_bp = 4                     ; Slave Select Trigger Interrupt Enable bit position\n.equ SPI_TXCIE_bm = 0x40                 ; Transfer Complete Interrupt Enable bit mask\n.equ SPI_TXCIE_bp = 6                    ; Transfer Complete Interrupt Enable bit position\n\n; SPI_INTFLAGS masks\n.equ SPI_BUFOVF_bm = 0x01                ; Buffer Overflow bit mask\n.equ SPI_BUFOVF_bp = 0                   ; Buffer Overflow bit position\n.equ SPI_DREIF_bm = 0x20                 ; Data Register Empty Interrupt Flag bit mask\n.equ SPI_DREIF_bp = 5                    ; Data Register Empty Interrupt Flag bit position\n.equ SPI_RXCIF_bm = 0x80                 ; Receive Complete Interrupt Flag bit mask\n.equ SPI_RXCIF_bp = 7                    ; Receive Complete Interrupt Flag bit position\n.equ SPI_SSIF_bm = 0x10                  ; Slave Select Trigger Interrupt Flag bit mask\n.equ SPI_SSIF_bp = 4                     ; Slave Select Trigger Interrupt Flag bit position\n.equ SPI_TXCIF_bm = 0x40                 ; Transfer Complete Interrupt Flag bit mask\n.equ SPI_TXCIF_bp = 6                    ; Transfer Complete Interrupt Flag bit position\n.equ SPI_IF_bm = 0x80                    ; Interrupt Flag bit mask\n.equ SPI_IF_bp = 7                       ; Interrupt Flag bit position\n.equ SPI_WRCOL_bm = 0x40                 ; Write Collision bit mask\n.equ SPI_WRCOL_bp = 6                    ; Write Collision bit position\n\n; Prescaler select\n.equ SPI_PRESC_DIV4_gc = (0x00<<1)       ; System Clock / 4\n.equ SPI_PRESC_DIV16_gc = (0x01<<1)      ; System Clock / 16\n.equ SPI_PRESC_DIV64_gc = (0x02<<1)      ; System Clock / 64\n.equ SPI_PRESC_DIV128_gc = (0x03<<1)     ; System Clock / 128\n\n; SPI Mode select\n.equ SPI_MODE_0_gc = (0x00<<0)           ; SPI Mode 0\n.equ SPI_MODE_1_gc = (0x01<<0)           ; SPI Mode 1\n.equ SPI_MODE_2_gc = (0x02<<0)           ; SPI Mode 2\n.equ SPI_MODE_3_gc = (0x03<<0)           ; SPI Mode 3\n\n\n;*************************************************************************\n;** SYSCFG - System Configuration Registers\n;*************************************************************************\n\n; SYSCFG_EXTBRK masks\n.equ SYSCFG_ENEXTBRK_bm = 0x01           ; External break enable bit mask\n.equ SYSCFG_ENEXTBRK_bp = 0              ; External break enable bit position\n\n\n;*************************************************************************\n;** TCA - 16-bit Timer/Counter Type A\n;*************************************************************************\n\n; TCA_SINGLE_CTRLA masks\n.equ TCA_SINGLE_CLKSEL_gm = 0x0E         ; Clock Selection group mask\n.equ TCA_SINGLE_CLKSEL_gp = 1            ; Clock Selection group position\n.equ TCA_SINGLE_CLKSEL0_bm = (1<<1)      ; Clock Selection bit 0 mask\n.equ TCA_SINGLE_CLKSEL0_bp = 1           ; Clock Selection bit 0 position\n.equ TCA_SINGLE_CLKSEL1_bm = (1<<2)      ; Clock Selection bit 1 mask\n.equ TCA_SINGLE_CLKSEL1_bp = 2           ; Clock Selection bit 1 position\n.equ TCA_SINGLE_CLKSEL2_bm = (1<<3)      ; Clock Selection bit 2 mask\n.equ TCA_SINGLE_CLKSEL2_bp = 3           ; Clock Selection bit 2 position\n.equ TCA_SINGLE_ENABLE_bm = 0x01         ; Module Enable bit mask\n.equ TCA_SINGLE_ENABLE_bp = 0            ; Module Enable bit position\n\n; TCA_SINGLE_CTRLB masks\n.equ TCA_SINGLE_ALUPD_bm = 0x08          ; Auto Lock Update bit mask\n.equ TCA_SINGLE_ALUPD_bp = 3             ; Auto Lock Update bit position\n.equ TCA_SINGLE_CMP0EN_bm = 0x10         ; Compare 0 Enable bit mask\n.equ TCA_SINGLE_CMP0EN_bp = 4            ; Compare 0 Enable bit position\n.equ TCA_SINGLE_CMP1EN_bm = 0x20         ; Compare 1 Enable bit mask\n.equ TCA_SINGLE_CMP1EN_bp = 5            ; Compare 1 Enable bit position\n.equ TCA_SINGLE_CMP2EN_bm = 0x40         ; Compare 2 Enable bit mask\n.equ TCA_SINGLE_CMP2EN_bp = 6            ; Compare 2 Enable bit position\n.equ TCA_SINGLE_WGMODE_gm = 0x07         ; Waveform generation mode group mask\n.equ TCA_SINGLE_WGMODE_gp = 0            ; Waveform generation mode group position\n.equ TCA_SINGLE_WGMODE0_bm = (1<<0)      ; Waveform generation mode bit 0 mask\n.equ TCA_SINGLE_WGMODE0_bp = 0           ; Waveform generation mode bit 0 position\n.equ TCA_SINGLE_WGMODE1_bm = (1<<1)      ; Waveform generation mode bit 1 mask\n.equ TCA_SINGLE_WGMODE1_bp = 1           ; Waveform generation mode bit 1 position\n.equ TCA_SINGLE_WGMODE2_bm = (1<<2)      ; Waveform generation mode bit 2 mask\n.equ TCA_SINGLE_WGMODE2_bp = 2           ; Waveform generation mode bit 2 position\n\n; TCA_SINGLE_CTRLC masks\n.equ TCA_SINGLE_CMP0OV_bm = 0x01         ; Compare 0 Waveform Output Value bit mask\n.equ TCA_SINGLE_CMP0OV_bp = 0            ; Compare 0 Waveform Output Value bit position\n.equ TCA_SINGLE_CMP1OV_bm = 0x02         ; Compare 1 Waveform Output Value bit mask\n.equ TCA_SINGLE_CMP1OV_bp = 1            ; Compare 1 Waveform Output Value bit position\n.equ TCA_SINGLE_CMP2OV_bm = 0x04         ; Compare 2 Waveform Output Value bit mask\n.equ TCA_SINGLE_CMP2OV_bp = 2            ; Compare 2 Waveform Output Value bit position\n\n; TCA_SINGLE_CTRLD masks\n.equ TCA_SINGLE_SPLITM_bm = 0x01         ; Split Mode Enable bit mask\n.equ TCA_SINGLE_SPLITM_bp = 0            ; Split Mode Enable bit position\n\n; TCA_SINGLE_CTRLECLR masks\n.equ TCA_SINGLE_CMD_gm = 0x0C            ; Command group mask\n.equ TCA_SINGLE_CMD_gp = 2               ; Command group position\n.equ TCA_SINGLE_CMD0_bm = (1<<2)         ; Command bit 0 mask\n.equ TCA_SINGLE_CMD0_bp = 2              ; Command bit 0 position\n.equ TCA_SINGLE_CMD1_bm = (1<<3)         ; Command bit 1 mask\n.equ TCA_SINGLE_CMD1_bp = 3              ; Command bit 1 position\n.equ TCA_SINGLE_DIR_bm = 0x01            ; Direction bit mask\n.equ TCA_SINGLE_DIR_bp = 0               ; Direction bit position\n.equ TCA_SINGLE_LUPD_bm = 0x02           ; Lock Update bit mask\n.equ TCA_SINGLE_LUPD_bp = 1              ; Lock Update bit position\n\n; TCA_SINGLE_CTRLESET masks\n; Masks for TCA_SINGLE_CMD already defined\n; Masks for TCA_SINGLE_DIR already defined\n; Masks for TCA_SINGLE_LUPD already defined\n\n; TCA_SINGLE_CTRLFCLR masks\n.equ TCA_SINGLE_CMP0BV_bm = 0x02         ; Compare 0 Buffer Valid bit mask\n.equ TCA_SINGLE_CMP0BV_bp = 1            ; Compare 0 Buffer Valid bit position\n.equ TCA_SINGLE_CMP1BV_bm = 0x04         ; Compare 1 Buffer Valid bit mask\n.equ TCA_SINGLE_CMP1BV_bp = 2            ; Compare 1 Buffer Valid bit position\n.equ TCA_SINGLE_CMP2BV_bm = 0x08         ; Compare 2 Buffer Valid bit mask\n.equ TCA_SINGLE_CMP2BV_bp = 3            ; Compare 2 Buffer Valid bit position\n.equ TCA_SINGLE_PERBV_bm = 0x01          ; Period Buffer Valid bit mask\n.equ TCA_SINGLE_PERBV_bp = 0             ; Period Buffer Valid bit position\n\n; TCA_SINGLE_CTRLFSET masks\n; Masks for TCA_SINGLE_CMP0BV already defined\n; Masks for TCA_SINGLE_CMP1BV already defined\n; Masks for TCA_SINGLE_CMP2BV already defined\n; Masks for TCA_SINGLE_PERBV already defined\n\n; TCA_SINGLE_DBGCTRL masks\n.equ TCA_SINGLE_DBGRUN_bm = 0x01         ; Debug Run bit mask\n.equ TCA_SINGLE_DBGRUN_bp = 0            ; Debug Run bit position\n\n; TCA_SINGLE_EVCTRL masks\n.equ TCA_SINGLE_CNTEI_bm = 0x01          ; Count on Event Input bit mask\n.equ TCA_SINGLE_CNTEI_bp = 0             ; Count on Event Input bit position\n.equ TCA_SINGLE_EVACT_gm = 0x06          ; Event Action group mask\n.equ TCA_SINGLE_EVACT_gp = 1             ; Event Action group position\n.equ TCA_SINGLE_EVACT0_bm = (1<<1)       ; Event Action bit 0 mask\n.equ TCA_SINGLE_EVACT0_bp = 1            ; Event Action bit 0 position\n.equ TCA_SINGLE_EVACT1_bm = (1<<2)       ; Event Action bit 1 mask\n.equ TCA_SINGLE_EVACT1_bp = 2            ; Event Action bit 1 position\n\n; TCA_SINGLE_INTCTRL masks\n.equ TCA_SINGLE_CMP0_bm = 0x10           ; Compare 0 Interrupt bit mask\n.equ TCA_SINGLE_CMP0_bp = 4              ; Compare 0 Interrupt bit position\n.equ TCA_SINGLE_CMP1_bm = 0x20           ; Compare 1 Interrupt bit mask\n.equ TCA_SINGLE_CMP1_bp = 5              ; Compare 1 Interrupt bit position\n.equ TCA_SINGLE_CMP2_bm = 0x40           ; Compare 2 Interrupt bit mask\n.equ TCA_SINGLE_CMP2_bp = 6              ; Compare 2 Interrupt bit position\n.equ TCA_SINGLE_OVF_bm = 0x01            ; Overflow Interrupt bit mask\n.equ TCA_SINGLE_OVF_bp = 0               ; Overflow Interrupt bit position\n\n; TCA_SINGLE_INTFLAGS masks\n; Masks for TCA_SINGLE_CMP0 already defined\n; Masks for TCA_SINGLE_CMP1 already defined\n; Masks for TCA_SINGLE_CMP2 already defined\n; Masks for TCA_SINGLE_OVF already defined\n\n; TCA_SPLIT_CTRLA masks\n.equ TCA_SPLIT_CLKSEL_gm = 0x0E          ; Clock Selection group mask\n.equ TCA_SPLIT_CLKSEL_gp = 1             ; Clock Selection group position\n.equ TCA_SPLIT_CLKSEL0_bm = (1<<1)       ; Clock Selection bit 0 mask\n.equ TCA_SPLIT_CLKSEL0_bp = 1            ; Clock Selection bit 0 position\n.equ TCA_SPLIT_CLKSEL1_bm = (1<<2)       ; Clock Selection bit 1 mask\n.equ TCA_SPLIT_CLKSEL1_bp = 2            ; Clock Selection bit 1 position\n.equ TCA_SPLIT_CLKSEL2_bm = (1<<3)       ; Clock Selection bit 2 mask\n.equ TCA_SPLIT_CLKSEL2_bp = 3            ; Clock Selection bit 2 position\n.equ TCA_SPLIT_ENABLE_bm = 0x01          ; Module Enable bit mask\n.equ TCA_SPLIT_ENABLE_bp = 0             ; Module Enable bit position\n\n; TCA_SPLIT_CTRLB masks\n.equ TCA_SPLIT_HCMP0EN_bm = 0x10         ; High Compare 0 Enable bit mask\n.equ TCA_SPLIT_HCMP0EN_bp = 4            ; High Compare 0 Enable bit position\n.equ TCA_SPLIT_HCMP1EN_bm = 0x20         ; High Compare 1 Enable bit mask\n.equ TCA_SPLIT_HCMP1EN_bp = 5            ; High Compare 1 Enable bit position\n.equ TCA_SPLIT_HCMP2EN_bm = 0x40         ; High Compare 2 Enable bit mask\n.equ TCA_SPLIT_HCMP2EN_bp = 6            ; High Compare 2 Enable bit position\n.equ TCA_SPLIT_LCMP0EN_bm = 0x01         ; Low Compare 0 Enable bit mask\n.equ TCA_SPLIT_LCMP0EN_bp = 0            ; Low Compare 0 Enable bit position\n.equ TCA_SPLIT_LCMP1EN_bm = 0x02         ; Low Compare 1 Enable bit mask\n.equ TCA_SPLIT_LCMP1EN_bp = 1            ; Low Compare 1 Enable bit position\n.equ TCA_SPLIT_LCMP2EN_bm = 0x04         ; Low Compare 2 Enable bit mask\n.equ TCA_SPLIT_LCMP2EN_bp = 2            ; Low Compare 2 Enable bit position\n\n; TCA_SPLIT_CTRLC masks\n.equ TCA_SPLIT_HCMP0OV_bm = 0x10         ; High Compare 0 Output Value bit mask\n.equ TCA_SPLIT_HCMP0OV_bp = 4            ; High Compare 0 Output Value bit position\n.equ TCA_SPLIT_HCMP1OV_bm = 0x20         ; High Compare 1 Output Value bit mask\n.equ TCA_SPLIT_HCMP1OV_bp = 5            ; High Compare 1 Output Value bit position\n.equ TCA_SPLIT_HCMP2OV_bm = 0x40         ; High Compare 2 Output Value bit mask\n.equ TCA_SPLIT_HCMP2OV_bp = 6            ; High Compare 2 Output Value bit position\n.equ TCA_SPLIT_LCMP0OV_bm = 0x01         ; Low Compare 0 Output Value bit mask\n.equ TCA_SPLIT_LCMP0OV_bp = 0            ; Low Compare 0 Output Value bit position\n.equ TCA_SPLIT_LCMP1OV_bm = 0x02         ; Low Compare 1 Output Value bit mask\n.equ TCA_SPLIT_LCMP1OV_bp = 1            ; Low Compare 1 Output Value bit position\n.equ TCA_SPLIT_LCMP2OV_bm = 0x04         ; Low Compare 2 Output Value bit mask\n.equ TCA_SPLIT_LCMP2OV_bp = 2            ; Low Compare 2 Output Value bit position\n\n; TCA_SPLIT_CTRLD masks\n.equ TCA_SPLIT_SPLITM_bm = 0x01          ; Split Mode Enable bit mask\n.equ TCA_SPLIT_SPLITM_bp = 0             ; Split Mode Enable bit position\n\n; TCA_SPLIT_CTRLECLR masks\n.equ TCA_SPLIT_CMD_gm = 0x0C             ; Command group mask\n.equ TCA_SPLIT_CMD_gp = 2                ; Command group position\n.equ TCA_SPLIT_CMD0_bm = (1<<2)          ; Command bit 0 mask\n.equ TCA_SPLIT_CMD0_bp = 2               ; Command bit 0 position\n.equ TCA_SPLIT_CMD1_bm = (1<<3)          ; Command bit 1 mask\n.equ TCA_SPLIT_CMD1_bp = 3               ; Command bit 1 position\n\n; TCA_SPLIT_CTRLESET masks\n; Masks for TCA_SPLIT_CMD already defined\n\n; TCA_SPLIT_DBGCTRL masks\n.equ TCA_SPLIT_DBGRUN_bm = 0x01          ; Debug Run bit mask\n.equ TCA_SPLIT_DBGRUN_bp = 0             ; Debug Run bit position\n\n; TCA_SPLIT_INTCTRL masks\n.equ TCA_SPLIT_HUNF_bm = 0x02            ; High Underflow Interrupt Enable bit mask\n.equ TCA_SPLIT_HUNF_bp = 1               ; High Underflow Interrupt Enable bit position\n.equ TCA_SPLIT_LCMP0_bm = 0x10           ; Low Compare 0 Interrupt Enable bit mask\n.equ TCA_SPLIT_LCMP0_bp = 4              ; Low Compare 0 Interrupt Enable bit position\n.equ TCA_SPLIT_LCMP1_bm = 0x20           ; Low Compare 1 Interrupt Enable bit mask\n.equ TCA_SPLIT_LCMP1_bp = 5              ; Low Compare 1 Interrupt Enable bit position\n.equ TCA_SPLIT_LCMP2_bm = 0x40           ; Low Compare 2 Interrupt Enable bit mask\n.equ TCA_SPLIT_LCMP2_bp = 6              ; Low Compare 2 Interrupt Enable bit position\n.equ TCA_SPLIT_LUNF_bm = 0x01            ; Low Underflow Interrupt Enable bit mask\n.equ TCA_SPLIT_LUNF_bp = 0               ; Low Underflow Interrupt Enable bit position\n\n; TCA_SPLIT_INTFLAGS masks\n; Masks for TCA_SPLIT_HUNF already defined\n; Masks for TCA_SPLIT_LCMP0 already defined\n; Masks for TCA_SPLIT_LCMP1 already defined\n; Masks for TCA_SPLIT_LCMP2 already defined\n; Masks for TCA_SPLIT_LUNF already defined\n\n; Clock Selection select\n.equ TCA_SINGLE_CLKSEL_DIV1_gc = (0x00<<1) ; System Clock\n.equ TCA_SINGLE_CLKSEL_DIV2_gc = (0x01<<1) ; System Clock / 2\n.equ TCA_SINGLE_CLKSEL_DIV4_gc = (0x02<<1) ; System Clock / 4\n.equ TCA_SINGLE_CLKSEL_DIV8_gc = (0x03<<1) ; System Clock / 8\n.equ TCA_SINGLE_CLKSEL_DIV16_gc = (0x04<<1) ; System Clock / 16\n.equ TCA_SINGLE_CLKSEL_DIV64_gc = (0x05<<1) ; System Clock / 64\n.equ TCA_SINGLE_CLKSEL_DIV256_gc = (0x06<<1) ; System Clock / 256\n.equ TCA_SINGLE_CLKSEL_DIV1024_gc = (0x07<<1) ; System Clock / 1024\n\n; Waveform generation mode select\n.equ TCA_SINGLE_WGMODE_NORMAL_gc = (0x00<<0) ; Normal Mode\n.equ TCA_SINGLE_WGMODE_FRQ_gc = (0x01<<0) ; Frequency Generation Mode\n.equ TCA_SINGLE_WGMODE_SINGLESLOPE_gc = (0x03<<0) ; Single Slope PWM\n.equ TCA_SINGLE_WGMODE_DSTOP_gc = (0x05<<0) ; Dual Slope PWM, overflow on TOP\n.equ TCA_SINGLE_WGMODE_DSBOTH_gc = (0x06<<0) ; Dual Slope PWM, overflow on TOP and BOTTOM\n.equ TCA_SINGLE_WGMODE_DSBOTTOM_gc = (0x07<<0) ; Dual Slope PWM, overflow on BOTTOM\n\n; Command select\n.equ TCA_SINGLE_CMD_NONE_gc = (0x00<<2)  ; No Command\n.equ TCA_SINGLE_CMD_UPDATE_gc = (0x01<<2) ; Force Update\n.equ TCA_SINGLE_CMD_RESTART_gc = (0x02<<2) ; Force Restart\n.equ TCA_SINGLE_CMD_RESET_gc = (0x03<<2) ; Force Hard Reset\n\n; Direction select\n.equ TCA_SINGLE_DIR_UP_gc = (0x00<<0)    ; Count up\n.equ TCA_SINGLE_DIR_DOWN_gc = (0x01<<0)  ; Count down\n\n; Event Action select\n.equ TCA_SINGLE_EVACT_POSEDGE_gc = (0x00<<1) ; Count on positive edge event\n.equ TCA_SINGLE_EVACT_ANYEDGE_gc = (0x01<<1) ; Count on any edge event\n.equ TCA_SINGLE_EVACT_HIGHLVL_gc = (0x02<<1) ; Count on prescaled clock while event line is 1.\n.equ TCA_SINGLE_EVACT_UPDOWN_gc = (0x03<<1) ; Count on prescaled clock. Event controls count direction. Up-count when event line is 0, down-count when event line is 1.\n\n; Clock Selection select\n.equ TCA_SPLIT_CLKSEL_DIV1_gc = (0x00<<1) ; System Clock\n.equ TCA_SPLIT_CLKSEL_DIV2_gc = (0x01<<1) ; System Clock / 2\n.equ TCA_SPLIT_CLKSEL_DIV4_gc = (0x02<<1) ; System Clock / 4\n.equ TCA_SPLIT_CLKSEL_DIV8_gc = (0x03<<1) ; System Clock / 8\n.equ TCA_SPLIT_CLKSEL_DIV16_gc = (0x04<<1) ; System Clock / 16\n.equ TCA_SPLIT_CLKSEL_DIV64_gc = (0x05<<1) ; System Clock / 64\n.equ TCA_SPLIT_CLKSEL_DIV256_gc = (0x06<<1) ; System Clock / 256\n.equ TCA_SPLIT_CLKSEL_DIV1024_gc = (0x07<<1) ; System Clock / 1024\n\n; Command select\n.equ TCA_SPLIT_CMD_NONE_gc = (0x00<<2)   ; No Command\n.equ TCA_SPLIT_CMD_UPDATE_gc = (0x01<<2) ; Force Update\n.equ TCA_SPLIT_CMD_RESTART_gc = (0x02<<2) ; Force Restart\n.equ TCA_SPLIT_CMD_RESET_gc = (0x03<<2)  ; Force Hard Reset\n\n\n;*************************************************************************\n;** TCB - 16-bit Timer Type B\n;*************************************************************************\n\n; TCB_CTRLA masks\n.equ TCB_CLKSEL_gm = 0x06                ; Clock Select group mask\n.equ TCB_CLKSEL_gp = 1                   ; Clock Select group position\n.equ TCB_CLKSEL0_bm = (1<<1)             ; Clock Select bit 0 mask\n.equ TCB_CLKSEL0_bp = 1                  ; Clock Select bit 0 position\n.equ TCB_CLKSEL1_bm = (1<<2)             ; Clock Select bit 1 mask\n.equ TCB_CLKSEL1_bp = 2                  ; Clock Select bit 1 position\n.equ TCB_ENABLE_bm = 0x01                ; Enable bit mask\n.equ TCB_ENABLE_bp = 0                   ; Enable bit position\n.equ TCB_RUNSTDBY_bm = 0x40              ; Run Standby bit mask\n.equ TCB_RUNSTDBY_bp = 6                 ; Run Standby bit position\n.equ TCB_SYNCUPD_bm = 0x10               ; Synchronize Update bit mask\n.equ TCB_SYNCUPD_bp = 4                  ; Synchronize Update bit position\n\n; TCB_CTRLB masks\n.equ TCB_ASYNC_bm = 0x40                 ; Asynchronous Enable bit mask\n.equ TCB_ASYNC_bp = 6                    ; Asynchronous Enable bit position\n.equ TCB_CCMPEN_bm = 0x10                ; Pin Output Enable bit mask\n.equ TCB_CCMPEN_bp = 4                   ; Pin Output Enable bit position\n.equ TCB_CCMPINIT_bm = 0x20              ; Pin Initial State bit mask\n.equ TCB_CCMPINIT_bp = 5                 ; Pin Initial State bit position\n.equ TCB_CNTMODE_gm = 0x07               ; Timer Mode group mask\n.equ TCB_CNTMODE_gp = 0                  ; Timer Mode group position\n.equ TCB_CNTMODE0_bm = (1<<0)            ; Timer Mode bit 0 mask\n.equ TCB_CNTMODE0_bp = 0                 ; Timer Mode bit 0 position\n.equ TCB_CNTMODE1_bm = (1<<1)            ; Timer Mode bit 1 mask\n.equ TCB_CNTMODE1_bp = 1                 ; Timer Mode bit 1 position\n.equ TCB_CNTMODE2_bm = (1<<2)            ; Timer Mode bit 2 mask\n.equ TCB_CNTMODE2_bp = 2                 ; Timer Mode bit 2 position\n\n; TCB_DBGCTRL masks\n.equ TCB_DBGRUN_bm = 0x01                ; Debug Run bit mask\n.equ TCB_DBGRUN_bp = 0                   ; Debug Run bit position\n\n; TCB_EVCTRL masks\n.equ TCB_CAPTEI_bm = 0x01                ; Event Input Enable bit mask\n.equ TCB_CAPTEI_bp = 0                   ; Event Input Enable bit position\n.equ TCB_EDGE_bm = 0x10                  ; Event Edge bit mask\n.equ TCB_EDGE_bp = 4                     ; Event Edge bit position\n.equ TCB_FILTER_bm = 0x40                ; Input Capture Noise Cancellation Filter bit mask\n.equ TCB_FILTER_bp = 6                   ; Input Capture Noise Cancellation Filter bit position\n\n; TCB_INTCTRL masks\n.equ TCB_CAPT_bm = 0x01                  ; Capture or Timeout bit mask\n.equ TCB_CAPT_bp = 0                     ; Capture or Timeout bit position\n\n; TCB_INTFLAGS masks\n; Masks for TCB_CAPT already defined\n\n; TCB_STATUS masks\n.equ TCB_RUN_bm = 0x01                   ; Run bit mask\n.equ TCB_RUN_bp = 0                      ; Run bit position\n\n; Clock Select select\n.equ TCB_CLKSEL_CLKDIV1_gc = (0x00<<1)   ; CLK_PER (No Prescaling)\n.equ TCB_CLKSEL_CLKDIV2_gc = (0x01<<1)   ; CLK_PER/2 (From Prescaler)\n.equ TCB_CLKSEL_CLKTCA_gc = (0x02<<1)    ; Use Clock from TCA\n\n; Timer Mode select\n.equ TCB_CNTMODE_INT_gc = (0x00<<0)      ; Periodic Interrupt\n.equ TCB_CNTMODE_TIMEOUT_gc = (0x01<<0)  ; Periodic Timeout\n.equ TCB_CNTMODE_CAPT_gc = (0x02<<0)     ; Input Capture Event\n.equ TCB_CNTMODE_FRQ_gc = (0x03<<0)      ; Input Capture Frequency measurement\n.equ TCB_CNTMODE_PW_gc = (0x04<<0)       ; Input Capture Pulse-Width measurement\n.equ TCB_CNTMODE_FRQPW_gc = (0x05<<0)    ; Input Capture Frequency and Pulse-Width measurement\n.equ TCB_CNTMODE_SINGLE_gc = (0x06<<0)   ; Single Shot\n.equ TCB_CNTMODE_PWM8_gc = (0x07<<0)     ; 8-bit PWM\n\n\n;*************************************************************************\n;** TCD - Timer Counter D\n;*************************************************************************\n\n; TCD_CTRLA masks\n.equ TCD_CLKSEL_gm = 0x60                ; clock select group mask\n.equ TCD_CLKSEL_gp = 5                   ; clock select group position\n.equ TCD_CLKSEL0_bm = (1<<5)             ; clock select bit 0 mask\n.equ TCD_CLKSEL0_bp = 5                  ; clock select bit 0 position\n.equ TCD_CLKSEL1_bm = (1<<6)             ; clock select bit 1 mask\n.equ TCD_CLKSEL1_bp = 6                  ; clock select bit 1 position\n.equ TCD_CNTPRES_gm = 0x18               ; counter prescaler group mask\n.equ TCD_CNTPRES_gp = 3                  ; counter prescaler group position\n.equ TCD_CNTPRES0_bm = (1<<3)            ; counter prescaler bit 0 mask\n.equ TCD_CNTPRES0_bp = 3                 ; counter prescaler bit 0 position\n.equ TCD_CNTPRES1_bm = (1<<4)            ; counter prescaler bit 1 mask\n.equ TCD_CNTPRES1_bp = 4                 ; counter prescaler bit 1 position\n.equ TCD_ENABLE_bm = 0x01                ; Enable bit mask\n.equ TCD_ENABLE_bp = 0                   ; Enable bit position\n.equ TCD_SYNCPRES_gm = 0x06              ; Syncronization prescaler group mask\n.equ TCD_SYNCPRES_gp = 1                 ; Syncronization prescaler group position\n.equ TCD_SYNCPRES0_bm = (1<<1)           ; Syncronization prescaler bit 0 mask\n.equ TCD_SYNCPRES0_bp = 1                ; Syncronization prescaler bit 0 position\n.equ TCD_SYNCPRES1_bm = (1<<2)           ; Syncronization prescaler bit 1 mask\n.equ TCD_SYNCPRES1_bp = 2                ; Syncronization prescaler bit 1 position\n\n; TCD_CTRLB masks\n.equ TCD_WGMODE_gm = 0x03                ; Waveform generation mode group mask\n.equ TCD_WGMODE_gp = 0                   ; Waveform generation mode group position\n.equ TCD_WGMODE0_bm = (1<<0)             ; Waveform generation mode bit 0 mask\n.equ TCD_WGMODE0_bp = 0                  ; Waveform generation mode bit 0 position\n.equ TCD_WGMODE1_bm = (1<<1)             ; Waveform generation mode bit 1 mask\n.equ TCD_WGMODE1_bp = 1                  ; Waveform generation mode bit 1 position\n\n; TCD_CTRLC masks\n.equ TCD_AUPDATE_bm = 0x02               ; Auto update bit mask\n.equ TCD_AUPDATE_bp = 1                  ; Auto update bit position\n.equ TCD_CMPCSEL_bm = 0x40               ; Compare C output select bit mask\n.equ TCD_CMPCSEL_bp = 6                  ; Compare C output select bit position\n.equ TCD_CMPDSEL_bm = 0x80               ; Compare D output select bit mask\n.equ TCD_CMPDSEL_bp = 7                  ; Compare D output select bit position\n.equ TCD_CMPOVR_bm = 0x01                ; Compare output value override bit mask\n.equ TCD_CMPOVR_bp = 0                   ; Compare output value override bit position\n.equ TCD_FIFTY_bm = 0x08                 ; Fifty percent waveform bit mask\n.equ TCD_FIFTY_bp = 3                    ; Fifty percent waveform bit position\n\n; TCD_CTRLD masks\n.equ TCD_CMPAVAL_gm = 0x0F               ; Compare A value group mask\n.equ TCD_CMPAVAL_gp = 0                  ; Compare A value group position\n.equ TCD_CMPAVAL0_bm = (1<<0)            ; Compare A value bit 0 mask\n.equ TCD_CMPAVAL0_bp = 0                 ; Compare A value bit 0 position\n.equ TCD_CMPAVAL1_bm = (1<<1)            ; Compare A value bit 1 mask\n.equ TCD_CMPAVAL1_bp = 1                 ; Compare A value bit 1 position\n.equ TCD_CMPAVAL2_bm = (1<<2)            ; Compare A value bit 2 mask\n.equ TCD_CMPAVAL2_bp = 2                 ; Compare A value bit 2 position\n.equ TCD_CMPAVAL3_bm = (1<<3)            ; Compare A value bit 3 mask\n.equ TCD_CMPAVAL3_bp = 3                 ; Compare A value bit 3 position\n.equ TCD_CMPBVAL_gm = 0xF0               ; Compare B value group mask\n.equ TCD_CMPBVAL_gp = 4                  ; Compare B value group position\n.equ TCD_CMPBVAL0_bm = (1<<4)            ; Compare B value bit 0 mask\n.equ TCD_CMPBVAL0_bp = 4                 ; Compare B value bit 0 position\n.equ TCD_CMPBVAL1_bm = (1<<5)            ; Compare B value bit 1 mask\n.equ TCD_CMPBVAL1_bp = 5                 ; Compare B value bit 1 position\n.equ TCD_CMPBVAL2_bm = (1<<6)            ; Compare B value bit 2 mask\n.equ TCD_CMPBVAL2_bp = 6                 ; Compare B value bit 2 position\n.equ TCD_CMPBVAL3_bm = (1<<7)            ; Compare B value bit 3 mask\n.equ TCD_CMPBVAL3_bp = 7                 ; Compare B value bit 3 position\n\n; TCD_CTRLE masks\n.equ TCD_DISEOC_bm = 0x80                ; Disable at end of cycle bit mask\n.equ TCD_DISEOC_bp = 7                   ; Disable at end of cycle bit position\n.equ TCD_RESTART_bm = 0x04               ; Restart strobe bit mask\n.equ TCD_RESTART_bp = 2                  ; Restart strobe bit position\n.equ TCD_SCAPTUREA_bm = 0x08             ; Software Capture A Strobe bit mask\n.equ TCD_SCAPTUREA_bp = 3                ; Software Capture A Strobe bit position\n.equ TCD_SCAPTUREB_bm = 0x10             ; Software Capture B Strobe bit mask\n.equ TCD_SCAPTUREB_bp = 4                ; Software Capture B Strobe bit position\n.equ TCD_SYNC_bm = 0x02                  ; synchronize strobe bit mask\n.equ TCD_SYNC_bp = 1                     ; synchronize strobe bit position\n.equ TCD_SYNCEOC_bm = 0x01               ; synchronize end of cycle strobe bit mask\n.equ TCD_SYNCEOC_bp = 0                  ; synchronize end of cycle strobe bit position\n\n; TCD_DBGCTRL masks\n.equ TCD_DBGRUN_bm = 0x01                ; Debug run bit mask\n.equ TCD_DBGRUN_bp = 0                   ; Debug run bit position\n.equ TCD_FAULTDET_bm = 0x04              ; Fault detection bit mask\n.equ TCD_FAULTDET_bp = 2                 ; Fault detection bit position\n\n; TCD_DITCTRL masks\n.equ TCD_DITHERSEL_gm = 0x03             ; dither select group mask\n.equ TCD_DITHERSEL_gp = 0                ; dither select group position\n.equ TCD_DITHERSEL0_bm = (1<<0)          ; dither select bit 0 mask\n.equ TCD_DITHERSEL0_bp = 0               ; dither select bit 0 position\n.equ TCD_DITHERSEL1_bm = (1<<1)          ; dither select bit 1 mask\n.equ TCD_DITHERSEL1_bp = 1               ; dither select bit 1 position\n\n; TCD_DITVAL masks\n.equ TCD_DITHER_gm = 0x0F                ; Dither value group mask\n.equ TCD_DITHER_gp = 0                   ; Dither value group position\n.equ TCD_DITHER0_bm = (1<<0)             ; Dither value bit 0 mask\n.equ TCD_DITHER0_bp = 0                  ; Dither value bit 0 position\n.equ TCD_DITHER1_bm = (1<<1)             ; Dither value bit 1 mask\n.equ TCD_DITHER1_bp = 1                  ; Dither value bit 1 position\n.equ TCD_DITHER2_bm = (1<<2)             ; Dither value bit 2 mask\n.equ TCD_DITHER2_bp = 2                  ; Dither value bit 2 position\n.equ TCD_DITHER3_bm = (1<<3)             ; Dither value bit 3 mask\n.equ TCD_DITHER3_bp = 3                  ; Dither value bit 3 position\n\n; TCD_DLYCTRL masks\n.equ TCD_DLYPRESC_gm = 0x30              ; Delay prescaler group mask\n.equ TCD_DLYPRESC_gp = 4                 ; Delay prescaler group position\n.equ TCD_DLYPRESC0_bm = (1<<4)           ; Delay prescaler bit 0 mask\n.equ TCD_DLYPRESC0_bp = 4                ; Delay prescaler bit 0 position\n.equ TCD_DLYPRESC1_bm = (1<<5)           ; Delay prescaler bit 1 mask\n.equ TCD_DLYPRESC1_bp = 5                ; Delay prescaler bit 1 position\n.equ TCD_DLYSEL_gm = 0x03                ; Delay select group mask\n.equ TCD_DLYSEL_gp = 0                   ; Delay select group position\n.equ TCD_DLYSEL0_bm = (1<<0)             ; Delay select bit 0 mask\n.equ TCD_DLYSEL0_bp = 0                  ; Delay select bit 0 position\n.equ TCD_DLYSEL1_bm = (1<<1)             ; Delay select bit 1 mask\n.equ TCD_DLYSEL1_bp = 1                  ; Delay select bit 1 position\n.equ TCD_DLYTRIG_gm = 0x0C               ; Delay trigger group mask\n.equ TCD_DLYTRIG_gp = 2                  ; Delay trigger group position\n.equ TCD_DLYTRIG0_bm = (1<<2)            ; Delay trigger bit 0 mask\n.equ TCD_DLYTRIG0_bp = 2                 ; Delay trigger bit 0 position\n.equ TCD_DLYTRIG1_bm = (1<<3)            ; Delay trigger bit 1 mask\n.equ TCD_DLYTRIG1_bp = 3                 ; Delay trigger bit 1 position\n\n; TCD_DLYVAL masks\n.equ TCD_DLYVAL_gm = 0xFF                ; Delay value group mask\n.equ TCD_DLYVAL_gp = 0                   ; Delay value group position\n.equ TCD_DLYVAL0_bm = (1<<0)             ; Delay value bit 0 mask\n.equ TCD_DLYVAL0_bp = 0                  ; Delay value bit 0 position\n.equ TCD_DLYVAL1_bm = (1<<1)             ; Delay value bit 1 mask\n.equ TCD_DLYVAL1_bp = 1                  ; Delay value bit 1 position\n.equ TCD_DLYVAL2_bm = (1<<2)             ; Delay value bit 2 mask\n.equ TCD_DLYVAL2_bp = 2                  ; Delay value bit 2 position\n.equ TCD_DLYVAL3_bm = (1<<3)             ; Delay value bit 3 mask\n.equ TCD_DLYVAL3_bp = 3                  ; Delay value bit 3 position\n.equ TCD_DLYVAL4_bm = (1<<4)             ; Delay value bit 4 mask\n.equ TCD_DLYVAL4_bp = 4                  ; Delay value bit 4 position\n.equ TCD_DLYVAL5_bm = (1<<5)             ; Delay value bit 5 mask\n.equ TCD_DLYVAL5_bp = 5                  ; Delay value bit 5 position\n.equ TCD_DLYVAL6_bm = (1<<6)             ; Delay value bit 6 mask\n.equ TCD_DLYVAL6_bp = 6                  ; Delay value bit 6 position\n.equ TCD_DLYVAL7_bm = (1<<7)             ; Delay value bit 7 mask\n.equ TCD_DLYVAL7_bp = 7                  ; Delay value bit 7 position\n\n; TCD_EVCTRLA masks\n.equ TCD_ACTION_bm = 0x04                ; event action bit mask\n.equ TCD_ACTION_bp = 2                   ; event action bit position\n.equ TCD_CFG_gm = 0xC0                   ; event config group mask\n.equ TCD_CFG_gp = 6                      ; event config group position\n.equ TCD_CFG0_bm = (1<<6)                ; event config bit 0 mask\n.equ TCD_CFG0_bp = 6                     ; event config bit 0 position\n.equ TCD_CFG1_bm = (1<<7)                ; event config bit 1 mask\n.equ TCD_CFG1_bp = 7                     ; event config bit 1 position\n.equ TCD_EDGE_bm = 0x10                  ; edge select bit mask\n.equ TCD_EDGE_bp = 4                     ; edge select bit position\n.equ TCD_TRIGEI_bm = 0x01                ; Trigger event enable bit mask\n.equ TCD_TRIGEI_bp = 0                   ; Trigger event enable bit position\n\n; TCD_EVCTRLB masks\n; Masks for TCD_ACTION already defined\n; Masks for TCD_CFG already defined\n; Masks for TCD_EDGE already defined\n; Masks for TCD_TRIGEI already defined\n\n; TCD_FAULTCTRL masks\n.equ TCD_CMPA_bm = 0x01                  ; Compare A value bit mask\n.equ TCD_CMPA_bp = 0                     ; Compare A value bit position\n.equ TCD_CMPAEN_bm = 0x10                ; Compare A enable bit mask\n.equ TCD_CMPAEN_bp = 4                   ; Compare A enable bit position\n.equ TCD_CMPB_bm = 0x02                  ; Compare B value bit mask\n.equ TCD_CMPB_bp = 1                     ; Compare B value bit position\n.equ TCD_CMPBEN_bm = 0x20                ; Compare B enable bit mask\n.equ TCD_CMPBEN_bp = 5                   ; Compare B enable bit position\n.equ TCD_CMPC_bm = 0x04                  ; Compare C value bit mask\n.equ TCD_CMPC_bp = 2                     ; Compare C value bit position\n.equ TCD_CMPCEN_bm = 0x40                ; Compare C enable bit mask\n.equ TCD_CMPCEN_bp = 6                   ; Compare C enable bit position\n.equ TCD_CMPD_bm = 0x08                  ; Compare D vaule bit mask\n.equ TCD_CMPD_bp = 3                     ; Compare D vaule bit position\n.equ TCD_CMPDEN_bm = 0x80                ; Compare D enable bit mask\n.equ TCD_CMPDEN_bp = 7                   ; Compare D enable bit position\n\n; TCD_INPUTCTRLA masks\n.equ TCD_INPUTMODE_gm = 0x0F             ; Input mode group mask\n.equ TCD_INPUTMODE_gp = 0                ; Input mode group position\n.equ TCD_INPUTMODE0_bm = (1<<0)          ; Input mode bit 0 mask\n.equ TCD_INPUTMODE0_bp = 0               ; Input mode bit 0 position\n.equ TCD_INPUTMODE1_bm = (1<<1)          ; Input mode bit 1 mask\n.equ TCD_INPUTMODE1_bp = 1               ; Input mode bit 1 position\n.equ TCD_INPUTMODE2_bm = (1<<2)          ; Input mode bit 2 mask\n.equ TCD_INPUTMODE2_bp = 2               ; Input mode bit 2 position\n.equ TCD_INPUTMODE3_bm = (1<<3)          ; Input mode bit 3 mask\n.equ TCD_INPUTMODE3_bp = 3               ; Input mode bit 3 position\n\n; TCD_INPUTCTRLB masks\n; Masks for TCD_INPUTMODE already defined\n\n; TCD_INTCTRL masks\n.equ TCD_OVF_bm = 0x01                   ; Overflow interrupt enable bit mask\n.equ TCD_OVF_bp = 0                      ; Overflow interrupt enable bit position\n.equ TCD_TRIGA_bm = 0x04                 ; Trigger A interrupt enable bit mask\n.equ TCD_TRIGA_bp = 2                    ; Trigger A interrupt enable bit position\n.equ TCD_TRIGB_bm = 0x08                 ; Trigger B interrupt enable bit mask\n.equ TCD_TRIGB_bp = 3                    ; Trigger B interrupt enable bit position\n\n; TCD_INTFLAGS masks\n; Masks for TCD_OVF already defined\n; Masks for TCD_TRIGA already defined\n; Masks for TCD_TRIGB already defined\n\n; TCD_STATUS masks\n.equ TCD_CMDRDY_bm = 0x02                ; Command ready bit mask\n.equ TCD_CMDRDY_bp = 1                   ; Command ready bit position\n.equ TCD_ENRDY_bm = 0x01                 ; Enable ready bit mask\n.equ TCD_ENRDY_bp = 0                    ; Enable ready bit position\n.equ TCD_PWMACTA_bm = 0x40               ; PWM activity on A bit mask\n.equ TCD_PWMACTA_bp = 6                  ; PWM activity on A bit position\n.equ TCD_PWMACTB_bm = 0x80               ; PWM activity on B bit mask\n.equ TCD_PWMACTB_bp = 7                  ; PWM activity on B bit position\n\n; clock select select\n.equ TCD_CLKSEL_20MHZ_gc = (0x00<<5)     ; 20 MHz oscillator\n.equ TCD_CLKSEL_EXTCLK_gc = (0x02<<5)    ; External clock\n.equ TCD_CLKSEL_SYSCLK_gc = (0x03<<5)    ; System clock\n\n; counter prescaler select\n.equ TCD_CNTPRES_DIV1_gc = (0x00<<3)     ; Sync clock divided by 1\n.equ TCD_CNTPRES_DIV4_gc = (0x01<<3)     ; Sync clock divided by 4\n.equ TCD_CNTPRES_DIV32_gc = (0x02<<3)    ; Sync clock divided by 32\n\n; Syncronization prescaler select\n.equ TCD_SYNCPRES_DIV1_gc = (0x00<<1)    ; Selevted clock source divided by 1\n.equ TCD_SYNCPRES_DIV2_gc = (0x01<<1)    ; Selevted clock source divided by 2\n.equ TCD_SYNCPRES_DIV4_gc = (0x02<<1)    ; Selevted clock source divided by 4\n.equ TCD_SYNCPRES_DIV8_gc = (0x03<<1)    ; Selevted clock source divided by 8\n\n; Waveform generation mode select\n.equ TCD_WGMODE_ONERAMP_gc = (0x00<<0)   ; One ramp mode\n.equ TCD_WGMODE_TWORAMP_gc = (0x01<<0)   ; Two ramp mode\n.equ TCD_WGMODE_FOURRAMP_gc = (0x02<<0)  ; Four ramp mode\n.equ TCD_WGMODE_DS_gc = (0x03<<0)        ; Dual slope mode\n\n; Compare C output select select\n.equ TCD_CMPCSEL_PWMA_gc = (0x00<<6)     ; PWM A output\n.equ TCD_CMPCSEL_PWMB_gc = (0x01<<6)     ; PWM B output\n\n; Compare D output select select\n.equ TCD_CMPDSEL_PWMA_gc = (0x00<<7)     ; PWM A output\n.equ TCD_CMPDSEL_PWMB_gc = (0x01<<7)     ; PWM B output\n\n; dither select select\n.equ TCD_DITHERSEL_ONTIMEB_gc = (0x00<<0) ; On-time ramp B\n.equ TCD_DITHERSEL_ONTIMEAB_gc = (0x01<<0) ; On-time ramp A and B\n.equ TCD_DITHERSEL_DEADTIMEB_gc = (0x02<<0) ; Dead-time rampB\n.equ TCD_DITHERSEL_DEADTIMEAB_gc = (0x03<<0) ; Dead-time ramp A and B\n\n; Delay prescaler select\n.equ TCD_DLYPRESC_DIV1_gc = (0x00<<4)    ; No prescaling\n.equ TCD_DLYPRESC_DIV2_gc = (0x01<<4)    ; Prescale with 2\n.equ TCD_DLYPRESC_DIV4_gc = (0x02<<4)    ; Prescale with 4\n.equ TCD_DLYPRESC_DIV8_gc = (0x03<<4)    ; Prescale with 8\n\n; Delay select select\n.equ TCD_DLYSEL_OFF_gc = (0x00<<0)       ; No delay\n.equ TCD_DLYSEL_INBLANK_gc = (0x01<<0)   ; Input blanking enabled\n.equ TCD_DLYSEL_EVENT_gc = (0x02<<0)     ; Event delay enabled\n\n; Delay trigger select\n.equ TCD_DLYTRIG_CMPASET_gc = (0x00<<2)  ; Compare A set\n.equ TCD_DLYTRIG_CMPACLR_gc = (0x01<<2)  ; Compare A clear\n.equ TCD_DLYTRIG_CMPBSET_gc = (0x02<<2)  ; Compare B set\n.equ TCD_DLYTRIG_CMPBCLR_gc = (0x03<<2)  ; Compare B clear\n\n; event action select\n.equ TCD_ACTION_FAULT_gc = (0x00<<2)     ; Event trigger a fault\n.equ TCD_ACTION_CAPTURE_gc = (0x01<<2)   ; Event trigger a fault and capture\n\n; event config select\n.equ TCD_CFG_NEITHER_gc = (0x00<<6)      ; Neither Filter nor Asynchronous Event is enabled\n.equ TCD_CFG_FILTER_gc = (0x01<<6)       ; Input Capture Noise Cancellation Filter enabled\n.equ TCD_CFG_ASYNC_gc = (0x02<<6)        ; Asynchronous Event output qualification enabled\n\n; edge select select\n.equ TCD_EDGE_FALL_LOW_gc = (0x00<<4)    ; The falling edge or low level of event generates retrigger or fault action\n.equ TCD_EDGE_RISE_HIGH_gc = (0x01<<4)   ; The rising edge or high level of event generates retrigger or fault action\n\n; Input mode select\n.equ TCD_INPUTMODE_NONE_gc = (0x00<<0)   ; Input has no actions\n.equ TCD_INPUTMODE_JMPWAIT_gc = (0x01<<0) ; Stop output, jump to opposite compare cycle and wait\n.equ TCD_INPUTMODE_EXECWAIT_gc = (0x02<<0) ; Stop output, execute opposite compare cycle and wait\n.equ TCD_INPUTMODE_EXECFAULT_gc = (0x03<<0) ; stop output, execute opposite compare cycle while fault active\n.equ TCD_INPUTMODE_FREQ_gc = (0x04<<0)   ; Stop all outputs, maintain frequency\n.equ TCD_INPUTMODE_EXECDT_gc = (0x05<<0) ; Stop all outputs, execute dead time while fault active\n.equ TCD_INPUTMODE_WAIT_gc = (0x06<<0)   ; Stop all outputs, jump to next compare cycle and wait\n.equ TCD_INPUTMODE_WAITSW_gc = (0x07<<0) ; Stop all outputs, wait for software action\n.equ TCD_INPUTMODE_EDGETRIG_gc = (0x08<<0) ; Stop output on edge, jump to next compare cycle\n.equ TCD_INPUTMODE_EDGETRIGFREQ_gc = (0x09<<0) ; Stop output on edge, maintain frequency\n.equ TCD_INPUTMODE_LVLTRIGFREQ_gc = (0x0A<<0) ; Stop output at level, maintain frequency\n\n\n;*************************************************************************\n;** TWI - Two-Wire Interface\n;*************************************************************************\n\n; TWI_CTRLA masks\n.equ TWI_FMPEN_bm = 0x02                 ; FM Plus Enable bit mask\n.equ TWI_FMPEN_bp = 1                    ; FM Plus Enable bit position\n.equ TWI_SDAHOLD_gm = 0x0C               ; SDA Hold Time group mask\n.equ TWI_SDAHOLD_gp = 2                  ; SDA Hold Time group position\n.equ TWI_SDAHOLD0_bm = (1<<2)            ; SDA Hold Time bit 0 mask\n.equ TWI_SDAHOLD0_bp = 2                 ; SDA Hold Time bit 0 position\n.equ TWI_SDAHOLD1_bm = (1<<3)            ; SDA Hold Time bit 1 mask\n.equ TWI_SDAHOLD1_bp = 3                 ; SDA Hold Time bit 1 position\n.equ TWI_SDASETUP_bm = 0x10              ; SDA Setup Time bit mask\n.equ TWI_SDASETUP_bp = 4                 ; SDA Setup Time bit position\n\n; TWI_DBGCTRL masks\n.equ TWI_DBGRUN_bm = 0x01                ; Debug Run bit mask\n.equ TWI_DBGRUN_bp = 0                   ; Debug Run bit position\n\n; TWI_MCTRLA masks\n.equ TWI_ENABLE_bm = 0x01                ; Enable TWI Master bit mask\n.equ TWI_ENABLE_bp = 0                   ; Enable TWI Master bit position\n.equ TWI_QCEN_bm = 0x10                  ; Quick Command Enable bit mask\n.equ TWI_QCEN_bp = 4                     ; Quick Command Enable bit position\n.equ TWI_RIEN_bm = 0x80                  ; Read Interrupt Enable bit mask\n.equ TWI_RIEN_bp = 7                     ; Read Interrupt Enable bit position\n.equ TWI_SMEN_bm = 0x02                  ; Smart Mode Enable bit mask\n.equ TWI_SMEN_bp = 1                     ; Smart Mode Enable bit position\n.equ TWI_TIMEOUT_gm = 0x0C               ; Inactive Bus Timeout group mask\n.equ TWI_TIMEOUT_gp = 2                  ; Inactive Bus Timeout group position\n.equ TWI_TIMEOUT0_bm = (1<<2)            ; Inactive Bus Timeout bit 0 mask\n.equ TWI_TIMEOUT0_bp = 2                 ; Inactive Bus Timeout bit 0 position\n.equ TWI_TIMEOUT1_bm = (1<<3)            ; Inactive Bus Timeout bit 1 mask\n.equ TWI_TIMEOUT1_bp = 3                 ; Inactive Bus Timeout bit 1 position\n.equ TWI_WIEN_bm = 0x40                  ; Write Interrupt Enable bit mask\n.equ TWI_WIEN_bp = 6                     ; Write Interrupt Enable bit position\n\n; TWI_MCTRLB masks\n.equ TWI_ACKACT_bm = 0x04                ; Acknowledge Action bit mask\n.equ TWI_ACKACT_bp = 2                   ; Acknowledge Action bit position\n.equ TWI_FLUSH_bm = 0x08                 ; Flush bit mask\n.equ TWI_FLUSH_bp = 3                    ; Flush bit position\n.equ TWI_MCMD_gm = 0x03                  ; Command group mask\n.equ TWI_MCMD_gp = 0                     ; Command group position\n.equ TWI_MCMD0_bm = (1<<0)               ; Command bit 0 mask\n.equ TWI_MCMD0_bp = 0                    ; Command bit 0 position\n.equ TWI_MCMD1_bm = (1<<1)               ; Command bit 1 mask\n.equ TWI_MCMD1_bp = 1                    ; Command bit 1 position\n\n; TWI_MSTATUS masks\n.equ TWI_ARBLOST_bm = 0x08               ; Arbitration Lost bit mask\n.equ TWI_ARBLOST_bp = 3                  ; Arbitration Lost bit position\n.equ TWI_BUSERR_bm = 0x04                ; Bus Error bit mask\n.equ TWI_BUSERR_bp = 2                   ; Bus Error bit position\n.equ TWI_BUSSTATE_gm = 0x03              ; Bus State group mask\n.equ TWI_BUSSTATE_gp = 0                 ; Bus State group position\n.equ TWI_BUSSTATE0_bm = (1<<0)           ; Bus State bit 0 mask\n.equ TWI_BUSSTATE0_bp = 0                ; Bus State bit 0 position\n.equ TWI_BUSSTATE1_bm = (1<<1)           ; Bus State bit 1 mask\n.equ TWI_BUSSTATE1_bp = 1                ; Bus State bit 1 position\n.equ TWI_CLKHOLD_bm = 0x20               ; Clock Hold bit mask\n.equ TWI_CLKHOLD_bp = 5                  ; Clock Hold bit position\n.equ TWI_RIF_bm = 0x80                   ; Read Interrupt Flag bit mask\n.equ TWI_RIF_bp = 7                      ; Read Interrupt Flag bit position\n.equ TWI_RXACK_bm = 0x10                 ; Received Acknowledge bit mask\n.equ TWI_RXACK_bp = 4                    ; Received Acknowledge bit position\n.equ TWI_WIF_bm = 0x40                   ; Write Interrupt Flag bit mask\n.equ TWI_WIF_bp = 6                      ; Write Interrupt Flag bit position\n\n; TWI_SADDRMASK masks\n.equ TWI_ADDREN_bm = 0x01                ; Address Enable bit mask\n.equ TWI_ADDREN_bp = 0                   ; Address Enable bit position\n.equ TWI_ADDRMASK_gm = 0xFE              ; Address Mask group mask\n.equ TWI_ADDRMASK_gp = 1                 ; Address Mask group position\n.equ TWI_ADDRMASK0_bm = (1<<1)           ; Address Mask bit 0 mask\n.equ TWI_ADDRMASK0_bp = 1                ; Address Mask bit 0 position\n.equ TWI_ADDRMASK1_bm = (1<<2)           ; Address Mask bit 1 mask\n.equ TWI_ADDRMASK1_bp = 2                ; Address Mask bit 1 position\n.equ TWI_ADDRMASK2_bm = (1<<3)           ; Address Mask bit 2 mask\n.equ TWI_ADDRMASK2_bp = 3                ; Address Mask bit 2 position\n.equ TWI_ADDRMASK3_bm = (1<<4)           ; Address Mask bit 3 mask\n.equ TWI_ADDRMASK3_bp = 4                ; Address Mask bit 3 position\n.equ TWI_ADDRMASK4_bm = (1<<5)           ; Address Mask bit 4 mask\n.equ TWI_ADDRMASK4_bp = 5                ; Address Mask bit 4 position\n.equ TWI_ADDRMASK5_bm = (1<<6)           ; Address Mask bit 5 mask\n.equ TWI_ADDRMASK5_bp = 6                ; Address Mask bit 5 position\n.equ TWI_ADDRMASK6_bm = (1<<7)           ; Address Mask bit 6 mask\n.equ TWI_ADDRMASK6_bp = 7                ; Address Mask bit 6 position\n\n; TWI_SCTRLA masks\n.equ TWI_APIEN_bm = 0x40                 ; Address/Stop Interrupt Enable bit mask\n.equ TWI_APIEN_bp = 6                    ; Address/Stop Interrupt Enable bit position\n.equ TWI_DIEN_bm = 0x80                  ; Data Interrupt Enable bit mask\n.equ TWI_DIEN_bp = 7                     ; Data Interrupt Enable bit position\n; Masks for TWI_ENABLE already defined\n.equ TWI_PIEN_bm = 0x20                  ; Stop Interrupt Enable bit mask\n.equ TWI_PIEN_bp = 5                     ; Stop Interrupt Enable bit position\n.equ TWI_PMEN_bm = 0x04                  ; Promiscuous Mode Enable bit mask\n.equ TWI_PMEN_bp = 2                     ; Promiscuous Mode Enable bit position\n; Masks for TWI_SMEN already defined\n\n; TWI_SCTRLB masks\n; Masks for TWI_ACKACT already defined\n.equ TWI_SCMD_gm = 0x03                  ; Command group mask\n.equ TWI_SCMD_gp = 0                     ; Command group position\n.equ TWI_SCMD0_bm = (1<<0)               ; Command bit 0 mask\n.equ TWI_SCMD0_bp = 0                    ; Command bit 0 position\n.equ TWI_SCMD1_bm = (1<<1)               ; Command bit 1 mask\n.equ TWI_SCMD1_bp = 1                    ; Command bit 1 position\n\n; TWI_SSTATUS masks\n.equ TWI_AP_bm = 0x01                    ; Slave Address or Stop bit mask\n.equ TWI_AP_bp = 0                       ; Slave Address or Stop bit position\n.equ TWI_APIF_bm = 0x40                  ; Address/Stop Interrupt Flag bit mask\n.equ TWI_APIF_bp = 6                     ; Address/Stop Interrupt Flag bit position\n; Masks for TWI_BUSERR already defined\n; Masks for TWI_CLKHOLD already defined\n.equ TWI_COLL_bm = 0x08                  ; Collision bit mask\n.equ TWI_COLL_bp = 3                     ; Collision bit position\n.equ TWI_DIF_bm = 0x80                   ; Data Interrupt Flag bit mask\n.equ TWI_DIF_bp = 7                      ; Data Interrupt Flag bit position\n.equ TWI_DIR_bm = 0x02                   ; Read/Write Direction bit mask\n.equ TWI_DIR_bp = 1                      ; Read/Write Direction bit position\n; Masks for TWI_RXACK already defined\n\n; SDA Hold Time select\n.equ TWI_SDAHOLD_OFF_gc = (0x00<<2)      ; SDA hold time off\n.equ TWI_SDAHOLD_50NS_gc = (0x01<<2)     ; Typical 50ns hold time\n.equ TWI_SDAHOLD_300NS_gc = (0x02<<2)    ; Typical 300ns hold time\n.equ TWI_SDAHOLD_500NS_gc = (0x03<<2)    ; Typical 500ns hold time\n\n; SDA Setup Time select\n.equ TWI_SDASETUP_4CYC_gc = (0x00<<4)    ; SDA setup time is 4 clock cycles\n.equ TWI_SDASETUP_8CYC_gc = (0x01<<4)    ; SDA setup time is 8 clock cycles\n\n; Inactive Bus Timeout select\n.equ TWI_TIMEOUT_DISABLED_gc = (0x00<<2) ; Bus Timeout Disabled\n.equ TWI_TIMEOUT_50US_gc = (0x01<<2)     ; 50 Microseconds\n.equ TWI_TIMEOUT_100US_gc = (0x02<<2)    ; 100 Microseconds\n.equ TWI_TIMEOUT_200US_gc = (0x03<<2)    ; 200 Microseconds\n\n; Acknowledge Action select\n.equ TWI_ACKACT_ACK_gc = (0x00<<2)       ; Send ACK\n.equ TWI_ACKACT_NACK_gc = (0x01<<2)      ; Send NACK\n\n; Command select\n.equ TWI_MCMD_NOACT_gc = (0x00<<0)       ; No Action\n.equ TWI_MCMD_REPSTART_gc = (0x01<<0)    ; Issue Repeated Start Condition\n.equ TWI_MCMD_RECVTRANS_gc = (0x02<<0)   ; Receive or Transmit Data, depending on DIR\n.equ TWI_MCMD_STOP_gc = (0x03<<0)        ; Issue Stop Condition\n\n; Bus State select\n.equ TWI_BUSSTATE_UNKNOWN_gc = (0x00<<0) ; Unknown Bus State\n.equ TWI_BUSSTATE_IDLE_gc = (0x01<<0)    ; Bus is Idle\n.equ TWI_BUSSTATE_OWNER_gc = (0x02<<0)   ; This Module Controls The Bus\n.equ TWI_BUSSTATE_BUSY_gc = (0x03<<0)    ; The Bus is Busy\n\n; Command select\n.equ TWI_SCMD_NOACT_gc = (0x00<<0)       ; No Action\n.equ TWI_SCMD_COMPTRANS_gc = (0x02<<0)   ; Used To Complete a Transaction\n.equ TWI_SCMD_RESPONSE_gc = (0x03<<0)    ; Used in Response to Address/Data Interrupt\n\n; Slave Address or Stop select\n.equ TWI_AP_STOP_gc = (0x00<<0)          ; Stop condition generated APIF\n.equ TWI_AP_ADR_gc = (0x01<<0)           ; Address detection generated APIF\n\n\n;*************************************************************************\n;** USART - Universal Synchronous and Asynchronous Receiver and Transmitter\n;*************************************************************************\n\n; USART_CTRLA masks\n.equ USART_ABEIE_bm = 0x04               ; Auto-baud Error Interrupt Enable bit mask\n.equ USART_ABEIE_bp = 2                  ; Auto-baud Error Interrupt Enable bit position\n.equ USART_DREIE_bm = 0x20               ; Data Register Empty Interrupt Enable bit mask\n.equ USART_DREIE_bp = 5                  ; Data Register Empty Interrupt Enable bit position\n.equ USART_LBME_bm = 0x08                ; Loop-back Mode Enable bit mask\n.equ USART_LBME_bp = 3                   ; Loop-back Mode Enable bit position\n.equ USART_RS485_gm = 0x03               ; RS485 Mode internal transmitter group mask\n.equ USART_RS485_gp = 0                  ; RS485 Mode internal transmitter group position\n.equ USART_RS4850_bm = (1<<0)            ; RS485 Mode internal transmitter bit 0 mask\n.equ USART_RS4850_bp = 0                 ; RS485 Mode internal transmitter bit 0 position\n.equ USART_RS4851_bm = (1<<1)            ; RS485 Mode internal transmitter bit 1 mask\n.equ USART_RS4851_bp = 1                 ; RS485 Mode internal transmitter bit 1 position\n.equ USART_RXCIE_bm = 0x80               ; Receive Complete Interrupt Enable bit mask\n.equ USART_RXCIE_bp = 7                  ; Receive Complete Interrupt Enable bit position\n.equ USART_RXSIE_bm = 0x10               ; Receiver Start Frame Interrupt Enable bit mask\n.equ USART_RXSIE_bp = 4                  ; Receiver Start Frame Interrupt Enable bit position\n.equ USART_TXCIE_bm = 0x40               ; Transmit Complete Interrupt Enable bit mask\n.equ USART_TXCIE_bp = 6                  ; Transmit Complete Interrupt Enable bit position\n\n; USART_CTRLB masks\n.equ USART_MPCM_bm = 0x01                ; Multi-processor Communication Mode bit mask\n.equ USART_MPCM_bp = 0                   ; Multi-processor Communication Mode bit position\n.equ USART_ODME_bm = 0x08                ; Open Drain Mode Enable bit mask\n.equ USART_ODME_bp = 3                   ; Open Drain Mode Enable bit position\n.equ USART_RXEN_bm = 0x80                ; Reciever enable bit mask\n.equ USART_RXEN_bp = 7                   ; Reciever enable bit position\n.equ USART_RXMODE_gm = 0x06              ; Receiver Mode group mask\n.equ USART_RXMODE_gp = 1                 ; Receiver Mode group position\n.equ USART_RXMODE0_bm = (1<<1)           ; Receiver Mode bit 0 mask\n.equ USART_RXMODE0_bp = 1                ; Receiver Mode bit 0 position\n.equ USART_RXMODE1_bm = (1<<2)           ; Receiver Mode bit 1 mask\n.equ USART_RXMODE1_bp = 2                ; Receiver Mode bit 1 position\n.equ USART_SFDEN_bm = 0x10               ; Start Frame Detection Enable bit mask\n.equ USART_SFDEN_bp = 4                  ; Start Frame Detection Enable bit position\n.equ USART_TXEN_bm = 0x40                ; Transmitter Enable bit mask\n.equ USART_TXEN_bp = 6                   ; Transmitter Enable bit position\n\n; USART_CTRLC masks\n.equ USART_CMODE_gm = 0xC0               ; Communication Mode group mask\n.equ USART_CMODE_gp = 6                  ; Communication Mode group position\n.equ USART_CMODE0_bm = (1<<6)            ; Communication Mode bit 0 mask\n.equ USART_CMODE0_bp = 6                 ; Communication Mode bit 0 position\n.equ USART_CMODE1_bm = (1<<7)            ; Communication Mode bit 1 mask\n.equ USART_CMODE1_bp = 7                 ; Communication Mode bit 1 position\n.equ USART_UCPHA_bm = 0x02               ; SPI Master Mode, Clock Phase bit mask\n.equ USART_UCPHA_bp = 1                  ; SPI Master Mode, Clock Phase bit position\n.equ USART_UDORD_bm = 0x04               ; SPI Master Mode, Data Order bit mask\n.equ USART_UDORD_bp = 2                  ; SPI Master Mode, Data Order bit position\n.equ USART_CHSIZE_gm = 0x07              ; Character Size group mask\n.equ USART_CHSIZE_gp = 0                 ; Character Size group position\n.equ USART_CHSIZE0_bm = (1<<0)           ; Character Size bit 0 mask\n.equ USART_CHSIZE0_bp = 0                ; Character Size bit 0 position\n.equ USART_CHSIZE1_bm = (1<<1)           ; Character Size bit 1 mask\n.equ USART_CHSIZE1_bp = 1                ; Character Size bit 1 position\n.equ USART_CHSIZE2_bm = (1<<2)           ; Character Size bit 2 mask\n.equ USART_CHSIZE2_bp = 2                ; Character Size bit 2 position\n; Masks for USART_CMODE already defined\n.equ USART_PMODE_gm = 0x30               ; Parity Mode group mask\n.equ USART_PMODE_gp = 4                  ; Parity Mode group position\n.equ USART_PMODE0_bm = (1<<4)            ; Parity Mode bit 0 mask\n.equ USART_PMODE0_bp = 4                 ; Parity Mode bit 0 position\n.equ USART_PMODE1_bm = (1<<5)            ; Parity Mode bit 1 mask\n.equ USART_PMODE1_bp = 5                 ; Parity Mode bit 1 position\n.equ USART_SBMODE_bm = 0x08              ; Stop Bit Mode bit mask\n.equ USART_SBMODE_bp = 3                 ; Stop Bit Mode bit position\n\n; USART_DBGCTRL masks\n.equ USART_DBGRUN_bm = 0x01              ; Debug Run bit mask\n.equ USART_DBGRUN_bp = 0                 ; Debug Run bit position\n\n; USART_EVCTRL masks\n.equ USART_IREI_bm = 0x01                ; IrDA Event Input Enable bit mask\n.equ USART_IREI_bp = 0                   ; IrDA Event Input Enable bit position\n\n; USART_RXDATAH masks\n.equ USART_BUFOVF_bm = 0x40              ; Buffer Overflow bit mask\n.equ USART_BUFOVF_bp = 6                 ; Buffer Overflow bit position\n.equ USART_DATA8_bm = 0x01               ; Receiver Data Register bit mask\n.equ USART_DATA8_bp = 0                  ; Receiver Data Register bit position\n.equ USART_FERR_bm = 0x04                ; Frame Error bit mask\n.equ USART_FERR_bp = 2                   ; Frame Error bit position\n.equ USART_PERR_bm = 0x02                ; Parity Error bit mask\n.equ USART_PERR_bp = 1                   ; Parity Error bit position\n.equ USART_RXCIF_bm = 0x80               ; Receive Complete Interrupt Flag bit mask\n.equ USART_RXCIF_bp = 7                  ; Receive Complete Interrupt Flag bit position\n\n; USART_RXDATAL masks\n.equ USART_DATA_gm = 0xFF                ; RX Data group mask\n.equ USART_DATA_gp = 0                   ; RX Data group position\n.equ USART_DATA0_bm = (1<<0)             ; RX Data bit 0 mask\n.equ USART_DATA0_bp = 0                  ; RX Data bit 0 position\n.equ USART_DATA1_bm = (1<<1)             ; RX Data bit 1 mask\n.equ USART_DATA1_bp = 1                  ; RX Data bit 1 position\n.equ USART_DATA2_bm = (1<<2)             ; RX Data bit 2 mask\n.equ USART_DATA2_bp = 2                  ; RX Data bit 2 position\n.equ USART_DATA3_bm = (1<<3)             ; RX Data bit 3 mask\n.equ USART_DATA3_bp = 3                  ; RX Data bit 3 position\n.equ USART_DATA4_bm = (1<<4)             ; RX Data bit 4 mask\n.equ USART_DATA4_bp = 4                  ; RX Data bit 4 position\n.equ USART_DATA5_bm = (1<<5)             ; RX Data bit 5 mask\n.equ USART_DATA5_bp = 5                  ; RX Data bit 5 position\n.equ USART_DATA6_bm = (1<<6)             ; RX Data bit 6 mask\n.equ USART_DATA6_bp = 6                  ; RX Data bit 6 position\n.equ USART_DATA7_bm = (1<<7)             ; RX Data bit 7 mask\n.equ USART_DATA7_bp = 7                  ; RX Data bit 7 position\n\n; USART_RXPLCTRL masks\n.equ USART_RXPL_gm = 0x7F                ; Receiver Pulse Lenght group mask\n.equ USART_RXPL_gp = 0                   ; Receiver Pulse Lenght group position\n.equ USART_RXPL0_bm = (1<<0)             ; Receiver Pulse Lenght bit 0 mask\n.equ USART_RXPL0_bp = 0                  ; Receiver Pulse Lenght bit 0 position\n.equ USART_RXPL1_bm = (1<<1)             ; Receiver Pulse Lenght bit 1 mask\n.equ USART_RXPL1_bp = 1                  ; Receiver Pulse Lenght bit 1 position\n.equ USART_RXPL2_bm = (1<<2)             ; Receiver Pulse Lenght bit 2 mask\n.equ USART_RXPL2_bp = 2                  ; Receiver Pulse Lenght bit 2 position\n.equ USART_RXPL3_bm = (1<<3)             ; Receiver Pulse Lenght bit 3 mask\n.equ USART_RXPL3_bp = 3                  ; Receiver Pulse Lenght bit 3 position\n.equ USART_RXPL4_bm = (1<<4)             ; Receiver Pulse Lenght bit 4 mask\n.equ USART_RXPL4_bp = 4                  ; Receiver Pulse Lenght bit 4 position\n.equ USART_RXPL5_bm = (1<<5)             ; Receiver Pulse Lenght bit 5 mask\n.equ USART_RXPL5_bp = 5                  ; Receiver Pulse Lenght bit 5 position\n.equ USART_RXPL6_bm = (1<<6)             ; Receiver Pulse Lenght bit 6 mask\n.equ USART_RXPL6_bp = 6                  ; Receiver Pulse Lenght bit 6 position\n\n; USART_STATUS masks\n.equ USART_BDF_bm = 0x02                 ; Break Detected Flag bit mask\n.equ USART_BDF_bp = 1                    ; Break Detected Flag bit position\n.equ USART_DREIF_bm = 0x20               ; Data Register Empty Flag bit mask\n.equ USART_DREIF_bp = 5                  ; Data Register Empty Flag bit position\n.equ USART_ISFIF_bm = 0x08               ; Inconsistent Sync Field Interrupt Flag bit mask\n.equ USART_ISFIF_bp = 3                  ; Inconsistent Sync Field Interrupt Flag bit position\n; Masks for USART_RXCIF already defined\n.equ USART_RXSIF_bm = 0x10               ; Receive Start Interrupt bit mask\n.equ USART_RXSIF_bp = 4                  ; Receive Start Interrupt bit position\n.equ USART_TXCIF_bm = 0x40               ; Transmit Interrupt Flag bit mask\n.equ USART_TXCIF_bp = 6                  ; Transmit Interrupt Flag bit position\n.equ USART_WFB_bm = 0x01                 ; Wait For Break bit mask\n.equ USART_WFB_bp = 0                    ; Wait For Break bit position\n\n; USART_TXDATAH masks\n; Masks for USART_DATA8 already defined\n\n; USART_TXDATAL masks\n; Masks for USART_DATA already defined\n\n; USART_TXPLCTRL masks\n.equ USART_TXPL_gm = 0xFF                ; Transmit pulse length group mask\n.equ USART_TXPL_gp = 0                   ; Transmit pulse length group position\n.equ USART_TXPL0_bm = (1<<0)             ; Transmit pulse length bit 0 mask\n.equ USART_TXPL0_bp = 0                  ; Transmit pulse length bit 0 position\n.equ USART_TXPL1_bm = (1<<1)             ; Transmit pulse length bit 1 mask\n.equ USART_TXPL1_bp = 1                  ; Transmit pulse length bit 1 position\n.equ USART_TXPL2_bm = (1<<2)             ; Transmit pulse length bit 2 mask\n.equ USART_TXPL2_bp = 2                  ; Transmit pulse length bit 2 position\n.equ USART_TXPL3_bm = (1<<3)             ; Transmit pulse length bit 3 mask\n.equ USART_TXPL3_bp = 3                  ; Transmit pulse length bit 3 position\n.equ USART_TXPL4_bm = (1<<4)             ; Transmit pulse length bit 4 mask\n.equ USART_TXPL4_bp = 4                  ; Transmit pulse length bit 4 position\n.equ USART_TXPL5_bm = (1<<5)             ; Transmit pulse length bit 5 mask\n.equ USART_TXPL5_bp = 5                  ; Transmit pulse length bit 5 position\n.equ USART_TXPL6_bm = (1<<6)             ; Transmit pulse length bit 6 mask\n.equ USART_TXPL6_bp = 6                  ; Transmit pulse length bit 6 position\n.equ USART_TXPL7_bm = (1<<7)             ; Transmit pulse length bit 7 mask\n.equ USART_TXPL7_bp = 7                  ; Transmit pulse length bit 7 position\n\n; RS485 Mode internal transmitter select\n.equ USART_RS485_OFF_gc = (0x00<<0)      ; RS485 Mode disabled\n.equ USART_RS485_EXT_gc = (0x01<<0)      ; RS485 Mode External drive\n.equ USART_RS485_INT_gc = (0x02<<0)      ; RS485 Mode Internal drive\n\n; Receiver Mode select\n.equ USART_RXMODE_NORMAL_gc = (0x00<<1)  ; Normal mode\n.equ USART_RXMODE_CLK2X_gc = (0x01<<1)   ; CLK2x mode\n.equ USART_RXMODE_GENAUTO_gc = (0x02<<1) ; Generic autobaud mode\n.equ USART_RXMODE_LINAUTO_gc = (0x03<<1) ; LIN constrained autobaud mode\n\n; Communication Mode select\n.equ USART_MSPI_CMODE_ASYNCHRONOUS_gc = (0x00<<6) ; Asynchronous Mode\n.equ USART_MSPI_CMODE_SYNCHRONOUS_gc = (0x01<<6) ; Synchronous Mode\n.equ USART_MSPI_CMODE_IRCOM_gc = (0x02<<6) ; Infrared Communication\n.equ USART_MSPI_CMODE_MSPI_gc = (0x03<<6) ; Master SPI Mode\n\n; Character Size select\n.equ USART_NORMAL_CHSIZE_5BIT_gc = (0x00<<0) ; Character size: 5 bit\n.equ USART_NORMAL_CHSIZE_6BIT_gc = (0x01<<0) ; Character size: 6 bit\n.equ USART_NORMAL_CHSIZE_7BIT_gc = (0x02<<0) ; Character size: 7 bit\n.equ USART_NORMAL_CHSIZE_8BIT_gc = (0x03<<0) ; Character size: 8 bit\n.equ USART_NORMAL_CHSIZE_9BITL_gc = (0x06<<0) ; Character size: 9 bit read low byte first\n.equ USART_NORMAL_CHSIZE_9BITH_gc = (0x07<<0) ; Character size: 9 bit read high byte first\n\n; Communication Mode select\n.equ USART_NORMAL_CMODE_ASYNCHRONOUS_gc = (0x00<<6) ; Asynchronous Mode\n.equ USART_NORMAL_CMODE_SYNCHRONOUS_gc = (0x01<<6) ; Synchronous Mode\n.equ USART_NORMAL_CMODE_IRCOM_gc = (0x02<<6) ; Infrared Communication\n.equ USART_NORMAL_CMODE_MSPI_gc = (0x03<<6) ; Master SPI Mode\n\n; Parity Mode select\n.equ USART_NORMAL_PMODE_DISABLED_gc = (0x00<<4) ; No Parity\n.equ USART_NORMAL_PMODE_EVEN_gc = (0x02<<4) ; Even Parity\n.equ USART_NORMAL_PMODE_ODD_gc = (0x03<<4) ; Odd Parity\n\n; Stop Bit Mode select\n.equ USART_NORMAL_SBMODE_1BIT_gc = (0x00<<3) ; 1 stop bit\n.equ USART_NORMAL_SBMODE_2BIT_gc = (0x01<<3) ; 2 stop bits\n\n\n;*************************************************************************\n;** USERROW - User Row\n;*************************************************************************\n\n\n;*************************************************************************\n;** VPORT - Virtual Ports\n;*************************************************************************\n\n; VPORT_INTFLAGS masks\n.equ VPORT_INT_gm = 0xFF                 ; Pin Interrupt group mask\n.equ VPORT_INT_gp = 0                    ; Pin Interrupt group position\n.equ VPORT_INT0_bm = (1<<0)              ; Pin Interrupt bit 0 mask\n.equ VPORT_INT0_bp = 0                   ; Pin Interrupt bit 0 position\n.equ VPORT_INT1_bm = (1<<1)              ; Pin Interrupt bit 1 mask\n.equ VPORT_INT1_bp = 1                   ; Pin Interrupt bit 1 position\n.equ VPORT_INT2_bm = (1<<2)              ; Pin Interrupt bit 2 mask\n.equ VPORT_INT2_bp = 2                   ; Pin Interrupt bit 2 position\n.equ VPORT_INT3_bm = (1<<3)              ; Pin Interrupt bit 3 mask\n.equ VPORT_INT3_bp = 3                   ; Pin Interrupt bit 3 position\n.equ VPORT_INT4_bm = (1<<4)              ; Pin Interrupt bit 4 mask\n.equ VPORT_INT4_bp = 4                   ; Pin Interrupt bit 4 position\n.equ VPORT_INT5_bm = (1<<5)              ; Pin Interrupt bit 5 mask\n.equ VPORT_INT5_bp = 5                   ; Pin Interrupt bit 5 position\n.equ VPORT_INT6_bm = (1<<6)              ; Pin Interrupt bit 6 mask\n.equ VPORT_INT6_bp = 6                   ; Pin Interrupt bit 6 position\n.equ VPORT_INT7_bm = (1<<7)              ; Pin Interrupt bit 7 mask\n.equ VPORT_INT7_bp = 7                   ; Pin Interrupt bit 7 position\n\n\n;*************************************************************************\n;** VREF - Voltage reference\n;*************************************************************************\n\n; VREF_CTRLA masks\n.equ VREF_ADC0REFSEL_gm = 0x70           ; ADC0 reference select group mask\n.equ VREF_ADC0REFSEL_gp = 4              ; ADC0 reference select group position\n.equ VREF_ADC0REFSEL0_bm = (1<<4)        ; ADC0 reference select bit 0 mask\n.equ VREF_ADC0REFSEL0_bp = 4             ; ADC0 reference select bit 0 position\n.equ VREF_ADC0REFSEL1_bm = (1<<5)        ; ADC0 reference select bit 1 mask\n.equ VREF_ADC0REFSEL1_bp = 5             ; ADC0 reference select bit 1 position\n.equ VREF_ADC0REFSEL2_bm = (1<<6)        ; ADC0 reference select bit 2 mask\n.equ VREF_ADC0REFSEL2_bp = 6             ; ADC0 reference select bit 2 position\n.equ VREF_DAC0REFSEL_gm = 0x07           ; DAC0/AC0 reference select group mask\n.equ VREF_DAC0REFSEL_gp = 0              ; DAC0/AC0 reference select group position\n.equ VREF_DAC0REFSEL0_bm = (1<<0)        ; DAC0/AC0 reference select bit 0 mask\n.equ VREF_DAC0REFSEL0_bp = 0             ; DAC0/AC0 reference select bit 0 position\n.equ VREF_DAC0REFSEL1_bm = (1<<1)        ; DAC0/AC0 reference select bit 1 mask\n.equ VREF_DAC0REFSEL1_bp = 1             ; DAC0/AC0 reference select bit 1 position\n.equ VREF_DAC0REFSEL2_bm = (1<<2)        ; DAC0/AC0 reference select bit 2 mask\n.equ VREF_DAC0REFSEL2_bp = 2             ; DAC0/AC0 reference select bit 2 position\n\n; VREF_CTRLB masks\n.equ VREF_ADC0REFEN_bm = 0x02            ; ADC0 reference enable bit mask\n.equ VREF_ADC0REFEN_bp = 1               ; ADC0 reference enable bit position\n.equ VREF_DAC0REFEN_bm = 0x01            ; DAC0/AC0 reference enable bit mask\n.equ VREF_DAC0REFEN_bp = 0               ; DAC0/AC0 reference enable bit position\n\n; ADC0 reference select select\n.equ VREF_ADC0REFSEL_0V55_gc = (0x00<<4) ; Voltage reference at 0.55V\n.equ VREF_ADC0REFSEL_1V1_gc = (0x01<<4)  ; Voltage reference at 1.1V\n.equ VREF_ADC0REFSEL_2V5_gc = (0x02<<4)  ; Voltage reference at 2.5V\n.equ VREF_ADC0REFSEL_4V34_gc = (0x03<<4) ; Voltage reference at 4.34V\n.equ VREF_ADC0REFSEL_1V5_gc = (0x04<<4)  ; Voltage reference at 1.5V\n\n; DAC0/AC0 reference select select\n.equ VREF_DAC0REFSEL_0V55_gc = (0x00<<0) ; Voltage reference at 0.55V\n.equ VREF_DAC0REFSEL_1V1_gc = (0x01<<0)  ; Voltage reference at 1.1V\n.equ VREF_DAC0REFSEL_2V5_gc = (0x02<<0)  ; Voltage reference at 2.5V\n.equ VREF_DAC0REFSEL_4V34_gc = (0x03<<0) ; Voltage reference at 4.34V\n.equ VREF_DAC0REFSEL_1V5_gc = (0x04<<0)  ; Voltage reference at 1.5V\n\n\n;*************************************************************************\n;** WDT - Watch-Dog Timer\n;*************************************************************************\n\n; WDT_CTRLA masks\n.equ WDT_PERIOD_gm = 0x0F                ; Period group mask\n.equ WDT_PERIOD_gp = 0                   ; Period group position\n.equ WDT_PERIOD0_bm = (1<<0)             ; Period bit 0 mask\n.equ WDT_PERIOD0_bp = 0                  ; Period bit 0 position\n.equ WDT_PERIOD1_bm = (1<<1)             ; Period bit 1 mask\n.equ WDT_PERIOD1_bp = 1                  ; Period bit 1 position\n.equ WDT_PERIOD2_bm = (1<<2)             ; Period bit 2 mask\n.equ WDT_PERIOD2_bp = 2                  ; Period bit 2 position\n.equ WDT_PERIOD3_bm = (1<<3)             ; Period bit 3 mask\n.equ WDT_PERIOD3_bp = 3                  ; Period bit 3 position\n.equ WDT_WINDOW_gm = 0xF0                ; Window group mask\n.equ WDT_WINDOW_gp = 4                   ; Window group position\n.equ WDT_WINDOW0_bm = (1<<4)             ; Window bit 0 mask\n.equ WDT_WINDOW0_bp = 4                  ; Window bit 0 position\n.equ WDT_WINDOW1_bm = (1<<5)             ; Window bit 1 mask\n.equ WDT_WINDOW1_bp = 5                  ; Window bit 1 position\n.equ WDT_WINDOW2_bm = (1<<6)             ; Window bit 2 mask\n.equ WDT_WINDOW2_bp = 6                  ; Window bit 2 position\n.equ WDT_WINDOW3_bm = (1<<7)             ; Window bit 3 mask\n.equ WDT_WINDOW3_bp = 7                  ; Window bit 3 position\n\n; WDT_STATUS masks\n.equ WDT_LOCK_bm = 0x80                  ; Lock enable bit mask\n.equ WDT_LOCK_bp = 7                     ; Lock enable bit position\n.equ WDT_SYNCBUSY_bm = 0x01              ; Syncronization busy bit mask\n.equ WDT_SYNCBUSY_bp = 0                 ; Syncronization busy bit position\n\n; Period select\n.equ WDT_PERIOD_OFF_gc = (0x00<<0)       ; Watch-Dog timer Off\n.equ WDT_PERIOD_8CLK_gc = (0x01<<0)      ; 8 cycles (8ms)\n.equ WDT_PERIOD_16CLK_gc = (0x02<<0)     ; 16 cycles (16ms)\n.equ WDT_PERIOD_32CLK_gc = (0x03<<0)     ; 32 cycles (32ms)\n.equ WDT_PERIOD_64CLK_gc = (0x04<<0)     ; 64 cycles (64ms)\n.equ WDT_PERIOD_128CLK_gc = (0x05<<0)    ; 128 cycles (0.128s)\n.equ WDT_PERIOD_256CLK_gc = (0x06<<0)    ; 256 cycles (0.256s)\n.equ WDT_PERIOD_512CLK_gc = (0x07<<0)    ; 512 cycles (0.512s)\n.equ WDT_PERIOD_1KCLK_gc = (0x08<<0)     ; 1K cycles (1.0s)\n.equ WDT_PERIOD_2KCLK_gc = (0x09<<0)     ; 2K cycles (2.0s)\n.equ WDT_PERIOD_4KCLK_gc = (0x0A<<0)     ; 4K cycles (4.1s)\n.equ WDT_PERIOD_8KCLK_gc = (0x0B<<0)     ; 8K cycles (8.2s)\n\n; Window select\n.equ WDT_WINDOW_OFF_gc = (0x00<<4)       ; Window mode off\n.equ WDT_WINDOW_8CLK_gc = (0x01<<4)      ; 8 cycles (8ms)\n.equ WDT_WINDOW_16CLK_gc = (0x02<<4)     ; 16 cycles (16ms)\n.equ WDT_WINDOW_32CLK_gc = (0x03<<4)     ; 32 cycles (32ms)\n.equ WDT_WINDOW_64CLK_gc = (0x04<<4)     ; 64 cycles (64ms)\n.equ WDT_WINDOW_128CLK_gc = (0x05<<4)    ; 128 cycles (0.128s)\n.equ WDT_WINDOW_256CLK_gc = (0x06<<4)    ; 256 cycles (0.256s)\n.equ WDT_WINDOW_512CLK_gc = (0x07<<4)    ; 512 cycles (0.512s)\n.equ WDT_WINDOW_1KCLK_gc = (0x08<<4)     ; 1K cycles (1.0s)\n.equ WDT_WINDOW_2KCLK_gc = (0x09<<4)     ; 2K cycles (2.0s)\n.equ WDT_WINDOW_4KCLK_gc = (0x0A<<4)     ; 4K cycles (4.1s)\n.equ WDT_WINDOW_8KCLK_gc = (0x0B<<4)     ; 8K cycles (8.2s)\n\n\n\n\n; ***** CPU REGISTER DEFINITIONS *****************************************\n.def\tXH\t= r27\n.def\tXL\t= r26\n.def\tYH\t= r29\n.def\tYL\t= r28\n.def\tZH\t= r31\n.def\tZL\t= r30\n\n\n; ***** DATA MEMORY DECLARATIONS *****************************************\n\n\n#define DATAMEM_START 0x0000\n#define DATAMEM_SIZE 0x9000\n#define DATAMEM_END (0x0000 + 0x9000 - 1)\n\n#define EEPROM_START 0x1400\n#define EEPROM_SIZE 0x0080\n#define EEPROM_END (0x1400 + 0x0080 - 1)\n#define EEPROM_PAGE_SIZE 0x20\n\n#define FUSES_START 0x1280\n#define FUSES_SIZE 0x000A\n#define FUSES_END (0x1280 + 0x000A - 1)\n#define FUSES_PAGE_SIZE 0x20\n\n#define INTERNAL_SRAM_START 0x3F00\n#define INTERNAL_SRAM_SIZE 0x0100\n#define INTERNAL_SRAM_END (0x3F00 + 0x0100 - 1)\n\n#define IO_START 0x0000\n#define IO_SIZE 0x1100\n#define IO_END (0x0000 + 0x1100 - 1)\n\n#define LOCKBITS_START 0x128A\n#define LOCKBITS_SIZE 0x0001\n#define LOCKBITS_END (0x128A + 0x0001 - 1)\n#define LOCKBITS_PAGE_SIZE 0x20\n\n#define MAPPED_PROGMEM_START 0x8000\n#define MAPPED_PROGMEM_SIZE 0x1000\n#define MAPPED_PROGMEM_END (0x8000 + 0x1000 - 1)\n#define MAPPED_PROGMEM_PAGE_SIZE 0x40\n\n#define PROD_SIGNATURES_START 0x1103\n#define PROD_SIGNATURES_SIZE 0x003D\n#define PROD_SIGNATURES_END (0x1103 + 0x003D - 1)\n#define PROD_SIGNATURES_PAGE_SIZE 0x40\n\n#define SIGNATURES_START 0x1100\n#define SIGNATURES_SIZE 0x0003\n#define SIGNATURES_END (0x1100 + 0x0003 - 1)\n#define SIGNATURES_PAGE_SIZE 0x40\n\n#define USER_SIGNATURES_START 0x1300\n#define USER_SIGNATURES_SIZE 0x0020\n#define USER_SIGNATURES_END (0x1300 + 0x0020 - 1)\n#define USER_SIGNATURES_PAGE_SIZE 0x20\n\n#define PROGMEM_START 0x0000\n#define PROGMEM_SIZE 0x1000\n#define PROGMEM_END (0x0000 + 0x1000 - 1)\n#define PROGMEM_PAGE_SIZE 0x40\n\n\n; Legacy definitions\n.equ    FLASHSTART    = (PROGMEM_START / 2) ; Note: Word address\n.equ    FLASHEND      = (PROGMEM_END / 2) ; Note: Word address\n.equ    IOEND         = IO_END\n.equ    SRAM_START    = INTERNAL_SRAM_START\n.equ    SRAM_SIZE     = INTERNAL_SRAM_SIZE\n.equ    RAMEND        = INTERNAL_SRAM_END\n.equ    E2END         = EEPROM_END\n.equ    EEPROMEND     = EEPROM_END\n\n\n; Definitions used by the assembler\n#pragma AVRPART MEMORY PROG_FLASH 0x1000\n#pragma AVRPART MEMORY EEPROM 0x0080\n#pragma AVRPART MEMORY INT_SRAM SIZE 0x0100\n#pragma AVRPART MEMORY INT_SRAM START_ADDR 0x3F00\n\n; ***** INTERRUPT VECTORS, ABSOLUTE ADDRESSES ****************************\n\n; CRCSCAN interrupt vectors\n.equ CRCSCAN_NMI_vect = 0x0001           ; \n\n; BOD interrupt vectors\n.equ BOD_VLM_vect = 0x0002               ; \n\n; PORTA interrupt vectors\n.equ PORTA_PORT_vect = 0x0003            ; \n\n; RTC interrupt vectors\n.equ RTC_CNT_vect = 0x0006               ; \n.equ RTC_PIT_vect = 0x0007               ; \n\n; TCA0 interrupt vectors\n.equ TCA0_LUNF_vect = 0x0008             ; \n.equ TCA0_OVF_vect = 0x0008              ; \n.equ TCA0_HUNF_vect = 0x0009             ; \n.equ TCA0_CMP0_vect = 0x000A             ; \n.equ TCA0_LCMP0_vect = 0x000A            ; \n.equ TCA0_CMP1_vect = 0x000B             ; \n.equ TCA0_LCMP1_vect = 0x000B            ; \n.equ TCA0_CMP2_vect = 0x000C             ; \n.equ TCA0_LCMP2_vect = 0x000C            ; \n\n; TCB0 interrupt vectors\n.equ TCB0_INT_vect = 0x000D              ; \n\n; TCD0 interrupt vectors\n.equ TCD0_OVF_vect = 0x000E              ; \n.equ TCD0_TRIG_vect = 0x000F             ; \n\n; AC0 interrupt vectors\n.equ AC0_AC_vect = 0x0010                ; \n\n; ADC0 interrupt vectors\n.equ ADC0_RESRDY_vect = 0x0011           ; \n.equ ADC0_WCOMP_vect = 0x0012            ; \n\n; TWI0 interrupt vectors\n.equ TWI0_TWIS_vect = 0x0013             ; \n.equ TWI0_TWIM_vect = 0x0014             ; \n\n; SPI0 interrupt vectors\n.equ SPI0_INT_vect = 0x0015              ; \n\n; USART0 interrupt vectors\n.equ USART0_RXC_vect = 0x0016            ; \n.equ USART0_DRE_vect = 0x0017            ; \n.equ USART0_TXC_vect = 0x0018            ; \n\n; NVMCTRL interrupt vectors\n.equ NVMCTRL_EE_vect = 0x0019            ; \n\n\n\n; ***** INTERRUPT VECTORS, MODULE BASES **********************************\n\n.equ CRCSCAN_vbase = 0x0001\n.equ BOD_vbase = 0x0002\n.equ PORTA_vbase = 0x0003\n.equ RTC_vbase = 0x0006\n.equ TCA0_vbase = 0x0008\n.equ TCB0_vbase = 0x000D\n.equ TCD0_vbase = 0x000E\n.equ AC0_vbase = 0x0010\n.equ ADC0_vbase = 0x0011\n.equ TWI0_vbase = 0x0013\n.equ SPI0_vbase = 0x0015\n.equ USART0_vbase = 0x0016\n.equ NVMCTRL_vbase = 0x0019\n\n\n; ***** INTERRUPT VECTORS, VECTOR OFFSETS ********************************\n\n; CRCSCAN interrupt vector offsets\n\n.equ CRCSCAN_NMI_voffset = 0\n\n; BOD interrupt vector offsets\n\n.equ BOD_VLM_voffset = 0\n\n; PORTA interrupt vector offsets\n\n.equ PORTA_PORT_voffset = 0\n\n; RTC interrupt vector offsets\n\n.equ RTC_CNT_voffset = 0\n.equ RTC_PIT_voffset = 1\n\n; TCA0 interrupt vector offsets\n\n.equ TCA0_LUNF_voffset = 0\n.equ TCA0_OVF_voffset = 0\n.equ TCA0_HUNF_voffset = 1\n.equ TCA0_CMP0_voffset = 2\n.equ TCA0_LCMP0_voffset = 2\n.equ TCA0_CMP1_voffset = 3\n.equ TCA0_LCMP1_voffset = 3\n.equ TCA0_CMP2_voffset = 4\n.equ TCA0_LCMP2_voffset = 4\n\n; TCB0 interrupt vector offsets\n\n.equ TCB0_INT_voffset = 0\n\n; TCD0 interrupt vector offsets\n\n.equ TCD0_OVF_voffset = 0\n.equ TCD0_TRIG_voffset = 1\n\n; AC0 interrupt vector offsets\n\n.equ AC0_AC_voffset = 0\n\n; ADC0 interrupt vector offsets\n\n.equ ADC0_RESRDY_voffset = 0\n.equ ADC0_WCOMP_voffset = 1\n\n; TWI0 interrupt vector offsets\n\n.equ TWI0_TWIS_voffset = 0\n.equ TWI0_TWIM_voffset = 1\n\n; SPI0 interrupt vector offsets\n\n.equ SPI0_INT_voffset = 0\n\n; USART0 interrupt vector offsets\n\n.equ USART0_RXC_voffset = 0\n.equ USART0_DRE_voffset = 1\n.equ USART0_TXC_voffset = 2\n\n; NVMCTRL interrupt vector offsets\n\n.equ NVMCTRL_EE_voffset = 0\n\n\n\n.equ INT_VECTORS_SIZE = 26 ; size in words\n\n\n#endif /* _TN412DEF_INC_ */\n\n; ***** END OF FILE ******************************************************\n\n\n\n","inc/tn814def.inc":";***** THIS IS A MACHINE GENERATED FILE - DO NOT EDIT ********************\n\n;*************************************************************************\n;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y\n;*\n;* Number            : AVR000\n;* File Name         : tn814def.inc\n;* Title             : Register/Bit Definitions for the ATtiny814\n;* Created           : 2021-07-13 10:42\n;* Version           : 1.00\n;* Support e-mail    : avr@atmel.com\n;* Target MCU        : ATtiny814\n;*\n;* DESCRIPTION\n;* When including this file in the assembly program file, all I/O register\n;* names and I/O register bit names appearing in the data book can be used.\n;* In addition, the six registers forming the three data pointers X, Y and\n;* Z have been assigned names XL - ZH. Highest RAM address for Internal\n;* SRAM is also defined\n;*\n;*************************************************************************\n\n#ifndef _TN814DEF_INC_\n#define _TN814DEF_INC_\n\n\n#pragma partinc 0\n\n; ***** SPECIFY DEVICE ***************************************************\n.device\tATtiny814\n\n#pragma AVRPART ADMIN PART_NAME ATtiny814\n\n.equ\tSIGNATURE_000\t= 0x1E\n.equ\tSIGNATURE_001\t= 0x93\n.equ\tSIGNATURE_002\t= 0x22\n\n#pragma AVRPART CORE CORE_VERSION V4\n\n\n; ***** ABSOLUTE I/O REGISTER LOCATIONS **********************************\n\n\n;*************************************************************************\n;** AC0 - Analog Comparator\n;*************************************************************************\n\n.equ AC0_CTRLA = 0x0670                  ; Control A\n.equ AC0_MUXCTRLA = 0x0672               ; Mux Control A\n.equ AC0_INTCTRL = 0x0676                ; Interrupt Control\n.equ AC0_STATUS = 0x0677                 ; Status\n\n;*************************************************************************\n;** ADC0 - Analog to Digital Converter\n;*************************************************************************\n\n.equ ADC0_CTRLA = 0x0600                 ; Control A\n.equ ADC0_CTRLB = 0x0601                 ; Control B\n.equ ADC0_CTRLC = 0x0602                 ; Control C\n.equ ADC0_CTRLD = 0x0603                 ; Control D\n.equ ADC0_CTRLE = 0x0604                 ; Control E\n.equ ADC0_SAMPCTRL = 0x0605              ; Sample Control\n.equ ADC0_MUXPOS = 0x0606                ; Positive mux input\n.equ ADC0_COMMAND = 0x0608               ; Command\n.equ ADC0_EVCTRL = 0x0609                ; Event Control\n.equ ADC0_INTCTRL = 0x060A               ; Interrupt Control\n.equ ADC0_INTFLAGS = 0x060B              ; Interrupt Flags\n.equ ADC0_DBGCTRL = 0x060C               ; Debug Control\n.equ ADC0_TEMP = 0x060D                  ; Temporary Data\n.equ ADC0_RES = 0x0610                   ; ADC Accumulator Result\n.equ ADC0_RESL = 0x0610                  ; ADC Accumulator Result low byte\n.equ ADC0_RESH = 0x0611                  ; ADC Accumulator Result hi byte\n.equ ADC0_WINLT = 0x0612                 ; Window comparator low threshold\n.equ ADC0_WINLTL = 0x0612                ; Window comparator low threshold low byte\n.equ ADC0_WINLTH = 0x0613                ; Window comparator low threshold hi byte\n.equ ADC0_WINHT = 0x0614                 ; Window comparator high threshold\n.equ ADC0_WINHTL = 0x0614                ; Window comparator high threshold low byte\n.equ ADC0_WINHTH = 0x0615                ; Window comparator high threshold hi byte\n.equ ADC0_CALIB = 0x0616                 ; Calibration\n\n;*************************************************************************\n;** BOD - Bod interface\n;*************************************************************************\n\n.equ BOD_CTRLA = 0x0080                  ; Control A\n.equ BOD_CTRLB = 0x0081                  ; Control B\n.equ BOD_VLMCTRLA = 0x0088               ; Voltage level monitor Control\n.equ BOD_INTCTRL = 0x0089                ; Voltage level monitor interrupt Control\n.equ BOD_INTFLAGS = 0x008A               ; Voltage level monitor interrupt Flags\n.equ BOD_STATUS = 0x008B                 ; Voltage level monitor status\n\n;*************************************************************************\n;** CCL - Configurable Custom Logic\n;*************************************************************************\n\n.equ CCL_CTRLA = 0x01C0                  ; Control Register A\n.equ CCL_SEQCTRL0 = 0x01C1               ; Sequential Control 0\n.equ CCL_LUT0CTRLA = 0x01C5              ; LUT Control 0 A\n.equ CCL_LUT0CTRLB = 0x01C6              ; LUT Control 0 B\n.equ CCL_LUT0CTRLC = 0x01C7              ; LUT Control 0 C\n.equ CCL_TRUTH0 = 0x01C8                 ; Truth 0\n.equ CCL_LUT1CTRLA = 0x01C9              ; LUT Control 1 A\n.equ CCL_LUT1CTRLB = 0x01CA              ; LUT Control 1 B\n.equ CCL_LUT1CTRLC = 0x01CB              ; LUT Control 1 C\n.equ CCL_TRUTH1 = 0x01CC                 ; Truth 1\n\n;*************************************************************************\n;** CLKCTRL - Clock controller\n;*************************************************************************\n\n.equ CLKCTRL_MCLKCTRLA = 0x0060          ; MCLK Control A\n.equ CLKCTRL_MCLKCTRLB = 0x0061          ; MCLK Control B\n.equ CLKCTRL_MCLKLOCK = 0x0062           ; MCLK Lock\n.equ CLKCTRL_MCLKSTATUS = 0x0063         ; MCLK Status\n.equ CLKCTRL_OSC20MCTRLA = 0x0070        ; OSC20M Control A\n.equ CLKCTRL_OSC20MCALIBA = 0x0071       ; OSC20M Calibration A\n.equ CLKCTRL_OSC20MCALIBB = 0x0072       ; OSC20M Calibration B\n.equ CLKCTRL_OSC32KCTRLA = 0x0078        ; OSC32K Control A\n.equ CLKCTRL_XOSC32KCTRLA = 0x007C       ; XOSC32K Control A\n\n;*************************************************************************\n;** CPU - CPU\n;*************************************************************************\n\n.equ CPU_CCP = 0x0034                    ; Configuration Change Protection\n.equ CPU_SPL = 0x003D                    ; Stack Pointer Low\n.equ CPU_SPH = 0x003E                    ; Stack Pointer High\n.equ CPU_SREG = 0x003F                   ; Status Register\n\n;*************************************************************************\n;** CPUINT - Interrupt Controller\n;*************************************************************************\n\n.equ CPUINT_CTRLA = 0x0110               ; Control A\n.equ CPUINT_STATUS = 0x0111              ; Status\n.equ CPUINT_LVL0PRI = 0x0112             ; Interrupt Level 0 Priority\n.equ CPUINT_LVL1VEC = 0x0113             ; Interrupt Level 1 Priority Vector\n\n;*************************************************************************\n;** CRCSCAN - CRCSCAN\n;*************************************************************************\n\n.equ CRCSCAN_CTRLA = 0x0120              ; Control A\n.equ CRCSCAN_CTRLB = 0x0121              ; Control B\n.equ CRCSCAN_STATUS = 0x0122             ; Status\n\n;*************************************************************************\n;** DAC0 - Digital to Analog Converter\n;*************************************************************************\n\n.equ DAC0_CTRLA = 0x0680                 ; Control Register A\n.equ DAC0_DATA = 0x0681                  ; DATA Register\n\n;*************************************************************************\n;** EVSYS - Event System\n;*************************************************************************\n\n.equ EVSYS_ASYNCSTROBE = 0x0180          ; Asynchronous Channel Strobe\n.equ EVSYS_SYNCSTROBE = 0x0181           ; Synchronous Channel Strobe\n.equ EVSYS_ASYNCCH0 = 0x0182             ; Asynchronous Channel 0 Generator Selection\n.equ EVSYS_ASYNCCH1 = 0x0183             ; Asynchronous Channel 1 Generator Selection\n.equ EVSYS_ASYNCCH2 = 0x0184             ; Asynchronous Channel 2 Generator Selection\n.equ EVSYS_ASYNCCH3 = 0x0185             ; Asynchronous Channel 3 Generator Selection\n.equ EVSYS_SYNCCH0 = 0x018A              ; Synchronous Channel 0 Generator Selection\n.equ EVSYS_SYNCCH1 = 0x018B              ; Synchronous Channel 1 Generator Selection\n.equ EVSYS_ASYNCUSER0 = 0x0192           ; Asynchronous User Ch 0 Input Selection - TCB0\n.equ EVSYS_ASYNCUSER1 = 0x0193           ; Asynchronous User Ch 1 Input Selection - ADC0\n.equ EVSYS_ASYNCUSER2 = 0x0194           ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0\n.equ EVSYS_ASYNCUSER3 = 0x0195           ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0\n.equ EVSYS_ASYNCUSER4 = 0x0196           ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1\n.equ EVSYS_ASYNCUSER5 = 0x0197           ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1\n.equ EVSYS_ASYNCUSER6 = 0x0198           ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0\n.equ EVSYS_ASYNCUSER7 = 0x0199           ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1\n.equ EVSYS_ASYNCUSER8 = 0x019A           ; Asynchronous User Ch 8 Input Selection - Event Out 0\n.equ EVSYS_ASYNCUSER9 = 0x019B           ; Asynchronous User Ch 9 Input Selection - Event Out 1\n.equ EVSYS_ASYNCUSER10 = 0x019C          ; Asynchronous User Ch 10 Input Selection - Event Out 2\n.equ EVSYS_SYNCUSER0 = 0x01A2            ; Synchronous User Ch 0 Input Selection - TCA0\n.equ EVSYS_SYNCUSER1 = 0x01A3            ; Synchronous User Ch 1 Input Selection - USART0\n\n;*************************************************************************\n;** FUSE - Fuses\n;*************************************************************************\n\n.equ FUSE_WDTCFG = 0x1280                ; Watchdog Configuration\n.equ FUSE_BODCFG = 0x1281                ; BOD Configuration\n.equ FUSE_OSCCFG = 0x1282                ; Oscillator Configuration\n.equ FUSE_TCD0CFG = 0x1284               ; TCD0 Configuration\n.equ FUSE_SYSCFG0 = 0x1285               ; System Configuration 0\n.equ FUSE_SYSCFG1 = 0x1286               ; System Configuration 1\n.equ FUSE_APPEND = 0x1287                ; Application Code Section End\n.equ FUSE_BOOTEND = 0x1288               ; Boot Section End\n\n;*************************************************************************\n;** GPIO - General Purpose IO\n;*************************************************************************\n\n.equ GPIO_GPIOR0 = 0x001C                ; General Purpose IO Register 0\n.equ GPIO_GPIOR1 = 0x001D                ; General Purpose IO Register 1\n.equ GPIO_GPIOR2 = 0x001E                ; General Purpose IO Register 2\n.equ GPIO_GPIOR3 = 0x001F                ; General Purpose IO Register 3\n\n;*************************************************************************\n;** LOCKBIT - Lockbit\n;*************************************************************************\n\n.equ LOCKBIT_LOCKBIT = 0x128A            ; Lock bits\n\n;*************************************************************************\n;** NVMCTRL - Non-volatile Memory Controller\n;*************************************************************************\n\n.equ NVMCTRL_CTRLA = 0x1000              ; Control A\n.equ NVMCTRL_CTRLB = 0x1001              ; Control B\n.equ NVMCTRL_STATUS = 0x1002             ; Status\n.equ NVMCTRL_INTCTRL = 0x1003            ; Interrupt Control\n.equ NVMCTRL_INTFLAGS = 0x1004           ; Interrupt Flags\n.equ NVMCTRL_DATA = 0x1006               ; Data\n.equ NVMCTRL_DATAL = 0x1006              ; Data low byte\n.equ NVMCTRL_DATAH = 0x1007              ; Data hi byte\n.equ NVMCTRL_ADDR = 0x1008               ; Address\n.equ NVMCTRL_ADDRL = 0x1008              ; Address low byte\n.equ NVMCTRL_ADDRH = 0x1009              ; Address hi byte\n\n;*************************************************************************\n;** PORTA - I/O Ports\n;*************************************************************************\n\n.equ PORTA_DIR = 0x0400                  ; Data Direction\n.equ PORTA_DIRSET = 0x0401               ; Data Direction Set\n.equ PORTA_DIRCLR = 0x0402               ; Data Direction Clear\n.equ PORTA_DIRTGL = 0x0403               ; Data Direction Toggle\n.equ PORTA_OUT = 0x0404                  ; Output Value\n.equ PORTA_OUTSET = 0x0405               ; Output Value Set\n.equ PORTA_OUTCLR = 0x0406               ; Output Value Clear\n.equ PORTA_OUTTGL = 0x0407               ; Output Value Toggle\n.equ PORTA_IN = 0x0408                   ; Input Value\n.equ PORTA_INTFLAGS = 0x0409             ; Interrupt Flags\n.equ PORTA_PIN0CTRL = 0x0410             ; Pin 0 Control\n.equ PORTA_PIN1CTRL = 0x0411             ; Pin 1 Control\n.equ PORTA_PIN2CTRL = 0x0412             ; Pin 2 Control\n.equ PORTA_PIN3CTRL = 0x0413             ; Pin 3 Control\n.equ PORTA_PIN4CTRL = 0x0414             ; Pin 4 Control\n.equ PORTA_PIN5CTRL = 0x0415             ; Pin 5 Control\n.equ PORTA_PIN6CTRL = 0x0416             ; Pin 6 Control\n.equ PORTA_PIN7CTRL = 0x0417             ; Pin 7 Control\n\n;*************************************************************************\n;** PORTB - I/O Ports\n;*************************************************************************\n\n.equ PORTB_DIR = 0x0420                  ; Data Direction\n.equ PORTB_DIRSET = 0x0421               ; Data Direction Set\n.equ PORTB_DIRCLR = 0x0422               ; Data Direction Clear\n.equ PORTB_DIRTGL = 0x0423               ; Data Direction Toggle\n.equ PORTB_OUT = 0x0424                  ; Output Value\n.equ PORTB_OUTSET = 0x0425               ; Output Value Set\n.equ PORTB_OUTCLR = 0x0426               ; Output Value Clear\n.equ PORTB_OUTTGL = 0x0427               ; Output Value Toggle\n.equ PORTB_IN = 0x0428                   ; Input Value\n.equ PORTB_INTFLAGS = 0x0429             ; Interrupt Flags\n.equ PORTB_PIN0CTRL = 0x0430             ; Pin 0 Control\n.equ PORTB_PIN1CTRL = 0x0431             ; Pin 1 Control\n.equ PORTB_PIN2CTRL = 0x0432             ; Pin 2 Control\n.equ PORTB_PIN3CTRL = 0x0433             ; Pin 3 Control\n.equ PORTB_PIN4CTRL = 0x0434             ; Pin 4 Control\n.equ PORTB_PIN5CTRL = 0x0435             ; Pin 5 Control\n.equ PORTB_PIN6CTRL = 0x0436             ; Pin 6 Control\n.equ PORTB_PIN7CTRL = 0x0437             ; Pin 7 Control\n\n;*************************************************************************\n;** PORTMUX - Port Multiplexer\n;*************************************************************************\n\n.equ PORTMUX_CTRLA = 0x0200              ; Port Multiplexer Control A\n.equ PORTMUX_CTRLB = 0x0201              ; Port Multiplexer Control B\n.equ PORTMUX_CTRLC = 0x0202              ; Port Multiplexer Control C\n.equ PORTMUX_CTRLD = 0x0203              ; Port Multiplexer Control D\n\n;*************************************************************************\n;** RSTCTRL - Reset controller\n;*************************************************************************\n\n.equ RSTCTRL_RSTFR = 0x0040              ; Reset Flags\n.equ RSTCTRL_SWRR = 0x0041               ; Software Reset\n\n;*************************************************************************\n;** RTC - Real-Time Counter\n;*************************************************************************\n\n.equ RTC_CTRLA = 0x0140                  ; Control A\n.equ RTC_STATUS = 0x0141                 ; Status\n.equ RTC_INTCTRL = 0x0142                ; Interrupt Control\n.equ RTC_INTFLAGS = 0x0143               ; Interrupt Flags\n.equ RTC_TEMP = 0x0144                   ; Temporary\n.equ RTC_DBGCTRL = 0x0145                ; Debug control\n.equ RTC_CLKSEL = 0x0147                 ; Clock Select\n.equ RTC_CNT = 0x0148                    ; Counter\n.equ RTC_CNTL = 0x0148                   ; Counter low byte\n.equ RTC_CNTH = 0x0149                   ; Counter hi byte\n.equ RTC_PER = 0x014A                    ; Period\n.equ RTC_PERL = 0x014A                   ; Period low byte\n.equ RTC_PERH = 0x014B                   ; Period hi byte\n.equ RTC_CMP = 0x014C                    ; Compare\n.equ RTC_CMPL = 0x014C                   ; Compare low byte\n.equ RTC_CMPH = 0x014D                   ; Compare hi byte\n.equ RTC_PITCTRLA = 0x0150               ; PIT Control A\n.equ RTC_PITSTATUS = 0x0151              ; PIT Status\n.equ RTC_PITINTCTRL = 0x0152             ; PIT Interrupt Control\n.equ RTC_PITINTFLAGS = 0x0153            ; PIT Interrupt Flags\n.equ RTC_PITDBGCTRL = 0x0155             ; PIT Debug control\n\n;*************************************************************************\n;** SIGROW - Signature row\n;*************************************************************************\n\n.equ SIGROW_DEVICEID0 = 0x1100           ; Device ID Byte 0\n.equ SIGROW_DEVICEID1 = 0x1101           ; Device ID Byte 1\n.equ SIGROW_DEVICEID2 = 0x1102           ; Device ID Byte 2\n.equ SIGROW_SERNUM0 = 0x1103             ; Serial Number Byte 0\n.equ SIGROW_SERNUM1 = 0x1104             ; Serial Number Byte 1\n.equ SIGROW_SERNUM2 = 0x1105             ; Serial Number Byte 2\n.equ SIGROW_SERNUM3 = 0x1106             ; Serial Number Byte 3\n.equ SIGROW_SERNUM4 = 0x1107             ; Serial Number Byte 4\n.equ SIGROW_SERNUM5 = 0x1108             ; Serial Number Byte 5\n.equ SIGROW_SERNUM6 = 0x1109             ; Serial Number Byte 6\n.equ SIGROW_SERNUM7 = 0x110A             ; Serial Number Byte 7\n.equ SIGROW_SERNUM8 = 0x110B             ; Serial Number Byte 8\n.equ SIGROW_SERNUM9 = 0x110C             ; Serial Number Byte 9\n.equ SIGROW_TEMPSENSE0 = 0x1120          ; Temperature Sensor Calibration Byte 0\n.equ SIGROW_TEMPSENSE1 = 0x1121          ; Temperature Sensor Calibration Byte 1\n.equ SIGROW_OSC16ERR3V = 0x1122          ; OSC16 error at 3V\n.equ SIGROW_OSC16ERR5V = 0x1123          ; OSC16 error at 5V\n.equ SIGROW_OSC20ERR3V = 0x1124          ; OSC20 error at 3V\n.equ SIGROW_OSC20ERR5V = 0x1125          ; OSC20 error at 5V\n\n;*************************************************************************\n;** SLPCTRL - Sleep Controller\n;*************************************************************************\n\n.equ SLPCTRL_CTRLA = 0x0050              ; Control\n\n;*************************************************************************\n;** SPI0 - Serial Peripheral Interface\n;*************************************************************************\n\n.equ SPI0_CTRLA = 0x0820                 ; Control A\n.equ SPI0_CTRLB = 0x0821                 ; Control B\n.equ SPI0_INTCTRL = 0x0822               ; Interrupt Control\n.equ SPI0_INTFLAGS = 0x0823              ; Interrupt Flags\n.equ SPI0_DATA = 0x0824                  ; Data\n\n;*************************************************************************\n;** SYSCFG - System Configuration Registers\n;*************************************************************************\n\n.equ SYSCFG_REVID = 0x0F01               ; Revision ID\n.equ SYSCFG_EXTBRK = 0x0F02              ; External Break\n\n;*************************************************************************\n;** TCA0 - 16-bit Timer/Counter Type A\n;*************************************************************************\n\n.equ TCA0_SINGLE_CTRLA = 0x0A00          ; SINGLE Control A\n.equ TCA0_SINGLE_CTRLB = 0x0A01          ; SINGLE Control B\n.equ TCA0_SINGLE_CTRLC = 0x0A02          ; SINGLE Control C\n.equ TCA0_SINGLE_CTRLD = 0x0A03          ; SINGLE Control D\n.equ TCA0_SINGLE_CTRLECLR = 0x0A04       ; SINGLE Control E Clear\n.equ TCA0_SINGLE_CTRLESET = 0x0A05       ; SINGLE Control E Set\n.equ TCA0_SINGLE_CTRLFCLR = 0x0A06       ; SINGLE Control F Clear\n.equ TCA0_SINGLE_CTRLFSET = 0x0A07       ; SINGLE Control F Set\n.equ TCA0_SINGLE_EVCTRL = 0x0A09         ; SINGLE Event Control\n.equ TCA0_SINGLE_INTCTRL = 0x0A0A        ; SINGLE Interrupt Control\n.equ TCA0_SINGLE_INTFLAGS = 0x0A0B       ; SINGLE Interrupt Flags\n.equ TCA0_SINGLE_DBGCTRL = 0x0A0E        ; SINGLE Degbug Control\n.equ TCA0_SINGLE_TEMP = 0x0A0F           ; SINGLE Temporary data for 16-bit Access\n.equ TCA0_SINGLE_CNT = 0x0A20            ; SINGLE Count\n.equ TCA0_SINGLE_PER = 0x0A26            ; SINGLE Period\n.equ TCA0_SINGLE_CMP0 = 0x0A28           ; SINGLE Compare 0\n.equ TCA0_SINGLE_CMP1 = 0x0A2A           ; SINGLE Compare 1\n.equ TCA0_SINGLE_CMP2 = 0x0A2C           ; SINGLE Compare 2\n.equ TCA0_SINGLE_PERBUF = 0x0A36         ; SINGLE Period Buffer\n.equ TCA0_SINGLE_CMP0BUF = 0x0A38        ; SINGLE Compare 0 Buffer\n.equ TCA0_SINGLE_CMP1BUF = 0x0A3A        ; SINGLE Compare 1 Buffer\n.equ TCA0_SINGLE_CMP2BUF = 0x0A3C        ; SINGLE Compare 2 Buffer\n.equ TCA0_SPLIT_CTRLA = 0x0A00           ; SPLIT Control A\n.equ TCA0_SPLIT_CTRLB = 0x0A01           ; SPLIT Control B\n.equ TCA0_SPLIT_CTRLC = 0x0A02           ; SPLIT Control C\n.equ TCA0_SPLIT_CTRLD = 0x0A03           ; SPLIT Control D\n.equ TCA0_SPLIT_CTRLECLR = 0x0A04        ; SPLIT Control E Clear\n.equ TCA0_SPLIT_CTRLESET = 0x0A05        ; SPLIT Control E Set\n.equ TCA0_SPLIT_INTCTRL = 0x0A0A         ; SPLIT Interrupt Control\n.equ TCA0_SPLIT_INTFLAGS = 0x0A0B        ; SPLIT Interrupt Flags\n.equ TCA0_SPLIT_DBGCTRL = 0x0A0E         ; SPLIT Degbug Control\n.equ TCA0_SPLIT_LCNT = 0x0A20            ; SPLIT Low Count\n.equ TCA0_SPLIT_HCNT = 0x0A21            ; SPLIT High Count\n.equ TCA0_SPLIT_LPER = 0x0A26            ; SPLIT Low Period\n.equ TCA0_SPLIT_HPER = 0x0A27            ; SPLIT High Period\n.equ TCA0_SPLIT_LCMP0 = 0x0A28           ; SPLIT Low Compare\n.equ TCA0_SPLIT_HCMP0 = 0x0A29           ; SPLIT High Compare\n.equ TCA0_SPLIT_LCMP1 = 0x0A2A           ; SPLIT Low Compare\n.equ TCA0_SPLIT_HCMP1 = 0x0A2B           ; SPLIT High Compare\n.equ TCA0_SPLIT_LCMP2 = 0x0A2C           ; SPLIT Low Compare\n.equ TCA0_SPLIT_HCMP2 = 0x0A2D           ; SPLIT High Compare\n\n;*************************************************************************\n;** TCB0 - 16-bit Timer Type B\n;*************************************************************************\n\n.equ TCB0_CTRLA = 0x0A40                 ; Control A\n.equ TCB0_CTRLB = 0x0A41                 ; Control Register B\n.equ TCB0_EVCTRL = 0x0A44                ; Event Control\n.equ TCB0_INTCTRL = 0x0A45               ; Interrupt Control\n.equ TCB0_INTFLAGS = 0x0A46              ; Interrupt Flags\n.equ TCB0_STATUS = 0x0A47                ; Status\n.equ TCB0_DBGCTRL = 0x0A48               ; Debug Control\n.equ TCB0_TEMP = 0x0A49                  ; Temporary Value\n.equ TCB0_CNT = 0x0A4A                   ; Count\n.equ TCB0_CNTL = 0x0A4A                  ; Count low byte\n.equ TCB0_CNTH = 0x0A4B                  ; Count hi byte\n.equ TCB0_CCMP = 0x0A4C                  ; Compare or Capture\n.equ TCB0_CCMPL = 0x0A4C                 ; Compare or Capture low byte\n.equ TCB0_CCMPH = 0x0A4D                 ; Compare or Capture hi byte\n\n;*************************************************************************\n;** TCD0 - Timer Counter D\n;*************************************************************************\n\n.equ TCD0_CTRLA = 0x0A80                 ; Control A\n.equ TCD0_CTRLB = 0x0A81                 ; Control B\n.equ TCD0_CTRLC = 0x0A82                 ; Control C\n.equ TCD0_CTRLD = 0x0A83                 ; Control D\n.equ TCD0_CTRLE = 0x0A84                 ; Control E\n.equ TCD0_EVCTRLA = 0x0A88               ; EVCTRLA\n.equ TCD0_EVCTRLB = 0x0A89               ; EVCTRLB\n.equ TCD0_INTCTRL = 0x0A8C               ; Interrupt Control\n.equ TCD0_INTFLAGS = 0x0A8D              ; Interrupt Flags\n.equ TCD0_STATUS = 0x0A8E                ; Status\n.equ TCD0_INPUTCTRLA = 0x0A90            ; Input Control A\n.equ TCD0_INPUTCTRLB = 0x0A91            ; Input Control B\n.equ TCD0_FAULTCTRL = 0x0A92             ; Fault Control\n.equ TCD0_DLYCTRL = 0x0A94               ; Delay Control\n.equ TCD0_DLYVAL = 0x0A95                ; Delay value\n.equ TCD0_DITCTRL = 0x0A98               ; Dither Control A\n.equ TCD0_DITVAL = 0x0A99                ; Dither value\n.equ TCD0_DBGCTRL = 0x0A9E               ; Debug Control\n.equ TCD0_CAPTUREA = 0x0AA2              ; Capture A\n.equ TCD0_CAPTUREAL = 0x0AA2             ; Capture A low byte\n.equ TCD0_CAPTUREAH = 0x0AA3             ; Capture A hi byte\n.equ TCD0_CAPTUREB = 0x0AA4              ; Capture B\n.equ TCD0_CAPTUREBL = 0x0AA4             ; Capture B low byte\n.equ TCD0_CAPTUREBH = 0x0AA5             ; Capture B hi byte\n.equ TCD0_CMPASET = 0x0AA8               ; Compare A Set\n.equ TCD0_CMPASETL = 0x0AA8              ; Compare A Set low byte\n.equ TCD0_CMPASETH = 0x0AA9              ; Compare A Set hi byte\n.equ TCD0_CMPACLR = 0x0AAA               ; Compare A Clear\n.equ TCD0_CMPACLRL = 0x0AAA              ; Compare A Clear low byte\n.equ TCD0_CMPACLRH = 0x0AAB              ; Compare A Clear hi byte\n.equ TCD0_CMPBSET = 0x0AAC               ; Compare B Set\n.equ TCD0_CMPBSETL = 0x0AAC              ; Compare B Set low byte\n.equ TCD0_CMPBSETH = 0x0AAD              ; Compare B Set hi byte\n.equ TCD0_CMPBCLR = 0x0AAE               ; Compare B Clear\n.equ TCD0_CMPBCLRL = 0x0AAE              ; Compare B Clear low byte\n.equ TCD0_CMPBCLRH = 0x0AAF              ; Compare B Clear hi byte\n\n;*************************************************************************\n;** TWI0 - Two-Wire Interface\n;*************************************************************************\n\n.equ TWI0_CTRLA = 0x0810                 ; Control A\n.equ TWI0_DBGCTRL = 0x0812               ; Debug Control Register\n.equ TWI0_MCTRLA = 0x0813                ; Master Control A\n.equ TWI0_MCTRLB = 0x0814                ; Master Control B\n.equ TWI0_MSTATUS = 0x0815               ; Master Status\n.equ TWI0_MBAUD = 0x0816                 ; Master Baurd Rate Control\n.equ TWI0_MADDR = 0x0817                 ; Master Address\n.equ TWI0_MDATA = 0x0818                 ; Master Data\n.equ TWI0_SCTRLA = 0x0819                ; Slave Control A\n.equ TWI0_SCTRLB = 0x081A                ; Slave Control B\n.equ TWI0_SSTATUS = 0x081B               ; Slave Status\n.equ TWI0_SADDR = 0x081C                 ; Slave Address\n.equ TWI0_SDATA = 0x081D                 ; Slave Data\n.equ TWI0_SADDRMASK = 0x081E             ; Slave Address Mask\n\n;*************************************************************************\n;** USART0 - Universal Synchronous and Asynchronous Receiver and Transmitter\n;*************************************************************************\n\n.equ USART0_RXDATAL = 0x0800             ; Receive Data Low Byte\n.equ USART0_RXDATAH = 0x0801             ; Receive Data High Byte\n.equ USART0_TXDATAL = 0x0802             ; Transmit Data Low Byte\n.equ USART0_TXDATAH = 0x0803             ; Transmit Data High Byte\n.equ USART0_STATUS = 0x0804              ; Status\n.equ USART0_CTRLA = 0x0805               ; Control A\n.equ USART0_CTRLB = 0x0806               ; Control B\n.equ USART0_CTRLC = 0x0807               ; Control C\n.equ USART0_BAUD = 0x0808                ; Baud Rate\n.equ USART0_BAUDL = 0x0808               ; Baud Rate low byte\n.equ USART0_BAUDH = 0x0809               ; Baud Rate hi byte\n.equ USART0_DBGCTRL = 0x080B             ; Debug Control\n.equ USART0_EVCTRL = 0x080C              ; Event Control\n.equ USART0_TXPLCTRL = 0x080D            ; IRCOM Transmitter Pulse Length Control\n.equ USART0_RXPLCTRL = 0x080E            ; IRCOM Receiver Pulse Length Control\n\n;*************************************************************************\n;** USERROW - User Row\n;*************************************************************************\n\n.equ USERROW_USERROW0 = 0x1300           ; User Row Byte 0\n.equ USERROW_USERROW1 = 0x1301           ; User Row Byte 1\n.equ USERROW_USERROW2 = 0x1302           ; User Row Byte 2\n.equ USERROW_USERROW3 = 0x1303           ; User Row Byte 3\n.equ USERROW_USERROW4 = 0x1304           ; User Row Byte 4\n.equ USERROW_USERROW5 = 0x1305           ; User Row Byte 5\n.equ USERROW_USERROW6 = 0x1306           ; User Row Byte 6\n.equ USERROW_USERROW7 = 0x1307           ; User Row Byte 7\n.equ USERROW_USERROW8 = 0x1308           ; User Row Byte 8\n.equ USERROW_USERROW9 = 0x1309           ; User Row Byte 9\n.equ USERROW_USERROW10 = 0x130A          ; User Row Byte 10\n.equ USERROW_USERROW11 = 0x130B          ; User Row Byte 11\n.equ USERROW_USERROW12 = 0x130C          ; User Row Byte 12\n.equ USERROW_USERROW13 = 0x130D          ; User Row Byte 13\n.equ USERROW_USERROW14 = 0x130E          ; User Row Byte 14\n.equ USERROW_USERROW15 = 0x130F          ; User Row Byte 15\n.equ USERROW_USERROW16 = 0x1310          ; User Row Byte 16\n.equ USERROW_USERROW17 = 0x1311          ; User Row Byte 17\n.equ USERROW_USERROW18 = 0x1312          ; User Row Byte 18\n.equ USERROW_USERROW19 = 0x1313          ; User Row Byte 19\n.equ USERROW_USERROW20 = 0x1314          ; User Row Byte 20\n.equ USERROW_USERROW21 = 0x1315          ; User Row Byte 21\n.equ USERROW_USERROW22 = 0x1316          ; User Row Byte 22\n.equ USERROW_USERROW23 = 0x1317          ; User Row Byte 23\n.equ USERROW_USERROW24 = 0x1318          ; User Row Byte 24\n.equ USERROW_USERROW25 = 0x1319          ; User Row Byte 25\n.equ USERROW_USERROW26 = 0x131A          ; User Row Byte 26\n.equ USERROW_USERROW27 = 0x131B          ; User Row Byte 27\n.equ USERROW_USERROW28 = 0x131C          ; User Row Byte 28\n.equ USERROW_USERROW29 = 0x131D          ; User Row Byte 29\n.equ USERROW_USERROW30 = 0x131E          ; User Row Byte 30\n.equ USERROW_USERROW31 = 0x131F          ; User Row Byte 31\n\n;*************************************************************************\n;** VPORTA - Virtual Ports\n;*************************************************************************\n\n.equ VPORTA_DIR = 0x0000                 ; Data Direction\n.equ VPORTA_OUT = 0x0001                 ; Output Value\n.equ VPORTA_IN = 0x0002                  ; Input Value\n.equ VPORTA_INTFLAGS = 0x0003            ; Interrupt Flags\n\n;*************************************************************************\n;** VPORTB - Virtual Ports\n;*************************************************************************\n\n.equ VPORTB_DIR = 0x0004                 ; Data Direction\n.equ VPORTB_OUT = 0x0005                 ; Output Value\n.equ VPORTB_IN = 0x0006                  ; Input Value\n.equ VPORTB_INTFLAGS = 0x0007            ; Interrupt Flags\n\n;*************************************************************************\n;** VPORTC - Virtual Ports\n;*************************************************************************\n\n.equ VPORTC_DIR = 0x0008                 ; Data Direction\n.equ VPORTC_OUT = 0x0009                 ; Output Value\n.equ VPORTC_IN = 0x000A                  ; Input Value\n.equ VPORTC_INTFLAGS = 0x000B            ; Interrupt Flags\n\n;*************************************************************************\n;** VREF - Voltage reference\n;*************************************************************************\n\n.equ VREF_CTRLA = 0x00A0                 ; Control A\n.equ VREF_CTRLB = 0x00A1                 ; Control B\n\n;*************************************************************************\n;** WDT - Watch-Dog Timer\n;*************************************************************************\n\n.equ WDT_CTRLA = 0x0100                  ; Control A\n.equ WDT_STATUS = 0x0101                 ; Status\n\n\n; ***** ALL MODULE BASE ADRESSES *****************************************\n\n.equ AC0_base = 0x0670                   ; Analog Comparator\n.equ ADC0_base = 0x0600                  ; Analog to Digital Converter\n.equ BOD_base = 0x0080                   ; Bod interface\n.equ CCL_base = 0x01C0                   ; Configurable Custom Logic\n.equ CLKCTRL_base = 0x0060               ; Clock controller\n.equ CPU_base = 0x0030                   ; CPU\n.equ CPUINT_base = 0x0110                ; Interrupt Controller\n.equ CRCSCAN_base = 0x0120               ; CRCSCAN\n.equ DAC0_base = 0x0680                  ; Digital to Analog Converter\n.equ EVSYS_base = 0x0180                 ; Event System\n.equ FUSE_base = 0x1280                  ; Fuses\n.equ GPIO_base = 0x001C                  ; General Purpose IO\n.equ LOCKBIT_base = 0x128A               ; Lockbit\n.equ NVMCTRL_base = 0x1000               ; Non-volatile Memory Controller\n.equ PORTA_base = 0x0400                 ; I/O Ports\n.equ PORTB_base = 0x0420                 ; I/O Ports\n.equ PORTMUX_base = 0x0200               ; Port Multiplexer\n.equ RSTCTRL_base = 0x0040               ; Reset controller\n.equ RTC_base = 0x0140                   ; Real-Time Counter\n.equ SIGROW_base = 0x1100                ; Signature row\n.equ SLPCTRL_base = 0x0050               ; Sleep Controller\n.equ SPI0_base = 0x0820                  ; Serial Peripheral Interface\n.equ SYSCFG_base = 0x0F00                ; System Configuration Registers\n.equ TCA0_base = 0x0A00                  ; 16-bit Timer/Counter Type A\n.equ TCB0_base = 0x0A40                  ; 16-bit Timer Type B\n.equ TCD0_base = 0x0A80                  ; Timer Counter D\n.equ TWI0_base = 0x0810                  ; Two-Wire Interface\n.equ USART0_base = 0x0800                ; Universal Synchronous and Asynchronous Receiver and Transmitter\n.equ USERROW_base = 0x1300               ; User Row\n.equ VPORTA_base = 0x0000                ; Virtual Ports\n.equ VPORTB_base = 0x0004                ; Virtual Ports\n.equ VPORTC_base = 0x0008                ; Virtual Ports\n.equ VREF_base = 0x00A0                  ; Voltage reference\n.equ WDT_base = 0x0100                   ; Watch-Dog Timer\n\n\n; ***** IO REGISTER OFFSETS **********************************************\n\n\n;*************************************************************************\n;** AC - Analog Comparator\n;*************************************************************************\n.equ AC_CTRLA_offset = 0x00              ; Control A\n.equ AC_MUXCTRLA_offset = 0x02           ; Mux Control A\n.equ AC_INTCTRL_offset = 0x06            ; Interrupt Control\n.equ AC_STATUS_offset = 0x07             ; Status\n\n;*************************************************************************\n;** ADC - Analog to Digital Converter\n;*************************************************************************\n.equ ADC_CTRLA_offset = 0x00             ; Control A\n.equ ADC_CTRLB_offset = 0x01             ; Control B\n.equ ADC_CTRLC_offset = 0x02             ; Control C\n.equ ADC_CTRLD_offset = 0x03             ; Control D\n.equ ADC_CTRLE_offset = 0x04             ; Control E\n.equ ADC_SAMPCTRL_offset = 0x05          ; Sample Control\n.equ ADC_MUXPOS_offset = 0x06            ; Positive mux input\n.equ ADC_COMMAND_offset = 0x08           ; Command\n.equ ADC_EVCTRL_offset = 0x09            ; Event Control\n.equ ADC_INTCTRL_offset = 0x0A           ; Interrupt Control\n.equ ADC_INTFLAGS_offset = 0x0B          ; Interrupt Flags\n.equ ADC_DBGCTRL_offset = 0x0C           ; Debug Control\n.equ ADC_TEMP_offset = 0x0D              ; Temporary Data\n.equ ADC_RES_offset = 0x10               ; ADC Accumulator Result\n.equ ADC_WINLT_offset = 0x12             ; Window comparator low threshold\n.equ ADC_WINHT_offset = 0x14             ; Window comparator high threshold\n.equ ADC_CALIB_offset = 0x16             ; Calibration\n\n;*************************************************************************\n;** BOD - Bod interface\n;*************************************************************************\n.equ BOD_CTRLA_offset = 0x00             ; Control A\n.equ BOD_CTRLB_offset = 0x01             ; Control B\n.equ BOD_VLMCTRLA_offset = 0x08          ; Voltage level monitor Control\n.equ BOD_INTCTRL_offset = 0x09           ; Voltage level monitor interrupt Control\n.equ BOD_INTFLAGS_offset = 0x0A          ; Voltage level monitor interrupt Flags\n.equ BOD_STATUS_offset = 0x0B            ; Voltage level monitor status\n\n;*************************************************************************\n;** CCL - Configurable Custom Logic\n;*************************************************************************\n.equ CCL_CTRLA_offset = 0x00             ; Control Register A\n.equ CCL_SEQCTRL0_offset = 0x01          ; Sequential Control 0\n.equ CCL_LUT0CTRLA_offset = 0x05         ; LUT Control 0 A\n.equ CCL_LUT0CTRLB_offset = 0x06         ; LUT Control 0 B\n.equ CCL_LUT0CTRLC_offset = 0x07         ; LUT Control 0 C\n.equ CCL_TRUTH0_offset = 0x08            ; Truth 0\n.equ CCL_LUT1CTRLA_offset = 0x09         ; LUT Control 1 A\n.equ CCL_LUT1CTRLB_offset = 0x0A         ; LUT Control 1 B\n.equ CCL_LUT1CTRLC_offset = 0x0B         ; LUT Control 1 C\n.equ CCL_TRUTH1_offset = 0x0C            ; Truth 1\n\n;*************************************************************************\n;** CLKCTRL - Clock controller\n;*************************************************************************\n.equ CLKCTRL_MCLKCTRLA_offset = 0x00     ; MCLK Control A\n.equ CLKCTRL_MCLKCTRLB_offset = 0x01     ; MCLK Control B\n.equ CLKCTRL_MCLKLOCK_offset = 0x02      ; MCLK Lock\n.equ CLKCTRL_MCLKSTATUS_offset = 0x03    ; MCLK Status\n.equ CLKCTRL_OSC20MCTRLA_offset = 0x10   ; OSC20M Control A\n.equ CLKCTRL_OSC20MCALIBA_offset = 0x11  ; OSC20M Calibration A\n.equ CLKCTRL_OSC20MCALIBB_offset = 0x12  ; OSC20M Calibration B\n.equ CLKCTRL_OSC32KCTRLA_offset = 0x18   ; OSC32K Control A\n.equ CLKCTRL_XOSC32KCTRLA_offset = 0x1C  ; XOSC32K Control A\n\n;*************************************************************************\n;** CPU - CPU\n;*************************************************************************\n.equ CPU_CCP_offset = 0x04               ; Configuration Change Protection\n.equ CPU_SPL_offset = 0x0D               ; Stack Pointer Low\n.equ CPU_SPH_offset = 0x0E               ; Stack Pointer High\n.equ CPU_SREG_offset = 0x0F              ; Status Register\n\n;*************************************************************************\n;** CPUINT - Interrupt Controller\n;*************************************************************************\n.equ CPUINT_CTRLA_offset = 0x00          ; Control A\n.equ CPUINT_STATUS_offset = 0x01         ; Status\n.equ CPUINT_LVL0PRI_offset = 0x02        ; Interrupt Level 0 Priority\n.equ CPUINT_LVL1VEC_offset = 0x03        ; Interrupt Level 1 Priority Vector\n\n;*************************************************************************\n;** CRCSCAN - CRCSCAN\n;*************************************************************************\n.equ CRCSCAN_CTRLA_offset = 0x00         ; Control A\n.equ CRCSCAN_CTRLB_offset = 0x01         ; Control B\n.equ CRCSCAN_STATUS_offset = 0x02        ; Status\n\n;*************************************************************************\n;** DAC - Digital to Analog Converter\n;*************************************************************************\n.equ DAC_CTRLA_offset = 0x00             ; Control Register A\n.equ DAC_DATA_offset = 0x01              ; DATA Register\n\n;*************************************************************************\n;** EVSYS - Event System\n;*************************************************************************\n.equ EVSYS_ASYNCSTROBE_offset = 0x00     ; Asynchronous Channel Strobe\n.equ EVSYS_SYNCSTROBE_offset = 0x01      ; Synchronous Channel Strobe\n.equ EVSYS_ASYNCCH0_offset = 0x02        ; Asynchronous Channel 0 Generator Selection\n.equ EVSYS_ASYNCCH1_offset = 0x03        ; Asynchronous Channel 1 Generator Selection\n.equ EVSYS_ASYNCCH2_offset = 0x04        ; Asynchronous Channel 2 Generator Selection\n.equ EVSYS_ASYNCCH3_offset = 0x05        ; Asynchronous Channel 3 Generator Selection\n.equ EVSYS_SYNCCH0_offset = 0x0A         ; Synchronous Channel 0 Generator Selection\n.equ EVSYS_SYNCCH1_offset = 0x0B         ; Synchronous Channel 1 Generator Selection\n.equ EVSYS_ASYNCUSER0_offset = 0x12      ; Asynchronous User Ch 0 Input Selection - TCB0\n.equ EVSYS_ASYNCUSER1_offset = 0x13      ; Asynchronous User Ch 1 Input Selection - ADC0\n.equ EVSYS_ASYNCUSER2_offset = 0x14      ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0\n.equ EVSYS_ASYNCUSER3_offset = 0x15      ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0\n.equ EVSYS_ASYNCUSER4_offset = 0x16      ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1\n.equ EVSYS_ASYNCUSER5_offset = 0x17      ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1\n.equ EVSYS_ASYNCUSER6_offset = 0x18      ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0\n.equ EVSYS_ASYNCUSER7_offset = 0x19      ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1\n.equ EVSYS_ASYNCUSER8_offset = 0x1A      ; Asynchronous User Ch 8 Input Selection - Event Out 0\n.equ EVSYS_ASYNCUSER9_offset = 0x1B      ; Asynchronous User Ch 9 Input Selection - Event Out 1\n.equ EVSYS_ASYNCUSER10_offset = 0x1C     ; Asynchronous User Ch 10 Input Selection - Event Out 2\n.equ EVSYS_SYNCUSER0_offset = 0x22       ; Synchronous User Ch 0 Input Selection - TCA0\n.equ EVSYS_SYNCUSER1_offset = 0x23       ; Synchronous User Ch 1 Input Selection - USART0\n\n;*************************************************************************\n;** FUSE - Fuses\n;*************************************************************************\n.equ FUSE_WDTCFG_offset = 0x00           ; Watchdog Configuration\n.equ FUSE_BODCFG_offset = 0x01           ; BOD Configuration\n.equ FUSE_OSCCFG_offset = 0x02           ; Oscillator Configuration\n.equ FUSE_TCD0CFG_offset = 0x04          ; TCD0 Configuration\n.equ FUSE_SYSCFG0_offset = 0x05          ; System Configuration 0\n.equ FUSE_SYSCFG1_offset = 0x06          ; System Configuration 1\n.equ FUSE_APPEND_offset = 0x07           ; Application Code Section End\n.equ FUSE_BOOTEND_offset = 0x08          ; Boot Section End\n\n;*************************************************************************\n;** GPIO - General Purpose IO\n;*************************************************************************\n.equ GPIO_GPIOR0_offset = 0x00           ; General Purpose IO Register 0\n.equ GPIO_GPIOR1_offset = 0x01           ; General Purpose IO Register 1\n.equ GPIO_GPIOR2_offset = 0x02           ; General Purpose IO Register 2\n.equ GPIO_GPIOR3_offset = 0x03           ; General Purpose IO Register 3\n\n;*************************************************************************\n;** LOCKBIT - Lockbit\n;*************************************************************************\n.equ LOCKBIT_LOCKBIT_offset = 0x00       ; Lock bits\n\n;*************************************************************************\n;** NVMCTRL - Non-volatile Memory Controller\n;*************************************************************************\n.equ NVMCTRL_CTRLA_offset = 0x00         ; Control A\n.equ NVMCTRL_CTRLB_offset = 0x01         ; Control B\n.equ NVMCTRL_STATUS_offset = 0x02        ; Status\n.equ NVMCTRL_INTCTRL_offset = 0x03       ; Interrupt Control\n.equ NVMCTRL_INTFLAGS_offset = 0x04      ; Interrupt Flags\n.equ NVMCTRL_DATA_offset = 0x06          ; Data\n.equ NVMCTRL_ADDR_offset = 0x08          ; Address\n\n;*************************************************************************\n;** PORT - I/O Ports\n;*************************************************************************\n.equ PORT_DIR_offset = 0x00              ; Data Direction\n.equ PORT_DIRSET_offset = 0x01           ; Data Direction Set\n.equ PORT_DIRCLR_offset = 0x02           ; Data Direction Clear\n.equ PORT_DIRTGL_offset = 0x03           ; Data Direction Toggle\n.equ PORT_OUT_offset = 0x04              ; Output Value\n.equ PORT_OUTSET_offset = 0x05           ; Output Value Set\n.equ PORT_OUTCLR_offset = 0x06           ; Output Value Clear\n.equ PORT_OUTTGL_offset = 0x07           ; Output Value Toggle\n.equ PORT_IN_offset = 0x08               ; Input Value\n.equ PORT_INTFLAGS_offset = 0x09         ; Interrupt Flags\n.equ PORT_PIN0CTRL_offset = 0x10         ; Pin 0 Control\n.equ PORT_PIN1CTRL_offset = 0x11         ; Pin 1 Control\n.equ PORT_PIN2CTRL_offset = 0x12         ; Pin 2 Control\n.equ PORT_PIN3CTRL_offset = 0x13         ; Pin 3 Control\n.equ PORT_PIN4CTRL_offset = 0x14         ; Pin 4 Control\n.equ PORT_PIN5CTRL_offset = 0x15         ; Pin 5 Control\n.equ PORT_PIN6CTRL_offset = 0x16         ; Pin 6 Control\n.equ PORT_PIN7CTRL_offset = 0x17         ; Pin 7 Control\n\n;*************************************************************************\n;** PORTMUX - Port Multiplexer\n;*************************************************************************\n.equ PORTMUX_CTRLA_offset = 0x00         ; Port Multiplexer Control A\n.equ PORTMUX_CTRLB_offset = 0x01         ; Port Multiplexer Control B\n.equ PORTMUX_CTRLC_offset = 0x02         ; Port Multiplexer Control C\n.equ PORTMUX_CTRLD_offset = 0x03         ; Port Multiplexer Control D\n\n;*************************************************************************\n;** PTC - Peripherial Touch Controller\n;*************************************************************************\n\n;*************************************************************************\n;** RSTCTRL - Reset controller\n;*************************************************************************\n.equ RSTCTRL_RSTFR_offset = 0x00         ; Reset Flags\n.equ RSTCTRL_SWRR_offset = 0x01          ; Software Reset\n\n;*************************************************************************\n;** RTC - Real-Time Counter\n;*************************************************************************\n.equ RTC_CTRLA_offset = 0x00             ; Control A\n.equ RTC_STATUS_offset = 0x01            ; Status\n.equ RTC_INTCTRL_offset = 0x02           ; Interrupt Control\n.equ RTC_INTFLAGS_offset = 0x03          ; Interrupt Flags\n.equ RTC_TEMP_offset = 0x04              ; Temporary\n.equ RTC_DBGCTRL_offset = 0x05           ; Debug control\n.equ RTC_CLKSEL_offset = 0x07            ; Clock Select\n.equ RTC_CNT_offset = 0x08               ; Counter\n.equ RTC_PER_offset = 0x0A               ; Period\n.equ RTC_CMP_offset = 0x0C               ; Compare\n.equ RTC_PITCTRLA_offset = 0x10          ; PIT Control A\n.equ RTC_PITSTATUS_offset = 0x11         ; PIT Status\n.equ RTC_PITINTCTRL_offset = 0x12        ; PIT Interrupt Control\n.equ RTC_PITINTFLAGS_offset = 0x13       ; PIT Interrupt Flags\n.equ RTC_PITDBGCTRL_offset = 0x15        ; PIT Debug control\n\n;*************************************************************************\n;** SIGROW - Signature row\n;*************************************************************************\n.equ SIGROW_DEVICEID0_offset = 0x00      ; Device ID Byte 0\n.equ SIGROW_DEVICEID1_offset = 0x01      ; Device ID Byte 1\n.equ SIGROW_DEVICEID2_offset = 0x02      ; Device ID Byte 2\n.equ SIGROW_SERNUM0_offset = 0x03        ; Serial Number Byte 0\n.equ SIGROW_SERNUM1_offset = 0x04        ; Serial Number Byte 1\n.equ SIGROW_SERNUM2_offset = 0x05        ; Serial Number Byte 2\n.equ SIGROW_SERNUM3_offset = 0x06        ; Serial Number Byte 3\n.equ SIGROW_SERNUM4_offset = 0x07        ; Serial Number Byte 4\n.equ SIGROW_SERNUM5_offset = 0x08        ; Serial Number Byte 5\n.equ SIGROW_SERNUM6_offset = 0x09        ; Serial Number Byte 6\n.equ SIGROW_SERNUM7_offset = 0x0A        ; Serial Number Byte 7\n.equ SIGROW_SERNUM8_offset = 0x0B        ; Serial Number Byte 8\n.equ SIGROW_SERNUM9_offset = 0x0C        ; Serial Number Byte 9\n.equ SIGROW_TEMPSENSE0_offset = 0x20     ; Temperature Sensor Calibration Byte 0\n.equ SIGROW_TEMPSENSE1_offset = 0x21     ; Temperature Sensor Calibration Byte 1\n.equ SIGROW_OSC16ERR3V_offset = 0x22     ; OSC16 error at 3V\n.equ SIGROW_OSC16ERR5V_offset = 0x23     ; OSC16 error at 5V\n.equ SIGROW_OSC20ERR3V_offset = 0x24     ; OSC20 error at 3V\n.equ SIGROW_OSC20ERR5V_offset = 0x25     ; OSC20 error at 5V\n\n;*************************************************************************\n;** SLPCTRL - Sleep Controller\n;*************************************************************************\n.equ SLPCTRL_CTRLA_offset = 0x00         ; Control\n\n;*************************************************************************\n;** SPI - Serial Peripheral Interface\n;*************************************************************************\n.equ SPI_CTRLA_offset = 0x00             ; Control A\n.equ SPI_CTRLB_offset = 0x01             ; Control B\n.equ SPI_INTCTRL_offset = 0x02           ; Interrupt Control\n.equ SPI_INTFLAGS_offset = 0x03          ; Interrupt Flags\n.equ SPI_DATA_offset = 0x04              ; Data\n\n;*************************************************************************\n;** SYSCFG - System Configuration Registers\n;*************************************************************************\n.equ SYSCFG_REVID_offset = 0x01          ; Revision ID\n.equ SYSCFG_EXTBRK_offset = 0x02         ; External Break\n\n;*************************************************************************\n;** TCA - 16-bit Timer/Counter Type A\n;*************************************************************************\n.equ TCA_SINGLE_CTRLA_offset = 0x00      ; Control A\n.equ TCA_SINGLE_CTRLB_offset = 0x01      ; Control B\n.equ TCA_SINGLE_CTRLC_offset = 0x02      ; Control C\n.equ TCA_SINGLE_CTRLD_offset = 0x03      ; Control D\n.equ TCA_SINGLE_CTRLECLR_offset = 0x04   ; Control E Clear\n.equ TCA_SINGLE_CTRLESET_offset = 0x05   ; Control E Set\n.equ TCA_SINGLE_CTRLFCLR_offset = 0x06   ; Control F Clear\n.equ TCA_SINGLE_CTRLFSET_offset = 0x07   ; Control F Set\n.equ TCA_SINGLE_EVCTRL_offset = 0x09     ; Event Control\n.equ TCA_SINGLE_INTCTRL_offset = 0x0A    ; Interrupt Control\n.equ TCA_SINGLE_INTFLAGS_offset = 0x0B   ; Interrupt Flags\n.equ TCA_SINGLE_DBGCTRL_offset = 0x0E    ; Degbug Control\n.equ TCA_SINGLE_TEMP_offset = 0x0F       ; Temporary data for 16-bit Access\n.equ TCA_SINGLE_CNT_offset = 0x20        ; Count\n.equ TCA_SINGLE_PER_offset = 0x26        ; Period\n.equ TCA_SINGLE_CMP0_offset = 0x28       ; Compare 0\n.equ TCA_SINGLE_CMP1_offset = 0x2A       ; Compare 1\n.equ TCA_SINGLE_CMP2_offset = 0x2C       ; Compare 2\n.equ TCA_SINGLE_PERBUF_offset = 0x36     ; Period Buffer\n.equ TCA_SINGLE_CMP0BUF_offset = 0x38    ; Compare 0 Buffer\n.equ TCA_SINGLE_CMP1BUF_offset = 0x3A    ; Compare 1 Buffer\n.equ TCA_SINGLE_CMP2BUF_offset = 0x3C    ; Compare 2 Buffer\n.equ TCA_SPLIT_CTRLA_offset = 0x00       ; Control A\n.equ TCA_SPLIT_CTRLB_offset = 0x01       ; Control B\n.equ TCA_SPLIT_CTRLC_offset = 0x02       ; Control C\n.equ TCA_SPLIT_CTRLD_offset = 0x03       ; Control D\n.equ TCA_SPLIT_CTRLECLR_offset = 0x04    ; Control E Clear\n.equ TCA_SPLIT_CTRLESET_offset = 0x05    ; Control E Set\n.equ TCA_SPLIT_INTCTRL_offset = 0x0A     ; Interrupt Control\n.equ TCA_SPLIT_INTFLAGS_offset = 0x0B    ; Interrupt Flags\n.equ TCA_SPLIT_DBGCTRL_offset = 0x0E     ; Degbug Control\n.equ TCA_SPLIT_LCNT_offset = 0x20        ; Low Count\n.equ TCA_SPLIT_HCNT_offset = 0x21        ; High Count\n.equ TCA_SPLIT_LPER_offset = 0x26        ; Low Period\n.equ TCA_SPLIT_HPER_offset = 0x27        ; High Period\n.equ TCA_SPLIT_LCMP0_offset = 0x28       ; Low Compare\n.equ TCA_SPLIT_HCMP0_offset = 0x29       ; High Compare\n.equ TCA_SPLIT_LCMP1_offset = 0x2A       ; Low Compare\n.equ TCA_SPLIT_HCMP1_offset = 0x2B       ; High Compare\n.equ TCA_SPLIT_LCMP2_offset = 0x2C       ; Low Compare\n.equ TCA_SPLIT_HCMP2_offset = 0x2D       ; High Compare\n.equ TCA_SINGLE_offset = 0x00            ; \n.equ TCA_SPLIT_offset = 0x00             ; \n\n;*************************************************************************\n;** TCB - 16-bit Timer Type B\n;*************************************************************************\n.equ TCB_CTRLA_offset = 0x00             ; Control A\n.equ TCB_CTRLB_offset = 0x01             ; Control Register B\n.equ TCB_EVCTRL_offset = 0x04            ; Event Control\n.equ TCB_INTCTRL_offset = 0x05           ; Interrupt Control\n.equ TCB_INTFLAGS_offset = 0x06          ; Interrupt Flags\n.equ TCB_STATUS_offset = 0x07            ; Status\n.equ TCB_DBGCTRL_offset = 0x08           ; Debug Control\n.equ TCB_TEMP_offset = 0x09              ; Temporary Value\n.equ TCB_CNT_offset = 0x0A               ; Count\n.equ TCB_CCMP_offset = 0x0C              ; Compare or Capture\n\n;*************************************************************************\n;** TCD - Timer Counter D\n;*************************************************************************\n.equ TCD_CTRLA_offset = 0x00             ; Control A\n.equ TCD_CTRLB_offset = 0x01             ; Control B\n.equ TCD_CTRLC_offset = 0x02             ; Control C\n.equ TCD_CTRLD_offset = 0x03             ; Control D\n.equ TCD_CTRLE_offset = 0x04             ; Control E\n.equ TCD_EVCTRLA_offset = 0x08           ; EVCTRLA\n.equ TCD_EVCTRLB_offset = 0x09           ; EVCTRLB\n.equ TCD_INTCTRL_offset = 0x0C           ; Interrupt Control\n.equ TCD_INTFLAGS_offset = 0x0D          ; Interrupt Flags\n.equ TCD_STATUS_offset = 0x0E            ; Status\n.equ TCD_INPUTCTRLA_offset = 0x10        ; Input Control A\n.equ TCD_INPUTCTRLB_offset = 0x11        ; Input Control B\n.equ TCD_FAULTCTRL_offset = 0x12         ; Fault Control\n.equ TCD_DLYCTRL_offset = 0x14           ; Delay Control\n.equ TCD_DLYVAL_offset = 0x15            ; Delay value\n.equ TCD_DITCTRL_offset = 0x18           ; Dither Control A\n.equ TCD_DITVAL_offset = 0x19            ; Dither value\n.equ TCD_DBGCTRL_offset = 0x1E           ; Debug Control\n.equ TCD_CAPTUREA_offset = 0x22          ; Capture A\n.equ TCD_CAPTUREB_offset = 0x24          ; Capture B\n.equ TCD_CMPASET_offset = 0x28           ; Compare A Set\n.equ TCD_CMPACLR_offset = 0x2A           ; Compare A Clear\n.equ TCD_CMPBSET_offset = 0x2C           ; Compare B Set\n.equ TCD_CMPBCLR_offset = 0x2E           ; Compare B Clear\n\n;*************************************************************************\n;** TWI - Two-Wire Interface\n;*************************************************************************\n.equ TWI_CTRLA_offset = 0x00             ; Control A\n.equ TWI_DBGCTRL_offset = 0x02           ; Debug Control Register\n.equ TWI_MCTRLA_offset = 0x03            ; Master Control A\n.equ TWI_MCTRLB_offset = 0x04            ; Master Control B\n.equ TWI_MSTATUS_offset = 0x05           ; Master Status\n.equ TWI_MBAUD_offset = 0x06             ; Master Baurd Rate Control\n.equ TWI_MADDR_offset = 0x07             ; Master Address\n.equ TWI_MDATA_offset = 0x08             ; Master Data\n.equ TWI_SCTRLA_offset = 0x09            ; Slave Control A\n.equ TWI_SCTRLB_offset = 0x0A            ; Slave Control B\n.equ TWI_SSTATUS_offset = 0x0B           ; Slave Status\n.equ TWI_SADDR_offset = 0x0C             ; Slave Address\n.equ TWI_SDATA_offset = 0x0D             ; Slave Data\n.equ TWI_SADDRMASK_offset = 0x0E         ; Slave Address Mask\n\n;*************************************************************************\n;** USART - Universal Synchronous and Asynchronous Receiver and Transmitter\n;*************************************************************************\n.equ USART_RXDATAL_offset = 0x00         ; Receive Data Low Byte\n.equ USART_RXDATAH_offset = 0x01         ; Receive Data High Byte\n.equ USART_TXDATAL_offset = 0x02         ; Transmit Data Low Byte\n.equ USART_TXDATAH_offset = 0x03         ; Transmit Data High Byte\n.equ USART_STATUS_offset = 0x04          ; Status\n.equ USART_CTRLA_offset = 0x05           ; Control A\n.equ USART_CTRLB_offset = 0x06           ; Control B\n.equ USART_CTRLC_offset = 0x07           ; Control C\n.equ USART_BAUD_offset = 0x08            ; Baud Rate\n.equ USART_DBGCTRL_offset = 0x0B         ; Debug Control\n.equ USART_EVCTRL_offset = 0x0C          ; Event Control\n.equ USART_TXPLCTRL_offset = 0x0D        ; IRCOM Transmitter Pulse Length Control\n.equ USART_RXPLCTRL_offset = 0x0E        ; IRCOM Receiver Pulse Length Control\n\n;*************************************************************************\n;** USERROW - User Row\n;*************************************************************************\n.equ USERROW_USERROW0_offset = 0x00      ; User Row Byte 0\n.equ USERROW_USERROW1_offset = 0x01      ; User Row Byte 1\n.equ USERROW_USERROW2_offset = 0x02      ; User Row Byte 2\n.equ USERROW_USERROW3_offset = 0x03      ; User Row Byte 3\n.equ USERROW_USERROW4_offset = 0x04      ; User Row Byte 4\n.equ USERROW_USERROW5_offset = 0x05      ; User Row Byte 5\n.equ USERROW_USERROW6_offset = 0x06      ; User Row Byte 6\n.equ USERROW_USERROW7_offset = 0x07      ; User Row Byte 7\n.equ USERROW_USERROW8_offset = 0x08      ; User Row Byte 8\n.equ USERROW_USERROW9_offset = 0x09      ; User Row Byte 9\n.equ USERROW_USERROW10_offset = 0x0A     ; User Row Byte 10\n.equ USERROW_USERROW11_offset = 0x0B     ; User Row Byte 11\n.equ USERROW_USERROW12_offset = 0x0C     ; User Row Byte 12\n.equ USERROW_USERROW13_offset = 0x0D     ; User Row Byte 13\n.equ USERROW_USERROW14_offset = 0x0E     ; User Row Byte 14\n.equ USERROW_USERROW15_offset = 0x0F     ; User Row Byte 15\n.equ USERROW_USERROW16_offset = 0x10     ; User Row Byte 16\n.equ USERROW_USERROW17_offset = 0x11     ; User Row Byte 17\n.equ USERROW_USERROW18_offset = 0x12     ; User Row Byte 18\n.equ USERROW_USERROW19_offset = 0x13     ; User Row Byte 19\n.equ USERROW_USERROW20_offset = 0x14     ; User Row Byte 20\n.equ USERROW_USERROW21_offset = 0x15     ; User Row Byte 21\n.equ USERROW_USERROW22_offset = 0x16     ; User Row Byte 22\n.equ USERROW_USERROW23_offset = 0x17     ; User Row Byte 23\n.equ USERROW_USERROW24_offset = 0x18     ; User Row Byte 24\n.equ USERROW_USERROW25_offset = 0x19     ; User Row Byte 25\n.equ USERROW_USERROW26_offset = 0x1A     ; User Row Byte 26\n.equ USERROW_USERROW27_offset = 0x1B     ; User Row Byte 27\n.equ USERROW_USERROW28_offset = 0x1C     ; User Row Byte 28\n.equ USERROW_USERROW29_offset = 0x1D     ; User Row Byte 29\n.equ USERROW_USERROW30_offset = 0x1E     ; User Row Byte 30\n.equ USERROW_USERROW31_offset = 0x1F     ; User Row Byte 31\n\n;*************************************************************************\n;** VPORT - Virtual Ports\n;*************************************************************************\n.equ VPORT_DIR_offset = 0x00             ; Data Direction\n.equ VPORT_OUT_offset = 0x01             ; Output Value\n.equ VPORT_IN_offset = 0x02              ; Input Value\n.equ VPORT_INTFLAGS_offset = 0x03        ; Interrupt Flags\n\n;*************************************************************************\n;** VREF - Voltage reference\n;*************************************************************************\n.equ VREF_CTRLA_offset = 0x00            ; Control A\n.equ VREF_CTRLB_offset = 0x01            ; Control B\n\n;*************************************************************************\n;** WDT - Watch-Dog Timer\n;*************************************************************************\n.equ WDT_CTRLA_offset = 0x00             ; Control A\n.equ WDT_STATUS_offset = 0x01            ; Status\n\n\n; ***** LOCKBIT REGISTER LOCATIONS ***************************************\n\n\n\n\n; ***** FUSE REGISTER LOCATIONS ******************************************\n\n\n\n\n; ***** BIT AND VALUE DEFINITIONS ****************************************\n\n\n;*************************************************************************\n;** AC - Analog Comparator\n;*************************************************************************\n\n; AC_CTRLA masks\n.equ AC_ENABLE_bm = 0x01                 ; Enable bit mask\n.equ AC_ENABLE_bp = 0                    ; Enable bit position\n.equ AC_HYSMODE_gm = 0x06                ; Hysteresis Mode group mask\n.equ AC_HYSMODE_gp = 1                   ; Hysteresis Mode group position\n.equ AC_HYSMODE0_bm = (1<<1)             ; Hysteresis Mode bit 0 mask\n.equ AC_HYSMODE0_bp = 1                  ; Hysteresis Mode bit 0 position\n.equ AC_HYSMODE1_bm = (1<<2)             ; Hysteresis Mode bit 1 mask\n.equ AC_HYSMODE1_bp = 2                  ; Hysteresis Mode bit 1 position\n.equ AC_INTMODE_gm = 0x30                ; Interrupt Mode group mask\n.equ AC_INTMODE_gp = 4                   ; Interrupt Mode group position\n.equ AC_INTMODE0_bm = (1<<4)             ; Interrupt Mode bit 0 mask\n.equ AC_INTMODE0_bp = 4                  ; Interrupt Mode bit 0 position\n.equ AC_INTMODE1_bm = (1<<5)             ; Interrupt Mode bit 1 mask\n.equ AC_INTMODE1_bp = 5                  ; Interrupt Mode bit 1 position\n.equ AC_LPMODE_bm = 0x08                 ; Low Power Mode bit mask\n.equ AC_LPMODE_bp = 3                    ; Low Power Mode bit position\n.equ AC_OUTEN_bm = 0x40                  ; Output Buffer Enable bit mask\n.equ AC_OUTEN_bp = 6                     ; Output Buffer Enable bit position\n.equ AC_RUNSTDBY_bm = 0x80               ; Run in Standby Mode bit mask\n.equ AC_RUNSTDBY_bp = 7                  ; Run in Standby Mode bit position\n\n; AC_INTCTRL masks\n.equ AC_CMP_bm = 0x01                    ; Analog Comparator 0 Interrupt Enable bit mask\n.equ AC_CMP_bp = 0                       ; Analog Comparator 0 Interrupt Enable bit position\n\n; AC_MUXCTRLA masks\n.equ AC_INVERT_bm = 0x80                 ; Invert AC Output bit mask\n.equ AC_INVERT_bp = 7                    ; Invert AC Output bit position\n.equ AC_MUXNEG_gm = 0x03                 ; Negative Input MUX Selection group mask\n.equ AC_MUXNEG_gp = 0                    ; Negative Input MUX Selection group position\n.equ AC_MUXNEG0_bm = (1<<0)              ; Negative Input MUX Selection bit 0 mask\n.equ AC_MUXNEG0_bp = 0                   ; Negative Input MUX Selection bit 0 position\n.equ AC_MUXNEG1_bm = (1<<1)              ; Negative Input MUX Selection bit 1 mask\n.equ AC_MUXNEG1_bp = 1                   ; Negative Input MUX Selection bit 1 position\n.equ AC_MUXPOS_bm = 0x08                 ; Positive Input MUX Selection bit mask\n.equ AC_MUXPOS_bp = 3                    ; Positive Input MUX Selection bit position\n\n; AC_STATUS masks\n; Masks for AC_CMP already defined\n.equ AC_STATE_bm = 0x10                  ; Analog Comparator State bit mask\n.equ AC_STATE_bp = 4                     ; Analog Comparator State bit position\n\n; Hysteresis Mode select\n.equ AC_HYSMODE_OFF_gc = (0x00<<1)       ; No hysteresis\n.equ AC_HYSMODE_10mV_gc = (0x01<<1)      ; 10mV hysteresis\n.equ AC_HYSMODE_25mV_gc = (0x02<<1)      ; 25mV hysteresis\n.equ AC_HYSMODE_50mV_gc = (0x03<<1)      ; 50mV hysteresis\n\n; Interrupt Mode select\n.equ AC_INTMODE_BOTHEDGE_gc = (0x00<<4)  ; Any Edge\n.equ AC_INTMODE_NEGEDGE_gc = (0x02<<4)   ; Negative Edge\n.equ AC_INTMODE_POSEDGE_gc = (0x03<<4)   ; Positive Edge\n\n; Low Power Mode select\n.equ AC_LPMODE_DIS_gc = (0x00<<3)        ; Low power mode disabled\n.equ AC_LPMODE_EN_gc = (0x01<<3)         ; Low power mode enabled\n\n; Negative Input MUX Selection select\n.equ AC_MUXNEG_PIN0_gc = (0x00<<0)       ; Negative Pin 0\n.equ AC_MUXNEG_PIN1_gc = (0x01<<0)       ; Negative Pin 1\n.equ AC_MUXNEG_VREF_gc = (0x02<<0)       ; Voltage Reference\n.equ AC_MUXNEG_DAC_gc = (0x03<<0)        ; DAC output\n\n; Positive Input MUX Selection select\n.equ AC_MUXPOS_PIN0_gc = (0x00<<3)       ; Positive Pin 0\n.equ AC_MUXPOS_PIN1_gc = (0x01<<3)       ; Positive Pin 1\n\n\n;*************************************************************************\n;** ADC - Analog to Digital Converter\n;*************************************************************************\n\n; ADC_CALIB masks\n.equ ADC_DUTYCYC_bm = 0x01               ; Duty Cycle bit mask\n.equ ADC_DUTYCYC_bp = 0                  ; Duty Cycle bit position\n\n; ADC_COMMAND masks\n.equ ADC_STCONV_bm = 0x01                ; Start Conversion Operation bit mask\n.equ ADC_STCONV_bp = 0                   ; Start Conversion Operation bit position\n\n; ADC_CTRLA masks\n.equ ADC_ENABLE_bm = 0x01                ; ADC Enable bit mask\n.equ ADC_ENABLE_bp = 0                   ; ADC Enable bit position\n.equ ADC_FREERUN_bm = 0x02               ; ADC Freerun mode bit mask\n.equ ADC_FREERUN_bp = 1                  ; ADC Freerun mode bit position\n.equ ADC_RESSEL_bm = 0x04                ; ADC Resolution bit mask\n.equ ADC_RESSEL_bp = 2                   ; ADC Resolution bit position\n.equ ADC_RUNSTBY_bm = 0x80               ; Run standby mode bit mask\n.equ ADC_RUNSTBY_bp = 7                  ; Run standby mode bit position\n\n; ADC_CTRLB masks\n.equ ADC_SAMPNUM_gm = 0x07               ; Accumulation Samples group mask\n.equ ADC_SAMPNUM_gp = 0                  ; Accumulation Samples group position\n.equ ADC_SAMPNUM0_bm = (1<<0)            ; Accumulation Samples bit 0 mask\n.equ ADC_SAMPNUM0_bp = 0                 ; Accumulation Samples bit 0 position\n.equ ADC_SAMPNUM1_bm = (1<<1)            ; Accumulation Samples bit 1 mask\n.equ ADC_SAMPNUM1_bp = 1                 ; Accumulation Samples bit 1 position\n.equ ADC_SAMPNUM2_bm = (1<<2)            ; Accumulation Samples bit 2 mask\n.equ ADC_SAMPNUM2_bp = 2                 ; Accumulation Samples bit 2 position\n\n; ADC_CTRLC masks\n.equ ADC_PRESC_gm = 0x07                 ; Clock Pre-scaler group mask\n.equ ADC_PRESC_gp = 0                    ; Clock Pre-scaler group position\n.equ ADC_PRESC0_bm = (1<<0)              ; Clock Pre-scaler bit 0 mask\n.equ ADC_PRESC0_bp = 0                   ; Clock Pre-scaler bit 0 position\n.equ ADC_PRESC1_bm = (1<<1)              ; Clock Pre-scaler bit 1 mask\n.equ ADC_PRESC1_bp = 1                   ; Clock Pre-scaler bit 1 position\n.equ ADC_PRESC2_bm = (1<<2)              ; Clock Pre-scaler bit 2 mask\n.equ ADC_PRESC2_bp = 2                   ; Clock Pre-scaler bit 2 position\n.equ ADC_REFSEL_gm = 0x30                ; Reference Selection group mask\n.equ ADC_REFSEL_gp = 4                   ; Reference Selection group position\n.equ ADC_REFSEL0_bm = (1<<4)             ; Reference Selection bit 0 mask\n.equ ADC_REFSEL0_bp = 4                  ; Reference Selection bit 0 position\n.equ ADC_REFSEL1_bm = (1<<5)             ; Reference Selection bit 1 mask\n.equ ADC_REFSEL1_bp = 5                  ; Reference Selection bit 1 position\n.equ ADC_SAMPCAP_bm = 0x40               ; Sample Capacitance Selection bit mask\n.equ ADC_SAMPCAP_bp = 6                  ; Sample Capacitance Selection bit position\n\n; ADC_CTRLD masks\n.equ ADC_ASDV_bm = 0x10                  ; Automatic Sampling Delay Variation bit mask\n.equ ADC_ASDV_bp = 4                     ; Automatic Sampling Delay Variation bit position\n.equ ADC_INITDLY_gm = 0xE0               ; Initial Delay Selection group mask\n.equ ADC_INITDLY_gp = 5                  ; Initial Delay Selection group position\n.equ ADC_INITDLY0_bm = (1<<5)            ; Initial Delay Selection bit 0 mask\n.equ ADC_INITDLY0_bp = 5                 ; Initial Delay Selection bit 0 position\n.equ ADC_INITDLY1_bm = (1<<6)            ; Initial Delay Selection bit 1 mask\n.equ ADC_INITDLY1_bp = 6                 ; Initial Delay Selection bit 1 position\n.equ ADC_INITDLY2_bm = (1<<7)            ; Initial Delay Selection bit 2 mask\n.equ ADC_INITDLY2_bp = 7                 ; Initial Delay Selection bit 2 position\n.equ ADC_SAMPDLY_gm = 0x0F               ; Sampling Delay Selection group mask\n.equ ADC_SAMPDLY_gp = 0                  ; Sampling Delay Selection group position\n.equ ADC_SAMPDLY0_bm = (1<<0)            ; Sampling Delay Selection bit 0 mask\n.equ ADC_SAMPDLY0_bp = 0                 ; Sampling Delay Selection bit 0 position\n.equ ADC_SAMPDLY1_bm = (1<<1)            ; Sampling Delay Selection bit 1 mask\n.equ ADC_SAMPDLY1_bp = 1                 ; Sampling Delay Selection bit 1 position\n.equ ADC_SAMPDLY2_bm = (1<<2)            ; Sampling Delay Selection bit 2 mask\n.equ ADC_SAMPDLY2_bp = 2                 ; Sampling Delay Selection bit 2 position\n.equ ADC_SAMPDLY3_bm = (1<<3)            ; Sampling Delay Selection bit 3 mask\n.equ ADC_SAMPDLY3_bp = 3                 ; Sampling Delay Selection bit 3 position\n\n; ADC_CTRLE masks\n.equ ADC_WINCM_gm = 0x07                 ; Window Comparator Mode group mask\n.equ ADC_WINCM_gp = 0                    ; Window Comparator Mode group position\n.equ ADC_WINCM0_bm = (1<<0)              ; Window Comparator Mode bit 0 mask\n.equ ADC_WINCM0_bp = 0                   ; Window Comparator Mode bit 0 position\n.equ ADC_WINCM1_bm = (1<<1)              ; Window Comparator Mode bit 1 mask\n.equ ADC_WINCM1_bp = 1                   ; Window Comparator Mode bit 1 position\n.equ ADC_WINCM2_bm = (1<<2)              ; Window Comparator Mode bit 2 mask\n.equ ADC_WINCM2_bp = 2                   ; Window Comparator Mode bit 2 position\n\n; ADC_DBGCTRL masks\n.equ ADC_DBGRUN_bm = 0x01                ; Debug run bit mask\n.equ ADC_DBGRUN_bp = 0                   ; Debug run bit position\n\n; ADC_EVCTRL masks\n.equ ADC_STARTEI_bm = 0x01               ; Start Event Input Enable bit mask\n.equ ADC_STARTEI_bp = 0                  ; Start Event Input Enable bit position\n\n; ADC_INTCTRL masks\n.equ ADC_RESRDY_bm = 0x01                ; Result Ready Interrupt Enable bit mask\n.equ ADC_RESRDY_bp = 0                   ; Result Ready Interrupt Enable bit position\n.equ ADC_WCMP_bm = 0x02                  ; Window Comparator Interrupt Enable bit mask\n.equ ADC_WCMP_bp = 1                     ; Window Comparator Interrupt Enable bit position\n\n; ADC_INTFLAGS masks\n; Masks for ADC_RESRDY already defined\n; Masks for ADC_WCMP already defined\n\n; ADC_MUXPOS masks\n.equ ADC_MUXPOS_gm = 0x1F                ; Analog Channel Selection Bits group mask\n.equ ADC_MUXPOS_gp = 0                   ; Analog Channel Selection Bits group position\n.equ ADC_MUXPOS0_bm = (1<<0)             ; Analog Channel Selection Bits bit 0 mask\n.equ ADC_MUXPOS0_bp = 0                  ; Analog Channel Selection Bits bit 0 position\n.equ ADC_MUXPOS1_bm = (1<<1)             ; Analog Channel Selection Bits bit 1 mask\n.equ ADC_MUXPOS1_bp = 1                  ; Analog Channel Selection Bits bit 1 position\n.equ ADC_MUXPOS2_bm = (1<<2)             ; Analog Channel Selection Bits bit 2 mask\n.equ ADC_MUXPOS2_bp = 2                  ; Analog Channel Selection Bits bit 2 position\n.equ ADC_MUXPOS3_bm = (1<<3)             ; Analog Channel Selection Bits bit 3 mask\n.equ ADC_MUXPOS3_bp = 3                  ; Analog Channel Selection Bits bit 3 position\n.equ ADC_MUXPOS4_bm = (1<<4)             ; Analog Channel Selection Bits bit 4 mask\n.equ ADC_MUXPOS4_bp = 4                  ; Analog Channel Selection Bits bit 4 position\n\n; ADC_SAMPCTRL masks\n.equ ADC_SAMPLEN_gm = 0x1F               ; Sample lenght group mask\n.equ ADC_SAMPLEN_gp = 0                  ; Sample lenght group position\n.equ ADC_SAMPLEN0_bm = (1<<0)            ; Sample lenght bit 0 mask\n.equ ADC_SAMPLEN0_bp = 0                 ; Sample lenght bit 0 position\n.equ ADC_SAMPLEN1_bm = (1<<1)            ; Sample lenght bit 1 mask\n.equ ADC_SAMPLEN1_bp = 1                 ; Sample lenght bit 1 position\n.equ ADC_SAMPLEN2_bm = (1<<2)            ; Sample lenght bit 2 mask\n.equ ADC_SAMPLEN2_bp = 2                 ; Sample lenght bit 2 position\n.equ ADC_SAMPLEN3_bm = (1<<3)            ; Sample lenght bit 3 mask\n.equ ADC_SAMPLEN3_bp = 3                 ; Sample lenght bit 3 position\n.equ ADC_SAMPLEN4_bm = (1<<4)            ; Sample lenght bit 4 mask\n.equ ADC_SAMPLEN4_bp = 4                 ; Sample lenght bit 4 position\n\n; ADC_TEMP masks\n.equ ADC_TEMP_gm = 0xFF                  ; Temporary group mask\n.equ ADC_TEMP_gp = 0                     ; Temporary group position\n.equ ADC_TEMP0_bm = (1<<0)               ; Temporary bit 0 mask\n.equ ADC_TEMP0_bp = 0                    ; Temporary bit 0 position\n.equ ADC_TEMP1_bm = (1<<1)               ; Temporary bit 1 mask\n.equ ADC_TEMP1_bp = 1                    ; Temporary bit 1 position\n.equ ADC_TEMP2_bm = (1<<2)               ; Temporary bit 2 mask\n.equ ADC_TEMP2_bp = 2                    ; Temporary bit 2 position\n.equ ADC_TEMP3_bm = (1<<3)               ; Temporary bit 3 mask\n.equ ADC_TEMP3_bp = 3                    ; Temporary bit 3 position\n.equ ADC_TEMP4_bm = (1<<4)               ; Temporary bit 4 mask\n.equ ADC_TEMP4_bp = 4                    ; Temporary bit 4 position\n.equ ADC_TEMP5_bm = (1<<5)               ; Temporary bit 5 mask\n.equ ADC_TEMP5_bp = 5                    ; Temporary bit 5 position\n.equ ADC_TEMP6_bm = (1<<6)               ; Temporary bit 6 mask\n.equ ADC_TEMP6_bp = 6                    ; Temporary bit 6 position\n.equ ADC_TEMP7_bm = (1<<7)               ; Temporary bit 7 mask\n.equ ADC_TEMP7_bp = 7                    ; Temporary bit 7 position\n\n; Duty Cycle select\n.equ ADC_DUTYCYC_DUTY50_gc = (0x00<<0)   ; 50% Duty cycle\n.equ ADC_DUTYCYC_DUTY25_gc = (0x01<<0)   ; 25% Duty cycle\n\n; ADC Resolution select\n.equ ADC_RESSEL_10BIT_gc = (0x00<<2)     ; 10-bit mode\n.equ ADC_RESSEL_8BIT_gc = (0x01<<2)      ; 8-bit mode\n\n; Accumulation Samples select\n.equ ADC_SAMPNUM_ACC1_gc = (0x00<<0)     ; 1 ADC sample\n.equ ADC_SAMPNUM_ACC2_gc = (0x01<<0)     ; Accumulate 2 samples\n.equ ADC_SAMPNUM_ACC4_gc = (0x02<<0)     ; Accumulate 4 samples\n.equ ADC_SAMPNUM_ACC8_gc = (0x03<<0)     ; Accumulate 8 samples\n.equ ADC_SAMPNUM_ACC16_gc = (0x04<<0)    ; Accumulate 16 samples\n.equ ADC_SAMPNUM_ACC32_gc = (0x05<<0)    ; Accumulate 32 samples\n.equ ADC_SAMPNUM_ACC64_gc = (0x06<<0)    ; Accumulate 64 samples\n\n; Clock Pre-scaler select\n.equ ADC_PRESC_DIV2_gc = (0x00<<0)       ; CLK_PER divided by 2\n.equ ADC_PRESC_DIV4_gc = (0x01<<0)       ; CLK_PER divided by 4\n.equ ADC_PRESC_DIV8_gc = (0x02<<0)       ; CLK_PER divided by 8\n.equ ADC_PRESC_DIV16_gc = (0x03<<0)      ; CLK_PER divided by 16\n.equ ADC_PRESC_DIV32_gc = (0x04<<0)      ; CLK_PER divided by 32\n.equ ADC_PRESC_DIV64_gc = (0x05<<0)      ; CLK_PER divided by 64\n.equ ADC_PRESC_DIV128_gc = (0x06<<0)     ; CLK_PER divided by 128\n.equ ADC_PRESC_DIV256_gc = (0x07<<0)     ; CLK_PER divided by 256\n\n; Reference Selection select\n.equ ADC_REFSEL_INTREF_gc = (0x00<<4)    ; Internal reference\n.equ ADC_REFSEL_VDDREF_gc = (0x01<<4)    ; VDD\n\n; Automatic Sampling Delay Variation select\n.equ ADC_ASDV_ASVOFF_gc = (0x00<<4)      ; The Automatic Sampling Delay Variation is disabled\n.equ ADC_ASDV_ASVON_gc = (0x01<<4)       ; The Automatic Sampling Delay Variation is enabled\n\n; Initial Delay Selection select\n.equ ADC_INITDLY_DLY0_gc = (0x00<<5)     ; Delay 0 CLK_ADC cycles\n.equ ADC_INITDLY_DLY16_gc = (0x01<<5)    ; Delay 16 CLK_ADC cycles\n.equ ADC_INITDLY_DLY32_gc = (0x02<<5)    ; Delay 32 CLK_ADC cycles\n.equ ADC_INITDLY_DLY64_gc = (0x03<<5)    ; Delay 64 CLK_ADC cycles\n.equ ADC_INITDLY_DLY128_gc = (0x04<<5)   ; Delay 128 CLK_ADC cycles\n.equ ADC_INITDLY_DLY256_gc = (0x05<<5)   ; Delay 256 CLK_ADC cycles\n\n; Window Comparator Mode select\n.equ ADC_WINCM_NONE_gc = (0x00<<0)       ; No Window Comparison\n.equ ADC_WINCM_BELOW_gc = (0x01<<0)      ; Below Window\n.equ ADC_WINCM_ABOVE_gc = (0x02<<0)      ; Above Window\n.equ ADC_WINCM_INSIDE_gc = (0x03<<0)     ; Inside Window\n.equ ADC_WINCM_OUTSIDE_gc = (0x04<<0)    ; Outside Window\n\n; Analog Channel Selection Bits select\n.equ ADC_MUXPOS_AIN0_gc = (0x00<<0)      ; ADC input pin 0\n.equ ADC_MUXPOS_AIN1_gc = (0x01<<0)      ; ADC input pin 1\n.equ ADC_MUXPOS_AIN2_gc = (0x02<<0)      ; ADC input pin 2\n.equ ADC_MUXPOS_AIN3_gc = (0x03<<0)      ; ADC input pin 3\n.equ ADC_MUXPOS_AIN4_gc = (0x04<<0)      ; ADC input pin 4\n.equ ADC_MUXPOS_AIN5_gc = (0x05<<0)      ; ADC input pin 5\n.equ ADC_MUXPOS_AIN6_gc = (0x06<<0)      ; ADC input pin 6\n.equ ADC_MUXPOS_AIN7_gc = (0x07<<0)      ; ADC input pin 7\n.equ ADC_MUXPOS_AIN8_gc = (0x08<<0)      ; ADC input pin 8\n.equ ADC_MUXPOS_AIN9_gc = (0x09<<0)      ; ADC input pin 9\n.equ ADC_MUXPOS_AIN10_gc = (0x0A<<0)     ; ADC input pin 10\n.equ ADC_MUXPOS_AIN11_gc = (0x0B<<0)     ; ADC input pin 11\n.equ ADC_MUXPOS_DAC0_gc = (0x1C<<0)      ; DAC0\n.equ ADC_MUXPOS_INTREF_gc = (0x1D<<0)    ; Internal Ref\n.equ ADC_MUXPOS_TEMPSENSE_gc = (0x1E<<0) ; Temp sensor\n.equ ADC_MUXPOS_GND_gc = (0x1F<<0)       ; GND\n\n\n;*************************************************************************\n;** BOD - Bod interface\n;*************************************************************************\n\n; BOD_CTRLA masks\n.equ BOD_ACTIVE_gm = 0x0C                ; Operation in active mode group mask\n.equ BOD_ACTIVE_gp = 2                   ; Operation in active mode group position\n.equ BOD_ACTIVE0_bm = (1<<2)             ; Operation in active mode bit 0 mask\n.equ BOD_ACTIVE0_bp = 2                  ; Operation in active mode bit 0 position\n.equ BOD_ACTIVE1_bm = (1<<3)             ; Operation in active mode bit 1 mask\n.equ BOD_ACTIVE1_bp = 3                  ; Operation in active mode bit 1 position\n.equ BOD_SAMPFREQ_bm = 0x10              ; Sample frequency bit mask\n.equ BOD_SAMPFREQ_bp = 4                 ; Sample frequency bit position\n.equ BOD_SLEEP_gm = 0x03                 ; Operation in sleep mode group mask\n.equ BOD_SLEEP_gp = 0                    ; Operation in sleep mode group position\n.equ BOD_SLEEP0_bm = (1<<0)              ; Operation in sleep mode bit 0 mask\n.equ BOD_SLEEP0_bp = 0                   ; Operation in sleep mode bit 0 position\n.equ BOD_SLEEP1_bm = (1<<1)              ; Operation in sleep mode bit 1 mask\n.equ BOD_SLEEP1_bp = 1                   ; Operation in sleep mode bit 1 position\n\n; BOD_CTRLB masks\n.equ BOD_LVL_gm = 0x07                   ; Bod level group mask\n.equ BOD_LVL_gp = 0                      ; Bod level group position\n.equ BOD_LVL0_bm = (1<<0)                ; Bod level bit 0 mask\n.equ BOD_LVL0_bp = 0                     ; Bod level bit 0 position\n.equ BOD_LVL1_bm = (1<<1)                ; Bod level bit 1 mask\n.equ BOD_LVL1_bp = 1                     ; Bod level bit 1 position\n.equ BOD_LVL2_bm = (1<<2)                ; Bod level bit 2 mask\n.equ BOD_LVL2_bp = 2                     ; Bod level bit 2 position\n\n; BOD_INTCTRL masks\n.equ BOD_VLMCFG_gm = 0x06                ; Configuration group mask\n.equ BOD_VLMCFG_gp = 1                   ; Configuration group position\n.equ BOD_VLMCFG0_bm = (1<<1)             ; Configuration bit 0 mask\n.equ BOD_VLMCFG0_bp = 1                  ; Configuration bit 0 position\n.equ BOD_VLMCFG1_bm = (1<<2)             ; Configuration bit 1 mask\n.equ BOD_VLMCFG1_bp = 2                  ; Configuration bit 1 position\n.equ BOD_VLMIE_bm = 0x01                 ; voltage level monitor interrrupt enable bit mask\n.equ BOD_VLMIE_bp = 0                    ; voltage level monitor interrrupt enable bit position\n\n; BOD_INTFLAGS masks\n.equ BOD_VLMIF_bm = 0x01                 ; Voltage level monitor interrupt flag bit mask\n.equ BOD_VLMIF_bp = 0                    ; Voltage level monitor interrupt flag bit position\n\n; BOD_STATUS masks\n.equ BOD_VLMS_bm = 0x01                  ; Voltage level monitor status bit mask\n.equ BOD_VLMS_bp = 0                     ; Voltage level monitor status bit position\n\n; BOD_VLMCTRLA masks\n.equ BOD_VLMLVL_gm = 0x03                ; voltage level monitor level group mask\n.equ BOD_VLMLVL_gp = 0                   ; voltage level monitor level group position\n.equ BOD_VLMLVL0_bm = (1<<0)             ; voltage level monitor level bit 0 mask\n.equ BOD_VLMLVL0_bp = 0                  ; voltage level monitor level bit 0 position\n.equ BOD_VLMLVL1_bm = (1<<1)             ; voltage level monitor level bit 1 mask\n.equ BOD_VLMLVL1_bp = 1                  ; voltage level monitor level bit 1 position\n\n; Operation in active mode select\n.equ BOD_ACTIVE_DIS_gc = (0x00<<2)       ; Disabled\n.equ BOD_ACTIVE_ENABLED_gc = (0x01<<2)   ; Enabled\n.equ BOD_ACTIVE_SAMPLED_gc = (0x02<<2)   ; Sampled\n.equ BOD_ACTIVE_ENWAKE_gc = (0x03<<2)    ; Enabled with wakeup halt\n\n; Sample frequency select\n.equ BOD_SAMPFREQ_1KHZ_gc = (0x00<<4)    ; 1kHz sampling\n.equ BOD_SAMPFREQ_125Hz_gc = (0x01<<4)   ; 125Hz sampling\n\n; Operation in sleep mode select\n.equ BOD_SLEEP_DIS_gc = (0x00<<0)        ; Disabled\n.equ BOD_SLEEP_ENABLED_gc = (0x01<<0)    ; Enabled\n.equ BOD_SLEEP_SAMPLED_gc = (0x02<<0)    ; Sampled\n\n; Bod level select\n.equ BOD_LVL_BODLEVEL0_gc = (0x00<<0)    ; 1.8 V\n.equ BOD_LVL_BODLEVEL1_gc = (0x01<<0)    ; 2.1 V\n.equ BOD_LVL_BODLEVEL2_gc = (0x02<<0)    ; 2.6 V\n.equ BOD_LVL_BODLEVEL3_gc = (0x03<<0)    ; 2.9 V\n.equ BOD_LVL_BODLEVEL4_gc = (0x04<<0)    ; 3.3 V\n.equ BOD_LVL_BODLEVEL5_gc = (0x05<<0)    ; 3.7 V\n.equ BOD_LVL_BODLEVEL6_gc = (0x06<<0)    ; 4.0 V\n.equ BOD_LVL_BODLEVEL7_gc = (0x07<<0)    ; 4.2 V\n\n; Configuration select\n.equ BOD_VLMCFG_BELOW_gc = (0x00<<1)     ; Interrupt when supply goes below VLM level\n.equ BOD_VLMCFG_ABOVE_gc = (0x01<<1)     ; Interrupt when supply goes above VLM level\n.equ BOD_VLMCFG_CROSS_gc = (0x02<<1)     ; Interrupt when supply crosses VLM level\n\n; voltage level monitor level select\n.equ BOD_VLMLVL_5ABOVE_gc = (0x00<<0)    ; VLM threshold 5% above BOD level\n.equ BOD_VLMLVL_15ABOVE_gc = (0x01<<0)   ; VLM threshold 15% above BOD level\n.equ BOD_VLMLVL_25ABOVE_gc = (0x02<<0)   ; VLM threshold 25% above BOD level\n\n\n;*************************************************************************\n;** CCL - Configurable Custom Logic\n;*************************************************************************\n\n; CCL_CTRLA masks\n.equ CCL_ENABLE_bm = 0x01                ; Enable bit mask\n.equ CCL_ENABLE_bp = 0                   ; Enable bit position\n.equ CCL_RUNSTDBY_bm = 0x40              ; Run in Standby bit mask\n.equ CCL_RUNSTDBY_bp = 6                 ; Run in Standby bit position\n\n; CCL_LUT0CTRLA masks\n.equ CCL_CLKSRC_bm = 0x40                ; Clock Source Selection bit mask\n.equ CCL_CLKSRC_bp = 6                   ; Clock Source Selection bit position\n.equ CCL_EDGEDET_bm = 0x80               ; Edge Detection Enable bit mask\n.equ CCL_EDGEDET_bp = 7                  ; Edge Detection Enable bit position\n; Masks for CCL_ENABLE already defined\n.equ CCL_FILTSEL_gm = 0x30               ; Filter Selection group mask\n.equ CCL_FILTSEL_gp = 4                  ; Filter Selection group position\n.equ CCL_FILTSEL0_bm = (1<<4)            ; Filter Selection bit 0 mask\n.equ CCL_FILTSEL0_bp = 4                 ; Filter Selection bit 0 position\n.equ CCL_FILTSEL1_bm = (1<<5)            ; Filter Selection bit 1 mask\n.equ CCL_FILTSEL1_bp = 5                 ; Filter Selection bit 1 position\n.equ CCL_OUTEN_bm = 0x08                 ; Output Enable bit mask\n.equ CCL_OUTEN_bp = 3                    ; Output Enable bit position\n\n; CCL_LUT0CTRLB masks\n.equ CCL_INSEL0_gm = 0x0F                ; LUT Input 0 Source Selection group mask\n.equ CCL_INSEL0_gp = 0                   ; LUT Input 0 Source Selection group position\n.equ CCL_INSEL00_bm = (1<<0)             ; LUT Input 0 Source Selection bit 0 mask\n.equ CCL_INSEL00_bp = 0                  ; LUT Input 0 Source Selection bit 0 position\n.equ CCL_INSEL01_bm = (1<<1)             ; LUT Input 0 Source Selection bit 1 mask\n.equ CCL_INSEL01_bp = 1                  ; LUT Input 0 Source Selection bit 1 position\n.equ CCL_INSEL02_bm = (1<<2)             ; LUT Input 0 Source Selection bit 2 mask\n.equ CCL_INSEL02_bp = 2                  ; LUT Input 0 Source Selection bit 2 position\n.equ CCL_INSEL03_bm = (1<<3)             ; LUT Input 0 Source Selection bit 3 mask\n.equ CCL_INSEL03_bp = 3                  ; LUT Input 0 Source Selection bit 3 position\n.equ CCL_INSEL1_gm = 0xF0                ; LUT Input 1 Source Selection group mask\n.equ CCL_INSEL1_gp = 4                   ; LUT Input 1 Source Selection group position\n.equ CCL_INSEL10_bm = (1<<4)             ; LUT Input 1 Source Selection bit 0 mask\n.equ CCL_INSEL10_bp = 4                  ; LUT Input 1 Source Selection bit 0 position\n.equ CCL_INSEL11_bm = (1<<5)             ; LUT Input 1 Source Selection bit 1 mask\n.equ CCL_INSEL11_bp = 5                  ; LUT Input 1 Source Selection bit 1 position\n.equ CCL_INSEL12_bm = (1<<6)             ; LUT Input 1 Source Selection bit 2 mask\n.equ CCL_INSEL12_bp = 6                  ; LUT Input 1 Source Selection bit 2 position\n.equ CCL_INSEL13_bm = (1<<7)             ; LUT Input 1 Source Selection bit 3 mask\n.equ CCL_INSEL13_bp = 7                  ; LUT Input 1 Source Selection bit 3 position\n\n; CCL_LUT0CTRLC masks\n.equ CCL_INSEL2_gm = 0x0F                ; LUT Input 2 Source Selection group mask\n.equ CCL_INSEL2_gp = 0                   ; LUT Input 2 Source Selection group position\n.equ CCL_INSEL20_bm = (1<<0)             ; LUT Input 2 Source Selection bit 0 mask\n.equ CCL_INSEL20_bp = 0                  ; LUT Input 2 Source Selection bit 0 position\n.equ CCL_INSEL21_bm = (1<<1)             ; LUT Input 2 Source Selection bit 1 mask\n.equ CCL_INSEL21_bp = 1                  ; LUT Input 2 Source Selection bit 1 position\n.equ CCL_INSEL22_bm = (1<<2)             ; LUT Input 2 Source Selection bit 2 mask\n.equ CCL_INSEL22_bp = 2                  ; LUT Input 2 Source Selection bit 2 position\n.equ CCL_INSEL23_bm = (1<<3)             ; LUT Input 2 Source Selection bit 3 mask\n.equ CCL_INSEL23_bp = 3                  ; LUT Input 2 Source Selection bit 3 position\n\n; CCL_LUT1CTRLA masks\n; Masks for CCL_CLKSRC already defined\n; Masks for CCL_EDGEDET already defined\n; Masks for CCL_ENABLE already defined\n; Masks for CCL_FILTSEL already defined\n; Masks for CCL_OUTEN already defined\n\n; CCL_LUT1CTRLB masks\n; Masks for CCL_INSEL0 already defined\n; Masks for CCL_INSEL1 already defined\n\n; CCL_LUT1CTRLC masks\n; Masks for CCL_INSEL2 already defined\n\n; CCL_SEQCTRL0 masks\n.equ CCL_SEQSEL_gm = 0x07                ; Sequential Selection group mask\n.equ CCL_SEQSEL_gp = 0                   ; Sequential Selection group position\n.equ CCL_SEQSEL0_bm = (1<<0)             ; Sequential Selection bit 0 mask\n.equ CCL_SEQSEL0_bp = 0                  ; Sequential Selection bit 0 position\n.equ CCL_SEQSEL1_bm = (1<<1)             ; Sequential Selection bit 1 mask\n.equ CCL_SEQSEL1_bp = 1                  ; Sequential Selection bit 1 position\n.equ CCL_SEQSEL2_bm = (1<<2)             ; Sequential Selection bit 2 mask\n.equ CCL_SEQSEL2_bp = 2                  ; Sequential Selection bit 2 position\n\n; Edge Detection Enable select\n.equ CCL_EDGEDET_DIS_gc = (0x00<<7)      ; Edge detector is disabled\n.equ CCL_EDGEDET_EN_gc = (0x01<<7)       ; Edge detector is enabled\n\n; Filter Selection select\n.equ CCL_FILTSEL_DISABLE_gc = (0x00<<4)  ; Filter disabled\n.equ CCL_FILTSEL_SYNCH_gc = (0x01<<4)    ; Synchronizer enabled\n.equ CCL_FILTSEL_FILTER_gc = (0x02<<4)   ; Filter enabled\n\n; LUT Input 0 Source Selection select\n.equ CCL_INSEL0_MASK_gc = (0x00<<0)      ; Masked input\n.equ CCL_INSEL0_FEEDBACK_gc = (0x01<<0)  ; Feedback input source\n.equ CCL_INSEL0_LINK_gc = (0x02<<0)      ; Linked LUT input source\n.equ CCL_INSEL0_EVENT0_gc = (0x03<<0)    ; Event input source 0\n.equ CCL_INSEL0_EVENT1_gc = (0x04<<0)    ; Event input source 1\n.equ CCL_INSEL0_IO_gc = (0x05<<0)        ; IO pin LUTn-IN0 input source\n.equ CCL_INSEL0_AC0_gc = (0x06<<0)       ; AC0 OUT input source\n.equ CCL_INSEL0_TCB0_gc = (0x07<<0)      ; TCB0 WO input source\n.equ CCL_INSEL0_TCA0_gc = (0x08<<0)      ; TCA0 WO0 input source\n.equ CCL_INSEL0_TCD0_gc = (0x09<<0)      ; TCD0 WOA input source\n.equ CCL_INSEL0_USART0_gc = (0x0A<<0)    ; USART0 XCK input source\n.equ CCL_INSEL0_SPI0_gc = (0x0B<<0)      ; SPI0 SCK source\n\n; LUT Input 1 Source Selection select\n.equ CCL_INSEL1_MASK_gc = (0x00<<4)      ; Masked input\n.equ CCL_INSEL1_FEEDBACK_gc = (0x01<<4)  ; Feedback input source\n.equ CCL_INSEL1_LINK_gc = (0x02<<4)      ; Linked LUT input source\n.equ CCL_INSEL1_EVENT0_gc = (0x03<<4)    ; Event input source 0\n.equ CCL_INSEL1_EVENT1_gc = (0x04<<4)    ; Event input source 1\n.equ CCL_INSEL1_IO_gc = (0x05<<4)        ; IO pin LUTn-N1 input source\n.equ CCL_INSEL1_AC0_gc = (0x06<<4)       ; AC0 OUT input source\n.equ CCL_INSEL1_TCB0_gc = (0x07<<4)      ; TCB0 WO input source\n.equ CCL_INSEL1_TCA0_gc = (0x08<<4)      ; TCA0 WO1 input source\n.equ CCL_INSEL1_TCD0_gc = (0x09<<4)      ; TCD0 WOB input source\n.equ CCL_INSEL1_USART0_gc = (0x0A<<4)    ; USART0 TXD input source\n.equ CCL_INSEL1_SPI0_gc = (0x0B<<4)      ; SPI0 MOSI input source\n\n; LUT Input 2 Source Selection select\n.equ CCL_INSEL2_MASK_gc = (0x00<<0)      ; Masked input\n.equ CCL_INSEL2_FEEDBACK_gc = (0x01<<0)  ; Feedback input source\n.equ CCL_INSEL2_LINK_gc = (0x02<<0)      ; Linked LUT input source\n.equ CCL_INSEL2_EVENT0_gc = (0x03<<0)    ; Event input source 0\n.equ CCL_INSEL2_EVENT1_gc = (0x04<<0)    ; Event input source 1\n.equ CCL_INSEL2_IO_gc = (0x05<<0)        ; IO pin LUTn-IN2 input source\n.equ CCL_INSEL2_AC0_gc = (0x06<<0)       ; AC0 OUT input source\n.equ CCL_INSEL2_TCB0_gc = (0x07<<0)      ; TCB0 WO input source\n.equ CCL_INSEL2_TCA0_gc = (0x08<<0)      ; TCA0 WO2 input source\n.equ CCL_INSEL2_TCD0_gc = (0x09<<0)      ; TCD0 WOA input source\n.equ CCL_INSEL2_SPI0_gc = (0x0B<<0)      ; SPI0 MISO source\n\n; Sequential Selection select\n.equ CCL_SEQSEL_DISABLE_gc = (0x00<<0)   ; Sequential logic disabled\n.equ CCL_SEQSEL_DFF_gc = (0x01<<0)       ; D FlipFlop\n.equ CCL_SEQSEL_JK_gc = (0x02<<0)        ; JK FlipFlop\n.equ CCL_SEQSEL_LATCH_gc = (0x03<<0)     ; D Latch\n.equ CCL_SEQSEL_RS_gc = (0x04<<0)        ; RS Latch\n\n\n;*************************************************************************\n;** CLKCTRL - Clock controller\n;*************************************************************************\n\n; CLKCTRL_MCLKCTRLA masks\n.equ CLKCTRL_CLKOUT_bm = 0x80            ; System clock out bit mask\n.equ CLKCTRL_CLKOUT_bp = 7               ; System clock out bit position\n.equ CLKCTRL_CLKSEL_gm = 0x03            ; clock select group mask\n.equ CLKCTRL_CLKSEL_gp = 0               ; clock select group position\n.equ CLKCTRL_CLKSEL0_bm = (1<<0)         ; clock select bit 0 mask\n.equ CLKCTRL_CLKSEL0_bp = 0              ; clock select bit 0 position\n.equ CLKCTRL_CLKSEL1_bm = (1<<1)         ; clock select bit 1 mask\n.equ CLKCTRL_CLKSEL1_bp = 1              ; clock select bit 1 position\n\n; CLKCTRL_MCLKCTRLB masks\n.equ CLKCTRL_PDIV_gm = 0x1E              ; Prescaler division group mask\n.equ CLKCTRL_PDIV_gp = 1                 ; Prescaler division group position\n.equ CLKCTRL_PDIV0_bm = (1<<1)           ; Prescaler division bit 0 mask\n.equ CLKCTRL_PDIV0_bp = 1                ; Prescaler division bit 0 position\n.equ CLKCTRL_PDIV1_bm = (1<<2)           ; Prescaler division bit 1 mask\n.equ CLKCTRL_PDIV1_bp = 2                ; Prescaler division bit 1 position\n.equ CLKCTRL_PDIV2_bm = (1<<3)           ; Prescaler division bit 2 mask\n.equ CLKCTRL_PDIV2_bp = 3                ; Prescaler division bit 2 position\n.equ CLKCTRL_PDIV3_bm = (1<<4)           ; Prescaler division bit 3 mask\n.equ CLKCTRL_PDIV3_bp = 4                ; Prescaler division bit 3 position\n.equ CLKCTRL_PEN_bm = 0x01               ; Prescaler enable bit mask\n.equ CLKCTRL_PEN_bp = 0                  ; Prescaler enable bit position\n\n; CLKCTRL_MCLKLOCK masks\n.equ CLKCTRL_LOCKEN_bm = 0x01            ; lock ebable bit mask\n.equ CLKCTRL_LOCKEN_bp = 0               ; lock ebable bit position\n\n; CLKCTRL_MCLKSTATUS masks\n.equ CLKCTRL_EXTS_bm = 0x80              ; External Clock status bit mask\n.equ CLKCTRL_EXTS_bp = 7                 ; External Clock status bit position\n.equ CLKCTRL_OSC20MS_bm = 0x10           ; 20MHz oscillator status bit mask\n.equ CLKCTRL_OSC20MS_bp = 4              ; 20MHz oscillator status bit position\n.equ CLKCTRL_OSC32KS_bm = 0x20           ; 32KHz oscillator status bit mask\n.equ CLKCTRL_OSC32KS_bp = 5              ; 32KHz oscillator status bit position\n.equ CLKCTRL_SOSC_bm = 0x01              ; System Oscillator changing bit mask\n.equ CLKCTRL_SOSC_bp = 0                 ; System Oscillator changing bit position\n.equ CLKCTRL_XOSC32KS_bm = 0x40          ; 32.768 kHz Crystal Oscillator status bit mask\n.equ CLKCTRL_XOSC32KS_bp = 6             ; 32.768 kHz Crystal Oscillator status bit position\n\n; CLKCTRL_OSC20MCALIBA masks\n.equ CLKCTRL_CAL20M_gm = 0x3F            ; Calibration group mask\n.equ CLKCTRL_CAL20M_gp = 0               ; Calibration group position\n.equ CLKCTRL_CAL20M0_bm = (1<<0)         ; Calibration bit 0 mask\n.equ CLKCTRL_CAL20M0_bp = 0              ; Calibration bit 0 position\n.equ CLKCTRL_CAL20M1_bm = (1<<1)         ; Calibration bit 1 mask\n.equ CLKCTRL_CAL20M1_bp = 1              ; Calibration bit 1 position\n.equ CLKCTRL_CAL20M2_bm = (1<<2)         ; Calibration bit 2 mask\n.equ CLKCTRL_CAL20M2_bp = 2              ; Calibration bit 2 position\n.equ CLKCTRL_CAL20M3_bm = (1<<3)         ; Calibration bit 3 mask\n.equ CLKCTRL_CAL20M3_bp = 3              ; Calibration bit 3 position\n.equ CLKCTRL_CAL20M4_bm = (1<<4)         ; Calibration bit 4 mask\n.equ CLKCTRL_CAL20M4_bp = 4              ; Calibration bit 4 position\n.equ CLKCTRL_CAL20M5_bm = (1<<5)         ; Calibration bit 5 mask\n.equ CLKCTRL_CAL20M5_bp = 5              ; Calibration bit 5 position\n\n; CLKCTRL_OSC20MCALIBB masks\n.equ CLKCTRL_LOCK_bm = 0x80              ; Lock bit mask\n.equ CLKCTRL_LOCK_bp = 7                 ; Lock bit position\n.equ CLKCTRL_TEMPCAL20M_gm = 0x0F        ; Oscillator temperature coefficient group mask\n.equ CLKCTRL_TEMPCAL20M_gp = 0           ; Oscillator temperature coefficient group position\n.equ CLKCTRL_TEMPCAL20M0_bm = (1<<0)     ; Oscillator temperature coefficient bit 0 mask\n.equ CLKCTRL_TEMPCAL20M0_bp = 0          ; Oscillator temperature coefficient bit 0 position\n.equ CLKCTRL_TEMPCAL20M1_bm = (1<<1)     ; Oscillator temperature coefficient bit 1 mask\n.equ CLKCTRL_TEMPCAL20M1_bp = 1          ; Oscillator temperature coefficient bit 1 position\n.equ CLKCTRL_TEMPCAL20M2_bm = (1<<2)     ; Oscillator temperature coefficient bit 2 mask\n.equ CLKCTRL_TEMPCAL20M2_bp = 2          ; Oscillator temperature coefficient bit 2 position\n.equ CLKCTRL_TEMPCAL20M3_bm = (1<<3)     ; Oscillator temperature coefficient bit 3 mask\n.equ CLKCTRL_TEMPCAL20M3_bp = 3          ; Oscillator temperature coefficient bit 3 position\n\n; CLKCTRL_OSC20MCTRLA masks\n.equ CLKCTRL_RUNSTDBY_bm = 0x02          ; Run standby bit mask\n.equ CLKCTRL_RUNSTDBY_bp = 1             ; Run standby bit position\n\n; CLKCTRL_OSC32KCTRLA masks\n; Masks for CLKCTRL_RUNSTDBY already defined\n\n; CLKCTRL_XOSC32KCTRLA masks\n.equ CLKCTRL_CSUT_gm = 0x30              ; Crystal startup time group mask\n.equ CLKCTRL_CSUT_gp = 4                 ; Crystal startup time group position\n.equ CLKCTRL_CSUT0_bm = (1<<4)           ; Crystal startup time bit 0 mask\n.equ CLKCTRL_CSUT0_bp = 4                ; Crystal startup time bit 0 position\n.equ CLKCTRL_CSUT1_bm = (1<<5)           ; Crystal startup time bit 1 mask\n.equ CLKCTRL_CSUT1_bp = 5                ; Crystal startup time bit 1 position\n.equ CLKCTRL_ENABLE_bm = 0x01            ; Enable bit mask\n.equ CLKCTRL_ENABLE_bp = 0               ; Enable bit position\n; Masks for CLKCTRL_RUNSTDBY already defined\n.equ CLKCTRL_SEL_bm = 0x04               ; Select bit mask\n.equ CLKCTRL_SEL_bp = 2                  ; Select bit position\n\n; clock select select\n.equ CLKCTRL_CLKSEL_OSC20M_gc = (0x00<<0) ; 20MHz internal oscillator\n.equ CLKCTRL_CLKSEL_OSCULP32K_gc = (0x01<<0) ; 32KHz internal Ultra Low Power oscillator\n.equ CLKCTRL_CLKSEL_XOSC32K_gc = (0x02<<0) ; 32.768kHz external crystal oscillator\n.equ CLKCTRL_CLKSEL_EXTCLK_gc = (0x03<<0) ; External clock\n\n; Prescaler division select\n.equ CLKCTRL_PDIV_2X_gc = (0x00<<1)      ; 2X\n.equ CLKCTRL_PDIV_4X_gc = (0x01<<1)      ; 4X\n.equ CLKCTRL_PDIV_8X_gc = (0x02<<1)      ; 8X\n.equ CLKCTRL_PDIV_16X_gc = (0x03<<1)     ; 16X\n.equ CLKCTRL_PDIV_32X_gc = (0x04<<1)     ; 32X\n.equ CLKCTRL_PDIV_64X_gc = (0x05<<1)     ; 64X\n.equ CLKCTRL_PDIV_6X_gc = (0x08<<1)      ; 6X\n.equ CLKCTRL_PDIV_10X_gc = (0x09<<1)     ; 10X\n.equ CLKCTRL_PDIV_12X_gc = (0x0A<<1)     ; 12X\n.equ CLKCTRL_PDIV_24X_gc = (0x0B<<1)     ; 24X\n.equ CLKCTRL_PDIV_48X_gc = (0x0C<<1)     ; 48X\n\n; Crystal startup time select\n.equ CLKCTRL_CSUT_1K_gc = (0x00<<4)      ; 1K cycles\n.equ CLKCTRL_CSUT_16K_gc = (0x01<<4)     ; 16K cycles\n.equ CLKCTRL_CSUT_32K_gc = (0x02<<4)     ; 32K cycles\n.equ CLKCTRL_CSUT_64K_gc = (0x03<<4)     ; 64K cycles\n\n\n;*************************************************************************\n;** CPU - CPU\n;*************************************************************************\n\n; CPU_CCP masks\n.equ CPU_CCP_gm = 0xFF                   ; CCP signature group mask\n.equ CPU_CCP_gp = 0                      ; CCP signature group position\n.equ CPU_CCP0_bm = (1<<0)                ; CCP signature bit 0 mask\n.equ CPU_CCP0_bp = 0                     ; CCP signature bit 0 position\n.equ CPU_CCP1_bm = (1<<1)                ; CCP signature bit 1 mask\n.equ CPU_CCP1_bp = 1                     ; CCP signature bit 1 position\n.equ CPU_CCP2_bm = (1<<2)                ; CCP signature bit 2 mask\n.equ CPU_CCP2_bp = 2                     ; CCP signature bit 2 position\n.equ CPU_CCP3_bm = (1<<3)                ; CCP signature bit 3 mask\n.equ CPU_CCP3_bp = 3                     ; CCP signature bit 3 position\n.equ CPU_CCP4_bm = (1<<4)                ; CCP signature bit 4 mask\n.equ CPU_CCP4_bp = 4                     ; CCP signature bit 4 position\n.equ CPU_CCP5_bm = (1<<5)                ; CCP signature bit 5 mask\n.equ CPU_CCP5_bp = 5                     ; CCP signature bit 5 position\n.equ CPU_CCP6_bm = (1<<6)                ; CCP signature bit 6 mask\n.equ CPU_CCP6_bp = 6                     ; CCP signature bit 6 position\n.equ CPU_CCP7_bm = (1<<7)                ; CCP signature bit 7 mask\n.equ CPU_CCP7_bp = 7                     ; CCP signature bit 7 position\n\n; CPU_SREG masks\n.equ CPU_C_bm = 0x01                     ; Carry Flag bit mask\n.equ CPU_C_bp = 0                        ; Carry Flag bit position\n.equ CPU_H_bm = 0x20                     ; Half Carry Flag bit mask\n.equ CPU_H_bp = 5                        ; Half Carry Flag bit position\n.equ CPU_I_bm = 0x80                     ; Global Interrupt Enable Flag bit mask\n.equ CPU_I_bp = 7                        ; Global Interrupt Enable Flag bit position\n.equ CPU_N_bm = 0x04                     ; Negative Flag bit mask\n.equ CPU_N_bp = 2                        ; Negative Flag bit position\n.equ CPU_S_bm = 0x10                     ; N Exclusive Or V Flag bit mask\n.equ CPU_S_bp = 4                        ; N Exclusive Or V Flag bit position\n.equ CPU_T_bm = 0x40                     ; Transfer Bit bit mask\n.equ CPU_T_bp = 6                        ; Transfer Bit bit position\n.equ CPU_V_bm = 0x08                     ; Two's Complement Overflow Flag bit mask\n.equ CPU_V_bp = 3                        ; Two's Complement Overflow Flag bit position\n.equ CPU_Z_bm = 0x02                     ; Zero Flag bit mask\n.equ CPU_Z_bp = 1                        ; Zero Flag bit position\n\n; CCP signature select\n.equ CPU_CCP_SPM_gc = (0x9D<<0)          ; SPM Instruction Protection\n.equ CPU_CCP_IOREG_gc = (0xD8<<0)        ; IO Register Protection\n\n\n;*************************************************************************\n;** CPUINT - Interrupt Controller\n;*************************************************************************\n\n; CPUINT_CTRLA masks\n.equ CPUINT_CVT_bm = 0x20                ; Compact Vector Table bit mask\n.equ CPUINT_CVT_bp = 5                   ; Compact Vector Table bit position\n.equ CPUINT_IVSEL_bm = 0x40              ; Interrupt Vector Select bit mask\n.equ CPUINT_IVSEL_bp = 6                 ; Interrupt Vector Select bit position\n.equ CPUINT_LVL0RR_bm = 0x01             ; Round-robin Scheduling Enable bit mask\n.equ CPUINT_LVL0RR_bp = 0                ; Round-robin Scheduling Enable bit position\n\n; CPUINT_LVL0PRI masks\n.equ CPUINT_LVL0PRI_gm = 0xFF            ; Interrupt Level Priority group mask\n.equ CPUINT_LVL0PRI_gp = 0               ; Interrupt Level Priority group position\n.equ CPUINT_LVL0PRI0_bm = (1<<0)         ; Interrupt Level Priority bit 0 mask\n.equ CPUINT_LVL0PRI0_bp = 0              ; Interrupt Level Priority bit 0 position\n.equ CPUINT_LVL0PRI1_bm = (1<<1)         ; Interrupt Level Priority bit 1 mask\n.equ CPUINT_LVL0PRI1_bp = 1              ; Interrupt Level Priority bit 1 position\n.equ CPUINT_LVL0PRI2_bm = (1<<2)         ; Interrupt Level Priority bit 2 mask\n.equ CPUINT_LVL0PRI2_bp = 2              ; Interrupt Level Priority bit 2 position\n.equ CPUINT_LVL0PRI3_bm = (1<<3)         ; Interrupt Level Priority bit 3 mask\n.equ CPUINT_LVL0PRI3_bp = 3              ; Interrupt Level Priority bit 3 position\n.equ CPUINT_LVL0PRI4_bm = (1<<4)         ; Interrupt Level Priority bit 4 mask\n.equ CPUINT_LVL0PRI4_bp = 4              ; Interrupt Level Priority bit 4 position\n.equ CPUINT_LVL0PRI5_bm = (1<<5)         ; Interrupt Level Priority bit 5 mask\n.equ CPUINT_LVL0PRI5_bp = 5              ; Interrupt Level Priority bit 5 position\n.equ CPUINT_LVL0PRI6_bm = (1<<6)         ; Interrupt Level Priority bit 6 mask\n.equ CPUINT_LVL0PRI6_bp = 6              ; Interrupt Level Priority bit 6 position\n.equ CPUINT_LVL0PRI7_bm = (1<<7)         ; Interrupt Level Priority bit 7 mask\n.equ CPUINT_LVL0PRI7_bp = 7              ; Interrupt Level Priority bit 7 position\n\n; CPUINT_LVL1VEC masks\n.equ CPUINT_LVL1VEC_gm = 0xFF            ; Interrupt Vector with High Priority group mask\n.equ CPUINT_LVL1VEC_gp = 0               ; Interrupt Vector with High Priority group position\n.equ CPUINT_LVL1VEC0_bm = (1<<0)         ; Interrupt Vector with High Priority bit 0 mask\n.equ CPUINT_LVL1VEC0_bp = 0              ; Interrupt Vector with High Priority bit 0 position\n.equ CPUINT_LVL1VEC1_bm = (1<<1)         ; Interrupt Vector with High Priority bit 1 mask\n.equ CPUINT_LVL1VEC1_bp = 1              ; Interrupt Vector with High Priority bit 1 position\n.equ CPUINT_LVL1VEC2_bm = (1<<2)         ; Interrupt Vector with High Priority bit 2 mask\n.equ CPUINT_LVL1VEC2_bp = 2              ; Interrupt Vector with High Priority bit 2 position\n.equ CPUINT_LVL1VEC3_bm = (1<<3)         ; Interrupt Vector with High Priority bit 3 mask\n.equ CPUINT_LVL1VEC3_bp = 3              ; Interrupt Vector with High Priority bit 3 position\n.equ CPUINT_LVL1VEC4_bm = (1<<4)         ; Interrupt Vector with High Priority bit 4 mask\n.equ CPUINT_LVL1VEC4_bp = 4              ; Interrupt Vector with High Priority bit 4 position\n.equ CPUINT_LVL1VEC5_bm = (1<<5)         ; Interrupt Vector with High Priority bit 5 mask\n.equ CPUINT_LVL1VEC5_bp = 5              ; Interrupt Vector with High Priority bit 5 position\n.equ CPUINT_LVL1VEC6_bm = (1<<6)         ; Interrupt Vector with High Priority bit 6 mask\n.equ CPUINT_LVL1VEC6_bp = 6              ; Interrupt Vector with High Priority bit 6 position\n.equ CPUINT_LVL1VEC7_bm = (1<<7)         ; Interrupt Vector with High Priority bit 7 mask\n.equ CPUINT_LVL1VEC7_bp = 7              ; Interrupt Vector with High Priority bit 7 position\n\n; CPUINT_STATUS masks\n.equ CPUINT_LVL0EX_bm = 0x01             ; Level 0 Interrupt Executing bit mask\n.equ CPUINT_LVL0EX_bp = 0                ; Level 0 Interrupt Executing bit position\n.equ CPUINT_LVL1EX_bm = 0x02             ; Level 1 Interrupt Executing bit mask\n.equ CPUINT_LVL1EX_bp = 1                ; Level 1 Interrupt Executing bit position\n.equ CPUINT_NMIEX_bm = 0x80              ; Non-maskable Interrupt Executing bit mask\n.equ CPUINT_NMIEX_bp = 7                 ; Non-maskable Interrupt Executing bit position\n\n\n;*************************************************************************\n;** CRCSCAN - CRCSCAN\n;*************************************************************************\n\n; CRCSCAN_CTRLA masks\n.equ CRCSCAN_ENABLE_bm = 0x01            ; Enable CRC scan bit mask\n.equ CRCSCAN_ENABLE_bp = 0               ; Enable CRC scan bit position\n.equ CRCSCAN_NMIEN_bm = 0x02             ; Enable NMI Trigger bit mask\n.equ CRCSCAN_NMIEN_bp = 1                ; Enable NMI Trigger bit position\n.equ CRCSCAN_RESET_bm = 0x80             ; Reset CRC scan bit mask\n.equ CRCSCAN_RESET_bp = 7                ; Reset CRC scan bit position\n\n; CRCSCAN_CTRLB masks\n.equ CRCSCAN_MODE_gm = 0x30              ; CRC Flash Access Mode group mask\n.equ CRCSCAN_MODE_gp = 4                 ; CRC Flash Access Mode group position\n.equ CRCSCAN_MODE0_bm = (1<<4)           ; CRC Flash Access Mode bit 0 mask\n.equ CRCSCAN_MODE0_bp = 4                ; CRC Flash Access Mode bit 0 position\n.equ CRCSCAN_MODE1_bm = (1<<5)           ; CRC Flash Access Mode bit 1 mask\n.equ CRCSCAN_MODE1_bp = 5                ; CRC Flash Access Mode bit 1 position\n.equ CRCSCAN_SRC_gm = 0x03               ; CRC Source group mask\n.equ CRCSCAN_SRC_gp = 0                  ; CRC Source group position\n.equ CRCSCAN_SRC0_bm = (1<<0)            ; CRC Source bit 0 mask\n.equ CRCSCAN_SRC0_bp = 0                 ; CRC Source bit 0 position\n.equ CRCSCAN_SRC1_bm = (1<<1)            ; CRC Source bit 1 mask\n.equ CRCSCAN_SRC1_bp = 1                 ; CRC Source bit 1 position\n\n; CRCSCAN_STATUS masks\n.equ CRCSCAN_BUSY_bm = 0x01              ; CRC Busy bit mask\n.equ CRCSCAN_BUSY_bp = 0                 ; CRC Busy bit position\n.equ CRCSCAN_OK_bm = 0x02                ; CRC Ok bit mask\n.equ CRCSCAN_OK_bp = 1                   ; CRC Ok bit position\n\n; CRC Flash Access Mode select\n.equ CRCSCAN_MODE_PRIORITY_gc = (0x00<<4) ; Priority to flash\n.equ CRCSCAN_MODE_RESERVED_gc = (0x01<<4) ; Reserved\n.equ CRCSCAN_MODE_BACKGROUND_gc = (0x02<<4) ; Lowest priority to flash\n.equ CRCSCAN_MODE_CONTINUOUS_gc = (0x03<<4) ; Continuous checks in background\n\n; CRC Source select\n.equ CRCSCAN_SRC_FLASH_gc = (0x00<<0)    ; CRC on entire flash\n.equ CRCSCAN_SRC_APPLICATION_gc = (0x01<<0) ; CRC on boot and appl section of flash\n.equ CRCSCAN_SRC_BOOT_gc = (0x02<<0)     ; CRC on boot section of flash\n\n\n;*************************************************************************\n;** DAC - Digital to Analog Converter\n;*************************************************************************\n\n; DAC_CTRLA masks\n.equ DAC_ENABLE_bm = 0x01                ; DAC Enable bit mask\n.equ DAC_ENABLE_bp = 0                   ; DAC Enable bit position\n.equ DAC_OUTEN_bm = 0x40                 ; Output Buffer Enable bit mask\n.equ DAC_OUTEN_bp = 6                    ; Output Buffer Enable bit position\n.equ DAC_RUNSTDBY_bm = 0x80              ; Run in Standby Mode bit mask\n.equ DAC_RUNSTDBY_bp = 7                 ; Run in Standby Mode bit position\n\n\n;*************************************************************************\n;** EVSYS - Event System\n;*************************************************************************\n\n; EVSYS_ASYNCCH0 masks\n.equ EVSYS_ASYNCCH0_gm = 0xFF            ; Asynchronous Channel 0 Generator Selection group mask\n.equ EVSYS_ASYNCCH0_gp = 0               ; Asynchronous Channel 0 Generator Selection group position\n.equ EVSYS_ASYNCCH00_bm = (1<<0)         ; Asynchronous Channel 0 Generator Selection bit 0 mask\n.equ EVSYS_ASYNCCH00_bp = 0              ; Asynchronous Channel 0 Generator Selection bit 0 position\n.equ EVSYS_ASYNCCH01_bm = (1<<1)         ; Asynchronous Channel 0 Generator Selection bit 1 mask\n.equ EVSYS_ASYNCCH01_bp = 1              ; Asynchronous Channel 0 Generator Selection bit 1 position\n.equ EVSYS_ASYNCCH02_bm = (1<<2)         ; Asynchronous Channel 0 Generator Selection bit 2 mask\n.equ EVSYS_ASYNCCH02_bp = 2              ; Asynchronous Channel 0 Generator Selection bit 2 position\n.equ EVSYS_ASYNCCH03_bm = (1<<3)         ; Asynchronous Channel 0 Generator Selection bit 3 mask\n.equ EVSYS_ASYNCCH03_bp = 3              ; Asynchronous Channel 0 Generator Selection bit 3 position\n.equ EVSYS_ASYNCCH04_bm = (1<<4)         ; Asynchronous Channel 0 Generator Selection bit 4 mask\n.equ EVSYS_ASYNCCH04_bp = 4              ; Asynchronous Channel 0 Generator Selection bit 4 position\n.equ EVSYS_ASYNCCH05_bm = (1<<5)         ; Asynchronous Channel 0 Generator Selection bit 5 mask\n.equ EVSYS_ASYNCCH05_bp = 5              ; Asynchronous Channel 0 Generator Selection bit 5 position\n.equ EVSYS_ASYNCCH06_bm = (1<<6)         ; Asynchronous Channel 0 Generator Selection bit 6 mask\n.equ EVSYS_ASYNCCH06_bp = 6              ; Asynchronous Channel 0 Generator Selection bit 6 position\n.equ EVSYS_ASYNCCH07_bm = (1<<7)         ; Asynchronous Channel 0 Generator Selection bit 7 mask\n.equ EVSYS_ASYNCCH07_bp = 7              ; Asynchronous Channel 0 Generator Selection bit 7 position\n\n; EVSYS_ASYNCCH1 masks\n.equ EVSYS_ASYNCCH1_gm = 0xFF            ; Asynchronous Channel 1 Generator Selection group mask\n.equ EVSYS_ASYNCCH1_gp = 0               ; Asynchronous Channel 1 Generator Selection group position\n.equ EVSYS_ASYNCCH10_bm = (1<<0)         ; Asynchronous Channel 1 Generator Selection bit 0 mask\n.equ EVSYS_ASYNCCH10_bp = 0              ; Asynchronous Channel 1 Generator Selection bit 0 position\n.equ EVSYS_ASYNCCH11_bm = (1<<1)         ; Asynchronous Channel 1 Generator Selection bit 1 mask\n.equ EVSYS_ASYNCCH11_bp = 1              ; Asynchronous Channel 1 Generator Selection bit 1 position\n.equ EVSYS_ASYNCCH12_bm = (1<<2)         ; Asynchronous Channel 1 Generator Selection bit 2 mask\n.equ EVSYS_ASYNCCH12_bp = 2              ; Asynchronous Channel 1 Generator Selection bit 2 position\n.equ EVSYS_ASYNCCH13_bm = (1<<3)         ; Asynchronous Channel 1 Generator Selection bit 3 mask\n.equ EVSYS_ASYNCCH13_bp = 3              ; Asynchronous Channel 1 Generator Selection bit 3 position\n.equ EVSYS_ASYNCCH14_bm = (1<<4)         ; Asynchronous Channel 1 Generator Selection bit 4 mask\n.equ EVSYS_ASYNCCH14_bp = 4              ; Asynchronous Channel 1 Generator Selection bit 4 position\n.equ EVSYS_ASYNCCH15_bm = (1<<5)         ; Asynchronous Channel 1 Generator Selection bit 5 mask\n.equ EVSYS_ASYNCCH15_bp = 5              ; Asynchronous Channel 1 Generator Selection bit 5 position\n.equ EVSYS_ASYNCCH16_bm = (1<<6)         ; Asynchronous Channel 1 Generator Selection bit 6 mask\n.equ EVSYS_ASYNCCH16_bp = 6              ; Asynchronous Channel 1 Generator Selection bit 6 position\n.equ EVSYS_ASYNCCH17_bm = (1<<7)         ; Asynchronous Channel 1 Generator Selection bit 7 mask\n.equ EVSYS_ASYNCCH17_bp = 7              ; Asynchronous Channel 1 Generator Selection bit 7 position\n\n; EVSYS_ASYNCCH2 masks\n.equ EVSYS_ASYNCCH2_gm = 0xFF            ; Asynchronous Channel 2 Generator Selection group mask\n.equ EVSYS_ASYNCCH2_gp = 0               ; Asynchronous Channel 2 Generator Selection group position\n.equ EVSYS_ASYNCCH20_bm = (1<<0)         ; Asynchronous Channel 2 Generator Selection bit 0 mask\n.equ EVSYS_ASYNCCH20_bp = 0              ; Asynchronous Channel 2 Generator Selection bit 0 position\n.equ EVSYS_ASYNCCH21_bm = (1<<1)         ; Asynchronous Channel 2 Generator Selection bit 1 mask\n.equ EVSYS_ASYNCCH21_bp = 1              ; Asynchronous Channel 2 Generator Selection bit 1 position\n.equ EVSYS_ASYNCCH22_bm = (1<<2)         ; Asynchronous Channel 2 Generator Selection bit 2 mask\n.equ EVSYS_ASYNCCH22_bp = 2              ; Asynchronous Channel 2 Generator Selection bit 2 position\n.equ EVSYS_ASYNCCH23_bm = (1<<3)         ; Asynchronous Channel 2 Generator Selection bit 3 mask\n.equ EVSYS_ASYNCCH23_bp = 3              ; Asynchronous Channel 2 Generator Selection bit 3 position\n.equ EVSYS_ASYNCCH24_bm = (1<<4)         ; Asynchronous Channel 2 Generator Selection bit 4 mask\n.equ EVSYS_ASYNCCH24_bp = 4              ; Asynchronous Channel 2 Generator Selection bit 4 position\n.equ EVSYS_ASYNCCH25_bm = (1<<5)         ; Asynchronous Channel 2 Generator Selection bit 5 mask\n.equ EVSYS_ASYNCCH25_bp = 5              ; Asynchronous Channel 2 Generator Selection bit 5 position\n.equ EVSYS_ASYNCCH26_bm = (1<<6)         ; Asynchronous Channel 2 Generator Selection bit 6 mask\n.equ EVSYS_ASYNCCH26_bp = 6              ; Asynchronous Channel 2 Generator Selection bit 6 position\n.equ EVSYS_ASYNCCH27_bm = (1<<7)         ; Asynchronous Channel 2 Generator Selection bit 7 mask\n.equ EVSYS_ASYNCCH27_bp = 7              ; Asynchronous Channel 2 Generator Selection bit 7 position\n\n; EVSYS_ASYNCCH3 masks\n.equ EVSYS_ASYNCCH3_gm = 0xFF            ; Asynchronous Channel 3 Generator Selection group mask\n.equ EVSYS_ASYNCCH3_gp = 0               ; Asynchronous Channel 3 Generator Selection group position\n.equ EVSYS_ASYNCCH30_bm = (1<<0)         ; Asynchronous Channel 3 Generator Selection bit 0 mask\n.equ EVSYS_ASYNCCH30_bp = 0              ; Asynchronous Channel 3 Generator Selection bit 0 position\n.equ EVSYS_ASYNCCH31_bm = (1<<1)         ; Asynchronous Channel 3 Generator Selection bit 1 mask\n.equ EVSYS_ASYNCCH31_bp = 1              ; Asynchronous Channel 3 Generator Selection bit 1 position\n.equ EVSYS_ASYNCCH32_bm = (1<<2)         ; Asynchronous Channel 3 Generator Selection bit 2 mask\n.equ EVSYS_ASYNCCH32_bp = 2              ; Asynchronous Channel 3 Generator Selection bit 2 position\n.equ EVSYS_ASYNCCH33_bm = (1<<3)         ; Asynchronous Channel 3 Generator Selection bit 3 mask\n.equ EVSYS_ASYNCCH33_bp = 3              ; Asynchronous Channel 3 Generator Selection bit 3 position\n.equ EVSYS_ASYNCCH34_bm = (1<<4)         ; Asynchronous Channel 3 Generator Selection bit 4 mask\n.equ EVSYS_ASYNCCH34_bp = 4              ; Asynchronous Channel 3 Generator Selection bit 4 position\n.equ EVSYS_ASYNCCH35_bm = (1<<5)         ; Asynchronous Channel 3 Generator Selection bit 5 mask\n.equ EVSYS_ASYNCCH35_bp = 5              ; Asynchronous Channel 3 Generator Selection bit 5 position\n.equ EVSYS_ASYNCCH36_bm = (1<<6)         ; Asynchronous Channel 3 Generator Selection bit 6 mask\n.equ EVSYS_ASYNCCH36_bp = 6              ; Asynchronous Channel 3 Generator Selection bit 6 position\n.equ EVSYS_ASYNCCH37_bm = (1<<7)         ; Asynchronous Channel 3 Generator Selection bit 7 mask\n.equ EVSYS_ASYNCCH37_bp = 7              ; Asynchronous Channel 3 Generator Selection bit 7 position\n\n; EVSYS_ASYNCUSER0 masks\n.equ EVSYS_ASYNCUSER0_gm = 0xFF          ; Asynchronous User Ch 0 Input Selection - TCB0 group mask\n.equ EVSYS_ASYNCUSER0_gp = 0             ; Asynchronous User Ch 0 Input Selection - TCB0 group position\n.equ EVSYS_ASYNCUSER00_bm = (1<<0)       ; Asynchronous User Ch 0 Input Selection - TCB0 bit 0 mask\n.equ EVSYS_ASYNCUSER00_bp = 0            ; Asynchronous User Ch 0 Input Selection - TCB0 bit 0 position\n.equ EVSYS_ASYNCUSER01_bm = (1<<1)       ; Asynchronous User Ch 0 Input Selection - TCB0 bit 1 mask\n.equ EVSYS_ASYNCUSER01_bp = 1            ; Asynchronous User Ch 0 Input Selection - TCB0 bit 1 position\n.equ EVSYS_ASYNCUSER02_bm = (1<<2)       ; Asynchronous User Ch 0 Input Selection - TCB0 bit 2 mask\n.equ EVSYS_ASYNCUSER02_bp = 2            ; Asynchronous User Ch 0 Input Selection - TCB0 bit 2 position\n.equ EVSYS_ASYNCUSER03_bm = (1<<3)       ; Asynchronous User Ch 0 Input Selection - TCB0 bit 3 mask\n.equ EVSYS_ASYNCUSER03_bp = 3            ; Asynchronous User Ch 0 Input Selection - TCB0 bit 3 position\n.equ EVSYS_ASYNCUSER04_bm = (1<<4)       ; Asynchronous User Ch 0 Input Selection - TCB0 bit 4 mask\n.equ EVSYS_ASYNCUSER04_bp = 4            ; Asynchronous User Ch 0 Input Selection - TCB0 bit 4 position\n.equ EVSYS_ASYNCUSER05_bm = (1<<5)       ; Asynchronous User Ch 0 Input Selection - TCB0 bit 5 mask\n.equ EVSYS_ASYNCUSER05_bp = 5            ; Asynchronous User Ch 0 Input Selection - TCB0 bit 5 position\n.equ EVSYS_ASYNCUSER06_bm = (1<<6)       ; Asynchronous User Ch 0 Input Selection - TCB0 bit 6 mask\n.equ EVSYS_ASYNCUSER06_bp = 6            ; Asynchronous User Ch 0 Input Selection - TCB0 bit 6 position\n.equ EVSYS_ASYNCUSER07_bm = (1<<7)       ; Asynchronous User Ch 0 Input Selection - TCB0 bit 7 mask\n.equ EVSYS_ASYNCUSER07_bp = 7            ; Asynchronous User Ch 0 Input Selection - TCB0 bit 7 position\n\n; EVSYS_ASYNCUSER1 masks\n.equ EVSYS_ASYNCUSER1_gm = 0xFF          ; Asynchronous User Ch 1 Input Selection - ADC0 group mask\n.equ EVSYS_ASYNCUSER1_gp = 0             ; Asynchronous User Ch 1 Input Selection - ADC0 group position\n.equ EVSYS_ASYNCUSER10_bm = (1<<0)       ; Asynchronous User Ch 1 Input Selection - ADC0 bit 0 mask\n.equ EVSYS_ASYNCUSER10_bp = 0            ; Asynchronous User Ch 1 Input Selection - ADC0 bit 0 position\n.equ EVSYS_ASYNCUSER11_bm = (1<<1)       ; Asynchronous User Ch 1 Input Selection - ADC0 bit 1 mask\n.equ EVSYS_ASYNCUSER11_bp = 1            ; Asynchronous User Ch 1 Input Selection - ADC0 bit 1 position\n.equ EVSYS_ASYNCUSER12_bm = (1<<2)       ; Asynchronous User Ch 1 Input Selection - ADC0 bit 2 mask\n.equ EVSYS_ASYNCUSER12_bp = 2            ; Asynchronous User Ch 1 Input Selection - ADC0 bit 2 position\n.equ EVSYS_ASYNCUSER13_bm = (1<<3)       ; Asynchronous User Ch 1 Input Selection - ADC0 bit 3 mask\n.equ EVSYS_ASYNCUSER13_bp = 3            ; Asynchronous User Ch 1 Input Selection - ADC0 bit 3 position\n.equ EVSYS_ASYNCUSER14_bm = (1<<4)       ; Asynchronous User Ch 1 Input Selection - ADC0 bit 4 mask\n.equ EVSYS_ASYNCUSER14_bp = 4            ; Asynchronous User Ch 1 Input Selection - ADC0 bit 4 position\n.equ EVSYS_ASYNCUSER15_bm = (1<<5)       ; Asynchronous User Ch 1 Input Selection - ADC0 bit 5 mask\n.equ EVSYS_ASYNCUSER15_bp = 5            ; Asynchronous User Ch 1 Input Selection - ADC0 bit 5 position\n.equ EVSYS_ASYNCUSER16_bm = (1<<6)       ; Asynchronous User Ch 1 Input Selection - ADC0 bit 6 mask\n.equ EVSYS_ASYNCUSER16_bp = 6            ; Asynchronous User Ch 1 Input Selection - ADC0 bit 6 position\n.equ EVSYS_ASYNCUSER17_bm = (1<<7)       ; Asynchronous User Ch 1 Input Selection - ADC0 bit 7 mask\n.equ EVSYS_ASYNCUSER17_bp = 7            ; Asynchronous User Ch 1 Input Selection - ADC0 bit 7 position\n\n; EVSYS_ASYNCUSER2 masks\n.equ EVSYS_ASYNCUSER2_gm = 0xFF          ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 group mask\n.equ EVSYS_ASYNCUSER2_gp = 0             ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 group position\n.equ EVSYS_ASYNCUSER20_bm = (1<<0)       ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 0 mask\n.equ EVSYS_ASYNCUSER20_bp = 0            ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 0 position\n.equ EVSYS_ASYNCUSER21_bm = (1<<1)       ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 1 mask\n.equ EVSYS_ASYNCUSER21_bp = 1            ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 1 position\n.equ EVSYS_ASYNCUSER22_bm = (1<<2)       ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 2 mask\n.equ EVSYS_ASYNCUSER22_bp = 2            ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 2 position\n.equ EVSYS_ASYNCUSER23_bm = (1<<3)       ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 3 mask\n.equ EVSYS_ASYNCUSER23_bp = 3            ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 3 position\n.equ EVSYS_ASYNCUSER24_bm = (1<<4)       ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 4 mask\n.equ EVSYS_ASYNCUSER24_bp = 4            ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 4 position\n.equ EVSYS_ASYNCUSER25_bm = (1<<5)       ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 5 mask\n.equ EVSYS_ASYNCUSER25_bp = 5            ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 5 position\n.equ EVSYS_ASYNCUSER26_bm = (1<<6)       ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 6 mask\n.equ EVSYS_ASYNCUSER26_bp = 6            ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 6 position\n.equ EVSYS_ASYNCUSER27_bm = (1<<7)       ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 7 mask\n.equ EVSYS_ASYNCUSER27_bp = 7            ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 7 position\n\n; EVSYS_ASYNCUSER3 masks\n.equ EVSYS_ASYNCUSER3_gm = 0xFF          ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 group mask\n.equ EVSYS_ASYNCUSER3_gp = 0             ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 group position\n.equ EVSYS_ASYNCUSER30_bm = (1<<0)       ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 0 mask\n.equ EVSYS_ASYNCUSER30_bp = 0            ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 0 position\n.equ EVSYS_ASYNCUSER31_bm = (1<<1)       ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 1 mask\n.equ EVSYS_ASYNCUSER31_bp = 1            ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 1 position\n.equ EVSYS_ASYNCUSER32_bm = (1<<2)       ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 2 mask\n.equ EVSYS_ASYNCUSER32_bp = 2            ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 2 position\n.equ EVSYS_ASYNCUSER33_bm = (1<<3)       ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 3 mask\n.equ EVSYS_ASYNCUSER33_bp = 3            ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 3 position\n.equ EVSYS_ASYNCUSER34_bm = (1<<4)       ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 4 mask\n.equ EVSYS_ASYNCUSER34_bp = 4            ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 4 position\n.equ EVSYS_ASYNCUSER35_bm = (1<<5)       ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 5 mask\n.equ EVSYS_ASYNCUSER35_bp = 5            ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 5 position\n.equ EVSYS_ASYNCUSER36_bm = (1<<6)       ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 6 mask\n.equ EVSYS_ASYNCUSER36_bp = 6            ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 6 position\n.equ EVSYS_ASYNCUSER37_bm = (1<<7)       ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 7 mask\n.equ EVSYS_ASYNCUSER37_bp = 7            ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 7 position\n\n; EVSYS_ASYNCUSER4 masks\n.equ EVSYS_ASYNCUSER4_gm = 0xFF          ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 group mask\n.equ EVSYS_ASYNCUSER4_gp = 0             ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 group position\n.equ EVSYS_ASYNCUSER40_bm = (1<<0)       ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 0 mask\n.equ EVSYS_ASYNCUSER40_bp = 0            ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 0 position\n.equ EVSYS_ASYNCUSER41_bm = (1<<1)       ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 1 mask\n.equ EVSYS_ASYNCUSER41_bp = 1            ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 1 position\n.equ EVSYS_ASYNCUSER42_bm = (1<<2)       ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 2 mask\n.equ EVSYS_ASYNCUSER42_bp = 2            ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 2 position\n.equ EVSYS_ASYNCUSER43_bm = (1<<3)       ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 3 mask\n.equ EVSYS_ASYNCUSER43_bp = 3            ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 3 position\n.equ EVSYS_ASYNCUSER44_bm = (1<<4)       ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 4 mask\n.equ EVSYS_ASYNCUSER44_bp = 4            ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 4 position\n.equ EVSYS_ASYNCUSER45_bm = (1<<5)       ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 5 mask\n.equ EVSYS_ASYNCUSER45_bp = 5            ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 5 position\n.equ EVSYS_ASYNCUSER46_bm = (1<<6)       ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 6 mask\n.equ EVSYS_ASYNCUSER46_bp = 6            ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 6 position\n.equ EVSYS_ASYNCUSER47_bm = (1<<7)       ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 7 mask\n.equ EVSYS_ASYNCUSER47_bp = 7            ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 7 position\n\n; EVSYS_ASYNCUSER5 masks\n.equ EVSYS_ASYNCUSER5_gm = 0xFF          ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 group mask\n.equ EVSYS_ASYNCUSER5_gp = 0             ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 group position\n.equ EVSYS_ASYNCUSER50_bm = (1<<0)       ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 0 mask\n.equ EVSYS_ASYNCUSER50_bp = 0            ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 0 position\n.equ EVSYS_ASYNCUSER51_bm = (1<<1)       ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 1 mask\n.equ EVSYS_ASYNCUSER51_bp = 1            ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 1 position\n.equ EVSYS_ASYNCUSER52_bm = (1<<2)       ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 2 mask\n.equ EVSYS_ASYNCUSER52_bp = 2            ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 2 position\n.equ EVSYS_ASYNCUSER53_bm = (1<<3)       ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 3 mask\n.equ EVSYS_ASYNCUSER53_bp = 3            ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 3 position\n.equ EVSYS_ASYNCUSER54_bm = (1<<4)       ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 4 mask\n.equ EVSYS_ASYNCUSER54_bp = 4            ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 4 position\n.equ EVSYS_ASYNCUSER55_bm = (1<<5)       ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 5 mask\n.equ EVSYS_ASYNCUSER55_bp = 5            ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 5 position\n.equ EVSYS_ASYNCUSER56_bm = (1<<6)       ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 6 mask\n.equ EVSYS_ASYNCUSER56_bp = 6            ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 6 position\n.equ EVSYS_ASYNCUSER57_bm = (1<<7)       ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 7 mask\n.equ EVSYS_ASYNCUSER57_bp = 7            ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 7 position\n\n; EVSYS_ASYNCUSER6 masks\n.equ EVSYS_ASYNCUSER6_gm = 0xFF          ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 group mask\n.equ EVSYS_ASYNCUSER6_gp = 0             ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 group position\n.equ EVSYS_ASYNCUSER60_bm = (1<<0)       ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 0 mask\n.equ EVSYS_ASYNCUSER60_bp = 0            ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 0 position\n.equ EVSYS_ASYNCUSER61_bm = (1<<1)       ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 1 mask\n.equ EVSYS_ASYNCUSER61_bp = 1            ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 1 position\n.equ EVSYS_ASYNCUSER62_bm = (1<<2)       ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 2 mask\n.equ EVSYS_ASYNCUSER62_bp = 2            ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 2 position\n.equ EVSYS_ASYNCUSER63_bm = (1<<3)       ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 3 mask\n.equ EVSYS_ASYNCUSER63_bp = 3            ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 3 position\n.equ EVSYS_ASYNCUSER64_bm = (1<<4)       ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 4 mask\n.equ EVSYS_ASYNCUSER64_bp = 4            ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 4 position\n.equ EVSYS_ASYNCUSER65_bm = (1<<5)       ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 5 mask\n.equ EVSYS_ASYNCUSER65_bp = 5            ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 5 position\n.equ EVSYS_ASYNCUSER66_bm = (1<<6)       ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 6 mask\n.equ EVSYS_ASYNCUSER66_bp = 6            ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 6 position\n.equ EVSYS_ASYNCUSER67_bm = (1<<7)       ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 7 mask\n.equ EVSYS_ASYNCUSER67_bp = 7            ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 7 position\n\n; EVSYS_ASYNCUSER7 masks\n.equ EVSYS_ASYNCUSER7_gm = 0xFF          ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 group mask\n.equ EVSYS_ASYNCUSER7_gp = 0             ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 group position\n.equ EVSYS_ASYNCUSER70_bm = (1<<0)       ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 0 mask\n.equ EVSYS_ASYNCUSER70_bp = 0            ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 0 position\n.equ EVSYS_ASYNCUSER71_bm = (1<<1)       ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 1 mask\n.equ EVSYS_ASYNCUSER71_bp = 1            ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 1 position\n.equ EVSYS_ASYNCUSER72_bm = (1<<2)       ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 2 mask\n.equ EVSYS_ASYNCUSER72_bp = 2            ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 2 position\n.equ EVSYS_ASYNCUSER73_bm = (1<<3)       ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 3 mask\n.equ EVSYS_ASYNCUSER73_bp = 3            ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 3 position\n.equ EVSYS_ASYNCUSER74_bm = (1<<4)       ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 4 mask\n.equ EVSYS_ASYNCUSER74_bp = 4            ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 4 position\n.equ EVSYS_ASYNCUSER75_bm = (1<<5)       ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 5 mask\n.equ EVSYS_ASYNCUSER75_bp = 5            ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 5 position\n.equ EVSYS_ASYNCUSER76_bm = (1<<6)       ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 6 mask\n.equ EVSYS_ASYNCUSER76_bp = 6            ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 6 position\n.equ EVSYS_ASYNCUSER77_bm = (1<<7)       ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 7 mask\n.equ EVSYS_ASYNCUSER77_bp = 7            ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 7 position\n\n; EVSYS_ASYNCUSER8 masks\n.equ EVSYS_ASYNCUSER8_gm = 0xFF          ; Asynchronous User Ch 8 Input Selection - Event Out 0 group mask\n.equ EVSYS_ASYNCUSER8_gp = 0             ; Asynchronous User Ch 8 Input Selection - Event Out 0 group position\n.equ EVSYS_ASYNCUSER80_bm = (1<<0)       ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 0 mask\n.equ EVSYS_ASYNCUSER80_bp = 0            ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 0 position\n.equ EVSYS_ASYNCUSER81_bm = (1<<1)       ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 1 mask\n.equ EVSYS_ASYNCUSER81_bp = 1            ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 1 position\n.equ EVSYS_ASYNCUSER82_bm = (1<<2)       ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 2 mask\n.equ EVSYS_ASYNCUSER82_bp = 2            ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 2 position\n.equ EVSYS_ASYNCUSER83_bm = (1<<3)       ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 3 mask\n.equ EVSYS_ASYNCUSER83_bp = 3            ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 3 position\n.equ EVSYS_ASYNCUSER84_bm = (1<<4)       ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 4 mask\n.equ EVSYS_ASYNCUSER84_bp = 4            ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 4 position\n.equ EVSYS_ASYNCUSER85_bm = (1<<5)       ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 5 mask\n.equ EVSYS_ASYNCUSER85_bp = 5            ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 5 position\n.equ EVSYS_ASYNCUSER86_bm = (1<<6)       ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 6 mask\n.equ EVSYS_ASYNCUSER86_bp = 6            ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 6 position\n.equ EVSYS_ASYNCUSER87_bm = (1<<7)       ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 7 mask\n.equ EVSYS_ASYNCUSER87_bp = 7            ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 7 position\n\n; EVSYS_ASYNCUSER9 masks\n.equ EVSYS_ASYNCUSER9_gm = 0xFF          ; Asynchronous User Ch 9 Input Selection - Event Out 1 group mask\n.equ EVSYS_ASYNCUSER9_gp = 0             ; Asynchronous User Ch 9 Input Selection - Event Out 1 group position\n.equ EVSYS_ASYNCUSER90_bm = (1<<0)       ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 0 mask\n.equ EVSYS_ASYNCUSER90_bp = 0            ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 0 position\n.equ EVSYS_ASYNCUSER91_bm = (1<<1)       ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 1 mask\n.equ EVSYS_ASYNCUSER91_bp = 1            ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 1 position\n.equ EVSYS_ASYNCUSER92_bm = (1<<2)       ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 2 mask\n.equ EVSYS_ASYNCUSER92_bp = 2            ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 2 position\n.equ EVSYS_ASYNCUSER93_bm = (1<<3)       ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 3 mask\n.equ EVSYS_ASYNCUSER93_bp = 3            ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 3 position\n.equ EVSYS_ASYNCUSER94_bm = (1<<4)       ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 4 mask\n.equ EVSYS_ASYNCUSER94_bp = 4            ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 4 position\n.equ EVSYS_ASYNCUSER95_bm = (1<<5)       ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 5 mask\n.equ EVSYS_ASYNCUSER95_bp = 5            ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 5 position\n.equ EVSYS_ASYNCUSER96_bm = (1<<6)       ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 6 mask\n.equ EVSYS_ASYNCUSER96_bp = 6            ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 6 position\n.equ EVSYS_ASYNCUSER97_bm = (1<<7)       ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 7 mask\n.equ EVSYS_ASYNCUSER97_bp = 7            ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 7 position\n\n; EVSYS_ASYNCUSER10 masks\n.equ EVSYS_ASYNCUSER10_gm = 0xFF         ; Asynchronous User Ch 10 Input Selection - Event Out 2 group mask\n.equ EVSYS_ASYNCUSER10_gp = 0            ; Asynchronous User Ch 10 Input Selection - Event Out 2 group position\n.equ EVSYS_ASYNCUSER100_bm = (1<<0)      ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 0 mask\n.equ EVSYS_ASYNCUSER100_bp = 0           ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 0 position\n.equ EVSYS_ASYNCUSER101_bm = (1<<1)      ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 1 mask\n.equ EVSYS_ASYNCUSER101_bp = 1           ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 1 position\n.equ EVSYS_ASYNCUSER102_bm = (1<<2)      ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 2 mask\n.equ EVSYS_ASYNCUSER102_bp = 2           ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 2 position\n.equ EVSYS_ASYNCUSER103_bm = (1<<3)      ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 3 mask\n.equ EVSYS_ASYNCUSER103_bp = 3           ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 3 position\n.equ EVSYS_ASYNCUSER104_bm = (1<<4)      ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 4 mask\n.equ EVSYS_ASYNCUSER104_bp = 4           ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 4 position\n.equ EVSYS_ASYNCUSER105_bm = (1<<5)      ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 5 mask\n.equ EVSYS_ASYNCUSER105_bp = 5           ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 5 position\n.equ EVSYS_ASYNCUSER106_bm = (1<<6)      ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 6 mask\n.equ EVSYS_ASYNCUSER106_bp = 6           ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 6 position\n.equ EVSYS_ASYNCUSER107_bm = (1<<7)      ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 7 mask\n.equ EVSYS_ASYNCUSER107_bp = 7           ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 7 position\n\n; EVSYS_SYNCCH0 masks\n.equ EVSYS_SYNCCH0_gm = 0xFF             ; Synchronous Channel 0 Generator Selection group mask\n.equ EVSYS_SYNCCH0_gp = 0                ; Synchronous Channel 0 Generator Selection group position\n.equ EVSYS_SYNCCH00_bm = (1<<0)          ; Synchronous Channel 0 Generator Selection bit 0 mask\n.equ EVSYS_SYNCCH00_bp = 0               ; Synchronous Channel 0 Generator Selection bit 0 position\n.equ EVSYS_SYNCCH01_bm = (1<<1)          ; Synchronous Channel 0 Generator Selection bit 1 mask\n.equ EVSYS_SYNCCH01_bp = 1               ; Synchronous Channel 0 Generator Selection bit 1 position\n.equ EVSYS_SYNCCH02_bm = (1<<2)          ; Synchronous Channel 0 Generator Selection bit 2 mask\n.equ EVSYS_SYNCCH02_bp = 2               ; Synchronous Channel 0 Generator Selection bit 2 position\n.equ EVSYS_SYNCCH03_bm = (1<<3)          ; Synchronous Channel 0 Generator Selection bit 3 mask\n.equ EVSYS_SYNCCH03_bp = 3               ; Synchronous Channel 0 Generator Selection bit 3 position\n.equ EVSYS_SYNCCH04_bm = (1<<4)          ; Synchronous Channel 0 Generator Selection bit 4 mask\n.equ EVSYS_SYNCCH04_bp = 4               ; Synchronous Channel 0 Generator Selection bit 4 position\n.equ EVSYS_SYNCCH05_bm = (1<<5)          ; Synchronous Channel 0 Generator Selection bit 5 mask\n.equ EVSYS_SYNCCH05_bp = 5               ; Synchronous Channel 0 Generator Selection bit 5 position\n.equ EVSYS_SYNCCH06_bm = (1<<6)          ; Synchronous Channel 0 Generator Selection bit 6 mask\n.equ EVSYS_SYNCCH06_bp = 6               ; Synchronous Channel 0 Generator Selection bit 6 position\n.equ EVSYS_SYNCCH07_bm = (1<<7)          ; Synchronous Channel 0 Generator Selection bit 7 mask\n.equ EVSYS_SYNCCH07_bp = 7               ; Synchronous Channel 0 Generator Selection bit 7 position\n\n; EVSYS_SYNCCH1 masks\n.equ EVSYS_SYNCCH1_gm = 0xFF             ; Synchronous Channel 1 Generator Selection group mask\n.equ EVSYS_SYNCCH1_gp = 0                ; Synchronous Channel 1 Generator Selection group position\n.equ EVSYS_SYNCCH10_bm = (1<<0)          ; Synchronous Channel 1 Generator Selection bit 0 mask\n.equ EVSYS_SYNCCH10_bp = 0               ; Synchronous Channel 1 Generator Selection bit 0 position\n.equ EVSYS_SYNCCH11_bm = (1<<1)          ; Synchronous Channel 1 Generator Selection bit 1 mask\n.equ EVSYS_SYNCCH11_bp = 1               ; Synchronous Channel 1 Generator Selection bit 1 position\n.equ EVSYS_SYNCCH12_bm = (1<<2)          ; Synchronous Channel 1 Generator Selection bit 2 mask\n.equ EVSYS_SYNCCH12_bp = 2               ; Synchronous Channel 1 Generator Selection bit 2 position\n.equ EVSYS_SYNCCH13_bm = (1<<3)          ; Synchronous Channel 1 Generator Selection bit 3 mask\n.equ EVSYS_SYNCCH13_bp = 3               ; Synchronous Channel 1 Generator Selection bit 3 position\n.equ EVSYS_SYNCCH14_bm = (1<<4)          ; Synchronous Channel 1 Generator Selection bit 4 mask\n.equ EVSYS_SYNCCH14_bp = 4               ; Synchronous Channel 1 Generator Selection bit 4 position\n.equ EVSYS_SYNCCH15_bm = (1<<5)          ; Synchronous Channel 1 Generator Selection bit 5 mask\n.equ EVSYS_SYNCCH15_bp = 5               ; Synchronous Channel 1 Generator Selection bit 5 position\n.equ EVSYS_SYNCCH16_bm = (1<<6)          ; Synchronous Channel 1 Generator Selection bit 6 mask\n.equ EVSYS_SYNCCH16_bp = 6               ; Synchronous Channel 1 Generator Selection bit 6 position\n.equ EVSYS_SYNCCH17_bm = (1<<7)          ; Synchronous Channel 1 Generator Selection bit 7 mask\n.equ EVSYS_SYNCCH17_bp = 7               ; Synchronous Channel 1 Generator Selection bit 7 position\n\n; EVSYS_SYNCUSER0 masks\n.equ EVSYS_SYNCUSER0_gm = 0xFF           ; Synchronous User Ch 0 Input Selection - TCA0 group mask\n.equ EVSYS_SYNCUSER0_gp = 0              ; Synchronous User Ch 0 Input Selection - TCA0 group position\n.equ EVSYS_SYNCUSER00_bm = (1<<0)        ; Synchronous User Ch 0 Input Selection - TCA0 bit 0 mask\n.equ EVSYS_SYNCUSER00_bp = 0             ; Synchronous User Ch 0 Input Selection - TCA0 bit 0 position\n.equ EVSYS_SYNCUSER01_bm = (1<<1)        ; Synchronous User Ch 0 Input Selection - TCA0 bit 1 mask\n.equ EVSYS_SYNCUSER01_bp = 1             ; Synchronous User Ch 0 Input Selection - TCA0 bit 1 position\n.equ EVSYS_SYNCUSER02_bm = (1<<2)        ; Synchronous User Ch 0 Input Selection - TCA0 bit 2 mask\n.equ EVSYS_SYNCUSER02_bp = 2             ; Synchronous User Ch 0 Input Selection - TCA0 bit 2 position\n.equ EVSYS_SYNCUSER03_bm = (1<<3)        ; Synchronous User Ch 0 Input Selection - TCA0 bit 3 mask\n.equ EVSYS_SYNCUSER03_bp = 3             ; Synchronous User Ch 0 Input Selection - TCA0 bit 3 position\n.equ EVSYS_SYNCUSER04_bm = (1<<4)        ; Synchronous User Ch 0 Input Selection - TCA0 bit 4 mask\n.equ EVSYS_SYNCUSER04_bp = 4             ; Synchronous User Ch 0 Input Selection - TCA0 bit 4 position\n.equ EVSYS_SYNCUSER05_bm = (1<<5)        ; Synchronous User Ch 0 Input Selection - TCA0 bit 5 mask\n.equ EVSYS_SYNCUSER05_bp = 5             ; Synchronous User Ch 0 Input Selection - TCA0 bit 5 position\n.equ EVSYS_SYNCUSER06_bm = (1<<6)        ; Synchronous User Ch 0 Input Selection - TCA0 bit 6 mask\n.equ EVSYS_SYNCUSER06_bp = 6             ; Synchronous User Ch 0 Input Selection - TCA0 bit 6 position\n.equ EVSYS_SYNCUSER07_bm = (1<<7)        ; Synchronous User Ch 0 Input Selection - TCA0 bit 7 mask\n.equ EVSYS_SYNCUSER07_bp = 7             ; Synchronous User Ch 0 Input Selection - TCA0 bit 7 position\n\n; EVSYS_SYNCUSER1 masks\n.equ EVSYS_SYNCUSER1_gm = 0xFF           ; Synchronous User Ch 1 Input Selection - USART0 group mask\n.equ EVSYS_SYNCUSER1_gp = 0              ; Synchronous User Ch 1 Input Selection - USART0 group position\n.equ EVSYS_SYNCUSER10_bm = (1<<0)        ; Synchronous User Ch 1 Input Selection - USART0 bit 0 mask\n.equ EVSYS_SYNCUSER10_bp = 0             ; Synchronous User Ch 1 Input Selection - USART0 bit 0 position\n.equ EVSYS_SYNCUSER11_bm = (1<<1)        ; Synchronous User Ch 1 Input Selection - USART0 bit 1 mask\n.equ EVSYS_SYNCUSER11_bp = 1             ; Synchronous User Ch 1 Input Selection - USART0 bit 1 position\n.equ EVSYS_SYNCUSER12_bm = (1<<2)        ; Synchronous User Ch 1 Input Selection - USART0 bit 2 mask\n.equ EVSYS_SYNCUSER12_bp = 2             ; Synchronous User Ch 1 Input Selection - USART0 bit 2 position\n.equ EVSYS_SYNCUSER13_bm = (1<<3)        ; Synchronous User Ch 1 Input Selection - USART0 bit 3 mask\n.equ EVSYS_SYNCUSER13_bp = 3             ; Synchronous User Ch 1 Input Selection - USART0 bit 3 position\n.equ EVSYS_SYNCUSER14_bm = (1<<4)        ; Synchronous User Ch 1 Input Selection - USART0 bit 4 mask\n.equ EVSYS_SYNCUSER14_bp = 4             ; Synchronous User Ch 1 Input Selection - USART0 bit 4 position\n.equ EVSYS_SYNCUSER15_bm = (1<<5)        ; Synchronous User Ch 1 Input Selection - USART0 bit 5 mask\n.equ EVSYS_SYNCUSER15_bp = 5             ; Synchronous User Ch 1 Input Selection - USART0 bit 5 position\n.equ EVSYS_SYNCUSER16_bm = (1<<6)        ; Synchronous User Ch 1 Input Selection - USART0 bit 6 mask\n.equ EVSYS_SYNCUSER16_bp = 6             ; Synchronous User Ch 1 Input Selection - USART0 bit 6 position\n.equ EVSYS_SYNCUSER17_bm = (1<<7)        ; Synchronous User Ch 1 Input Selection - USART0 bit 7 mask\n.equ EVSYS_SYNCUSER17_bp = 7             ; Synchronous User Ch 1 Input Selection - USART0 bit 7 position\n\n; Asynchronous Channel 0 Generator Selection select\n.equ EVSYS_ASYNCCH0_OFF_gc = (0x00<<0)   ; Off\n.equ EVSYS_ASYNCCH0_CCL_LUT0_gc = (0x01<<0) ; Configurable Custom Logic LUT0\n.equ EVSYS_ASYNCCH0_CCL_LUT1_gc = (0x02<<0) ; Configurable Custom Logic LUT1\n.equ EVSYS_ASYNCCH0_AC0_OUT_gc = (0x03<<0) ; Analog Comparator 0 out\n.equ EVSYS_ASYNCCH0_TCD0_CMPBCLR_gc = (0x04<<0) ; Timer/Counter D0 compare B clear\n.equ EVSYS_ASYNCCH0_TCD0_CMPASET_gc = (0x05<<0) ; Timer/Counter D0 compare A set\n.equ EVSYS_ASYNCCH0_TCD0_CMPBSET_gc = (0x06<<0) ; Timer/Counter D0 compare B set\n.equ EVSYS_ASYNCCH0_TCD0_PROGEV_gc = (0x07<<0) ; Timer/Counter D0 program event\n.equ EVSYS_ASYNCCH0_RTC_OVF_gc = (0x08<<0) ; Real Time Counter overflow\n.equ EVSYS_ASYNCCH0_RTC_CMP_gc = (0x09<<0) ; Real Time Counter compare\n.equ EVSYS_ASYNCCH0_PORTA_PIN0_gc = (0x0A<<0) ; Asynchronous Event from Pin PA0\n.equ EVSYS_ASYNCCH0_PORTA_PIN1_gc = (0x0B<<0) ; Asynchronous Event from Pin PA1\n.equ EVSYS_ASYNCCH0_PORTA_PIN2_gc = (0x0C<<0) ; Asynchronous Event from Pin PA2\n.equ EVSYS_ASYNCCH0_PORTA_PIN3_gc = (0x0D<<0) ; Asynchronous Event from Pin PA3\n.equ EVSYS_ASYNCCH0_PORTA_PIN4_gc = (0x0E<<0) ; Asynchronous Event from Pin PA4\n.equ EVSYS_ASYNCCH0_PORTA_PIN5_gc = (0x0F<<0) ; Asynchronous Event from Pin PA5\n.equ EVSYS_ASYNCCH0_PORTA_PIN6_gc = (0x10<<0) ; Asynchronous Event from Pin PA6\n.equ EVSYS_ASYNCCH0_PORTA_PIN7_gc = (0x11<<0) ; Asynchronous Event from Pin PA7\n.equ EVSYS_ASYNCCH0_UPDI_gc = (0x12<<0)  ; Unified Program and debug interface\n\n; Asynchronous Channel 1 Generator Selection select\n.equ EVSYS_ASYNCCH1_OFF_gc = (0x00<<0)   ; Off\n.equ EVSYS_ASYNCCH1_CCL_LUT0_gc = (0x01<<0) ; Configurable custom logic LUT0\n.equ EVSYS_ASYNCCH1_CCL_LUT1_gc = (0x02<<0) ; Configurable custom logic LUT1\n.equ EVSYS_ASYNCCH1_AC0_OUT_gc = (0x03<<0) ; Analog Comparator 0 out\n.equ EVSYS_ASYNCCH1_TCD0_CMPBCLR_gc = (0x04<<0) ; Timer/Counter D0 compare B clear\n.equ EVSYS_ASYNCCH1_TCD0_CMPASET_gc = (0x05<<0) ; Timer/Counter D0 compare A set\n.equ EVSYS_ASYNCCH1_TCD0_CMPBSET_gc = (0x06<<0) ; Timer/Counter D0 compare B set\n.equ EVSYS_ASYNCCH1_TCD0_PROGEV_gc = (0x07<<0) ; Timer/Counter D0 program event\n.equ EVSYS_ASYNCCH1_RTC_OVF_gc = (0x08<<0) ; Real Time Counter overflow\n.equ EVSYS_ASYNCCH1_RTC_CMP_gc = (0x09<<0) ; Real Time Counter compare\n.equ EVSYS_ASYNCCH1_PORTB_PIN0_gc = (0x0A<<0) ; Asynchronous Event from Pin PB0\n.equ EVSYS_ASYNCCH1_PORTB_PIN1_gc = (0x0B<<0) ; Asynchronous Event from Pin PB1\n.equ EVSYS_ASYNCCH1_PORTB_PIN2_gc = (0x0C<<0) ; Asynchronous Event from Pin PB2\n.equ EVSYS_ASYNCCH1_PORTB_PIN3_gc = (0x0D<<0) ; Asynchronous Event from Pin PB3\n.equ EVSYS_ASYNCCH1_PORTB_PIN4_gc = (0x0E<<0) ; Asynchronous Event from Pin PB4\n.equ EVSYS_ASYNCCH1_PORTB_PIN5_gc = (0x0F<<0) ; Asynchronous Event from Pin PB5\n.equ EVSYS_ASYNCCH1_PORTB_PIN6_gc = (0x10<<0) ; Asynchronous Event from Pin PB6\n.equ EVSYS_ASYNCCH1_PORTB_PIN7_gc = (0x11<<0) ; Asynchronous Event from Pin PB7\n\n; Asynchronous Channel 2 Generator Selection select\n.equ EVSYS_ASYNCCH2_OFF_gc = (0x00<<0)   ; Off\n.equ EVSYS_ASYNCCH2_CCL_LUT0_gc = (0x01<<0) ; Configurable Custom Logic LUT0\n.equ EVSYS_ASYNCCH2_CCL_LUT1_gc = (0x02<<0) ; Configurable Custom Logic LUT1\n.equ EVSYS_ASYNCCH2_AC0_OUT_gc = (0x03<<0) ; Analog Comparator 0 out\n.equ EVSYS_ASYNCCH2_TCD0_CMPBCLR_gc = (0x04<<0) ; Timer/Counter D0 compare B clear\n.equ EVSYS_ASYNCCH2_TCD0_CMPASET_gc = (0x05<<0) ; Timer/Counter D0 compare A set\n.equ EVSYS_ASYNCCH2_TCD0_CMPBSET_gc = (0x06<<0) ; Timer/Counter D0 compare B set\n.equ EVSYS_ASYNCCH2_TCD0_PROGEV_gc = (0x07<<0) ; Timer/Counter D0 program event\n.equ EVSYS_ASYNCCH2_RTC_OVF_gc = (0x08<<0) ; Real Time Counter overflow\n.equ EVSYS_ASYNCCH2_RTC_CMP_gc = (0x09<<0) ; Real Time Counter compare\n.equ EVSYS_ASYNCCH2_PORTC_PIN0_gc = (0x0A<<0) ; Asynchronous Event from Pin PC0\n.equ EVSYS_ASYNCCH2_PORTC_PIN1_gc = (0x0B<<0) ; Asynchronous Event from Pin PC1\n.equ EVSYS_ASYNCCH2_PORTC_PIN2_gc = (0x0C<<0) ; Asynchronous Event from Pin PC2\n.equ EVSYS_ASYNCCH2_PORTC_PIN3_gc = (0x0D<<0) ; Asynchronous Event from Pin PC3\n.equ EVSYS_ASYNCCH2_PORTC_PIN4_gc = (0x0E<<0) ; Asynchronous Event from Pin PC4\n.equ EVSYS_ASYNCCH2_PORTC_PIN5_gc = (0x0F<<0) ; Asynchronous Event from Pin PC5\n\n; Asynchronous Channel 3 Generator Selection select\n.equ EVSYS_ASYNCCH3_OFF_gc = (0x00<<0)   ; Off\n.equ EVSYS_ASYNCCH3_CCL_LUT0_gc = (0x01<<0) ; Configurable custom logic LUT0\n.equ EVSYS_ASYNCCH3_CCL_LUT1_gc = (0x02<<0) ; Configurable custom logic LUT1\n.equ EVSYS_ASYNCCH3_AC0_OUT_gc = (0x03<<0) ; Analog Comparator 0 out\n.equ EVSYS_ASYNCCH3_TCD0_CMPBCLR_gc = (0x04<<0) ; Timer/Counter type D compare B clear\n.equ EVSYS_ASYNCCH3_TCD0_CMPASET_gc = (0x05<<0) ; Timer/Counter type D compare A set\n.equ EVSYS_ASYNCCH3_TCD0_CMPBSET_gc = (0x06<<0) ; Timer/Counter type D compare B set\n.equ EVSYS_ASYNCCH3_TCD0_PROGEV_gc = (0x07<<0) ; Timer/Counter type D program event\n.equ EVSYS_ASYNCCH3_RTC_OVF_gc = (0x08<<0) ; Real Time Counter overflow\n.equ EVSYS_ASYNCCH3_RTC_CMP_gc = (0x09<<0) ; Real Time Counter compare\n.equ EVSYS_ASYNCCH3_PIT_DIV8192_gc = (0x0A<<0) ; Periodic Interrupt CLK_RTC div 8192\n.equ EVSYS_ASYNCCH3_PIT_DIV4096_gc = (0x0B<<0) ; Periodic Interrupt CLK_RTC div 4096\n.equ EVSYS_ASYNCCH3_PIT_DIV2048_gc = (0x0C<<0) ; Periodic Interrupt CLK_RTC div 2048\n.equ EVSYS_ASYNCCH3_PIT_DIV1024_gc = (0x0D<<0) ; Periodic Interrupt CLK_RTC div 1024\n.equ EVSYS_ASYNCCH3_PIT_DIV512_gc = (0x0E<<0) ; Periodic Interrupt CLK_RTC div 512\n.equ EVSYS_ASYNCCH3_PIT_DIV256_gc = (0x0F<<0) ; Periodic Interrupt CLK_RTC div 256\n.equ EVSYS_ASYNCCH3_PIT_DIV128_gc = (0x10<<0) ; Periodic Interrupt CLK_RTC div 128\n.equ EVSYS_ASYNCCH3_PIT_DIV64_gc = (0x11<<0) ; Periodic Interrupt CLK_RTC div 64\n\n; Asynchronous User Ch 0 Input Selection - TCB0 select\n.equ EVSYS_ASYNCUSER0_OFF_gc = (0x00<<0) ; Off\n.equ EVSYS_ASYNCUSER0_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_ASYNCUSER0_SYNCCH1_gc = (0x02<<0) ; Synchronous Event Channel 1\n.equ EVSYS_ASYNCUSER0_ASYNCCH0_gc = (0x03<<0) ; Asynchronous Event Channel 0\n.equ EVSYS_ASYNCUSER0_ASYNCCH1_gc = (0x04<<0) ; Asynchronous Event Channel 1\n.equ EVSYS_ASYNCUSER0_ASYNCCH2_gc = (0x05<<0) ; Asynchronous Event Channel 2\n.equ EVSYS_ASYNCUSER0_ASYNCCH3_gc = (0x06<<0) ; Asynchronous Event Channel 3\n\n; Asynchronous User Ch 1 Input Selection - ADC0 select\n.equ EVSYS_ASYNCUSER1_OFF_gc = (0x00<<0) ; Off\n.equ EVSYS_ASYNCUSER1_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_ASYNCUSER1_SYNCCH1_gc = (0x02<<0) ; Synchronous Event Channel 1\n.equ EVSYS_ASYNCUSER1_ASYNCCH0_gc = (0x03<<0) ; Asynchronous Event Channel 0\n.equ EVSYS_ASYNCUSER1_ASYNCCH1_gc = (0x04<<0) ; Asynchronous Event Channel 1\n.equ EVSYS_ASYNCUSER1_ASYNCCH2_gc = (0x05<<0) ; Asynchronous Event Channel 2\n.equ EVSYS_ASYNCUSER1_ASYNCCH3_gc = (0x06<<0) ; Asynchronous Event Channel 3\n\n; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 select\n.equ EVSYS_ASYNCUSER2_OFF_gc = (0x00<<0) ; Off\n.equ EVSYS_ASYNCUSER2_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_ASYNCUSER2_SYNCCH1_gc = (0x02<<0) ; Synchronous Event Channel 1\n.equ EVSYS_ASYNCUSER2_ASYNCCH0_gc = (0x03<<0) ; Asynchronous Event Channel 0\n.equ EVSYS_ASYNCUSER2_ASYNCCH1_gc = (0x04<<0) ; Asynchronous Event Channel 1\n.equ EVSYS_ASYNCUSER2_ASYNCCH2_gc = (0x05<<0) ; Asynchronous Event Channel 2\n.equ EVSYS_ASYNCUSER2_ASYNCCH3_gc = (0x06<<0) ; Asynchronous Event Channel 3\n\n; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 select\n.equ EVSYS_ASYNCUSER3_OFF_gc = (0x00<<0) ; Off\n.equ EVSYS_ASYNCUSER3_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_ASYNCUSER3_SYNCCH1_gc = (0x02<<0) ; Synchronous Event Channel 1\n.equ EVSYS_ASYNCUSER3_ASYNCCH0_gc = (0x03<<0) ; Asynchronous Event Channel 0\n.equ EVSYS_ASYNCUSER3_ASYNCCH1_gc = (0x04<<0) ; Asynchronous Event Channel 1\n.equ EVSYS_ASYNCUSER3_ASYNCCH2_gc = (0x05<<0) ; Asynchronous Event Channel 2\n.equ EVSYS_ASYNCUSER3_ASYNCCH3_gc = (0x06<<0) ; Asynchronous Event Channel 3\n\n; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 select\n.equ EVSYS_ASYNCUSER4_OFF_gc = (0x00<<0) ; Off\n.equ EVSYS_ASYNCUSER4_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_ASYNCUSER4_SYNCCH1_gc = (0x02<<0) ; Synchronous Event Channel 1\n.equ EVSYS_ASYNCUSER4_ASYNCCH0_gc = (0x03<<0) ; Asynchronous Event Channel 0\n.equ EVSYS_ASYNCUSER4_ASYNCCH1_gc = (0x04<<0) ; Asynchronous Event Channel 1\n.equ EVSYS_ASYNCUSER4_ASYNCCH2_gc = (0x05<<0) ; Asynchronous Event Channel 2\n.equ EVSYS_ASYNCUSER4_ASYNCCH3_gc = (0x06<<0) ; Asynchronous Event Channel 3\n\n; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 select\n.equ EVSYS_ASYNCUSER5_OFF_gc = (0x00<<0) ; Off\n.equ EVSYS_ASYNCUSER5_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_ASYNCUSER5_SYNCCH1_gc = (0x02<<0) ; Synchronous Event Channel 1\n.equ EVSYS_ASYNCUSER5_ASYNCCH0_gc = (0x03<<0) ; Asynchronous Event Channel 0\n.equ EVSYS_ASYNCUSER5_ASYNCCH1_gc = (0x04<<0) ; Asynchronous Event Channel 1\n.equ EVSYS_ASYNCUSER5_ASYNCCH2_gc = (0x05<<0) ; Asynchronous Event Channel 2\n.equ EVSYS_ASYNCUSER5_ASYNCCH3_gc = (0x06<<0) ; Asynchronous Event Channel 3\n\n; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 select\n.equ EVSYS_ASYNCUSER6_OFF_gc = (0x00<<0) ; Off\n.equ EVSYS_ASYNCUSER6_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_ASYNCUSER6_SYNCCH1_gc = (0x02<<0) ; Synchronous Event Channel 1\n.equ EVSYS_ASYNCUSER6_ASYNCCH0_gc = (0x03<<0) ; Asynchronous Event Channel 0\n.equ EVSYS_ASYNCUSER6_ASYNCCH1_gc = (0x04<<0) ; Asynchronous Event Channel 1\n.equ EVSYS_ASYNCUSER6_ASYNCCH2_gc = (0x05<<0) ; Asynchronous Event Channel 2\n.equ EVSYS_ASYNCUSER6_ASYNCCH3_gc = (0x06<<0) ; Asynchronous Event Channel 3\n\n; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 select\n.equ EVSYS_ASYNCUSER7_OFF_gc = (0x00<<0) ; Off\n.equ EVSYS_ASYNCUSER7_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_ASYNCUSER7_SYNCCH1_gc = (0x02<<0) ; Synchronous Event Channel 1\n.equ EVSYS_ASYNCUSER7_ASYNCCH0_gc = (0x03<<0) ; Asynchronous Event Channel 0\n.equ EVSYS_ASYNCUSER7_ASYNCCH1_gc = (0x04<<0) ; Asynchronous Event Channel 1\n.equ EVSYS_ASYNCUSER7_ASYNCCH2_gc = (0x05<<0) ; Asynchronous Event Channel 2\n.equ EVSYS_ASYNCUSER7_ASYNCCH3_gc = (0x06<<0) ; Asynchronous Event Channel 3\n\n; Asynchronous User Ch 8 Input Selection - Event Out 0 select\n.equ EVSYS_ASYNCUSER8_OFF_gc = (0x00<<0) ; Off\n.equ EVSYS_ASYNCUSER8_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_ASYNCUSER8_SYNCCH1_gc = (0x02<<0) ; Synchronous Event Channel 1\n.equ EVSYS_ASYNCUSER8_ASYNCCH0_gc = (0x03<<0) ; Asynchronous Event Channel 0\n.equ EVSYS_ASYNCUSER8_ASYNCCH1_gc = (0x04<<0) ; Asynchronous Event Channel 1\n.equ EVSYS_ASYNCUSER8_ASYNCCH2_gc = (0x05<<0) ; Asynchronous Event Channel 2\n.equ EVSYS_ASYNCUSER8_ASYNCCH3_gc = (0x06<<0) ; Asynchronous Event Channel 3\n\n; Asynchronous User Ch 9 Input Selection - Event Out 1 select\n.equ EVSYS_ASYNCUSER9_OFF_gc = (0x00<<0) ; Off\n.equ EVSYS_ASYNCUSER9_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_ASYNCUSER9_SYNCCH1_gc = (0x02<<0) ; Synchronous Event Channel 1\n.equ EVSYS_ASYNCUSER9_ASYNCCH0_gc = (0x03<<0) ; Asynchronous Event Channel 0\n.equ EVSYS_ASYNCUSER9_ASYNCCH1_gc = (0x04<<0) ; Asynchronous Event Channel 1\n.equ EVSYS_ASYNCUSER9_ASYNCCH2_gc = (0x05<<0) ; Asynchronous Event Channel 2\n.equ EVSYS_ASYNCUSER9_ASYNCCH3_gc = (0x06<<0) ; Asynchronous Event Channel 3\n\n; Asynchronous User Ch 10 Input Selection - Event Out 2 select\n.equ EVSYS_ASYNCUSER10_OFF_gc = (0x00<<0) ; Off\n.equ EVSYS_ASYNCUSER10_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_ASYNCUSER10_SYNCCH1_gc = (0x02<<0) ; Synchronous Event Channel 1\n.equ EVSYS_ASYNCUSER10_ASYNCCH0_gc = (0x03<<0) ; Asynchronous Event Channel 0\n.equ EVSYS_ASYNCUSER10_ASYNCCH1_gc = (0x04<<0) ; Asynchronous Event Channel 1\n.equ EVSYS_ASYNCUSER10_ASYNCCH2_gc = (0x05<<0) ; Asynchronous Event Channel 2\n.equ EVSYS_ASYNCUSER10_ASYNCCH3_gc = (0x06<<0) ; Asynchronous Event Channel 3\n\n; Synchronous Channel 0 Generator Selection select\n.equ EVSYS_SYNCCH0_OFF_gc = (0x00<<0)    ; Off\n.equ EVSYS_SYNCCH0_TCB0_gc = (0x01<<0)   ; Timer/Counter B0\n.equ EVSYS_SYNCCH0_TCA0_OVF_LUNF_gc = (0x02<<0) ; Timer/Counter A0 overflow\n.equ EVSYS_SYNCCH0_TCA0_HUNF_gc = (0x03<<0) ; Timer/Counter A0 underflow high byte (split mode)\n.equ EVSYS_SYNCCH0_TCA0_CMP0_gc = (0x04<<0) ; Timer/Counter A0 compare 0\n.equ EVSYS_SYNCCH0_TCA0_CMP1_gc = (0x05<<0) ; Timer/Counter A0 compare 1\n.equ EVSYS_SYNCCH0_TCA0_CMP2_gc = (0x06<<0) ; Timer/Counter A0 compare 2\n.equ EVSYS_SYNCCH0_PORTC_PIN0_gc = (0x07<<0) ; Synchronous Event from Pin PC0\n.equ EVSYS_SYNCCH0_PORTC_PIN1_gc = (0x08<<0) ; Synchronous Event from Pin PC1\n.equ EVSYS_SYNCCH0_PORTC_PIN2_gc = (0x09<<0) ; Synchronous Event from Pin PC2\n.equ EVSYS_SYNCCH0_PORTC_PIN3_gc = (0x0A<<0) ; Synchronous Event from Pin PC3\n.equ EVSYS_SYNCCH0_PORTC_PIN4_gc = (0x0B<<0) ; Synchronous Event from Pin PC4\n.equ EVSYS_SYNCCH0_PORTC_PIN5_gc = (0x0C<<0) ; Synchronous Event from Pin PC5\n.equ EVSYS_SYNCCH0_PORTA_PIN0_gc = (0x0D<<0) ; Synchronous Event from Pin PA0\n.equ EVSYS_SYNCCH0_PORTA_PIN1_gc = (0x0E<<0) ; Synchronous Event from Pin PA1\n.equ EVSYS_SYNCCH0_PORTA_PIN2_gc = (0x0F<<0) ; Synchronous Event from Pin PA2\n.equ EVSYS_SYNCCH0_PORTA_PIN3_gc = (0x10<<0) ; Synchronous Event from Pin PA3\n.equ EVSYS_SYNCCH0_PORTA_PIN4_gc = (0x11<<0) ; Synchronous Event from Pin PA4\n.equ EVSYS_SYNCCH0_PORTA_PIN5_gc = (0x12<<0) ; Synchronous Event from Pin PA5\n.equ EVSYS_SYNCCH0_PORTA_PIN6_gc = (0x13<<0) ; Synchronous Event from Pin PA6\n.equ EVSYS_SYNCCH0_PORTA_PIN7_gc = (0x14<<0) ; Synchronous Event from Pin PA7\n\n; Synchronous Channel 1 Generator Selection select\n.equ EVSYS_SYNCCH1_OFF_gc = (0x00<<0)    ; Off\n.equ EVSYS_SYNCCH1_TCB0_gc = (0x01<<0)   ; Timer/Counter B0\n.equ EVSYS_SYNCCH1_TCA0_OVF_LUNF_gc = (0x02<<0) ; Timer/Counter A0 overflow\n.equ EVSYS_SYNCCH1_TCA0_HUNF_gc = (0x03<<0) ; Timer/Counter A0 underflow high byte (split mode)\n.equ EVSYS_SYNCCH1_TCA0_CMP0_gc = (0x04<<0) ; Timer/Counter A0 compare 0\n.equ EVSYS_SYNCCH1_TCA0_CMP1_gc = (0x05<<0) ; Timer/Counter A0 compare 1\n.equ EVSYS_SYNCCH1_TCA0_CMP2_gc = (0x06<<0) ; Timer/Counter A0 compare 2\n.equ EVSYS_SYNCCH1_PORTB_PIN0_gc = (0x08<<0) ; Synchronous Event from Pin PB0\n.equ EVSYS_SYNCCH1_PORTB_PIN1_gc = (0x09<<0) ; Synchronous Event from Pin PB1\n.equ EVSYS_SYNCCH1_PORTB_PIN2_gc = (0x0A<<0) ; Synchronous Event from Pin PB2\n.equ EVSYS_SYNCCH1_PORTB_PIN3_gc = (0x0B<<0) ; Synchronous Event from Pin PB3\n.equ EVSYS_SYNCCH1_PORTB_PIN4_gc = (0x0C<<0) ; Synchronous Event from Pin PB4\n.equ EVSYS_SYNCCH1_PORTB_PIN5_gc = (0x0D<<0) ; Synchronous Event from Pin PB5\n.equ EVSYS_SYNCCH1_PORTB_PIN6_gc = (0x0E<<0) ; Synchronous Event from Pin PB6\n.equ EVSYS_SYNCCH1_PORTB_PIN7_gc = (0x0F<<0) ; Synchronous Event from Pin PB7\n\n; Synchronous User Ch 0 Input Selection - TCA0 select\n.equ EVSYS_SYNCUSER0_OFF_gc = (0x00<<0)  ; Off\n.equ EVSYS_SYNCUSER0_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_SYNCUSER0_SYNCCH1_gc = (0x02<<0) ; Synchronous Event Channel 1\n\n; Synchronous User Ch 1 Input Selection - USART0 select\n.equ EVSYS_SYNCUSER1_OFF_gc = (0x00<<0)  ; Off\n.equ EVSYS_SYNCUSER1_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_SYNCUSER1_SYNCCH1_gc = (0x02<<0) ; Synchronous Event Channel 1\n\n\n;*************************************************************************\n;** FUSE - Fuses\n;*************************************************************************\n\n; FUSE_BODCFG masks\n.equ FUSE_ACTIVE_gm = 0x0C               ; BOD Operation in Active Mode group mask\n.equ FUSE_ACTIVE_gp = 2                  ; BOD Operation in Active Mode group position\n.equ FUSE_ACTIVE0_bm = (1<<2)            ; BOD Operation in Active Mode bit 0 mask\n.equ FUSE_ACTIVE0_bp = 2                 ; BOD Operation in Active Mode bit 0 position\n.equ FUSE_ACTIVE1_bm = (1<<3)            ; BOD Operation in Active Mode bit 1 mask\n.equ FUSE_ACTIVE1_bp = 3                 ; BOD Operation in Active Mode bit 1 position\n.equ FUSE_LVL_gm = 0xE0                  ; BOD Level group mask\n.equ FUSE_LVL_gp = 5                     ; BOD Level group position\n.equ FUSE_LVL0_bm = (1<<5)               ; BOD Level bit 0 mask\n.equ FUSE_LVL0_bp = 5                    ; BOD Level bit 0 position\n.equ FUSE_LVL1_bm = (1<<6)               ; BOD Level bit 1 mask\n.equ FUSE_LVL1_bp = 6                    ; BOD Level bit 1 position\n.equ FUSE_LVL2_bm = (1<<7)               ; BOD Level bit 2 mask\n.equ FUSE_LVL2_bp = 7                    ; BOD Level bit 2 position\n.equ FUSE_SAMPFREQ_bm = 0x10             ; BOD Sample Frequency bit mask\n.equ FUSE_SAMPFREQ_bp = 4                ; BOD Sample Frequency bit position\n.equ FUSE_SLEEP_gm = 0x03                ; BOD Operation in Sleep Mode group mask\n.equ FUSE_SLEEP_gp = 0                   ; BOD Operation in Sleep Mode group position\n.equ FUSE_SLEEP0_bm = (1<<0)             ; BOD Operation in Sleep Mode bit 0 mask\n.equ FUSE_SLEEP0_bp = 0                  ; BOD Operation in Sleep Mode bit 0 position\n.equ FUSE_SLEEP1_bm = (1<<1)             ; BOD Operation in Sleep Mode bit 1 mask\n.equ FUSE_SLEEP1_bp = 1                  ; BOD Operation in Sleep Mode bit 1 position\n\n; FUSE_OSCCFG masks\n.equ FUSE_FREQSEL_gm = 0x03              ; Frequency Select group mask\n.equ FUSE_FREQSEL_gp = 0                 ; Frequency Select group position\n.equ FUSE_FREQSEL0_bm = (1<<0)           ; Frequency Select bit 0 mask\n.equ FUSE_FREQSEL0_bp = 0                ; Frequency Select bit 0 position\n.equ FUSE_FREQSEL1_bm = (1<<1)           ; Frequency Select bit 1 mask\n.equ FUSE_FREQSEL1_bp = 1                ; Frequency Select bit 1 position\n.equ FUSE_OSCLOCK_bm = 0x80              ; Oscillator Lock bit mask\n.equ FUSE_OSCLOCK_bp = 7                 ; Oscillator Lock bit position\n\n; FUSE_SYSCFG0 masks\n.equ FUSE_CRCSRC_gm = 0xC0               ; CRC Source group mask\n.equ FUSE_CRCSRC_gp = 6                  ; CRC Source group position\n.equ FUSE_CRCSRC0_bm = (1<<6)            ; CRC Source bit 0 mask\n.equ FUSE_CRCSRC0_bp = 6                 ; CRC Source bit 0 position\n.equ FUSE_CRCSRC1_bm = (1<<7)            ; CRC Source bit 1 mask\n.equ FUSE_CRCSRC1_bp = 7                 ; CRC Source bit 1 position\n.equ FUSE_EESAVE_bm = 0x01               ; EEPROM Save bit mask\n.equ FUSE_EESAVE_bp = 0                  ; EEPROM Save bit position\n.equ FUSE_RSTPINCFG_gm = 0x0C            ; Reset Pin Configuration group mask\n.equ FUSE_RSTPINCFG_gp = 2               ; Reset Pin Configuration group position\n.equ FUSE_RSTPINCFG0_bm = (1<<2)         ; Reset Pin Configuration bit 0 mask\n.equ FUSE_RSTPINCFG0_bp = 2              ; Reset Pin Configuration bit 0 position\n.equ FUSE_RSTPINCFG1_bm = (1<<3)         ; Reset Pin Configuration bit 1 mask\n.equ FUSE_RSTPINCFG1_bp = 3              ; Reset Pin Configuration bit 1 position\n\n; FUSE_SYSCFG1 masks\n.equ FUSE_SUT_gm = 0x07                  ; Startup Time group mask\n.equ FUSE_SUT_gp = 0                     ; Startup Time group position\n.equ FUSE_SUT0_bm = (1<<0)               ; Startup Time bit 0 mask\n.equ FUSE_SUT0_bp = 0                    ; Startup Time bit 0 position\n.equ FUSE_SUT1_bm = (1<<1)               ; Startup Time bit 1 mask\n.equ FUSE_SUT1_bp = 1                    ; Startup Time bit 1 position\n.equ FUSE_SUT2_bm = (1<<2)               ; Startup Time bit 2 mask\n.equ FUSE_SUT2_bp = 2                    ; Startup Time bit 2 position\n\n; FUSE_TCD0CFG masks\n.equ FUSE_CMPA_bm = 0x01                 ; Compare A Default Output Value bit mask\n.equ FUSE_CMPA_bp = 0                    ; Compare A Default Output Value bit position\n.equ FUSE_CMPAEN_bm = 0x10               ; Compare A Output Enable bit mask\n.equ FUSE_CMPAEN_bp = 4                  ; Compare A Output Enable bit position\n.equ FUSE_CMPB_bm = 0x02                 ; Compare B Default Output Value bit mask\n.equ FUSE_CMPB_bp = 1                    ; Compare B Default Output Value bit position\n.equ FUSE_CMPBEN_bm = 0x20               ; Compare B Output Enable bit mask\n.equ FUSE_CMPBEN_bp = 5                  ; Compare B Output Enable bit position\n.equ FUSE_CMPC_bm = 0x04                 ; Compare C Default Output Value bit mask\n.equ FUSE_CMPC_bp = 2                    ; Compare C Default Output Value bit position\n.equ FUSE_CMPCEN_bm = 0x40               ; Compare C Output Enable bit mask\n.equ FUSE_CMPCEN_bp = 6                  ; Compare C Output Enable bit position\n.equ FUSE_CMPD_bm = 0x08                 ; Compare D Default Output Value bit mask\n.equ FUSE_CMPD_bp = 3                    ; Compare D Default Output Value bit position\n.equ FUSE_CMPDEN_bm = 0x80               ; Compare D Output Enable bit mask\n.equ FUSE_CMPDEN_bp = 7                  ; Compare D Output Enable bit position\n\n; FUSE_WDTCFG masks\n.equ FUSE_PERIOD_gm = 0x0F               ; Watchdog Timeout Period group mask\n.equ FUSE_PERIOD_gp = 0                  ; Watchdog Timeout Period group position\n.equ FUSE_PERIOD0_bm = (1<<0)            ; Watchdog Timeout Period bit 0 mask\n.equ FUSE_PERIOD0_bp = 0                 ; Watchdog Timeout Period bit 0 position\n.equ FUSE_PERIOD1_bm = (1<<1)            ; Watchdog Timeout Period bit 1 mask\n.equ FUSE_PERIOD1_bp = 1                 ; Watchdog Timeout Period bit 1 position\n.equ FUSE_PERIOD2_bm = (1<<2)            ; Watchdog Timeout Period bit 2 mask\n.equ FUSE_PERIOD2_bp = 2                 ; Watchdog Timeout Period bit 2 position\n.equ FUSE_PERIOD3_bm = (1<<3)            ; Watchdog Timeout Period bit 3 mask\n.equ FUSE_PERIOD3_bp = 3                 ; Watchdog Timeout Period bit 3 position\n.equ FUSE_WINDOW_gm = 0xF0               ; Watchdog Window Timeout Period group mask\n.equ FUSE_WINDOW_gp = 4                  ; Watchdog Window Timeout Period group position\n.equ FUSE_WINDOW0_bm = (1<<4)            ; Watchdog Window Timeout Period bit 0 mask\n.equ FUSE_WINDOW0_bp = 4                 ; Watchdog Window Timeout Period bit 0 position\n.equ FUSE_WINDOW1_bm = (1<<5)            ; Watchdog Window Timeout Period bit 1 mask\n.equ FUSE_WINDOW1_bp = 5                 ; Watchdog Window Timeout Period bit 1 position\n.equ FUSE_WINDOW2_bm = (1<<6)            ; Watchdog Window Timeout Period bit 2 mask\n.equ FUSE_WINDOW2_bp = 6                 ; Watchdog Window Timeout Period bit 2 position\n.equ FUSE_WINDOW3_bm = (1<<7)            ; Watchdog Window Timeout Period bit 3 mask\n.equ FUSE_WINDOW3_bp = 7                 ; Watchdog Window Timeout Period bit 3 position\n\n; BOD Operation in Active Mode select\n.equ FUSE_ACTIVE_DIS_gc = (0x00<<2)      ; Disabled\n.equ FUSE_ACTIVE_ENABLED_gc = (0x01<<2)  ; Enabled\n.equ FUSE_ACTIVE_SAMPLED_gc = (0x02<<2)  ; Sampled\n.equ FUSE_ACTIVE_ENWAKE_gc = (0x03<<2)   ; Enabled with wake-up halted until BOD is ready\n\n; BOD Level select\n.equ FUSE_LVL_BODLEVEL0_gc = (0x00<<5)   ; 1.8 V\n.equ FUSE_LVL_BODLEVEL2_gc = (0x02<<5)   ; 2.6 V\n.equ FUSE_LVL_BODLEVEL7_gc = (0x07<<5)   ; 4.2 V\n\n; BOD Sample Frequency select\n.equ FUSE_SAMPFREQ_1KHz_gc = (0x00<<4)   ; 1kHz sampling frequency\n.equ FUSE_SAMPFREQ_125Hz_gc = (0x01<<4)  ; 125Hz sampling frequency\n\n; BOD Operation in Sleep Mode select\n.equ FUSE_SLEEP_DIS_gc = (0x00<<0)       ; Disabled\n.equ FUSE_SLEEP_ENABLED_gc = (0x01<<0)   ; Enabled\n.equ FUSE_SLEEP_SAMPLED_gc = (0x02<<0)   ; Sampled\n\n; Frequency Select select\n.equ FUSE_FREQSEL_16MHZ_gc = (0x01<<0)   ; 16 MHz\n.equ FUSE_FREQSEL_20MHZ_gc = (0x02<<0)   ; 20 MHz\n\n; CRC Source select\n.equ FUSE_CRCSRC_FLASH_gc = (0x00<<6)    ; The CRC is performed on the entire Flash (boot, application code and application data section).\n.equ FUSE_CRCSRC_BOOT_gc = (0x01<<6)     ; The CRC is performed on the boot section of Flash\n.equ FUSE_CRCSRC_BOOTAPP_gc = (0x02<<6)  ; The CRC is performed on the boot and application code section of Flash\n.equ FUSE_CRCSRC_NOCRC_gc = (0x03<<6)    ; Disable CRC.\n\n; Reset Pin Configuration select\n.equ FUSE_RSTPINCFG_GPIO_gc = (0x00<<2)  ; GPIO mode\n.equ FUSE_RSTPINCFG_UPDI_gc = (0x01<<2)  ; UPDI mode\n.equ FUSE_RSTPINCFG_RST_gc = (0x02<<2)   ; Reset mode\n\n; Startup Time select\n.equ FUSE_SUT_0MS_gc = (0x00<<0)         ; 0 ms\n.equ FUSE_SUT_1MS_gc = (0x01<<0)         ; 1 ms\n.equ FUSE_SUT_2MS_gc = (0x02<<0)         ; 2 ms\n.equ FUSE_SUT_4MS_gc = (0x03<<0)         ; 4 ms\n.equ FUSE_SUT_8MS_gc = (0x04<<0)         ; 8 ms\n.equ FUSE_SUT_16MS_gc = (0x05<<0)        ; 16 ms\n.equ FUSE_SUT_32MS_gc = (0x06<<0)        ; 32 ms\n.equ FUSE_SUT_64MS_gc = (0x07<<0)        ; 64 ms\n\n; Watchdog Timeout Period select\n.equ FUSE_PERIOD_OFF_gc = (0x00<<0)      ; Watch-Dog timer Off\n.equ FUSE_PERIOD_8CLK_gc = (0x01<<0)     ; 8 cycles (8ms)\n.equ FUSE_PERIOD_16CLK_gc = (0x02<<0)    ; 16 cycles (16ms)\n.equ FUSE_PERIOD_32CLK_gc = (0x03<<0)    ; 32 cycles (32ms)\n.equ FUSE_PERIOD_64CLK_gc = (0x04<<0)    ; 64 cycles (64ms)\n.equ FUSE_PERIOD_128CLK_gc = (0x05<<0)   ; 128 cycles (0.128s)\n.equ FUSE_PERIOD_256CLK_gc = (0x06<<0)   ; 256 cycles (0.256s)\n.equ FUSE_PERIOD_512CLK_gc = (0x07<<0)   ; 512 cycles (0.512s)\n.equ FUSE_PERIOD_1KCLK_gc = (0x08<<0)    ; 1K cycles (1.0s)\n.equ FUSE_PERIOD_2KCLK_gc = (0x09<<0)    ; 2K cycles (2.0s)\n.equ FUSE_PERIOD_4KCLK_gc = (0x0A<<0)    ; 4K cycles (4.1s)\n.equ FUSE_PERIOD_8KCLK_gc = (0x0B<<0)    ; 8K cycles (8.2s)\n\n; Watchdog Window Timeout Period select\n.equ FUSE_WINDOW_OFF_gc = (0x00<<4)      ; Window mode off\n.equ FUSE_WINDOW_8CLK_gc = (0x01<<4)     ; 8 cycles (8ms)\n.equ FUSE_WINDOW_16CLK_gc = (0x02<<4)    ; 16 cycles (16ms)\n.equ FUSE_WINDOW_32CLK_gc = (0x03<<4)    ; 32 cycles (32ms)\n.equ FUSE_WINDOW_64CLK_gc = (0x04<<4)    ; 64 cycles (64ms)\n.equ FUSE_WINDOW_128CLK_gc = (0x05<<4)   ; 128 cycles (0.128s)\n.equ FUSE_WINDOW_256CLK_gc = (0x06<<4)   ; 256 cycles (0.256s)\n.equ FUSE_WINDOW_512CLK_gc = (0x07<<4)   ; 512 cycles (0.512s)\n.equ FUSE_WINDOW_1KCLK_gc = (0x08<<4)    ; 1K cycles (1.0s)\n.equ FUSE_WINDOW_2KCLK_gc = (0x09<<4)    ; 2K cycles (2.0s)\n.equ FUSE_WINDOW_4KCLK_gc = (0x0A<<4)    ; 4K cycles (4.1s)\n.equ FUSE_WINDOW_8KCLK_gc = (0x0B<<4)    ; 8K cycles (8.2s)\n\n\n;*************************************************************************\n;** GPIO - General Purpose IO\n;*************************************************************************\n\n\n;*************************************************************************\n;** LOCKBIT - Lockbit\n;*************************************************************************\n\n; LOCKBIT_LOCKBIT masks\n.equ LOCKBIT_LB_gm = 0xFF                ; Lock Bits group mask\n.equ LOCKBIT_LB_gp = 0                   ; Lock Bits group position\n.equ LOCKBIT_LB0_bm = (1<<0)             ; Lock Bits bit 0 mask\n.equ LOCKBIT_LB0_bp = 0                  ; Lock Bits bit 0 position\n.equ LOCKBIT_LB1_bm = (1<<1)             ; Lock Bits bit 1 mask\n.equ LOCKBIT_LB1_bp = 1                  ; Lock Bits bit 1 position\n.equ LOCKBIT_LB2_bm = (1<<2)             ; Lock Bits bit 2 mask\n.equ LOCKBIT_LB2_bp = 2                  ; Lock Bits bit 2 position\n.equ LOCKBIT_LB3_bm = (1<<3)             ; Lock Bits bit 3 mask\n.equ LOCKBIT_LB3_bp = 3                  ; Lock Bits bit 3 position\n.equ LOCKBIT_LB4_bm = (1<<4)             ; Lock Bits bit 4 mask\n.equ LOCKBIT_LB4_bp = 4                  ; Lock Bits bit 4 position\n.equ LOCKBIT_LB5_bm = (1<<5)             ; Lock Bits bit 5 mask\n.equ LOCKBIT_LB5_bp = 5                  ; Lock Bits bit 5 position\n.equ LOCKBIT_LB6_bm = (1<<6)             ; Lock Bits bit 6 mask\n.equ LOCKBIT_LB6_bp = 6                  ; Lock Bits bit 6 position\n.equ LOCKBIT_LB7_bm = (1<<7)             ; Lock Bits bit 7 mask\n.equ LOCKBIT_LB7_bp = 7                  ; Lock Bits bit 7 position\n\n; Lock Bits select\n.equ LOCKBIT_LB_RWLOCK_gc = (0x3A<<0)    ; Read and write lock\n.equ LOCKBIT_LB_NOLOCK_gc = (0xC5<<0)    ; No locks\n\n\n;*************************************************************************\n;** NVMCTRL - Non-volatile Memory Controller\n;*************************************************************************\n\n; NVMCTRL_CTRLA masks\n.equ NVMCTRL_CMD_gm = 0x07               ; Command group mask\n.equ NVMCTRL_CMD_gp = 0                  ; Command group position\n.equ NVMCTRL_CMD0_bm = (1<<0)            ; Command bit 0 mask\n.equ NVMCTRL_CMD0_bp = 0                 ; Command bit 0 position\n.equ NVMCTRL_CMD1_bm = (1<<1)            ; Command bit 1 mask\n.equ NVMCTRL_CMD1_bp = 1                 ; Command bit 1 position\n.equ NVMCTRL_CMD2_bm = (1<<2)            ; Command bit 2 mask\n.equ NVMCTRL_CMD2_bp = 2                 ; Command bit 2 position\n\n; NVMCTRL_CTRLB masks\n.equ NVMCTRL_APCWP_bm = 0x01             ; Application code write protect bit mask\n.equ NVMCTRL_APCWP_bp = 0                ; Application code write protect bit position\n.equ NVMCTRL_BOOTLOCK_bm = 0x02          ; Boot Lock bit mask\n.equ NVMCTRL_BOOTLOCK_bp = 1             ; Boot Lock bit position\n\n; NVMCTRL_INTCTRL masks\n.equ NVMCTRL_EEREADY_bm = 0x01           ; EEPROM Ready bit mask\n.equ NVMCTRL_EEREADY_bp = 0              ; EEPROM Ready bit position\n\n; NVMCTRL_INTFLAGS masks\n; Masks for NVMCTRL_EEREADY already defined\n\n; NVMCTRL_STATUS masks\n.equ NVMCTRL_EEBUSY_bm = 0x02            ; EEPROM busy bit mask\n.equ NVMCTRL_EEBUSY_bp = 1               ; EEPROM busy bit position\n.equ NVMCTRL_FBUSY_bm = 0x01             ; Flash busy bit mask\n.equ NVMCTRL_FBUSY_bp = 0                ; Flash busy bit position\n.equ NVMCTRL_WRERROR_bm = 0x04           ; Write error bit mask\n.equ NVMCTRL_WRERROR_bp = 2              ; Write error bit position\n\n; Command select\n.equ NVMCTRL_CMD_NONE_gc = (0x00<<0)     ; No Command\n.equ NVMCTRL_CMD_PAGEWRITE_gc = (0x01<<0) ; Write page\n.equ NVMCTRL_CMD_PAGEERASE_gc = (0x02<<0) ; Erase page\n.equ NVMCTRL_CMD_PAGEERASEWRITE_gc = (0x03<<0) ; Erase and write page\n.equ NVMCTRL_CMD_PAGEBUFCLR_gc = (0x04<<0) ; Page buffer clear\n.equ NVMCTRL_CMD_CHIPERASE_gc = (0x05<<0) ; Chip erase\n.equ NVMCTRL_CMD_EEERASE_gc = (0x06<<0)  ; EEPROM erase\n.equ NVMCTRL_CMD_FUSEWRITE_gc = (0x07<<0) ; Write fuse (PDI only)\n\n\n;*************************************************************************\n;** PORT - I/O Ports\n;*************************************************************************\n\n; PORT_INTFLAGS masks\n.equ PORT_INT_gm = 0xFF                  ; Pin Interrupt group mask\n.equ PORT_INT_gp = 0                     ; Pin Interrupt group position\n.equ PORT_INT0_bm = (1<<0)               ; Pin Interrupt bit 0 mask\n.equ PORT_INT0_bp = 0                    ; Pin Interrupt bit 0 position\n.equ PORT_INT1_bm = (1<<1)               ; Pin Interrupt bit 1 mask\n.equ PORT_INT1_bp = 1                    ; Pin Interrupt bit 1 position\n.equ PORT_INT2_bm = (1<<2)               ; Pin Interrupt bit 2 mask\n.equ PORT_INT2_bp = 2                    ; Pin Interrupt bit 2 position\n.equ PORT_INT3_bm = (1<<3)               ; Pin Interrupt bit 3 mask\n.equ PORT_INT3_bp = 3                    ; Pin Interrupt bit 3 position\n.equ PORT_INT4_bm = (1<<4)               ; Pin Interrupt bit 4 mask\n.equ PORT_INT4_bp = 4                    ; Pin Interrupt bit 4 position\n.equ PORT_INT5_bm = (1<<5)               ; Pin Interrupt bit 5 mask\n.equ PORT_INT5_bp = 5                    ; Pin Interrupt bit 5 position\n.equ PORT_INT6_bm = (1<<6)               ; Pin Interrupt bit 6 mask\n.equ PORT_INT6_bp = 6                    ; Pin Interrupt bit 6 position\n.equ PORT_INT7_bm = (1<<7)               ; Pin Interrupt bit 7 mask\n.equ PORT_INT7_bp = 7                    ; Pin Interrupt bit 7 position\n\n; PORT_PIN0CTRL masks\n.equ PORT_INVEN_bm = 0x80                ; Inverted I/O Enable bit mask\n.equ PORT_INVEN_bp = 7                   ; Inverted I/O Enable bit position\n.equ PORT_ISC_gm = 0x07                  ; Input/Sense Configuration group mask\n.equ PORT_ISC_gp = 0                     ; Input/Sense Configuration group position\n.equ PORT_ISC0_bm = (1<<0)               ; Input/Sense Configuration bit 0 mask\n.equ PORT_ISC0_bp = 0                    ; Input/Sense Configuration bit 0 position\n.equ PORT_ISC1_bm = (1<<1)               ; Input/Sense Configuration bit 1 mask\n.equ PORT_ISC1_bp = 1                    ; Input/Sense Configuration bit 1 position\n.equ PORT_ISC2_bm = (1<<2)               ; Input/Sense Configuration bit 2 mask\n.equ PORT_ISC2_bp = 2                    ; Input/Sense Configuration bit 2 position\n.equ PORT_PULLUPEN_bm = 0x08             ; Pullup enable bit mask\n.equ PORT_PULLUPEN_bp = 3                ; Pullup enable bit position\n\n; PORT_PIN1CTRL masks\n; Masks for PORT_INVEN already defined\n; Masks for PORT_ISC already defined\n; Masks for PORT_PULLUPEN already defined\n\n; PORT_PIN2CTRL masks\n; Masks for PORT_INVEN already defined\n; Masks for PORT_ISC already defined\n; Masks for PORT_PULLUPEN already defined\n\n; PORT_PIN3CTRL masks\n; Masks for PORT_INVEN already defined\n; Masks for PORT_ISC already defined\n; Masks for PORT_PULLUPEN already defined\n\n; PORT_PIN4CTRL masks\n; Masks for PORT_INVEN already defined\n; Masks for PORT_ISC already defined\n; Masks for PORT_PULLUPEN already defined\n\n; PORT_PIN5CTRL masks\n; Masks for PORT_INVEN already defined\n; Masks for PORT_ISC already defined\n; Masks for PORT_PULLUPEN already defined\n\n; PORT_PIN6CTRL masks\n; Masks for PORT_INVEN already defined\n; Masks for PORT_ISC already defined\n; Masks for PORT_PULLUPEN already defined\n\n; PORT_PIN7CTRL masks\n; Masks for PORT_INVEN already defined\n; Masks for PORT_ISC already defined\n; Masks for PORT_PULLUPEN already defined\n\n; Input/Sense Configuration select\n.equ PORT_ISC_INTDISABLE_gc = (0x00<<0)  ; Interrupt disabled but input buffer enabled\n.equ PORT_ISC_BOTHEDGES_gc = (0x01<<0)   ; Sense Both Edges\n.equ PORT_ISC_RISING_gc = (0x02<<0)      ; Sense Rising Edge\n.equ PORT_ISC_FALLING_gc = (0x03<<0)     ; Sense Falling Edge\n.equ PORT_ISC_INPUT_DISABLE_gc = (0x04<<0) ; Digital Input Buffer disabled\n.equ PORT_ISC_LEVEL_gc = (0x05<<0)       ; Sense low Level\n\n\n;*************************************************************************\n;** PORTMUX - Port Multiplexer\n;*************************************************************************\n\n; PORTMUX_CTRLA masks\n.equ PORTMUX_EVOUT0_bm = 0x01            ; Event Output 0 bit mask\n.equ PORTMUX_EVOUT0_bp = 0               ; Event Output 0 bit position\n.equ PORTMUX_EVOUT1_bm = 0x02            ; Event Output 1 bit mask\n.equ PORTMUX_EVOUT1_bp = 1               ; Event Output 1 bit position\n.equ PORTMUX_EVOUT2_bm = 0x04            ; Event Output 2 bit mask\n.equ PORTMUX_EVOUT2_bp = 2               ; Event Output 2 bit position\n.equ PORTMUX_LUT0_bm = 0x10              ; Configurable Custom Logic LUT0 bit mask\n.equ PORTMUX_LUT0_bp = 4                 ; Configurable Custom Logic LUT0 bit position\n.equ PORTMUX_LUT1_bm = 0x20              ; Configurable Custom Logic LUT1 bit mask\n.equ PORTMUX_LUT1_bp = 5                 ; Configurable Custom Logic LUT1 bit position\n\n; PORTMUX_CTRLB masks\n.equ PORTMUX_SPI0_bm = 0x04              ; Port Multiplexer SPI0 bit mask\n.equ PORTMUX_SPI0_bp = 2                 ; Port Multiplexer SPI0 bit position\n.equ PORTMUX_TWI0_bm = 0x10              ; Port Multiplexer TWI0 bit mask\n.equ PORTMUX_TWI0_bp = 4                 ; Port Multiplexer TWI0 bit position\n.equ PORTMUX_USART0_bm = 0x01            ; Port Multiplexer USART0 bit mask\n.equ PORTMUX_USART0_bp = 0               ; Port Multiplexer USART0 bit position\n\n; PORTMUX_CTRLC masks\n.equ PORTMUX_TCA00_bm = 0x01             ; Port Multiplexer TCA0 Output 0 bit mask\n.equ PORTMUX_TCA00_bp = 0                ; Port Multiplexer TCA0 Output 0 bit position\n.equ PORTMUX_TCA01_bm = 0x02             ; Port Multiplexer TCA0 Output 1 bit mask\n.equ PORTMUX_TCA01_bp = 1                ; Port Multiplexer TCA0 Output 1 bit position\n.equ PORTMUX_TCA02_bm = 0x04             ; Port Multiplexer TCA0 Output 2 bit mask\n.equ PORTMUX_TCA02_bp = 2                ; Port Multiplexer TCA0 Output 2 bit position\n.equ PORTMUX_TCA03_bm = 0x08             ; Port Multiplexer TCA0 Output 3 bit mask\n.equ PORTMUX_TCA03_bp = 3                ; Port Multiplexer TCA0 Output 3 bit position\n.equ PORTMUX_TCA04_bm = 0x10             ; Port Multiplexer TCA0 Output 4 bit mask\n.equ PORTMUX_TCA04_bp = 4                ; Port Multiplexer TCA0 Output 4 bit position\n.equ PORTMUX_TCA05_bm = 0x20             ; Port Multiplexer TCA0 Output 5 bit mask\n.equ PORTMUX_TCA05_bp = 5                ; Port Multiplexer TCA0 Output 5 bit position\n\n; PORTMUX_CTRLD masks\n.equ PORTMUX_TCB0_bm = 0x01              ; Port Multiplexer TCB bit mask\n.equ PORTMUX_TCB0_bp = 0                 ; Port Multiplexer TCB bit position\n\n; Configurable Custom Logic LUT0 select\n.equ PORTMUX_LUT0_DEFAULT_gc = (0x00<<4) ; Default pin\n.equ PORTMUX_LUT0_ALTERNATE_gc = (0x01<<4) ; Alternate pin\n\n; Configurable Custom Logic LUT1 select\n.equ PORTMUX_LUT1_DEFAULT_gc = (0x00<<5) ; Default pin\n.equ PORTMUX_LUT1_ALTERNATE_gc = (0x01<<5) ; Alternate pin\n\n; Port Multiplexer SPI0 select\n.equ PORTMUX_SPI0_DEFAULT_gc = (0x00<<2) ; Default pins\n.equ PORTMUX_SPI0_ALTERNATE_gc = (0x01<<2) ; Alternate pins\n\n; Port Multiplexer TWI0 select\n.equ PORTMUX_TWI0_DEFAULT_gc = (0x00<<4) ; Default pins\n.equ PORTMUX_TWI0_ALTERNATE_gc = (0x01<<4) ; Alternate pins\n\n; Port Multiplexer USART0 select\n.equ PORTMUX_USART0_DEFAULT_gc = (0x00<<0) ; Default pins\n.equ PORTMUX_USART0_ALTERNATE_gc = (0x01<<0) ; Alternate pins\n\n; Port Multiplexer TCA0 Output 0 select\n.equ PORTMUX_TCA00_DEFAULT_gc = (0x00<<0) ; Default pin\n.equ PORTMUX_TCA00_ALTERNATE_gc = (0x01<<0) ; Alternate pin\n\n; Port Multiplexer TCA0 Output 1 select\n.equ PORTMUX_TCA01_DEFAULT_gc = (0x00<<1) ; Default pin\n.equ PORTMUX_TCA01_ALTERNATE_gc = (0x01<<1) ; Alternate pin\n\n; Port Multiplexer TCA0 Output 2 select\n.equ PORTMUX_TCA02_DEFAULT_gc = (0x00<<2) ; Default pin\n.equ PORTMUX_TCA02_ALTERNATE_gc = (0x01<<2) ; Alternate pin\n\n; Port Multiplexer TCA0 Output 3 select\n.equ PORTMUX_TCA03_DEFAULT_gc = (0x00<<3) ; Default pin\n.equ PORTMUX_TCA03_ALTERNATE_gc = (0x01<<3) ; Alternate pin\n\n; Port Multiplexer TCA0 Output 4 select\n.equ PORTMUX_TCA04_DEFAULT_gc = (0x00<<4) ; Default pin\n.equ PORTMUX_TCA04_ALTERNATE_gc = (0x01<<4) ; Alternate pin\n\n; Port Multiplexer TCA0 Output 5 select\n.equ PORTMUX_TCA05_DEFAULT_gc = (0x00<<5) ; Default pin\n.equ PORTMUX_TCA05_ALTERNATE_gc = (0x01<<5) ; Alternate pin\n\n; Port Multiplexer TCB select\n.equ PORTMUX_TCB0_DEFAULT_gc = (0x00<<0) ; Default pin\n.equ PORTMUX_TCB0_ALTERNATE_gc = (0x01<<0) ; Alternate pin\n\n\n;*************************************************************************\n;** PTC - Peripherial Touch Controller\n;*************************************************************************\n\n\n;*************************************************************************\n;** RSTCTRL - Reset controller\n;*************************************************************************\n\n; RSTCTRL_RSTFR masks\n.equ RSTCTRL_BORF_bm = 0x02              ; Brown out detector Reset flag bit mask\n.equ RSTCTRL_BORF_bp = 1                 ; Brown out detector Reset flag bit position\n.equ RSTCTRL_EXTRF_bm = 0x04             ; External Reset flag bit mask\n.equ RSTCTRL_EXTRF_bp = 2                ; External Reset flag bit position\n.equ RSTCTRL_PORF_bm = 0x01              ; Power on Reset flag bit mask\n.equ RSTCTRL_PORF_bp = 0                 ; Power on Reset flag bit position\n.equ RSTCTRL_SWRF_bm = 0x10              ; Software Reset flag bit mask\n.equ RSTCTRL_SWRF_bp = 4                 ; Software Reset flag bit position\n.equ RSTCTRL_UPDIRF_bm = 0x20            ; UPDI Reset flag bit mask\n.equ RSTCTRL_UPDIRF_bp = 5               ; UPDI Reset flag bit position\n.equ RSTCTRL_WDRF_bm = 0x08              ; Watch dog Reset flag bit mask\n.equ RSTCTRL_WDRF_bp = 3                 ; Watch dog Reset flag bit position\n\n; RSTCTRL_SWRR masks\n.equ RSTCTRL_SWRE_bm = 0x01              ; Software reset enable bit mask\n.equ RSTCTRL_SWRE_bp = 0                 ; Software reset enable bit position\n\n\n;*************************************************************************\n;** RTC - Real-Time Counter\n;*************************************************************************\n\n; RTC_CLKSEL masks\n.equ RTC_CLKSEL_gm = 0x03                ; Clock Select group mask\n.equ RTC_CLKSEL_gp = 0                   ; Clock Select group position\n.equ RTC_CLKSEL0_bm = (1<<0)             ; Clock Select bit 0 mask\n.equ RTC_CLKSEL0_bp = 0                  ; Clock Select bit 0 position\n.equ RTC_CLKSEL1_bm = (1<<1)             ; Clock Select bit 1 mask\n.equ RTC_CLKSEL1_bp = 1                  ; Clock Select bit 1 position\n\n; RTC_CTRLA masks\n.equ RTC_PRESCALER_gm = 0x78             ; Prescaling Factor group mask\n.equ RTC_PRESCALER_gp = 3                ; Prescaling Factor group position\n.equ RTC_PRESCALER0_bm = (1<<3)          ; Prescaling Factor bit 0 mask\n.equ RTC_PRESCALER0_bp = 3               ; Prescaling Factor bit 0 position\n.equ RTC_PRESCALER1_bm = (1<<4)          ; Prescaling Factor bit 1 mask\n.equ RTC_PRESCALER1_bp = 4               ; Prescaling Factor bit 1 position\n.equ RTC_PRESCALER2_bm = (1<<5)          ; Prescaling Factor bit 2 mask\n.equ RTC_PRESCALER2_bp = 5               ; Prescaling Factor bit 2 position\n.equ RTC_PRESCALER3_bm = (1<<6)          ; Prescaling Factor bit 3 mask\n.equ RTC_PRESCALER3_bp = 6               ; Prescaling Factor bit 3 position\n.equ RTC_RTCEN_bm = 0x01                 ; Enable bit mask\n.equ RTC_RTCEN_bp = 0                    ; Enable bit position\n.equ RTC_RUNSTDBY_bm = 0x80              ; Run In Standby bit mask\n.equ RTC_RUNSTDBY_bp = 7                 ; Run In Standby bit position\n\n; RTC_DBGCTRL masks\n.equ RTC_DBGRUN_bm = 0x01                ; Run in debug bit mask\n.equ RTC_DBGRUN_bp = 0                   ; Run in debug bit position\n\n; RTC_INTCTRL masks\n.equ RTC_CMP_bm = 0x02                   ; Compare Match Interrupt enable bit mask\n.equ RTC_CMP_bp = 1                      ; Compare Match Interrupt enable bit position\n.equ RTC_OVF_bm = 0x01                   ; Overflow Interrupt enable bit mask\n.equ RTC_OVF_bp = 0                      ; Overflow Interrupt enable bit position\n\n; RTC_INTFLAGS masks\n; Masks for RTC_CMP already defined\n; Masks for RTC_OVF already defined\n\n; RTC_PITCTRLA masks\n.equ RTC_PERIOD_gm = 0x78                ; Period group mask\n.equ RTC_PERIOD_gp = 3                   ; Period group position\n.equ RTC_PERIOD0_bm = (1<<3)             ; Period bit 0 mask\n.equ RTC_PERIOD0_bp = 3                  ; Period bit 0 position\n.equ RTC_PERIOD1_bm = (1<<4)             ; Period bit 1 mask\n.equ RTC_PERIOD1_bp = 4                  ; Period bit 1 position\n.equ RTC_PERIOD2_bm = (1<<5)             ; Period bit 2 mask\n.equ RTC_PERIOD2_bp = 5                  ; Period bit 2 position\n.equ RTC_PERIOD3_bm = (1<<6)             ; Period bit 3 mask\n.equ RTC_PERIOD3_bp = 6                  ; Period bit 3 position\n.equ RTC_PITEN_bm = 0x01                 ; Enable bit mask\n.equ RTC_PITEN_bp = 0                    ; Enable bit position\n\n; RTC_PITDBGCTRL masks\n; Masks for RTC_DBGRUN already defined\n\n; RTC_PITINTCTRL masks\n.equ RTC_PI_bm = 0x01                    ; Periodic Interrupt bit mask\n.equ RTC_PI_bp = 0                       ; Periodic Interrupt bit position\n\n; RTC_PITINTFLAGS masks\n; Masks for RTC_PI already defined\n\n; RTC_PITSTATUS masks\n.equ RTC_CTRLBUSY_bm = 0x01              ; CTRLA Synchronization Busy Flag bit mask\n.equ RTC_CTRLBUSY_bp = 0                 ; CTRLA Synchronization Busy Flag bit position\n\n; RTC_STATUS masks\n.equ RTC_CMPBUSY_bm = 0x08               ; Comparator Synchronization Busy Flag bit mask\n.equ RTC_CMPBUSY_bp = 3                  ; Comparator Synchronization Busy Flag bit position\n.equ RTC_CNTBUSY_bm = 0x02               ; Count Synchronization Busy Flag bit mask\n.equ RTC_CNTBUSY_bp = 1                  ; Count Synchronization Busy Flag bit position\n.equ RTC_CTRLABUSY_bm = 0x01             ; CTRLA Synchronization Busy Flag bit mask\n.equ RTC_CTRLABUSY_bp = 0                ; CTRLA Synchronization Busy Flag bit position\n.equ RTC_PERBUSY_bm = 0x04               ; Period Synchronization Busy Flag bit mask\n.equ RTC_PERBUSY_bp = 2                  ; Period Synchronization Busy Flag bit position\n\n; Clock Select select\n.equ RTC_CLKSEL_INT32K_gc = (0x00<<0)    ; Internal 32kHz OSC\n.equ RTC_CLKSEL_INT1K_gc = (0x01<<0)     ; Internal 1kHz OSC\n.equ RTC_CLKSEL_TOSC32K_gc = (0x02<<0)   ; 32KHz Crystal OSC\n.equ RTC_CLKSEL_EXTCLK_gc = (0x03<<0)    ; External Clock\n\n; Prescaling Factor select\n.equ RTC_PRESCALER_DIV1_gc = (0x00<<3)   ; RTC Clock / 1\n.equ RTC_PRESCALER_DIV2_gc = (0x01<<3)   ; RTC Clock / 2\n.equ RTC_PRESCALER_DIV4_gc = (0x02<<3)   ; RTC Clock / 4\n.equ RTC_PRESCALER_DIV8_gc = (0x03<<3)   ; RTC Clock / 8\n.equ RTC_PRESCALER_DIV16_gc = (0x04<<3)  ; RTC Clock / 16\n.equ RTC_PRESCALER_DIV32_gc = (0x05<<3)  ; RTC Clock / 32\n.equ RTC_PRESCALER_DIV64_gc = (0x06<<3)  ; RTC Clock / 64\n.equ RTC_PRESCALER_DIV128_gc = (0x07<<3) ; RTC Clock / 128\n.equ RTC_PRESCALER_DIV256_gc = (0x08<<3) ; RTC Clock / 256\n.equ RTC_PRESCALER_DIV512_gc = (0x09<<3) ; RTC Clock / 512\n.equ RTC_PRESCALER_DIV1024_gc = (0x0A<<3) ; RTC Clock / 1024\n.equ RTC_PRESCALER_DIV2048_gc = (0x0B<<3) ; RTC Clock / 2048\n.equ RTC_PRESCALER_DIV4096_gc = (0x0C<<3) ; RTC Clock / 4096\n.equ RTC_PRESCALER_DIV8192_gc = (0x0D<<3) ; RTC Clock / 8192\n.equ RTC_PRESCALER_DIV16384_gc = (0x0E<<3) ; RTC Clock / 16384\n.equ RTC_PRESCALER_DIV32768_gc = (0x0F<<3) ; RTC Clock / 32768\n\n; Period select\n.equ RTC_PERIOD_OFF_gc = (0x00<<3)       ; Off\n.equ RTC_PERIOD_CYC4_gc = (0x01<<3)      ; RTC Clock Cycles 4\n.equ RTC_PERIOD_CYC8_gc = (0x02<<3)      ; RTC Clock Cycles 8\n.equ RTC_PERIOD_CYC16_gc = (0x03<<3)     ; RTC Clock Cycles 16\n.equ RTC_PERIOD_CYC32_gc = (0x04<<3)     ; RTC Clock Cycles 32\n.equ RTC_PERIOD_CYC64_gc = (0x05<<3)     ; RTC Clock Cycles 64\n.equ RTC_PERIOD_CYC128_gc = (0x06<<3)    ; RTC Clock Cycles 128\n.equ RTC_PERIOD_CYC256_gc = (0x07<<3)    ; RTC Clock Cycles 256\n.equ RTC_PERIOD_CYC512_gc = (0x08<<3)    ; RTC Clock Cycles 512\n.equ RTC_PERIOD_CYC1024_gc = (0x09<<3)   ; RTC Clock Cycles 1024\n.equ RTC_PERIOD_CYC2048_gc = (0x0A<<3)   ; RTC Clock Cycles 2048\n.equ RTC_PERIOD_CYC4096_gc = (0x0B<<3)   ; RTC Clock Cycles 4096\n.equ RTC_PERIOD_CYC8192_gc = (0x0C<<3)   ; RTC Clock Cycles 8192\n.equ RTC_PERIOD_CYC16384_gc = (0x0D<<3)  ; RTC Clock Cycles 16384\n.equ RTC_PERIOD_CYC32768_gc = (0x0E<<3)  ; RTC Clock Cycles 32768\n\n\n;*************************************************************************\n;** SIGROW - Signature row\n;*************************************************************************\n\n\n;*************************************************************************\n;** SLPCTRL - Sleep Controller\n;*************************************************************************\n\n; SLPCTRL_CTRLA masks\n.equ SLPCTRL_SEN_bm = 0x01               ; Sleep enable bit mask\n.equ SLPCTRL_SEN_bp = 0                  ; Sleep enable bit position\n.equ SLPCTRL_SMODE_gm = 0x06             ; Sleep mode group mask\n.equ SLPCTRL_SMODE_gp = 1                ; Sleep mode group position\n.equ SLPCTRL_SMODE0_bm = (1<<1)          ; Sleep mode bit 0 mask\n.equ SLPCTRL_SMODE0_bp = 1               ; Sleep mode bit 0 position\n.equ SLPCTRL_SMODE1_bm = (1<<2)          ; Sleep mode bit 1 mask\n.equ SLPCTRL_SMODE1_bp = 2               ; Sleep mode bit 1 position\n\n; Sleep mode select\n.equ SLPCTRL_SMODE_IDLE_gc = (0x00<<1)   ; Idle mode\n.equ SLPCTRL_SMODE_STDBY_gc = (0x01<<1)  ; Standby Mode\n.equ SLPCTRL_SMODE_PDOWN_gc = (0x02<<1)  ; Power-down Mode\n\n\n;*************************************************************************\n;** SPI - Serial Peripheral Interface\n;*************************************************************************\n\n; SPI_CTRLA masks\n.equ SPI_CLK2X_bm = 0x10                 ; Enable Double Speed bit mask\n.equ SPI_CLK2X_bp = 4                    ; Enable Double Speed bit position\n.equ SPI_DORD_bm = 0x40                  ; Data Order Setting bit mask\n.equ SPI_DORD_bp = 6                     ; Data Order Setting bit position\n.equ SPI_ENABLE_bm = 0x01                ; Enable Module bit mask\n.equ SPI_ENABLE_bp = 0                   ; Enable Module bit position\n.equ SPI_MASTER_bm = 0x20                ; Master Operation Enable bit mask\n.equ SPI_MASTER_bp = 5                   ; Master Operation Enable bit position\n.equ SPI_PRESC_gm = 0x06                 ; Prescaler group mask\n.equ SPI_PRESC_gp = 1                    ; Prescaler group position\n.equ SPI_PRESC0_bm = (1<<1)              ; Prescaler bit 0 mask\n.equ SPI_PRESC0_bp = 1                   ; Prescaler bit 0 position\n.equ SPI_PRESC1_bm = (1<<2)              ; Prescaler bit 1 mask\n.equ SPI_PRESC1_bp = 2                   ; Prescaler bit 1 position\n\n; SPI_CTRLB masks\n.equ SPI_BUFEN_bm = 0x80                 ; Buffer Mode Enable bit mask\n.equ SPI_BUFEN_bp = 7                    ; Buffer Mode Enable bit position\n.equ SPI_BUFWR_bm = 0x40                 ; Buffer Write Mode bit mask\n.equ SPI_BUFWR_bp = 6                    ; Buffer Write Mode bit position\n.equ SPI_MODE_gm = 0x03                  ; SPI Mode group mask\n.equ SPI_MODE_gp = 0                     ; SPI Mode group position\n.equ SPI_MODE0_bm = (1<<0)               ; SPI Mode bit 0 mask\n.equ SPI_MODE0_bp = 0                    ; SPI Mode bit 0 position\n.equ SPI_MODE1_bm = (1<<1)               ; SPI Mode bit 1 mask\n.equ SPI_MODE1_bp = 1                    ; SPI Mode bit 1 position\n.equ SPI_SSD_bm = 0x04                   ; Slave Select Disable bit mask\n.equ SPI_SSD_bp = 2                      ; Slave Select Disable bit position\n\n; SPI_INTCTRL masks\n.equ SPI_DREIE_bm = 0x20                 ; Data Register Empty Interrupt Enable bit mask\n.equ SPI_DREIE_bp = 5                    ; Data Register Empty Interrupt Enable bit position\n.equ SPI_IE_bm = 0x01                    ; Interrupt Enable bit mask\n.equ SPI_IE_bp = 0                       ; Interrupt Enable bit position\n.equ SPI_RXCIE_bm = 0x80                 ; Receive Complete Interrupt Enable bit mask\n.equ SPI_RXCIE_bp = 7                    ; Receive Complete Interrupt Enable bit position\n.equ SPI_SSIE_bm = 0x10                  ; Slave Select Trigger Interrupt Enable bit mask\n.equ SPI_SSIE_bp = 4                     ; Slave Select Trigger Interrupt Enable bit position\n.equ SPI_TXCIE_bm = 0x40                 ; Transfer Complete Interrupt Enable bit mask\n.equ SPI_TXCIE_bp = 6                    ; Transfer Complete Interrupt Enable bit position\n\n; SPI_INTFLAGS masks\n.equ SPI_BUFOVF_bm = 0x01                ; Buffer Overflow bit mask\n.equ SPI_BUFOVF_bp = 0                   ; Buffer Overflow bit position\n.equ SPI_DREIF_bm = 0x20                 ; Data Register Empty Interrupt Flag bit mask\n.equ SPI_DREIF_bp = 5                    ; Data Register Empty Interrupt Flag bit position\n.equ SPI_RXCIF_bm = 0x80                 ; Receive Complete Interrupt Flag bit mask\n.equ SPI_RXCIF_bp = 7                    ; Receive Complete Interrupt Flag bit position\n.equ SPI_SSIF_bm = 0x10                  ; Slave Select Trigger Interrupt Flag bit mask\n.equ SPI_SSIF_bp = 4                     ; Slave Select Trigger Interrupt Flag bit position\n.equ SPI_TXCIF_bm = 0x40                 ; Transfer Complete Interrupt Flag bit mask\n.equ SPI_TXCIF_bp = 6                    ; Transfer Complete Interrupt Flag bit position\n.equ SPI_IF_bm = 0x80                    ; Interrupt Flag bit mask\n.equ SPI_IF_bp = 7                       ; Interrupt Flag bit position\n.equ SPI_WRCOL_bm = 0x40                 ; Write Collision bit mask\n.equ SPI_WRCOL_bp = 6                    ; Write Collision bit position\n\n; Prescaler select\n.equ SPI_PRESC_DIV4_gc = (0x00<<1)       ; System Clock / 4\n.equ SPI_PRESC_DIV16_gc = (0x01<<1)      ; System Clock / 16\n.equ SPI_PRESC_DIV64_gc = (0x02<<1)      ; System Clock / 64\n.equ SPI_PRESC_DIV128_gc = (0x03<<1)     ; System Clock / 128\n\n; SPI Mode select\n.equ SPI_MODE_0_gc = (0x00<<0)           ; SPI Mode 0\n.equ SPI_MODE_1_gc = (0x01<<0)           ; SPI Mode 1\n.equ SPI_MODE_2_gc = (0x02<<0)           ; SPI Mode 2\n.equ SPI_MODE_3_gc = (0x03<<0)           ; SPI Mode 3\n\n\n;*************************************************************************\n;** SYSCFG - System Configuration Registers\n;*************************************************************************\n\n; SYSCFG_EXTBRK masks\n.equ SYSCFG_ENEXTBRK_bm = 0x01           ; External break enable bit mask\n.equ SYSCFG_ENEXTBRK_bp = 0              ; External break enable bit position\n\n\n;*************************************************************************\n;** TCA - 16-bit Timer/Counter Type A\n;*************************************************************************\n\n; TCA_SINGLE_CTRLA masks\n.equ TCA_SINGLE_CLKSEL_gm = 0x0E         ; Clock Selection group mask\n.equ TCA_SINGLE_CLKSEL_gp = 1            ; Clock Selection group position\n.equ TCA_SINGLE_CLKSEL0_bm = (1<<1)      ; Clock Selection bit 0 mask\n.equ TCA_SINGLE_CLKSEL0_bp = 1           ; Clock Selection bit 0 position\n.equ TCA_SINGLE_CLKSEL1_bm = (1<<2)      ; Clock Selection bit 1 mask\n.equ TCA_SINGLE_CLKSEL1_bp = 2           ; Clock Selection bit 1 position\n.equ TCA_SINGLE_CLKSEL2_bm = (1<<3)      ; Clock Selection bit 2 mask\n.equ TCA_SINGLE_CLKSEL2_bp = 3           ; Clock Selection bit 2 position\n.equ TCA_SINGLE_ENABLE_bm = 0x01         ; Module Enable bit mask\n.equ TCA_SINGLE_ENABLE_bp = 0            ; Module Enable bit position\n\n; TCA_SINGLE_CTRLB masks\n.equ TCA_SINGLE_ALUPD_bm = 0x08          ; Auto Lock Update bit mask\n.equ TCA_SINGLE_ALUPD_bp = 3             ; Auto Lock Update bit position\n.equ TCA_SINGLE_CMP0EN_bm = 0x10         ; Compare 0 Enable bit mask\n.equ TCA_SINGLE_CMP0EN_bp = 4            ; Compare 0 Enable bit position\n.equ TCA_SINGLE_CMP1EN_bm = 0x20         ; Compare 1 Enable bit mask\n.equ TCA_SINGLE_CMP1EN_bp = 5            ; Compare 1 Enable bit position\n.equ TCA_SINGLE_CMP2EN_bm = 0x40         ; Compare 2 Enable bit mask\n.equ TCA_SINGLE_CMP2EN_bp = 6            ; Compare 2 Enable bit position\n.equ TCA_SINGLE_WGMODE_gm = 0x07         ; Waveform generation mode group mask\n.equ TCA_SINGLE_WGMODE_gp = 0            ; Waveform generation mode group position\n.equ TCA_SINGLE_WGMODE0_bm = (1<<0)      ; Waveform generation mode bit 0 mask\n.equ TCA_SINGLE_WGMODE0_bp = 0           ; Waveform generation mode bit 0 position\n.equ TCA_SINGLE_WGMODE1_bm = (1<<1)      ; Waveform generation mode bit 1 mask\n.equ TCA_SINGLE_WGMODE1_bp = 1           ; Waveform generation mode bit 1 position\n.equ TCA_SINGLE_WGMODE2_bm = (1<<2)      ; Waveform generation mode bit 2 mask\n.equ TCA_SINGLE_WGMODE2_bp = 2           ; Waveform generation mode bit 2 position\n\n; TCA_SINGLE_CTRLC masks\n.equ TCA_SINGLE_CMP0OV_bm = 0x01         ; Compare 0 Waveform Output Value bit mask\n.equ TCA_SINGLE_CMP0OV_bp = 0            ; Compare 0 Waveform Output Value bit position\n.equ TCA_SINGLE_CMP1OV_bm = 0x02         ; Compare 1 Waveform Output Value bit mask\n.equ TCA_SINGLE_CMP1OV_bp = 1            ; Compare 1 Waveform Output Value bit position\n.equ TCA_SINGLE_CMP2OV_bm = 0x04         ; Compare 2 Waveform Output Value bit mask\n.equ TCA_SINGLE_CMP2OV_bp = 2            ; Compare 2 Waveform Output Value bit position\n\n; TCA_SINGLE_CTRLD masks\n.equ TCA_SINGLE_SPLITM_bm = 0x01         ; Split Mode Enable bit mask\n.equ TCA_SINGLE_SPLITM_bp = 0            ; Split Mode Enable bit position\n\n; TCA_SINGLE_CTRLECLR masks\n.equ TCA_SINGLE_CMD_gm = 0x0C            ; Command group mask\n.equ TCA_SINGLE_CMD_gp = 2               ; Command group position\n.equ TCA_SINGLE_CMD0_bm = (1<<2)         ; Command bit 0 mask\n.equ TCA_SINGLE_CMD0_bp = 2              ; Command bit 0 position\n.equ TCA_SINGLE_CMD1_bm = (1<<3)         ; Command bit 1 mask\n.equ TCA_SINGLE_CMD1_bp = 3              ; Command bit 1 position\n.equ TCA_SINGLE_DIR_bm = 0x01            ; Direction bit mask\n.equ TCA_SINGLE_DIR_bp = 0               ; Direction bit position\n.equ TCA_SINGLE_LUPD_bm = 0x02           ; Lock Update bit mask\n.equ TCA_SINGLE_LUPD_bp = 1              ; Lock Update bit position\n\n; TCA_SINGLE_CTRLESET masks\n; Masks for TCA_SINGLE_CMD already defined\n; Masks for TCA_SINGLE_DIR already defined\n; Masks for TCA_SINGLE_LUPD already defined\n\n; TCA_SINGLE_CTRLFCLR masks\n.equ TCA_SINGLE_CMP0BV_bm = 0x02         ; Compare 0 Buffer Valid bit mask\n.equ TCA_SINGLE_CMP0BV_bp = 1            ; Compare 0 Buffer Valid bit position\n.equ TCA_SINGLE_CMP1BV_bm = 0x04         ; Compare 1 Buffer Valid bit mask\n.equ TCA_SINGLE_CMP1BV_bp = 2            ; Compare 1 Buffer Valid bit position\n.equ TCA_SINGLE_CMP2BV_bm = 0x08         ; Compare 2 Buffer Valid bit mask\n.equ TCA_SINGLE_CMP2BV_bp = 3            ; Compare 2 Buffer Valid bit position\n.equ TCA_SINGLE_PERBV_bm = 0x01          ; Period Buffer Valid bit mask\n.equ TCA_SINGLE_PERBV_bp = 0             ; Period Buffer Valid bit position\n\n; TCA_SINGLE_CTRLFSET masks\n; Masks for TCA_SINGLE_CMP0BV already defined\n; Masks for TCA_SINGLE_CMP1BV already defined\n; Masks for TCA_SINGLE_CMP2BV already defined\n; Masks for TCA_SINGLE_PERBV already defined\n\n; TCA_SINGLE_DBGCTRL masks\n.equ TCA_SINGLE_DBGRUN_bm = 0x01         ; Debug Run bit mask\n.equ TCA_SINGLE_DBGRUN_bp = 0            ; Debug Run bit position\n\n; TCA_SINGLE_EVCTRL masks\n.equ TCA_SINGLE_CNTEI_bm = 0x01          ; Count on Event Input bit mask\n.equ TCA_SINGLE_CNTEI_bp = 0             ; Count on Event Input bit position\n.equ TCA_SINGLE_EVACT_gm = 0x06          ; Event Action group mask\n.equ TCA_SINGLE_EVACT_gp = 1             ; Event Action group position\n.equ TCA_SINGLE_EVACT0_bm = (1<<1)       ; Event Action bit 0 mask\n.equ TCA_SINGLE_EVACT0_bp = 1            ; Event Action bit 0 position\n.equ TCA_SINGLE_EVACT1_bm = (1<<2)       ; Event Action bit 1 mask\n.equ TCA_SINGLE_EVACT1_bp = 2            ; Event Action bit 1 position\n\n; TCA_SINGLE_INTCTRL masks\n.equ TCA_SINGLE_CMP0_bm = 0x10           ; Compare 0 Interrupt bit mask\n.equ TCA_SINGLE_CMP0_bp = 4              ; Compare 0 Interrupt bit position\n.equ TCA_SINGLE_CMP1_bm = 0x20           ; Compare 1 Interrupt bit mask\n.equ TCA_SINGLE_CMP1_bp = 5              ; Compare 1 Interrupt bit position\n.equ TCA_SINGLE_CMP2_bm = 0x40           ; Compare 2 Interrupt bit mask\n.equ TCA_SINGLE_CMP2_bp = 6              ; Compare 2 Interrupt bit position\n.equ TCA_SINGLE_OVF_bm = 0x01            ; Overflow Interrupt bit mask\n.equ TCA_SINGLE_OVF_bp = 0               ; Overflow Interrupt bit position\n\n; TCA_SINGLE_INTFLAGS masks\n; Masks for TCA_SINGLE_CMP0 already defined\n; Masks for TCA_SINGLE_CMP1 already defined\n; Masks for TCA_SINGLE_CMP2 already defined\n; Masks for TCA_SINGLE_OVF already defined\n\n; TCA_SPLIT_CTRLA masks\n.equ TCA_SPLIT_CLKSEL_gm = 0x0E          ; Clock Selection group mask\n.equ TCA_SPLIT_CLKSEL_gp = 1             ; Clock Selection group position\n.equ TCA_SPLIT_CLKSEL0_bm = (1<<1)       ; Clock Selection bit 0 mask\n.equ TCA_SPLIT_CLKSEL0_bp = 1            ; Clock Selection bit 0 position\n.equ TCA_SPLIT_CLKSEL1_bm = (1<<2)       ; Clock Selection bit 1 mask\n.equ TCA_SPLIT_CLKSEL1_bp = 2            ; Clock Selection bit 1 position\n.equ TCA_SPLIT_CLKSEL2_bm = (1<<3)       ; Clock Selection bit 2 mask\n.equ TCA_SPLIT_CLKSEL2_bp = 3            ; Clock Selection bit 2 position\n.equ TCA_SPLIT_ENABLE_bm = 0x01          ; Module Enable bit mask\n.equ TCA_SPLIT_ENABLE_bp = 0             ; Module Enable bit position\n\n; TCA_SPLIT_CTRLB masks\n.equ TCA_SPLIT_HCMP0EN_bm = 0x10         ; High Compare 0 Enable bit mask\n.equ TCA_SPLIT_HCMP0EN_bp = 4            ; High Compare 0 Enable bit position\n.equ TCA_SPLIT_HCMP1EN_bm = 0x20         ; High Compare 1 Enable bit mask\n.equ TCA_SPLIT_HCMP1EN_bp = 5            ; High Compare 1 Enable bit position\n.equ TCA_SPLIT_HCMP2EN_bm = 0x40         ; High Compare 2 Enable bit mask\n.equ TCA_SPLIT_HCMP2EN_bp = 6            ; High Compare 2 Enable bit position\n.equ TCA_SPLIT_LCMP0EN_bm = 0x01         ; Low Compare 0 Enable bit mask\n.equ TCA_SPLIT_LCMP0EN_bp = 0            ; Low Compare 0 Enable bit position\n.equ TCA_SPLIT_LCMP1EN_bm = 0x02         ; Low Compare 1 Enable bit mask\n.equ TCA_SPLIT_LCMP1EN_bp = 1            ; Low Compare 1 Enable bit position\n.equ TCA_SPLIT_LCMP2EN_bm = 0x04         ; Low Compare 2 Enable bit mask\n.equ TCA_SPLIT_LCMP2EN_bp = 2            ; Low Compare 2 Enable bit position\n\n; TCA_SPLIT_CTRLC masks\n.equ TCA_SPLIT_HCMP0OV_bm = 0x10         ; High Compare 0 Output Value bit mask\n.equ TCA_SPLIT_HCMP0OV_bp = 4            ; High Compare 0 Output Value bit position\n.equ TCA_SPLIT_HCMP1OV_bm = 0x20         ; High Compare 1 Output Value bit mask\n.equ TCA_SPLIT_HCMP1OV_bp = 5            ; High Compare 1 Output Value bit position\n.equ TCA_SPLIT_HCMP2OV_bm = 0x40         ; High Compare 2 Output Value bit mask\n.equ TCA_SPLIT_HCMP2OV_bp = 6            ; High Compare 2 Output Value bit position\n.equ TCA_SPLIT_LCMP0OV_bm = 0x01         ; Low Compare 0 Output Value bit mask\n.equ TCA_SPLIT_LCMP0OV_bp = 0            ; Low Compare 0 Output Value bit position\n.equ TCA_SPLIT_LCMP1OV_bm = 0x02         ; Low Compare 1 Output Value bit mask\n.equ TCA_SPLIT_LCMP1OV_bp = 1            ; Low Compare 1 Output Value bit position\n.equ TCA_SPLIT_LCMP2OV_bm = 0x04         ; Low Compare 2 Output Value bit mask\n.equ TCA_SPLIT_LCMP2OV_bp = 2            ; Low Compare 2 Output Value bit position\n\n; TCA_SPLIT_CTRLD masks\n.equ TCA_SPLIT_SPLITM_bm = 0x01          ; Split Mode Enable bit mask\n.equ TCA_SPLIT_SPLITM_bp = 0             ; Split Mode Enable bit position\n\n; TCA_SPLIT_CTRLECLR masks\n.equ TCA_SPLIT_CMD_gm = 0x0C             ; Command group mask\n.equ TCA_SPLIT_CMD_gp = 2                ; Command group position\n.equ TCA_SPLIT_CMD0_bm = (1<<2)          ; Command bit 0 mask\n.equ TCA_SPLIT_CMD0_bp = 2               ; Command bit 0 position\n.equ TCA_SPLIT_CMD1_bm = (1<<3)          ; Command bit 1 mask\n.equ TCA_SPLIT_CMD1_bp = 3               ; Command bit 1 position\n\n; TCA_SPLIT_CTRLESET masks\n; Masks for TCA_SPLIT_CMD already defined\n\n; TCA_SPLIT_DBGCTRL masks\n.equ TCA_SPLIT_DBGRUN_bm = 0x01          ; Debug Run bit mask\n.equ TCA_SPLIT_DBGRUN_bp = 0             ; Debug Run bit position\n\n; TCA_SPLIT_INTCTRL masks\n.equ TCA_SPLIT_HUNF_bm = 0x02            ; High Underflow Interrupt Enable bit mask\n.equ TCA_SPLIT_HUNF_bp = 1               ; High Underflow Interrupt Enable bit position\n.equ TCA_SPLIT_LCMP0_bm = 0x10           ; Low Compare 0 Interrupt Enable bit mask\n.equ TCA_SPLIT_LCMP0_bp = 4              ; Low Compare 0 Interrupt Enable bit position\n.equ TCA_SPLIT_LCMP1_bm = 0x20           ; Low Compare 1 Interrupt Enable bit mask\n.equ TCA_SPLIT_LCMP1_bp = 5              ; Low Compare 1 Interrupt Enable bit position\n.equ TCA_SPLIT_LCMP2_bm = 0x40           ; Low Compare 2 Interrupt Enable bit mask\n.equ TCA_SPLIT_LCMP2_bp = 6              ; Low Compare 2 Interrupt Enable bit position\n.equ TCA_SPLIT_LUNF_bm = 0x01            ; Low Underflow Interrupt Enable bit mask\n.equ TCA_SPLIT_LUNF_bp = 0               ; Low Underflow Interrupt Enable bit position\n\n; TCA_SPLIT_INTFLAGS masks\n; Masks for TCA_SPLIT_HUNF already defined\n; Masks for TCA_SPLIT_LCMP0 already defined\n; Masks for TCA_SPLIT_LCMP1 already defined\n; Masks for TCA_SPLIT_LCMP2 already defined\n; Masks for TCA_SPLIT_LUNF already defined\n\n; Clock Selection select\n.equ TCA_SINGLE_CLKSEL_DIV1_gc = (0x00<<1) ; System Clock\n.equ TCA_SINGLE_CLKSEL_DIV2_gc = (0x01<<1) ; System Clock / 2\n.equ TCA_SINGLE_CLKSEL_DIV4_gc = (0x02<<1) ; System Clock / 4\n.equ TCA_SINGLE_CLKSEL_DIV8_gc = (0x03<<1) ; System Clock / 8\n.equ TCA_SINGLE_CLKSEL_DIV16_gc = (0x04<<1) ; System Clock / 16\n.equ TCA_SINGLE_CLKSEL_DIV64_gc = (0x05<<1) ; System Clock / 64\n.equ TCA_SINGLE_CLKSEL_DIV256_gc = (0x06<<1) ; System Clock / 256\n.equ TCA_SINGLE_CLKSEL_DIV1024_gc = (0x07<<1) ; System Clock / 1024\n\n; Waveform generation mode select\n.equ TCA_SINGLE_WGMODE_NORMAL_gc = (0x00<<0) ; Normal Mode\n.equ TCA_SINGLE_WGMODE_FRQ_gc = (0x01<<0) ; Frequency Generation Mode\n.equ TCA_SINGLE_WGMODE_SINGLESLOPE_gc = (0x03<<0) ; Single Slope PWM\n.equ TCA_SINGLE_WGMODE_DSTOP_gc = (0x05<<0) ; Dual Slope PWM, overflow on TOP\n.equ TCA_SINGLE_WGMODE_DSBOTH_gc = (0x06<<0) ; Dual Slope PWM, overflow on TOP and BOTTOM\n.equ TCA_SINGLE_WGMODE_DSBOTTOM_gc = (0x07<<0) ; Dual Slope PWM, overflow on BOTTOM\n\n; Command select\n.equ TCA_SINGLE_CMD_NONE_gc = (0x00<<2)  ; No Command\n.equ TCA_SINGLE_CMD_UPDATE_gc = (0x01<<2) ; Force Update\n.equ TCA_SINGLE_CMD_RESTART_gc = (0x02<<2) ; Force Restart\n.equ TCA_SINGLE_CMD_RESET_gc = (0x03<<2) ; Force Hard Reset\n\n; Direction select\n.equ TCA_SINGLE_DIR_UP_gc = (0x00<<0)    ; Count up\n.equ TCA_SINGLE_DIR_DOWN_gc = (0x01<<0)  ; Count down\n\n; Event Action select\n.equ TCA_SINGLE_EVACT_POSEDGE_gc = (0x00<<1) ; Count on positive edge event\n.equ TCA_SINGLE_EVACT_ANYEDGE_gc = (0x01<<1) ; Count on any edge event\n.equ TCA_SINGLE_EVACT_HIGHLVL_gc = (0x02<<1) ; Count on prescaled clock while event line is 1.\n.equ TCA_SINGLE_EVACT_UPDOWN_gc = (0x03<<1) ; Count on prescaled clock. Event controls count direction. Up-count when event line is 0, down-count when event line is 1.\n\n; Clock Selection select\n.equ TCA_SPLIT_CLKSEL_DIV1_gc = (0x00<<1) ; System Clock\n.equ TCA_SPLIT_CLKSEL_DIV2_gc = (0x01<<1) ; System Clock / 2\n.equ TCA_SPLIT_CLKSEL_DIV4_gc = (0x02<<1) ; System Clock / 4\n.equ TCA_SPLIT_CLKSEL_DIV8_gc = (0x03<<1) ; System Clock / 8\n.equ TCA_SPLIT_CLKSEL_DIV16_gc = (0x04<<1) ; System Clock / 16\n.equ TCA_SPLIT_CLKSEL_DIV64_gc = (0x05<<1) ; System Clock / 64\n.equ TCA_SPLIT_CLKSEL_DIV256_gc = (0x06<<1) ; System Clock / 256\n.equ TCA_SPLIT_CLKSEL_DIV1024_gc = (0x07<<1) ; System Clock / 1024\n\n; Command select\n.equ TCA_SPLIT_CMD_NONE_gc = (0x00<<2)   ; No Command\n.equ TCA_SPLIT_CMD_UPDATE_gc = (0x01<<2) ; Force Update\n.equ TCA_SPLIT_CMD_RESTART_gc = (0x02<<2) ; Force Restart\n.equ TCA_SPLIT_CMD_RESET_gc = (0x03<<2)  ; Force Hard Reset\n\n\n;*************************************************************************\n;** TCB - 16-bit Timer Type B\n;*************************************************************************\n\n; TCB_CTRLA masks\n.equ TCB_CLKSEL_gm = 0x06                ; Clock Select group mask\n.equ TCB_CLKSEL_gp = 1                   ; Clock Select group position\n.equ TCB_CLKSEL0_bm = (1<<1)             ; Clock Select bit 0 mask\n.equ TCB_CLKSEL0_bp = 1                  ; Clock Select bit 0 position\n.equ TCB_CLKSEL1_bm = (1<<2)             ; Clock Select bit 1 mask\n.equ TCB_CLKSEL1_bp = 2                  ; Clock Select bit 1 position\n.equ TCB_ENABLE_bm = 0x01                ; Enable bit mask\n.equ TCB_ENABLE_bp = 0                   ; Enable bit position\n.equ TCB_RUNSTDBY_bm = 0x40              ; Run Standby bit mask\n.equ TCB_RUNSTDBY_bp = 6                 ; Run Standby bit position\n.equ TCB_SYNCUPD_bm = 0x10               ; Synchronize Update bit mask\n.equ TCB_SYNCUPD_bp = 4                  ; Synchronize Update bit position\n\n; TCB_CTRLB masks\n.equ TCB_ASYNC_bm = 0x40                 ; Asynchronous Enable bit mask\n.equ TCB_ASYNC_bp = 6                    ; Asynchronous Enable bit position\n.equ TCB_CCMPEN_bm = 0x10                ; Pin Output Enable bit mask\n.equ TCB_CCMPEN_bp = 4                   ; Pin Output Enable bit position\n.equ TCB_CCMPINIT_bm = 0x20              ; Pin Initial State bit mask\n.equ TCB_CCMPINIT_bp = 5                 ; Pin Initial State bit position\n.equ TCB_CNTMODE_gm = 0x07               ; Timer Mode group mask\n.equ TCB_CNTMODE_gp = 0                  ; Timer Mode group position\n.equ TCB_CNTMODE0_bm = (1<<0)            ; Timer Mode bit 0 mask\n.equ TCB_CNTMODE0_bp = 0                 ; Timer Mode bit 0 position\n.equ TCB_CNTMODE1_bm = (1<<1)            ; Timer Mode bit 1 mask\n.equ TCB_CNTMODE1_bp = 1                 ; Timer Mode bit 1 position\n.equ TCB_CNTMODE2_bm = (1<<2)            ; Timer Mode bit 2 mask\n.equ TCB_CNTMODE2_bp = 2                 ; Timer Mode bit 2 position\n\n; TCB_DBGCTRL masks\n.equ TCB_DBGRUN_bm = 0x01                ; Debug Run bit mask\n.equ TCB_DBGRUN_bp = 0                   ; Debug Run bit position\n\n; TCB_EVCTRL masks\n.equ TCB_CAPTEI_bm = 0x01                ; Event Input Enable bit mask\n.equ TCB_CAPTEI_bp = 0                   ; Event Input Enable bit position\n.equ TCB_EDGE_bm = 0x10                  ; Event Edge bit mask\n.equ TCB_EDGE_bp = 4                     ; Event Edge bit position\n.equ TCB_FILTER_bm = 0x40                ; Input Capture Noise Cancellation Filter bit mask\n.equ TCB_FILTER_bp = 6                   ; Input Capture Noise Cancellation Filter bit position\n\n; TCB_INTCTRL masks\n.equ TCB_CAPT_bm = 0x01                  ; Capture or Timeout bit mask\n.equ TCB_CAPT_bp = 0                     ; Capture or Timeout bit position\n\n; TCB_INTFLAGS masks\n; Masks for TCB_CAPT already defined\n\n; TCB_STATUS masks\n.equ TCB_RUN_bm = 0x01                   ; Run bit mask\n.equ TCB_RUN_bp = 0                      ; Run bit position\n\n; Clock Select select\n.equ TCB_CLKSEL_CLKDIV1_gc = (0x00<<1)   ; CLK_PER (No Prescaling)\n.equ TCB_CLKSEL_CLKDIV2_gc = (0x01<<1)   ; CLK_PER/2 (From Prescaler)\n.equ TCB_CLKSEL_CLKTCA_gc = (0x02<<1)    ; Use Clock from TCA\n\n; Timer Mode select\n.equ TCB_CNTMODE_INT_gc = (0x00<<0)      ; Periodic Interrupt\n.equ TCB_CNTMODE_TIMEOUT_gc = (0x01<<0)  ; Periodic Timeout\n.equ TCB_CNTMODE_CAPT_gc = (0x02<<0)     ; Input Capture Event\n.equ TCB_CNTMODE_FRQ_gc = (0x03<<0)      ; Input Capture Frequency measurement\n.equ TCB_CNTMODE_PW_gc = (0x04<<0)       ; Input Capture Pulse-Width measurement\n.equ TCB_CNTMODE_FRQPW_gc = (0x05<<0)    ; Input Capture Frequency and Pulse-Width measurement\n.equ TCB_CNTMODE_SINGLE_gc = (0x06<<0)   ; Single Shot\n.equ TCB_CNTMODE_PWM8_gc = (0x07<<0)     ; 8-bit PWM\n\n\n;*************************************************************************\n;** TCD - Timer Counter D\n;*************************************************************************\n\n; TCD_CTRLA masks\n.equ TCD_CLKSEL_gm = 0x60                ; clock select group mask\n.equ TCD_CLKSEL_gp = 5                   ; clock select group position\n.equ TCD_CLKSEL0_bm = (1<<5)             ; clock select bit 0 mask\n.equ TCD_CLKSEL0_bp = 5                  ; clock select bit 0 position\n.equ TCD_CLKSEL1_bm = (1<<6)             ; clock select bit 1 mask\n.equ TCD_CLKSEL1_bp = 6                  ; clock select bit 1 position\n.equ TCD_CNTPRES_gm = 0x18               ; counter prescaler group mask\n.equ TCD_CNTPRES_gp = 3                  ; counter prescaler group position\n.equ TCD_CNTPRES0_bm = (1<<3)            ; counter prescaler bit 0 mask\n.equ TCD_CNTPRES0_bp = 3                 ; counter prescaler bit 0 position\n.equ TCD_CNTPRES1_bm = (1<<4)            ; counter prescaler bit 1 mask\n.equ TCD_CNTPRES1_bp = 4                 ; counter prescaler bit 1 position\n.equ TCD_ENABLE_bm = 0x01                ; Enable bit mask\n.equ TCD_ENABLE_bp = 0                   ; Enable bit position\n.equ TCD_SYNCPRES_gm = 0x06              ; Syncronization prescaler group mask\n.equ TCD_SYNCPRES_gp = 1                 ; Syncronization prescaler group position\n.equ TCD_SYNCPRES0_bm = (1<<1)           ; Syncronization prescaler bit 0 mask\n.equ TCD_SYNCPRES0_bp = 1                ; Syncronization prescaler bit 0 position\n.equ TCD_SYNCPRES1_bm = (1<<2)           ; Syncronization prescaler bit 1 mask\n.equ TCD_SYNCPRES1_bp = 2                ; Syncronization prescaler bit 1 position\n\n; TCD_CTRLB masks\n.equ TCD_WGMODE_gm = 0x03                ; Waveform generation mode group mask\n.equ TCD_WGMODE_gp = 0                   ; Waveform generation mode group position\n.equ TCD_WGMODE0_bm = (1<<0)             ; Waveform generation mode bit 0 mask\n.equ TCD_WGMODE0_bp = 0                  ; Waveform generation mode bit 0 position\n.equ TCD_WGMODE1_bm = (1<<1)             ; Waveform generation mode bit 1 mask\n.equ TCD_WGMODE1_bp = 1                  ; Waveform generation mode bit 1 position\n\n; TCD_CTRLC masks\n.equ TCD_AUPDATE_bm = 0x02               ; Auto update bit mask\n.equ TCD_AUPDATE_bp = 1                  ; Auto update bit position\n.equ TCD_CMPCSEL_bm = 0x40               ; Compare C output select bit mask\n.equ TCD_CMPCSEL_bp = 6                  ; Compare C output select bit position\n.equ TCD_CMPDSEL_bm = 0x80               ; Compare D output select bit mask\n.equ TCD_CMPDSEL_bp = 7                  ; Compare D output select bit position\n.equ TCD_CMPOVR_bm = 0x01                ; Compare output value override bit mask\n.equ TCD_CMPOVR_bp = 0                   ; Compare output value override bit position\n.equ TCD_FIFTY_bm = 0x08                 ; Fifty percent waveform bit mask\n.equ TCD_FIFTY_bp = 3                    ; Fifty percent waveform bit position\n\n; TCD_CTRLD masks\n.equ TCD_CMPAVAL_gm = 0x0F               ; Compare A value group mask\n.equ TCD_CMPAVAL_gp = 0                  ; Compare A value group position\n.equ TCD_CMPAVAL0_bm = (1<<0)            ; Compare A value bit 0 mask\n.equ TCD_CMPAVAL0_bp = 0                 ; Compare A value bit 0 position\n.equ TCD_CMPAVAL1_bm = (1<<1)            ; Compare A value bit 1 mask\n.equ TCD_CMPAVAL1_bp = 1                 ; Compare A value bit 1 position\n.equ TCD_CMPAVAL2_bm = (1<<2)            ; Compare A value bit 2 mask\n.equ TCD_CMPAVAL2_bp = 2                 ; Compare A value bit 2 position\n.equ TCD_CMPAVAL3_bm = (1<<3)            ; Compare A value bit 3 mask\n.equ TCD_CMPAVAL3_bp = 3                 ; Compare A value bit 3 position\n.equ TCD_CMPBVAL_gm = 0xF0               ; Compare B value group mask\n.equ TCD_CMPBVAL_gp = 4                  ; Compare B value group position\n.equ TCD_CMPBVAL0_bm = (1<<4)            ; Compare B value bit 0 mask\n.equ TCD_CMPBVAL0_bp = 4                 ; Compare B value bit 0 position\n.equ TCD_CMPBVAL1_bm = (1<<5)            ; Compare B value bit 1 mask\n.equ TCD_CMPBVAL1_bp = 5                 ; Compare B value bit 1 position\n.equ TCD_CMPBVAL2_bm = (1<<6)            ; Compare B value bit 2 mask\n.equ TCD_CMPBVAL2_bp = 6                 ; Compare B value bit 2 position\n.equ TCD_CMPBVAL3_bm = (1<<7)            ; Compare B value bit 3 mask\n.equ TCD_CMPBVAL3_bp = 7                 ; Compare B value bit 3 position\n\n; TCD_CTRLE masks\n.equ TCD_DISEOC_bm = 0x80                ; Disable at end of cycle bit mask\n.equ TCD_DISEOC_bp = 7                   ; Disable at end of cycle bit position\n.equ TCD_RESTART_bm = 0x04               ; Restart strobe bit mask\n.equ TCD_RESTART_bp = 2                  ; Restart strobe bit position\n.equ TCD_SCAPTUREA_bm = 0x08             ; Software Capture A Strobe bit mask\n.equ TCD_SCAPTUREA_bp = 3                ; Software Capture A Strobe bit position\n.equ TCD_SCAPTUREB_bm = 0x10             ; Software Capture B Strobe bit mask\n.equ TCD_SCAPTUREB_bp = 4                ; Software Capture B Strobe bit position\n.equ TCD_SYNC_bm = 0x02                  ; synchronize strobe bit mask\n.equ TCD_SYNC_bp = 1                     ; synchronize strobe bit position\n.equ TCD_SYNCEOC_bm = 0x01               ; synchronize end of cycle strobe bit mask\n.equ TCD_SYNCEOC_bp = 0                  ; synchronize end of cycle strobe bit position\n\n; TCD_DBGCTRL masks\n.equ TCD_DBGRUN_bm = 0x01                ; Debug run bit mask\n.equ TCD_DBGRUN_bp = 0                   ; Debug run bit position\n.equ TCD_FAULTDET_bm = 0x04              ; Fault detection bit mask\n.equ TCD_FAULTDET_bp = 2                 ; Fault detection bit position\n\n; TCD_DITCTRL masks\n.equ TCD_DITHERSEL_gm = 0x03             ; dither select group mask\n.equ TCD_DITHERSEL_gp = 0                ; dither select group position\n.equ TCD_DITHERSEL0_bm = (1<<0)          ; dither select bit 0 mask\n.equ TCD_DITHERSEL0_bp = 0               ; dither select bit 0 position\n.equ TCD_DITHERSEL1_bm = (1<<1)          ; dither select bit 1 mask\n.equ TCD_DITHERSEL1_bp = 1               ; dither select bit 1 position\n\n; TCD_DITVAL masks\n.equ TCD_DITHER_gm = 0x0F                ; Dither value group mask\n.equ TCD_DITHER_gp = 0                   ; Dither value group position\n.equ TCD_DITHER0_bm = (1<<0)             ; Dither value bit 0 mask\n.equ TCD_DITHER0_bp = 0                  ; Dither value bit 0 position\n.equ TCD_DITHER1_bm = (1<<1)             ; Dither value bit 1 mask\n.equ TCD_DITHER1_bp = 1                  ; Dither value bit 1 position\n.equ TCD_DITHER2_bm = (1<<2)             ; Dither value bit 2 mask\n.equ TCD_DITHER2_bp = 2                  ; Dither value bit 2 position\n.equ TCD_DITHER3_bm = (1<<3)             ; Dither value bit 3 mask\n.equ TCD_DITHER3_bp = 3                  ; Dither value bit 3 position\n\n; TCD_DLYCTRL masks\n.equ TCD_DLYPRESC_gm = 0x30              ; Delay prescaler group mask\n.equ TCD_DLYPRESC_gp = 4                 ; Delay prescaler group position\n.equ TCD_DLYPRESC0_bm = (1<<4)           ; Delay prescaler bit 0 mask\n.equ TCD_DLYPRESC0_bp = 4                ; Delay prescaler bit 0 position\n.equ TCD_DLYPRESC1_bm = (1<<5)           ; Delay prescaler bit 1 mask\n.equ TCD_DLYPRESC1_bp = 5                ; Delay prescaler bit 1 position\n.equ TCD_DLYSEL_gm = 0x03                ; Delay select group mask\n.equ TCD_DLYSEL_gp = 0                   ; Delay select group position\n.equ TCD_DLYSEL0_bm = (1<<0)             ; Delay select bit 0 mask\n.equ TCD_DLYSEL0_bp = 0                  ; Delay select bit 0 position\n.equ TCD_DLYSEL1_bm = (1<<1)             ; Delay select bit 1 mask\n.equ TCD_DLYSEL1_bp = 1                  ; Delay select bit 1 position\n.equ TCD_DLYTRIG_gm = 0x0C               ; Delay trigger group mask\n.equ TCD_DLYTRIG_gp = 2                  ; Delay trigger group position\n.equ TCD_DLYTRIG0_bm = (1<<2)            ; Delay trigger bit 0 mask\n.equ TCD_DLYTRIG0_bp = 2                 ; Delay trigger bit 0 position\n.equ TCD_DLYTRIG1_bm = (1<<3)            ; Delay trigger bit 1 mask\n.equ TCD_DLYTRIG1_bp = 3                 ; Delay trigger bit 1 position\n\n; TCD_DLYVAL masks\n.equ TCD_DLYVAL_gm = 0xFF                ; Delay value group mask\n.equ TCD_DLYVAL_gp = 0                   ; Delay value group position\n.equ TCD_DLYVAL0_bm = (1<<0)             ; Delay value bit 0 mask\n.equ TCD_DLYVAL0_bp = 0                  ; Delay value bit 0 position\n.equ TCD_DLYVAL1_bm = (1<<1)             ; Delay value bit 1 mask\n.equ TCD_DLYVAL1_bp = 1                  ; Delay value bit 1 position\n.equ TCD_DLYVAL2_bm = (1<<2)             ; Delay value bit 2 mask\n.equ TCD_DLYVAL2_bp = 2                  ; Delay value bit 2 position\n.equ TCD_DLYVAL3_bm = (1<<3)             ; Delay value bit 3 mask\n.equ TCD_DLYVAL3_bp = 3                  ; Delay value bit 3 position\n.equ TCD_DLYVAL4_bm = (1<<4)             ; Delay value bit 4 mask\n.equ TCD_DLYVAL4_bp = 4                  ; Delay value bit 4 position\n.equ TCD_DLYVAL5_bm = (1<<5)             ; Delay value bit 5 mask\n.equ TCD_DLYVAL5_bp = 5                  ; Delay value bit 5 position\n.equ TCD_DLYVAL6_bm = (1<<6)             ; Delay value bit 6 mask\n.equ TCD_DLYVAL6_bp = 6                  ; Delay value bit 6 position\n.equ TCD_DLYVAL7_bm = (1<<7)             ; Delay value bit 7 mask\n.equ TCD_DLYVAL7_bp = 7                  ; Delay value bit 7 position\n\n; TCD_EVCTRLA masks\n.equ TCD_ACTION_bm = 0x04                ; event action bit mask\n.equ TCD_ACTION_bp = 2                   ; event action bit position\n.equ TCD_CFG_gm = 0xC0                   ; event config group mask\n.equ TCD_CFG_gp = 6                      ; event config group position\n.equ TCD_CFG0_bm = (1<<6)                ; event config bit 0 mask\n.equ TCD_CFG0_bp = 6                     ; event config bit 0 position\n.equ TCD_CFG1_bm = (1<<7)                ; event config bit 1 mask\n.equ TCD_CFG1_bp = 7                     ; event config bit 1 position\n.equ TCD_EDGE_bm = 0x10                  ; edge select bit mask\n.equ TCD_EDGE_bp = 4                     ; edge select bit position\n.equ TCD_TRIGEI_bm = 0x01                ; Trigger event enable bit mask\n.equ TCD_TRIGEI_bp = 0                   ; Trigger event enable bit position\n\n; TCD_EVCTRLB masks\n; Masks for TCD_ACTION already defined\n; Masks for TCD_CFG already defined\n; Masks for TCD_EDGE already defined\n; Masks for TCD_TRIGEI already defined\n\n; TCD_FAULTCTRL masks\n.equ TCD_CMPA_bm = 0x01                  ; Compare A value bit mask\n.equ TCD_CMPA_bp = 0                     ; Compare A value bit position\n.equ TCD_CMPAEN_bm = 0x10                ; Compare A enable bit mask\n.equ TCD_CMPAEN_bp = 4                   ; Compare A enable bit position\n.equ TCD_CMPB_bm = 0x02                  ; Compare B value bit mask\n.equ TCD_CMPB_bp = 1                     ; Compare B value bit position\n.equ TCD_CMPBEN_bm = 0x20                ; Compare B enable bit mask\n.equ TCD_CMPBEN_bp = 5                   ; Compare B enable bit position\n.equ TCD_CMPC_bm = 0x04                  ; Compare C value bit mask\n.equ TCD_CMPC_bp = 2                     ; Compare C value bit position\n.equ TCD_CMPCEN_bm = 0x40                ; Compare C enable bit mask\n.equ TCD_CMPCEN_bp = 6                   ; Compare C enable bit position\n.equ TCD_CMPD_bm = 0x08                  ; Compare D vaule bit mask\n.equ TCD_CMPD_bp = 3                     ; Compare D vaule bit position\n.equ TCD_CMPDEN_bm = 0x80                ; Compare D enable bit mask\n.equ TCD_CMPDEN_bp = 7                   ; Compare D enable bit position\n\n; TCD_INPUTCTRLA masks\n.equ TCD_INPUTMODE_gm = 0x0F             ; Input mode group mask\n.equ TCD_INPUTMODE_gp = 0                ; Input mode group position\n.equ TCD_INPUTMODE0_bm = (1<<0)          ; Input mode bit 0 mask\n.equ TCD_INPUTMODE0_bp = 0               ; Input mode bit 0 position\n.equ TCD_INPUTMODE1_bm = (1<<1)          ; Input mode bit 1 mask\n.equ TCD_INPUTMODE1_bp = 1               ; Input mode bit 1 position\n.equ TCD_INPUTMODE2_bm = (1<<2)          ; Input mode bit 2 mask\n.equ TCD_INPUTMODE2_bp = 2               ; Input mode bit 2 position\n.equ TCD_INPUTMODE3_bm = (1<<3)          ; Input mode bit 3 mask\n.equ TCD_INPUTMODE3_bp = 3               ; Input mode bit 3 position\n\n; TCD_INPUTCTRLB masks\n; Masks for TCD_INPUTMODE already defined\n\n; TCD_INTCTRL masks\n.equ TCD_OVF_bm = 0x01                   ; Overflow interrupt enable bit mask\n.equ TCD_OVF_bp = 0                      ; Overflow interrupt enable bit position\n.equ TCD_TRIGA_bm = 0x04                 ; Trigger A interrupt enable bit mask\n.equ TCD_TRIGA_bp = 2                    ; Trigger A interrupt enable bit position\n.equ TCD_TRIGB_bm = 0x08                 ; Trigger B interrupt enable bit mask\n.equ TCD_TRIGB_bp = 3                    ; Trigger B interrupt enable bit position\n\n; TCD_INTFLAGS masks\n; Masks for TCD_OVF already defined\n; Masks for TCD_TRIGA already defined\n; Masks for TCD_TRIGB already defined\n\n; TCD_STATUS masks\n.equ TCD_CMDRDY_bm = 0x02                ; Command ready bit mask\n.equ TCD_CMDRDY_bp = 1                   ; Command ready bit position\n.equ TCD_ENRDY_bm = 0x01                 ; Enable ready bit mask\n.equ TCD_ENRDY_bp = 0                    ; Enable ready bit position\n.equ TCD_PWMACTA_bm = 0x40               ; PWM activity on A bit mask\n.equ TCD_PWMACTA_bp = 6                  ; PWM activity on A bit position\n.equ TCD_PWMACTB_bm = 0x80               ; PWM activity on B bit mask\n.equ TCD_PWMACTB_bp = 7                  ; PWM activity on B bit position\n\n; clock select select\n.equ TCD_CLKSEL_20MHZ_gc = (0x00<<5)     ; 20 MHz oscillator\n.equ TCD_CLKSEL_EXTCLK_gc = (0x02<<5)    ; External clock\n.equ TCD_CLKSEL_SYSCLK_gc = (0x03<<5)    ; System clock\n\n; counter prescaler select\n.equ TCD_CNTPRES_DIV1_gc = (0x00<<3)     ; Sync clock divided by 1\n.equ TCD_CNTPRES_DIV4_gc = (0x01<<3)     ; Sync clock divided by 4\n.equ TCD_CNTPRES_DIV32_gc = (0x02<<3)    ; Sync clock divided by 32\n\n; Syncronization prescaler select\n.equ TCD_SYNCPRES_DIV1_gc = (0x00<<1)    ; Selevted clock source divided by 1\n.equ TCD_SYNCPRES_DIV2_gc = (0x01<<1)    ; Selevted clock source divided by 2\n.equ TCD_SYNCPRES_DIV4_gc = (0x02<<1)    ; Selevted clock source divided by 4\n.equ TCD_SYNCPRES_DIV8_gc = (0x03<<1)    ; Selevted clock source divided by 8\n\n; Waveform generation mode select\n.equ TCD_WGMODE_ONERAMP_gc = (0x00<<0)   ; One ramp mode\n.equ TCD_WGMODE_TWORAMP_gc = (0x01<<0)   ; Two ramp mode\n.equ TCD_WGMODE_FOURRAMP_gc = (0x02<<0)  ; Four ramp mode\n.equ TCD_WGMODE_DS_gc = (0x03<<0)        ; Dual slope mode\n\n; Compare C output select select\n.equ TCD_CMPCSEL_PWMA_gc = (0x00<<6)     ; PWM A output\n.equ TCD_CMPCSEL_PWMB_gc = (0x01<<6)     ; PWM B output\n\n; Compare D output select select\n.equ TCD_CMPDSEL_PWMA_gc = (0x00<<7)     ; PWM A output\n.equ TCD_CMPDSEL_PWMB_gc = (0x01<<7)     ; PWM B output\n\n; dither select select\n.equ TCD_DITHERSEL_ONTIMEB_gc = (0x00<<0) ; On-time ramp B\n.equ TCD_DITHERSEL_ONTIMEAB_gc = (0x01<<0) ; On-time ramp A and B\n.equ TCD_DITHERSEL_DEADTIMEB_gc = (0x02<<0) ; Dead-time rampB\n.equ TCD_DITHERSEL_DEADTIMEAB_gc = (0x03<<0) ; Dead-time ramp A and B\n\n; Delay prescaler select\n.equ TCD_DLYPRESC_DIV1_gc = (0x00<<4)    ; No prescaling\n.equ TCD_DLYPRESC_DIV2_gc = (0x01<<4)    ; Prescale with 2\n.equ TCD_DLYPRESC_DIV4_gc = (0x02<<4)    ; Prescale with 4\n.equ TCD_DLYPRESC_DIV8_gc = (0x03<<4)    ; Prescale with 8\n\n; Delay select select\n.equ TCD_DLYSEL_OFF_gc = (0x00<<0)       ; No delay\n.equ TCD_DLYSEL_INBLANK_gc = (0x01<<0)   ; Input blanking enabled\n.equ TCD_DLYSEL_EVENT_gc = (0x02<<0)     ; Event delay enabled\n\n; Delay trigger select\n.equ TCD_DLYTRIG_CMPASET_gc = (0x00<<2)  ; Compare A set\n.equ TCD_DLYTRIG_CMPACLR_gc = (0x01<<2)  ; Compare A clear\n.equ TCD_DLYTRIG_CMPBSET_gc = (0x02<<2)  ; Compare B set\n.equ TCD_DLYTRIG_CMPBCLR_gc = (0x03<<2)  ; Compare B clear\n\n; event action select\n.equ TCD_ACTION_FAULT_gc = (0x00<<2)     ; Event trigger a fault\n.equ TCD_ACTION_CAPTURE_gc = (0x01<<2)   ; Event trigger a fault and capture\n\n; event config select\n.equ TCD_CFG_NEITHER_gc = (0x00<<6)      ; Neither Filter nor Asynchronous Event is enabled\n.equ TCD_CFG_FILTER_gc = (0x01<<6)       ; Input Capture Noise Cancellation Filter enabled\n.equ TCD_CFG_ASYNC_gc = (0x02<<6)        ; Asynchronous Event output qualification enabled\n\n; edge select select\n.equ TCD_EDGE_FALL_LOW_gc = (0x00<<4)    ; The falling edge or low level of event generates retrigger or fault action\n.equ TCD_EDGE_RISE_HIGH_gc = (0x01<<4)   ; The rising edge or high level of event generates retrigger or fault action\n\n; Input mode select\n.equ TCD_INPUTMODE_NONE_gc = (0x00<<0)   ; Input has no actions\n.equ TCD_INPUTMODE_JMPWAIT_gc = (0x01<<0) ; Stop output, jump to opposite compare cycle and wait\n.equ TCD_INPUTMODE_EXECWAIT_gc = (0x02<<0) ; Stop output, execute opposite compare cycle and wait\n.equ TCD_INPUTMODE_EXECFAULT_gc = (0x03<<0) ; stop output, execute opposite compare cycle while fault active\n.equ TCD_INPUTMODE_FREQ_gc = (0x04<<0)   ; Stop all outputs, maintain frequency\n.equ TCD_INPUTMODE_EXECDT_gc = (0x05<<0) ; Stop all outputs, execute dead time while fault active\n.equ TCD_INPUTMODE_WAIT_gc = (0x06<<0)   ; Stop all outputs, jump to next compare cycle and wait\n.equ TCD_INPUTMODE_WAITSW_gc = (0x07<<0) ; Stop all outputs, wait for software action\n.equ TCD_INPUTMODE_EDGETRIG_gc = (0x08<<0) ; Stop output on edge, jump to next compare cycle\n.equ TCD_INPUTMODE_EDGETRIGFREQ_gc = (0x09<<0) ; Stop output on edge, maintain frequency\n.equ TCD_INPUTMODE_LVLTRIGFREQ_gc = (0x0A<<0) ; Stop output at level, maintain frequency\n\n\n;*************************************************************************\n;** TWI - Two-Wire Interface\n;*************************************************************************\n\n; TWI_CTRLA masks\n.equ TWI_FMPEN_bm = 0x02                 ; FM Plus Enable bit mask\n.equ TWI_FMPEN_bp = 1                    ; FM Plus Enable bit position\n.equ TWI_SDAHOLD_gm = 0x0C               ; SDA Hold Time group mask\n.equ TWI_SDAHOLD_gp = 2                  ; SDA Hold Time group position\n.equ TWI_SDAHOLD0_bm = (1<<2)            ; SDA Hold Time bit 0 mask\n.equ TWI_SDAHOLD0_bp = 2                 ; SDA Hold Time bit 0 position\n.equ TWI_SDAHOLD1_bm = (1<<3)            ; SDA Hold Time bit 1 mask\n.equ TWI_SDAHOLD1_bp = 3                 ; SDA Hold Time bit 1 position\n.equ TWI_SDASETUP_bm = 0x10              ; SDA Setup Time bit mask\n.equ TWI_SDASETUP_bp = 4                 ; SDA Setup Time bit position\n\n; TWI_DBGCTRL masks\n.equ TWI_DBGRUN_bm = 0x01                ; Debug Run bit mask\n.equ TWI_DBGRUN_bp = 0                   ; Debug Run bit position\n\n; TWI_MCTRLA masks\n.equ TWI_ENABLE_bm = 0x01                ; Enable TWI Master bit mask\n.equ TWI_ENABLE_bp = 0                   ; Enable TWI Master bit position\n.equ TWI_QCEN_bm = 0x10                  ; Quick Command Enable bit mask\n.equ TWI_QCEN_bp = 4                     ; Quick Command Enable bit position\n.equ TWI_RIEN_bm = 0x80                  ; Read Interrupt Enable bit mask\n.equ TWI_RIEN_bp = 7                     ; Read Interrupt Enable bit position\n.equ TWI_SMEN_bm = 0x02                  ; Smart Mode Enable bit mask\n.equ TWI_SMEN_bp = 1                     ; Smart Mode Enable bit position\n.equ TWI_TIMEOUT_gm = 0x0C               ; Inactive Bus Timeout group mask\n.equ TWI_TIMEOUT_gp = 2                  ; Inactive Bus Timeout group position\n.equ TWI_TIMEOUT0_bm = (1<<2)            ; Inactive Bus Timeout bit 0 mask\n.equ TWI_TIMEOUT0_bp = 2                 ; Inactive Bus Timeout bit 0 position\n.equ TWI_TIMEOUT1_bm = (1<<3)            ; Inactive Bus Timeout bit 1 mask\n.equ TWI_TIMEOUT1_bp = 3                 ; Inactive Bus Timeout bit 1 position\n.equ TWI_WIEN_bm = 0x40                  ; Write Interrupt Enable bit mask\n.equ TWI_WIEN_bp = 6                     ; Write Interrupt Enable bit position\n\n; TWI_MCTRLB masks\n.equ TWI_ACKACT_bm = 0x04                ; Acknowledge Action bit mask\n.equ TWI_ACKACT_bp = 2                   ; Acknowledge Action bit position\n.equ TWI_FLUSH_bm = 0x08                 ; Flush bit mask\n.equ TWI_FLUSH_bp = 3                    ; Flush bit position\n.equ TWI_MCMD_gm = 0x03                  ; Command group mask\n.equ TWI_MCMD_gp = 0                     ; Command group position\n.equ TWI_MCMD0_bm = (1<<0)               ; Command bit 0 mask\n.equ TWI_MCMD0_bp = 0                    ; Command bit 0 position\n.equ TWI_MCMD1_bm = (1<<1)               ; Command bit 1 mask\n.equ TWI_MCMD1_bp = 1                    ; Command bit 1 position\n\n; TWI_MSTATUS masks\n.equ TWI_ARBLOST_bm = 0x08               ; Arbitration Lost bit mask\n.equ TWI_ARBLOST_bp = 3                  ; Arbitration Lost bit position\n.equ TWI_BUSERR_bm = 0x04                ; Bus Error bit mask\n.equ TWI_BUSERR_bp = 2                   ; Bus Error bit position\n.equ TWI_BUSSTATE_gm = 0x03              ; Bus State group mask\n.equ TWI_BUSSTATE_gp = 0                 ; Bus State group position\n.equ TWI_BUSSTATE0_bm = (1<<0)           ; Bus State bit 0 mask\n.equ TWI_BUSSTATE0_bp = 0                ; Bus State bit 0 position\n.equ TWI_BUSSTATE1_bm = (1<<1)           ; Bus State bit 1 mask\n.equ TWI_BUSSTATE1_bp = 1                ; Bus State bit 1 position\n.equ TWI_CLKHOLD_bm = 0x20               ; Clock Hold bit mask\n.equ TWI_CLKHOLD_bp = 5                  ; Clock Hold bit position\n.equ TWI_RIF_bm = 0x80                   ; Read Interrupt Flag bit mask\n.equ TWI_RIF_bp = 7                      ; Read Interrupt Flag bit position\n.equ TWI_RXACK_bm = 0x10                 ; Received Acknowledge bit mask\n.equ TWI_RXACK_bp = 4                    ; Received Acknowledge bit position\n.equ TWI_WIF_bm = 0x40                   ; Write Interrupt Flag bit mask\n.equ TWI_WIF_bp = 6                      ; Write Interrupt Flag bit position\n\n; TWI_SADDRMASK masks\n.equ TWI_ADDREN_bm = 0x01                ; Address Enable bit mask\n.equ TWI_ADDREN_bp = 0                   ; Address Enable bit position\n.equ TWI_ADDRMASK_gm = 0xFE              ; Address Mask group mask\n.equ TWI_ADDRMASK_gp = 1                 ; Address Mask group position\n.equ TWI_ADDRMASK0_bm = (1<<1)           ; Address Mask bit 0 mask\n.equ TWI_ADDRMASK0_bp = 1                ; Address Mask bit 0 position\n.equ TWI_ADDRMASK1_bm = (1<<2)           ; Address Mask bit 1 mask\n.equ TWI_ADDRMASK1_bp = 2                ; Address Mask bit 1 position\n.equ TWI_ADDRMASK2_bm = (1<<3)           ; Address Mask bit 2 mask\n.equ TWI_ADDRMASK2_bp = 3                ; Address Mask bit 2 position\n.equ TWI_ADDRMASK3_bm = (1<<4)           ; Address Mask bit 3 mask\n.equ TWI_ADDRMASK3_bp = 4                ; Address Mask bit 3 position\n.equ TWI_ADDRMASK4_bm = (1<<5)           ; Address Mask bit 4 mask\n.equ TWI_ADDRMASK4_bp = 5                ; Address Mask bit 4 position\n.equ TWI_ADDRMASK5_bm = (1<<6)           ; Address Mask bit 5 mask\n.equ TWI_ADDRMASK5_bp = 6                ; Address Mask bit 5 position\n.equ TWI_ADDRMASK6_bm = (1<<7)           ; Address Mask bit 6 mask\n.equ TWI_ADDRMASK6_bp = 7                ; Address Mask bit 6 position\n\n; TWI_SCTRLA masks\n.equ TWI_APIEN_bm = 0x40                 ; Address/Stop Interrupt Enable bit mask\n.equ TWI_APIEN_bp = 6                    ; Address/Stop Interrupt Enable bit position\n.equ TWI_DIEN_bm = 0x80                  ; Data Interrupt Enable bit mask\n.equ TWI_DIEN_bp = 7                     ; Data Interrupt Enable bit position\n; Masks for TWI_ENABLE already defined\n.equ TWI_PIEN_bm = 0x20                  ; Stop Interrupt Enable bit mask\n.equ TWI_PIEN_bp = 5                     ; Stop Interrupt Enable bit position\n.equ TWI_PMEN_bm = 0x04                  ; Promiscuous Mode Enable bit mask\n.equ TWI_PMEN_bp = 2                     ; Promiscuous Mode Enable bit position\n; Masks for TWI_SMEN already defined\n\n; TWI_SCTRLB masks\n; Masks for TWI_ACKACT already defined\n.equ TWI_SCMD_gm = 0x03                  ; Command group mask\n.equ TWI_SCMD_gp = 0                     ; Command group position\n.equ TWI_SCMD0_bm = (1<<0)               ; Command bit 0 mask\n.equ TWI_SCMD0_bp = 0                    ; Command bit 0 position\n.equ TWI_SCMD1_bm = (1<<1)               ; Command bit 1 mask\n.equ TWI_SCMD1_bp = 1                    ; Command bit 1 position\n\n; TWI_SSTATUS masks\n.equ TWI_AP_bm = 0x01                    ; Slave Address or Stop bit mask\n.equ TWI_AP_bp = 0                       ; Slave Address or Stop bit position\n.equ TWI_APIF_bm = 0x40                  ; Address/Stop Interrupt Flag bit mask\n.equ TWI_APIF_bp = 6                     ; Address/Stop Interrupt Flag bit position\n; Masks for TWI_BUSERR already defined\n; Masks for TWI_CLKHOLD already defined\n.equ TWI_COLL_bm = 0x08                  ; Collision bit mask\n.equ TWI_COLL_bp = 3                     ; Collision bit position\n.equ TWI_DIF_bm = 0x80                   ; Data Interrupt Flag bit mask\n.equ TWI_DIF_bp = 7                      ; Data Interrupt Flag bit position\n.equ TWI_DIR_bm = 0x02                   ; Read/Write Direction bit mask\n.equ TWI_DIR_bp = 1                      ; Read/Write Direction bit position\n; Masks for TWI_RXACK already defined\n\n; SDA Hold Time select\n.equ TWI_SDAHOLD_OFF_gc = (0x00<<2)      ; SDA hold time off\n.equ TWI_SDAHOLD_50NS_gc = (0x01<<2)     ; Typical 50ns hold time\n.equ TWI_SDAHOLD_300NS_gc = (0x02<<2)    ; Typical 300ns hold time\n.equ TWI_SDAHOLD_500NS_gc = (0x03<<2)    ; Typical 500ns hold time\n\n; SDA Setup Time select\n.equ TWI_SDASETUP_4CYC_gc = (0x00<<4)    ; SDA setup time is 4 clock cycles\n.equ TWI_SDASETUP_8CYC_gc = (0x01<<4)    ; SDA setup time is 8 clock cycles\n\n; Inactive Bus Timeout select\n.equ TWI_TIMEOUT_DISABLED_gc = (0x00<<2) ; Bus Timeout Disabled\n.equ TWI_TIMEOUT_50US_gc = (0x01<<2)     ; 50 Microseconds\n.equ TWI_TIMEOUT_100US_gc = (0x02<<2)    ; 100 Microseconds\n.equ TWI_TIMEOUT_200US_gc = (0x03<<2)    ; 200 Microseconds\n\n; Acknowledge Action select\n.equ TWI_ACKACT_ACK_gc = (0x00<<2)       ; Send ACK\n.equ TWI_ACKACT_NACK_gc = (0x01<<2)      ; Send NACK\n\n; Command select\n.equ TWI_MCMD_NOACT_gc = (0x00<<0)       ; No Action\n.equ TWI_MCMD_REPSTART_gc = (0x01<<0)    ; Issue Repeated Start Condition\n.equ TWI_MCMD_RECVTRANS_gc = (0x02<<0)   ; Receive or Transmit Data, depending on DIR\n.equ TWI_MCMD_STOP_gc = (0x03<<0)        ; Issue Stop Condition\n\n; Bus State select\n.equ TWI_BUSSTATE_UNKNOWN_gc = (0x00<<0) ; Unknown Bus State\n.equ TWI_BUSSTATE_IDLE_gc = (0x01<<0)    ; Bus is Idle\n.equ TWI_BUSSTATE_OWNER_gc = (0x02<<0)   ; This Module Controls The Bus\n.equ TWI_BUSSTATE_BUSY_gc = (0x03<<0)    ; The Bus is Busy\n\n; Command select\n.equ TWI_SCMD_NOACT_gc = (0x00<<0)       ; No Action\n.equ TWI_SCMD_COMPTRANS_gc = (0x02<<0)   ; Used To Complete a Transaction\n.equ TWI_SCMD_RESPONSE_gc = (0x03<<0)    ; Used in Response to Address/Data Interrupt\n\n; Slave Address or Stop select\n.equ TWI_AP_STOP_gc = (0x00<<0)          ; Stop condition generated APIF\n.equ TWI_AP_ADR_gc = (0x01<<0)           ; Address detection generated APIF\n\n\n;*************************************************************************\n;** USART - Universal Synchronous and Asynchronous Receiver and Transmitter\n;*************************************************************************\n\n; USART_CTRLA masks\n.equ USART_ABEIE_bm = 0x04               ; Auto-baud Error Interrupt Enable bit mask\n.equ USART_ABEIE_bp = 2                  ; Auto-baud Error Interrupt Enable bit position\n.equ USART_DREIE_bm = 0x20               ; Data Register Empty Interrupt Enable bit mask\n.equ USART_DREIE_bp = 5                  ; Data Register Empty Interrupt Enable bit position\n.equ USART_LBME_bm = 0x08                ; Loop-back Mode Enable bit mask\n.equ USART_LBME_bp = 3                   ; Loop-back Mode Enable bit position\n.equ USART_RS485_gm = 0x03               ; RS485 Mode internal transmitter group mask\n.equ USART_RS485_gp = 0                  ; RS485 Mode internal transmitter group position\n.equ USART_RS4850_bm = (1<<0)            ; RS485 Mode internal transmitter bit 0 mask\n.equ USART_RS4850_bp = 0                 ; RS485 Mode internal transmitter bit 0 position\n.equ USART_RS4851_bm = (1<<1)            ; RS485 Mode internal transmitter bit 1 mask\n.equ USART_RS4851_bp = 1                 ; RS485 Mode internal transmitter bit 1 position\n.equ USART_RXCIE_bm = 0x80               ; Receive Complete Interrupt Enable bit mask\n.equ USART_RXCIE_bp = 7                  ; Receive Complete Interrupt Enable bit position\n.equ USART_RXSIE_bm = 0x10               ; Receiver Start Frame Interrupt Enable bit mask\n.equ USART_RXSIE_bp = 4                  ; Receiver Start Frame Interrupt Enable bit position\n.equ USART_TXCIE_bm = 0x40               ; Transmit Complete Interrupt Enable bit mask\n.equ USART_TXCIE_bp = 6                  ; Transmit Complete Interrupt Enable bit position\n\n; USART_CTRLB masks\n.equ USART_MPCM_bm = 0x01                ; Multi-processor Communication Mode bit mask\n.equ USART_MPCM_bp = 0                   ; Multi-processor Communication Mode bit position\n.equ USART_ODME_bm = 0x08                ; Open Drain Mode Enable bit mask\n.equ USART_ODME_bp = 3                   ; Open Drain Mode Enable bit position\n.equ USART_RXEN_bm = 0x80                ; Reciever enable bit mask\n.equ USART_RXEN_bp = 7                   ; Reciever enable bit position\n.equ USART_RXMODE_gm = 0x06              ; Receiver Mode group mask\n.equ USART_RXMODE_gp = 1                 ; Receiver Mode group position\n.equ USART_RXMODE0_bm = (1<<1)           ; Receiver Mode bit 0 mask\n.equ USART_RXMODE0_bp = 1                ; Receiver Mode bit 0 position\n.equ USART_RXMODE1_bm = (1<<2)           ; Receiver Mode bit 1 mask\n.equ USART_RXMODE1_bp = 2                ; Receiver Mode bit 1 position\n.equ USART_SFDEN_bm = 0x10               ; Start Frame Detection Enable bit mask\n.equ USART_SFDEN_bp = 4                  ; Start Frame Detection Enable bit position\n.equ USART_TXEN_bm = 0x40                ; Transmitter Enable bit mask\n.equ USART_TXEN_bp = 6                   ; Transmitter Enable bit position\n\n; USART_CTRLC masks\n.equ USART_CMODE_gm = 0xC0               ; Communication Mode group mask\n.equ USART_CMODE_gp = 6                  ; Communication Mode group position\n.equ USART_CMODE0_bm = (1<<6)            ; Communication Mode bit 0 mask\n.equ USART_CMODE0_bp = 6                 ; Communication Mode bit 0 position\n.equ USART_CMODE1_bm = (1<<7)            ; Communication Mode bit 1 mask\n.equ USART_CMODE1_bp = 7                 ; Communication Mode bit 1 position\n.equ USART_UCPHA_bm = 0x02               ; SPI Master Mode, Clock Phase bit mask\n.equ USART_UCPHA_bp = 1                  ; SPI Master Mode, Clock Phase bit position\n.equ USART_UDORD_bm = 0x04               ; SPI Master Mode, Data Order bit mask\n.equ USART_UDORD_bp = 2                  ; SPI Master Mode, Data Order bit position\n.equ USART_CHSIZE_gm = 0x07              ; Character Size group mask\n.equ USART_CHSIZE_gp = 0                 ; Character Size group position\n.equ USART_CHSIZE0_bm = (1<<0)           ; Character Size bit 0 mask\n.equ USART_CHSIZE0_bp = 0                ; Character Size bit 0 position\n.equ USART_CHSIZE1_bm = (1<<1)           ; Character Size bit 1 mask\n.equ USART_CHSIZE1_bp = 1                ; Character Size bit 1 position\n.equ USART_CHSIZE2_bm = (1<<2)           ; Character Size bit 2 mask\n.equ USART_CHSIZE2_bp = 2                ; Character Size bit 2 position\n; Masks for USART_CMODE already defined\n.equ USART_PMODE_gm = 0x30               ; Parity Mode group mask\n.equ USART_PMODE_gp = 4                  ; Parity Mode group position\n.equ USART_PMODE0_bm = (1<<4)            ; Parity Mode bit 0 mask\n.equ USART_PMODE0_bp = 4                 ; Parity Mode bit 0 position\n.equ USART_PMODE1_bm = (1<<5)            ; Parity Mode bit 1 mask\n.equ USART_PMODE1_bp = 5                 ; Parity Mode bit 1 position\n.equ USART_SBMODE_bm = 0x08              ; Stop Bit Mode bit mask\n.equ USART_SBMODE_bp = 3                 ; Stop Bit Mode bit position\n\n; USART_DBGCTRL masks\n.equ USART_DBGRUN_bm = 0x01              ; Debug Run bit mask\n.equ USART_DBGRUN_bp = 0                 ; Debug Run bit position\n\n; USART_EVCTRL masks\n.equ USART_IREI_bm = 0x01                ; IrDA Event Input Enable bit mask\n.equ USART_IREI_bp = 0                   ; IrDA Event Input Enable bit position\n\n; USART_RXDATAH masks\n.equ USART_BUFOVF_bm = 0x40              ; Buffer Overflow bit mask\n.equ USART_BUFOVF_bp = 6                 ; Buffer Overflow bit position\n.equ USART_DATA8_bm = 0x01               ; Receiver Data Register bit mask\n.equ USART_DATA8_bp = 0                  ; Receiver Data Register bit position\n.equ USART_FERR_bm = 0x04                ; Frame Error bit mask\n.equ USART_FERR_bp = 2                   ; Frame Error bit position\n.equ USART_PERR_bm = 0x02                ; Parity Error bit mask\n.equ USART_PERR_bp = 1                   ; Parity Error bit position\n.equ USART_RXCIF_bm = 0x80               ; Receive Complete Interrupt Flag bit mask\n.equ USART_RXCIF_bp = 7                  ; Receive Complete Interrupt Flag bit position\n\n; USART_RXDATAL masks\n.equ USART_DATA_gm = 0xFF                ; RX Data group mask\n.equ USART_DATA_gp = 0                   ; RX Data group position\n.equ USART_DATA0_bm = (1<<0)             ; RX Data bit 0 mask\n.equ USART_DATA0_bp = 0                  ; RX Data bit 0 position\n.equ USART_DATA1_bm = (1<<1)             ; RX Data bit 1 mask\n.equ USART_DATA1_bp = 1                  ; RX Data bit 1 position\n.equ USART_DATA2_bm = (1<<2)             ; RX Data bit 2 mask\n.equ USART_DATA2_bp = 2                  ; RX Data bit 2 position\n.equ USART_DATA3_bm = (1<<3)             ; RX Data bit 3 mask\n.equ USART_DATA3_bp = 3                  ; RX Data bit 3 position\n.equ USART_DATA4_bm = (1<<4)             ; RX Data bit 4 mask\n.equ USART_DATA4_bp = 4                  ; RX Data bit 4 position\n.equ USART_DATA5_bm = (1<<5)             ; RX Data bit 5 mask\n.equ USART_DATA5_bp = 5                  ; RX Data bit 5 position\n.equ USART_DATA6_bm = (1<<6)             ; RX Data bit 6 mask\n.equ USART_DATA6_bp = 6                  ; RX Data bit 6 position\n.equ USART_DATA7_bm = (1<<7)             ; RX Data bit 7 mask\n.equ USART_DATA7_bp = 7                  ; RX Data bit 7 position\n\n; USART_RXPLCTRL masks\n.equ USART_RXPL_gm = 0x7F                ; Receiver Pulse Lenght group mask\n.equ USART_RXPL_gp = 0                   ; Receiver Pulse Lenght group position\n.equ USART_RXPL0_bm = (1<<0)             ; Receiver Pulse Lenght bit 0 mask\n.equ USART_RXPL0_bp = 0                  ; Receiver Pulse Lenght bit 0 position\n.equ USART_RXPL1_bm = (1<<1)             ; Receiver Pulse Lenght bit 1 mask\n.equ USART_RXPL1_bp = 1                  ; Receiver Pulse Lenght bit 1 position\n.equ USART_RXPL2_bm = (1<<2)             ; Receiver Pulse Lenght bit 2 mask\n.equ USART_RXPL2_bp = 2                  ; Receiver Pulse Lenght bit 2 position\n.equ USART_RXPL3_bm = (1<<3)             ; Receiver Pulse Lenght bit 3 mask\n.equ USART_RXPL3_bp = 3                  ; Receiver Pulse Lenght bit 3 position\n.equ USART_RXPL4_bm = (1<<4)             ; Receiver Pulse Lenght bit 4 mask\n.equ USART_RXPL4_bp = 4                  ; Receiver Pulse Lenght bit 4 position\n.equ USART_RXPL5_bm = (1<<5)             ; Receiver Pulse Lenght bit 5 mask\n.equ USART_RXPL5_bp = 5                  ; Receiver Pulse Lenght bit 5 position\n.equ USART_RXPL6_bm = (1<<6)             ; Receiver Pulse Lenght bit 6 mask\n.equ USART_RXPL6_bp = 6                  ; Receiver Pulse Lenght bit 6 position\n\n; USART_STATUS masks\n.equ USART_BDF_bm = 0x02                 ; Break Detected Flag bit mask\n.equ USART_BDF_bp = 1                    ; Break Detected Flag bit position\n.equ USART_DREIF_bm = 0x20               ; Data Register Empty Flag bit mask\n.equ USART_DREIF_bp = 5                  ; Data Register Empty Flag bit position\n.equ USART_ISFIF_bm = 0x08               ; Inconsistent Sync Field Interrupt Flag bit mask\n.equ USART_ISFIF_bp = 3                  ; Inconsistent Sync Field Interrupt Flag bit position\n; Masks for USART_RXCIF already defined\n.equ USART_RXSIF_bm = 0x10               ; Receive Start Interrupt bit mask\n.equ USART_RXSIF_bp = 4                  ; Receive Start Interrupt bit position\n.equ USART_TXCIF_bm = 0x40               ; Transmit Interrupt Flag bit mask\n.equ USART_TXCIF_bp = 6                  ; Transmit Interrupt Flag bit position\n.equ USART_WFB_bm = 0x01                 ; Wait For Break bit mask\n.equ USART_WFB_bp = 0                    ; Wait For Break bit position\n\n; USART_TXDATAH masks\n; Masks for USART_DATA8 already defined\n\n; USART_TXDATAL masks\n; Masks for USART_DATA already defined\n\n; USART_TXPLCTRL masks\n.equ USART_TXPL_gm = 0xFF                ; Transmit pulse length group mask\n.equ USART_TXPL_gp = 0                   ; Transmit pulse length group position\n.equ USART_TXPL0_bm = (1<<0)             ; Transmit pulse length bit 0 mask\n.equ USART_TXPL0_bp = 0                  ; Transmit pulse length bit 0 position\n.equ USART_TXPL1_bm = (1<<1)             ; Transmit pulse length bit 1 mask\n.equ USART_TXPL1_bp = 1                  ; Transmit pulse length bit 1 position\n.equ USART_TXPL2_bm = (1<<2)             ; Transmit pulse length bit 2 mask\n.equ USART_TXPL2_bp = 2                  ; Transmit pulse length bit 2 position\n.equ USART_TXPL3_bm = (1<<3)             ; Transmit pulse length bit 3 mask\n.equ USART_TXPL3_bp = 3                  ; Transmit pulse length bit 3 position\n.equ USART_TXPL4_bm = (1<<4)             ; Transmit pulse length bit 4 mask\n.equ USART_TXPL4_bp = 4                  ; Transmit pulse length bit 4 position\n.equ USART_TXPL5_bm = (1<<5)             ; Transmit pulse length bit 5 mask\n.equ USART_TXPL5_bp = 5                  ; Transmit pulse length bit 5 position\n.equ USART_TXPL6_bm = (1<<6)             ; Transmit pulse length bit 6 mask\n.equ USART_TXPL6_bp = 6                  ; Transmit pulse length bit 6 position\n.equ USART_TXPL7_bm = (1<<7)             ; Transmit pulse length bit 7 mask\n.equ USART_TXPL7_bp = 7                  ; Transmit pulse length bit 7 position\n\n; RS485 Mode internal transmitter select\n.equ USART_RS485_OFF_gc = (0x00<<0)      ; RS485 Mode disabled\n.equ USART_RS485_EXT_gc = (0x01<<0)      ; RS485 Mode External drive\n.equ USART_RS485_INT_gc = (0x02<<0)      ; RS485 Mode Internal drive\n\n; Receiver Mode select\n.equ USART_RXMODE_NORMAL_gc = (0x00<<1)  ; Normal mode\n.equ USART_RXMODE_CLK2X_gc = (0x01<<1)   ; CLK2x mode\n.equ USART_RXMODE_GENAUTO_gc = (0x02<<1) ; Generic autobaud mode\n.equ USART_RXMODE_LINAUTO_gc = (0x03<<1) ; LIN constrained autobaud mode\n\n; Communication Mode select\n.equ USART_MSPI_CMODE_ASYNCHRONOUS_gc = (0x00<<6) ; Asynchronous Mode\n.equ USART_MSPI_CMODE_SYNCHRONOUS_gc = (0x01<<6) ; Synchronous Mode\n.equ USART_MSPI_CMODE_IRCOM_gc = (0x02<<6) ; Infrared Communication\n.equ USART_MSPI_CMODE_MSPI_gc = (0x03<<6) ; Master SPI Mode\n\n; Character Size select\n.equ USART_NORMAL_CHSIZE_5BIT_gc = (0x00<<0) ; Character size: 5 bit\n.equ USART_NORMAL_CHSIZE_6BIT_gc = (0x01<<0) ; Character size: 6 bit\n.equ USART_NORMAL_CHSIZE_7BIT_gc = (0x02<<0) ; Character size: 7 bit\n.equ USART_NORMAL_CHSIZE_8BIT_gc = (0x03<<0) ; Character size: 8 bit\n.equ USART_NORMAL_CHSIZE_9BITL_gc = (0x06<<0) ; Character size: 9 bit read low byte first\n.equ USART_NORMAL_CHSIZE_9BITH_gc = (0x07<<0) ; Character size: 9 bit read high byte first\n\n; Communication Mode select\n.equ USART_NORMAL_CMODE_ASYNCHRONOUS_gc = (0x00<<6) ; Asynchronous Mode\n.equ USART_NORMAL_CMODE_SYNCHRONOUS_gc = (0x01<<6) ; Synchronous Mode\n.equ USART_NORMAL_CMODE_IRCOM_gc = (0x02<<6) ; Infrared Communication\n.equ USART_NORMAL_CMODE_MSPI_gc = (0x03<<6) ; Master SPI Mode\n\n; Parity Mode select\n.equ USART_NORMAL_PMODE_DISABLED_gc = (0x00<<4) ; No Parity\n.equ USART_NORMAL_PMODE_EVEN_gc = (0x02<<4) ; Even Parity\n.equ USART_NORMAL_PMODE_ODD_gc = (0x03<<4) ; Odd Parity\n\n; Stop Bit Mode select\n.equ USART_NORMAL_SBMODE_1BIT_gc = (0x00<<3) ; 1 stop bit\n.equ USART_NORMAL_SBMODE_2BIT_gc = (0x01<<3) ; 2 stop bits\n\n\n;*************************************************************************\n;** USERROW - User Row\n;*************************************************************************\n\n\n;*************************************************************************\n;** VPORT - Virtual Ports\n;*************************************************************************\n\n; VPORT_INTFLAGS masks\n.equ VPORT_INT_gm = 0xFF                 ; Pin Interrupt group mask\n.equ VPORT_INT_gp = 0                    ; Pin Interrupt group position\n.equ VPORT_INT0_bm = (1<<0)              ; Pin Interrupt bit 0 mask\n.equ VPORT_INT0_bp = 0                   ; Pin Interrupt bit 0 position\n.equ VPORT_INT1_bm = (1<<1)              ; Pin Interrupt bit 1 mask\n.equ VPORT_INT1_bp = 1                   ; Pin Interrupt bit 1 position\n.equ VPORT_INT2_bm = (1<<2)              ; Pin Interrupt bit 2 mask\n.equ VPORT_INT2_bp = 2                   ; Pin Interrupt bit 2 position\n.equ VPORT_INT3_bm = (1<<3)              ; Pin Interrupt bit 3 mask\n.equ VPORT_INT3_bp = 3                   ; Pin Interrupt bit 3 position\n.equ VPORT_INT4_bm = (1<<4)              ; Pin Interrupt bit 4 mask\n.equ VPORT_INT4_bp = 4                   ; Pin Interrupt bit 4 position\n.equ VPORT_INT5_bm = (1<<5)              ; Pin Interrupt bit 5 mask\n.equ VPORT_INT5_bp = 5                   ; Pin Interrupt bit 5 position\n.equ VPORT_INT6_bm = (1<<6)              ; Pin Interrupt bit 6 mask\n.equ VPORT_INT6_bp = 6                   ; Pin Interrupt bit 6 position\n.equ VPORT_INT7_bm = (1<<7)              ; Pin Interrupt bit 7 mask\n.equ VPORT_INT7_bp = 7                   ; Pin Interrupt bit 7 position\n\n\n;*************************************************************************\n;** VREF - Voltage reference\n;*************************************************************************\n\n; VREF_CTRLA masks\n.equ VREF_ADC0REFSEL_gm = 0x70           ; ADC0 reference select group mask\n.equ VREF_ADC0REFSEL_gp = 4              ; ADC0 reference select group position\n.equ VREF_ADC0REFSEL0_bm = (1<<4)        ; ADC0 reference select bit 0 mask\n.equ VREF_ADC0REFSEL0_bp = 4             ; ADC0 reference select bit 0 position\n.equ VREF_ADC0REFSEL1_bm = (1<<5)        ; ADC0 reference select bit 1 mask\n.equ VREF_ADC0REFSEL1_bp = 5             ; ADC0 reference select bit 1 position\n.equ VREF_ADC0REFSEL2_bm = (1<<6)        ; ADC0 reference select bit 2 mask\n.equ VREF_ADC0REFSEL2_bp = 6             ; ADC0 reference select bit 2 position\n.equ VREF_DAC0REFSEL_gm = 0x07           ; DAC0/AC0 reference select group mask\n.equ VREF_DAC0REFSEL_gp = 0              ; DAC0/AC0 reference select group position\n.equ VREF_DAC0REFSEL0_bm = (1<<0)        ; DAC0/AC0 reference select bit 0 mask\n.equ VREF_DAC0REFSEL0_bp = 0             ; DAC0/AC0 reference select bit 0 position\n.equ VREF_DAC0REFSEL1_bm = (1<<1)        ; DAC0/AC0 reference select bit 1 mask\n.equ VREF_DAC0REFSEL1_bp = 1             ; DAC0/AC0 reference select bit 1 position\n.equ VREF_DAC0REFSEL2_bm = (1<<2)        ; DAC0/AC0 reference select bit 2 mask\n.equ VREF_DAC0REFSEL2_bp = 2             ; DAC0/AC0 reference select bit 2 position\n\n; VREF_CTRLB masks\n.equ VREF_ADC0REFEN_bm = 0x02            ; ADC0 reference enable bit mask\n.equ VREF_ADC0REFEN_bp = 1               ; ADC0 reference enable bit position\n.equ VREF_DAC0REFEN_bm = 0x01            ; DAC0/AC0 reference enable bit mask\n.equ VREF_DAC0REFEN_bp = 0               ; DAC0/AC0 reference enable bit position\n\n; ADC0 reference select select\n.equ VREF_ADC0REFSEL_0V55_gc = (0x00<<4) ; Voltage reference at 0.55V\n.equ VREF_ADC0REFSEL_1V1_gc = (0x01<<4)  ; Voltage reference at 1.1V\n.equ VREF_ADC0REFSEL_2V5_gc = (0x02<<4)  ; Voltage reference at 2.5V\n.equ VREF_ADC0REFSEL_4V34_gc = (0x03<<4) ; Voltage reference at 4.34V\n.equ VREF_ADC0REFSEL_1V5_gc = (0x04<<4)  ; Voltage reference at 1.5V\n\n; DAC0/AC0 reference select select\n.equ VREF_DAC0REFSEL_0V55_gc = (0x00<<0) ; Voltage reference at 0.55V\n.equ VREF_DAC0REFSEL_1V1_gc = (0x01<<0)  ; Voltage reference at 1.1V\n.equ VREF_DAC0REFSEL_2V5_gc = (0x02<<0)  ; Voltage reference at 2.5V\n.equ VREF_DAC0REFSEL_4V34_gc = (0x03<<0) ; Voltage reference at 4.34V\n.equ VREF_DAC0REFSEL_1V5_gc = (0x04<<0)  ; Voltage reference at 1.5V\n\n\n;*************************************************************************\n;** WDT - Watch-Dog Timer\n;*************************************************************************\n\n; WDT_CTRLA masks\n.equ WDT_PERIOD_gm = 0x0F                ; Period group mask\n.equ WDT_PERIOD_gp = 0                   ; Period group position\n.equ WDT_PERIOD0_bm = (1<<0)             ; Period bit 0 mask\n.equ WDT_PERIOD0_bp = 0                  ; Period bit 0 position\n.equ WDT_PERIOD1_bm = (1<<1)             ; Period bit 1 mask\n.equ WDT_PERIOD1_bp = 1                  ; Period bit 1 position\n.equ WDT_PERIOD2_bm = (1<<2)             ; Period bit 2 mask\n.equ WDT_PERIOD2_bp = 2                  ; Period bit 2 position\n.equ WDT_PERIOD3_bm = (1<<3)             ; Period bit 3 mask\n.equ WDT_PERIOD3_bp = 3                  ; Period bit 3 position\n.equ WDT_WINDOW_gm = 0xF0                ; Window group mask\n.equ WDT_WINDOW_gp = 4                   ; Window group position\n.equ WDT_WINDOW0_bm = (1<<4)             ; Window bit 0 mask\n.equ WDT_WINDOW0_bp = 4                  ; Window bit 0 position\n.equ WDT_WINDOW1_bm = (1<<5)             ; Window bit 1 mask\n.equ WDT_WINDOW1_bp = 5                  ; Window bit 1 position\n.equ WDT_WINDOW2_bm = (1<<6)             ; Window bit 2 mask\n.equ WDT_WINDOW2_bp = 6                  ; Window bit 2 position\n.equ WDT_WINDOW3_bm = (1<<7)             ; Window bit 3 mask\n.equ WDT_WINDOW3_bp = 7                  ; Window bit 3 position\n\n; WDT_STATUS masks\n.equ WDT_LOCK_bm = 0x80                  ; Lock enable bit mask\n.equ WDT_LOCK_bp = 7                     ; Lock enable bit position\n.equ WDT_SYNCBUSY_bm = 0x01              ; Syncronization busy bit mask\n.equ WDT_SYNCBUSY_bp = 0                 ; Syncronization busy bit position\n\n; Period select\n.equ WDT_PERIOD_OFF_gc = (0x00<<0)       ; Watch-Dog timer Off\n.equ WDT_PERIOD_8CLK_gc = (0x01<<0)      ; 8 cycles (8ms)\n.equ WDT_PERIOD_16CLK_gc = (0x02<<0)     ; 16 cycles (16ms)\n.equ WDT_PERIOD_32CLK_gc = (0x03<<0)     ; 32 cycles (32ms)\n.equ WDT_PERIOD_64CLK_gc = (0x04<<0)     ; 64 cycles (64ms)\n.equ WDT_PERIOD_128CLK_gc = (0x05<<0)    ; 128 cycles (0.128s)\n.equ WDT_PERIOD_256CLK_gc = (0x06<<0)    ; 256 cycles (0.256s)\n.equ WDT_PERIOD_512CLK_gc = (0x07<<0)    ; 512 cycles (0.512s)\n.equ WDT_PERIOD_1KCLK_gc = (0x08<<0)     ; 1K cycles (1.0s)\n.equ WDT_PERIOD_2KCLK_gc = (0x09<<0)     ; 2K cycles (2.0s)\n.equ WDT_PERIOD_4KCLK_gc = (0x0A<<0)     ; 4K cycles (4.1s)\n.equ WDT_PERIOD_8KCLK_gc = (0x0B<<0)     ; 8K cycles (8.2s)\n\n; Window select\n.equ WDT_WINDOW_OFF_gc = (0x00<<4)       ; Window mode off\n.equ WDT_WINDOW_8CLK_gc = (0x01<<4)      ; 8 cycles (8ms)\n.equ WDT_WINDOW_16CLK_gc = (0x02<<4)     ; 16 cycles (16ms)\n.equ WDT_WINDOW_32CLK_gc = (0x03<<4)     ; 32 cycles (32ms)\n.equ WDT_WINDOW_64CLK_gc = (0x04<<4)     ; 64 cycles (64ms)\n.equ WDT_WINDOW_128CLK_gc = (0x05<<4)    ; 128 cycles (0.128s)\n.equ WDT_WINDOW_256CLK_gc = (0x06<<4)    ; 256 cycles (0.256s)\n.equ WDT_WINDOW_512CLK_gc = (0x07<<4)    ; 512 cycles (0.512s)\n.equ WDT_WINDOW_1KCLK_gc = (0x08<<4)     ; 1K cycles (1.0s)\n.equ WDT_WINDOW_2KCLK_gc = (0x09<<4)     ; 2K cycles (2.0s)\n.equ WDT_WINDOW_4KCLK_gc = (0x0A<<4)     ; 4K cycles (4.1s)\n.equ WDT_WINDOW_8KCLK_gc = (0x0B<<4)     ; 8K cycles (8.2s)\n\n\n\n\n; ***** CPU REGISTER DEFINITIONS *****************************************\n.def\tXH\t= r27\n.def\tXL\t= r26\n.def\tYH\t= r29\n.def\tYL\t= r28\n.def\tZH\t= r31\n.def\tZL\t= r30\n\n\n; ***** DATA MEMORY DECLARATIONS *****************************************\n\n\n#define DATAMEM_START 0x0000\n#define DATAMEM_SIZE 0xA000\n#define DATAMEM_END (0x0000 + 0xA000 - 1)\n\n#define EEPROM_START 0x1400\n#define EEPROM_SIZE 0x0080\n#define EEPROM_END (0x1400 + 0x0080 - 1)\n#define EEPROM_PAGE_SIZE 0x20\n\n#define FUSES_START 0x1280\n#define FUSES_SIZE 0x000A\n#define FUSES_END (0x1280 + 0x000A - 1)\n#define FUSES_PAGE_SIZE 0x20\n\n#define INTERNAL_SRAM_START 0x3E00\n#define INTERNAL_SRAM_SIZE 0x0200\n#define INTERNAL_SRAM_END (0x3E00 + 0x0200 - 1)\n\n#define IO_START 0x0000\n#define IO_SIZE 0x1100\n#define IO_END (0x0000 + 0x1100 - 1)\n\n#define LOCKBITS_START 0x128A\n#define LOCKBITS_SIZE 0x0001\n#define LOCKBITS_END (0x128A + 0x0001 - 1)\n#define LOCKBITS_PAGE_SIZE 0x20\n\n#define MAPPED_PROGMEM_START 0x8000\n#define MAPPED_PROGMEM_SIZE 0x2000\n#define MAPPED_PROGMEM_END (0x8000 + 0x2000 - 1)\n#define MAPPED_PROGMEM_PAGE_SIZE 0x40\n\n#define PROD_SIGNATURES_START 0x1103\n#define PROD_SIGNATURES_SIZE 0x003D\n#define PROD_SIGNATURES_END (0x1103 + 0x003D - 1)\n#define PROD_SIGNATURES_PAGE_SIZE 0x40\n\n#define SIGNATURES_START 0x1100\n#define SIGNATURES_SIZE 0x0003\n#define SIGNATURES_END (0x1100 + 0x0003 - 1)\n#define SIGNATURES_PAGE_SIZE 0x40\n\n#define USER_SIGNATURES_START 0x1300\n#define USER_SIGNATURES_SIZE 0x0020\n#define USER_SIGNATURES_END (0x1300 + 0x0020 - 1)\n#define USER_SIGNATURES_PAGE_SIZE 0x20\n\n#define PROGMEM_START 0x0000\n#define PROGMEM_SIZE 0x2000\n#define PROGMEM_END (0x0000 + 0x2000 - 1)\n#define PROGMEM_PAGE_SIZE 0x40\n\n\n; Legacy definitions\n.equ    FLASHSTART    = (PROGMEM_START / 2) ; Note: Word address\n.equ    FLASHEND      = (PROGMEM_END / 2) ; Note: Word address\n.equ    IOEND         = IO_END\n.equ    SRAM_START    = INTERNAL_SRAM_START\n.equ    SRAM_SIZE     = INTERNAL_SRAM_SIZE\n.equ    RAMEND        = INTERNAL_SRAM_END\n.equ    E2END         = EEPROM_END\n.equ    EEPROMEND     = EEPROM_END\n\n\n; Definitions used by the assembler\n#pragma AVRPART MEMORY PROG_FLASH 0x2000\n#pragma AVRPART MEMORY EEPROM 0x0080\n#pragma AVRPART MEMORY INT_SRAM SIZE 0x0200\n#pragma AVRPART MEMORY INT_SRAM START_ADDR 0x3E00\n\n; ***** INTERRUPT VECTORS, ABSOLUTE ADDRESSES ****************************\n\n; CRCSCAN interrupt vectors\n.equ CRCSCAN_NMI_vect = 0x0001           ; \n\n; BOD interrupt vectors\n.equ BOD_VLM_vect = 0x0002               ; \n\n; PORTA interrupt vectors\n.equ PORTA_PORT_vect = 0x0003            ; \n\n; PORTB interrupt vectors\n.equ PORTB_PORT_vect = 0x0004            ; \n\n; RTC interrupt vectors\n.equ RTC_CNT_vect = 0x0006               ; \n.equ RTC_PIT_vect = 0x0007               ; \n\n; TCA0 interrupt vectors\n.equ TCA0_LUNF_vect = 0x0008             ; \n.equ TCA0_OVF_vect = 0x0008              ; \n.equ TCA0_HUNF_vect = 0x0009             ; \n.equ TCA0_CMP0_vect = 0x000A             ; \n.equ TCA0_LCMP0_vect = 0x000A            ; \n.equ TCA0_CMP1_vect = 0x000B             ; \n.equ TCA0_LCMP1_vect = 0x000B            ; \n.equ TCA0_CMP2_vect = 0x000C             ; \n.equ TCA0_LCMP2_vect = 0x000C            ; \n\n; TCB0 interrupt vectors\n.equ TCB0_INT_vect = 0x000D              ; \n\n; TCD0 interrupt vectors\n.equ TCD0_OVF_vect = 0x000E              ; \n.equ TCD0_TRIG_vect = 0x000F             ; \n\n; AC0 interrupt vectors\n.equ AC0_AC_vect = 0x0010                ; \n\n; ADC0 interrupt vectors\n.equ ADC0_RESRDY_vect = 0x0011           ; \n.equ ADC0_WCOMP_vect = 0x0012            ; \n\n; TWI0 interrupt vectors\n.equ TWI0_TWIS_vect = 0x0013             ; \n.equ TWI0_TWIM_vect = 0x0014             ; \n\n; SPI0 interrupt vectors\n.equ SPI0_INT_vect = 0x0015              ; \n\n; USART0 interrupt vectors\n.equ USART0_RXC_vect = 0x0016            ; \n.equ USART0_DRE_vect = 0x0017            ; \n.equ USART0_TXC_vect = 0x0018            ; \n\n; NVMCTRL interrupt vectors\n.equ NVMCTRL_EE_vect = 0x0019            ; \n\n\n\n; ***** INTERRUPT VECTORS, MODULE BASES **********************************\n\n.equ CRCSCAN_vbase = 0x0001\n.equ BOD_vbase = 0x0002\n.equ PORTA_vbase = 0x0003\n.equ PORTB_vbase = 0x0004\n.equ RTC_vbase = 0x0006\n.equ TCA0_vbase = 0x0008\n.equ TCB0_vbase = 0x000D\n.equ TCD0_vbase = 0x000E\n.equ AC0_vbase = 0x0010\n.equ ADC0_vbase = 0x0011\n.equ TWI0_vbase = 0x0013\n.equ SPI0_vbase = 0x0015\n.equ USART0_vbase = 0x0016\n.equ NVMCTRL_vbase = 0x0019\n\n\n; ***** INTERRUPT VECTORS, VECTOR OFFSETS ********************************\n\n; CRCSCAN interrupt vector offsets\n\n.equ CRCSCAN_NMI_voffset = 0\n\n; BOD interrupt vector offsets\n\n.equ BOD_VLM_voffset = 0\n\n; PORTA interrupt vector offsets\n\n.equ PORTA_PORT_voffset = 0\n\n; PORTB interrupt vector offsets\n\n.equ PORTB_PORT_voffset = 0\n\n; RTC interrupt vector offsets\n\n.equ RTC_CNT_voffset = 0\n.equ RTC_PIT_voffset = 1\n\n; TCA0 interrupt vector offsets\n\n.equ TCA0_LUNF_voffset = 0\n.equ TCA0_OVF_voffset = 0\n.equ TCA0_HUNF_voffset = 1\n.equ TCA0_CMP0_voffset = 2\n.equ TCA0_LCMP0_voffset = 2\n.equ TCA0_CMP1_voffset = 3\n.equ TCA0_LCMP1_voffset = 3\n.equ TCA0_CMP2_voffset = 4\n.equ TCA0_LCMP2_voffset = 4\n\n; TCB0 interrupt vector offsets\n\n.equ TCB0_INT_voffset = 0\n\n; TCD0 interrupt vector offsets\n\n.equ TCD0_OVF_voffset = 0\n.equ TCD0_TRIG_voffset = 1\n\n; AC0 interrupt vector offsets\n\n.equ AC0_AC_voffset = 0\n\n; ADC0 interrupt vector offsets\n\n.equ ADC0_RESRDY_voffset = 0\n.equ ADC0_WCOMP_voffset = 1\n\n; TWI0 interrupt vector offsets\n\n.equ TWI0_TWIS_voffset = 0\n.equ TWI0_TWIM_voffset = 1\n\n; SPI0 interrupt vector offsets\n\n.equ SPI0_INT_voffset = 0\n\n; USART0 interrupt vector offsets\n\n.equ USART0_RXC_voffset = 0\n.equ USART0_DRE_voffset = 1\n.equ USART0_TXC_voffset = 2\n\n; NVMCTRL interrupt vector offsets\n\n.equ NVMCTRL_EE_voffset = 0\n\n\n\n.equ INT_VECTORS_SIZE = 26 ; size in words\n\n\n#endif /* _TN814DEF_INC_ */\n\n; ***** END OF FILE ******************************************************\n\n\n\n","inc/tn1614def.inc":";***** THIS IS A MACHINE GENERATED FILE - DO NOT EDIT ********************\n\n;*************************************************************************\n;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y\n;*\n;* Number            : AVR000\n;* File Name         : tn1614def.inc\n;* Title             : Register/Bit Definitions for the ATtiny1614\n;* Created           : 2021-07-13 10:42\n;* Version           : 1.00\n;* Support e-mail    : avr@atmel.com\n;* Target MCU        : ATtiny1614\n;*\n;* DESCRIPTION\n;* When including this file in the assembly program file, all I/O register\n;* names and I/O register bit names appearing in the data book can be used.\n;* In addition, the six registers forming the three data pointers X, Y and\n;* Z have been assigned names XL - ZH. Highest RAM address for Internal\n;* SRAM is also defined\n;*\n;*************************************************************************\n\n#ifndef _TN1614DEF_INC_\n#define _TN1614DEF_INC_\n\n\n#pragma partinc 0\n\n; ***** SPECIFY DEVICE ***************************************************\n.device\tATtiny1614\n\n#pragma AVRPART ADMIN PART_NAME ATtiny1614\n\n.equ\tSIGNATURE_000\t= 0x1E\n.equ\tSIGNATURE_001\t= 0x94\n.equ\tSIGNATURE_002\t= 0x22\n\n#pragma AVRPART CORE CORE_VERSION V4\n\n\n; ***** ABSOLUTE I/O REGISTER LOCATIONS **********************************\n\n\n;*************************************************************************\n;** AC0 - Analog Comparator\n;*************************************************************************\n\n.equ AC0_CTRLA = 0x0680                  ; Control A\n.equ AC0_MUXCTRLA = 0x0682               ; Mux Control A\n.equ AC0_INTCTRL = 0x0686                ; Interrupt Control\n.equ AC0_STATUS = 0x0687                 ; Status\n\n;*************************************************************************\n;** AC1 - Analog Comparator\n;*************************************************************************\n\n.equ AC1_CTRLA = 0x0688                  ; Control A\n.equ AC1_MUXCTRLA = 0x068A               ; Mux Control A\n.equ AC1_INTCTRL = 0x068E                ; Interrupt Control\n.equ AC1_STATUS = 0x068F                 ; Status\n\n;*************************************************************************\n;** AC2 - Analog Comparator\n;*************************************************************************\n\n.equ AC2_CTRLA = 0x0690                  ; Control A\n.equ AC2_MUXCTRLA = 0x0692               ; Mux Control A\n.equ AC2_INTCTRL = 0x0696                ; Interrupt Control\n.equ AC2_STATUS = 0x0697                 ; Status\n\n;*************************************************************************\n;** ADC0 - Analog to Digital Converter\n;*************************************************************************\n\n.equ ADC0_CTRLA = 0x0600                 ; Control A\n.equ ADC0_CTRLB = 0x0601                 ; Control B\n.equ ADC0_CTRLC = 0x0602                 ; Control C\n.equ ADC0_CTRLD = 0x0603                 ; Control D\n.equ ADC0_CTRLE = 0x0604                 ; Control E\n.equ ADC0_SAMPCTRL = 0x0605              ; Sample Control\n.equ ADC0_MUXPOS = 0x0606                ; Positive mux input\n.equ ADC0_COMMAND = 0x0608               ; Command\n.equ ADC0_EVCTRL = 0x0609                ; Event Control\n.equ ADC0_INTCTRL = 0x060A               ; Interrupt Control\n.equ ADC0_INTFLAGS = 0x060B              ; Interrupt Flags\n.equ ADC0_DBGCTRL = 0x060C               ; Debug Control\n.equ ADC0_TEMP = 0x060D                  ; Temporary Data\n.equ ADC0_RES = 0x0610                   ; ADC Accumulator Result\n.equ ADC0_RESL = 0x0610                  ; ADC Accumulator Result low byte\n.equ ADC0_RESH = 0x0611                  ; ADC Accumulator Result hi byte\n.equ ADC0_WINLT = 0x0612                 ; Window comparator low threshold\n.equ ADC0_WINLTL = 0x0612                ; Window comparator low threshold low byte\n.equ ADC0_WINLTH = 0x0613                ; Window comparator low threshold hi byte\n.equ ADC0_WINHT = 0x0614                 ; Window comparator high threshold\n.equ ADC0_WINHTL = 0x0614                ; Window comparator high threshold low byte\n.equ ADC0_WINHTH = 0x0615                ; Window comparator high threshold hi byte\n.equ ADC0_CALIB = 0x0616                 ; Calibration\n\n;*************************************************************************\n;** ADC1 - Analog to Digital Converter\n;*************************************************************************\n\n.equ ADC1_CTRLA = 0x0640                 ; Control A\n.equ ADC1_CTRLB = 0x0641                 ; Control B\n.equ ADC1_CTRLC = 0x0642                 ; Control C\n.equ ADC1_CTRLD = 0x0643                 ; Control D\n.equ ADC1_CTRLE = 0x0644                 ; Control E\n.equ ADC1_SAMPCTRL = 0x0645              ; Sample Control\n.equ ADC1_MUXPOS = 0x0646                ; Positive mux input\n.equ ADC1_COMMAND = 0x0648               ; Command\n.equ ADC1_EVCTRL = 0x0649                ; Event Control\n.equ ADC1_INTCTRL = 0x064A               ; Interrupt Control\n.equ ADC1_INTFLAGS = 0x064B              ; Interrupt Flags\n.equ ADC1_DBGCTRL = 0x064C               ; Debug Control\n.equ ADC1_TEMP = 0x064D                  ; Temporary Data\n.equ ADC1_RES = 0x0650                   ; ADC Accumulator Result\n.equ ADC1_RESL = 0x0650                  ; ADC Accumulator Result low byte\n.equ ADC1_RESH = 0x0651                  ; ADC Accumulator Result hi byte\n.equ ADC1_WINLT = 0x0652                 ; Window comparator low threshold\n.equ ADC1_WINLTL = 0x0652                ; Window comparator low threshold low byte\n.equ ADC1_WINLTH = 0x0653                ; Window comparator low threshold hi byte\n.equ ADC1_WINHT = 0x0654                 ; Window comparator high threshold\n.equ ADC1_WINHTL = 0x0654                ; Window comparator high threshold low byte\n.equ ADC1_WINHTH = 0x0655                ; Window comparator high threshold hi byte\n.equ ADC1_CALIB = 0x0656                 ; Calibration\n\n;*************************************************************************\n;** BOD - Bod interface\n;*************************************************************************\n\n.equ BOD_CTRLA = 0x0080                  ; Control A\n.equ BOD_CTRLB = 0x0081                  ; Control B\n.equ BOD_VLMCTRLA = 0x0088               ; Voltage level monitor Control\n.equ BOD_INTCTRL = 0x0089                ; Voltage level monitor interrupt Control\n.equ BOD_INTFLAGS = 0x008A               ; Voltage level monitor interrupt Flags\n.equ BOD_STATUS = 0x008B                 ; Voltage level monitor status\n\n;*************************************************************************\n;** CCL - Configurable Custom Logic\n;*************************************************************************\n\n.equ CCL_CTRLA = 0x01C0                  ; Control Register A\n.equ CCL_SEQCTRL0 = 0x01C1               ; Sequential Control 0\n.equ CCL_LUT0CTRLA = 0x01C5              ; LUT Control 0 A\n.equ CCL_LUT0CTRLB = 0x01C6              ; LUT Control 0 B\n.equ CCL_LUT0CTRLC = 0x01C7              ; LUT Control 0 C\n.equ CCL_TRUTH0 = 0x01C8                 ; Truth 0\n.equ CCL_LUT1CTRLA = 0x01C9              ; LUT Control 1 A\n.equ CCL_LUT1CTRLB = 0x01CA              ; LUT Control 1 B\n.equ CCL_LUT1CTRLC = 0x01CB              ; LUT Control 1 C\n.equ CCL_TRUTH1 = 0x01CC                 ; Truth 1\n\n;*************************************************************************\n;** CLKCTRL - Clock controller\n;*************************************************************************\n\n.equ CLKCTRL_MCLKCTRLA = 0x0060          ; MCLK Control A\n.equ CLKCTRL_MCLKCTRLB = 0x0061          ; MCLK Control B\n.equ CLKCTRL_MCLKLOCK = 0x0062           ; MCLK Lock\n.equ CLKCTRL_MCLKSTATUS = 0x0063         ; MCLK Status\n.equ CLKCTRL_OSC20MCTRLA = 0x0070        ; OSC20M Control A\n.equ CLKCTRL_OSC20MCALIBA = 0x0071       ; OSC20M Calibration A\n.equ CLKCTRL_OSC20MCALIBB = 0x0072       ; OSC20M Calibration B\n.equ CLKCTRL_OSC32KCTRLA = 0x0078        ; OSC32K Control A\n.equ CLKCTRL_XOSC32KCTRLA = 0x007C       ; XOSC32K Control A\n\n;*************************************************************************\n;** CPU - CPU\n;*************************************************************************\n\n.equ CPU_CCP = 0x0034                    ; Configuration Change Protection\n.equ CPU_SPL = 0x003D                    ; Stack Pointer Low\n.equ CPU_SPH = 0x003E                    ; Stack Pointer High\n.equ CPU_SREG = 0x003F                   ; Status Register\n\n;*************************************************************************\n;** CPUINT - Interrupt Controller\n;*************************************************************************\n\n.equ CPUINT_CTRLA = 0x0110               ; Control A\n.equ CPUINT_STATUS = 0x0111              ; Status\n.equ CPUINT_LVL0PRI = 0x0112             ; Interrupt Level 0 Priority\n.equ CPUINT_LVL1VEC = 0x0113             ; Interrupt Level 1 Priority Vector\n\n;*************************************************************************\n;** CRCSCAN - CRCSCAN\n;*************************************************************************\n\n.equ CRCSCAN_CTRLA = 0x0120              ; Control A\n.equ CRCSCAN_CTRLB = 0x0121              ; Control B\n.equ CRCSCAN_STATUS = 0x0122             ; Status\n\n;*************************************************************************\n;** DAC0 - Digital to Analog Converter\n;*************************************************************************\n\n.equ DAC0_CTRLA = 0x06A0                 ; Control Register A\n.equ DAC0_DATA = 0x06A1                  ; DATA Register\n\n;*************************************************************************\n;** DAC1 - Digital to Analog Converter\n;*************************************************************************\n\n.equ DAC1_CTRLA = 0x06A8                 ; Control Register A\n.equ DAC1_DATA = 0x06A9                  ; DATA Register\n\n;*************************************************************************\n;** DAC2 - Digital to Analog Converter\n;*************************************************************************\n\n.equ DAC2_CTRLA = 0x06B0                 ; Control Register A\n.equ DAC2_DATA = 0x06B1                  ; DATA Register\n\n;*************************************************************************\n;** EVSYS - Event System\n;*************************************************************************\n\n.equ EVSYS_ASYNCSTROBE = 0x0180          ; Asynchronous Channel Strobe\n.equ EVSYS_SYNCSTROBE = 0x0181           ; Synchronous Channel Strobe\n.equ EVSYS_ASYNCCH0 = 0x0182             ; Asynchronous Channel 0 Generator Selection\n.equ EVSYS_ASYNCCH1 = 0x0183             ; Asynchronous Channel 1 Generator Selection\n.equ EVSYS_ASYNCCH2 = 0x0184             ; Asynchronous Channel 2 Generator Selection\n.equ EVSYS_ASYNCCH3 = 0x0185             ; Asynchronous Channel 3 Generator Selection\n.equ EVSYS_SYNCCH0 = 0x018A              ; Synchronous Channel 0 Generator Selection\n.equ EVSYS_SYNCCH1 = 0x018B              ; Synchronous Channel 1 Generator Selection\n.equ EVSYS_ASYNCUSER0 = 0x0192           ; Asynchronous User Ch 0 Input Selection - TCB0\n.equ EVSYS_ASYNCUSER1 = 0x0193           ; Asynchronous User Ch 1 Input Selection - ADC0\n.equ EVSYS_ASYNCUSER2 = 0x0194           ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0\n.equ EVSYS_ASYNCUSER3 = 0x0195           ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0\n.equ EVSYS_ASYNCUSER4 = 0x0196           ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1\n.equ EVSYS_ASYNCUSER5 = 0x0197           ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1\n.equ EVSYS_ASYNCUSER6 = 0x0198           ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0\n.equ EVSYS_ASYNCUSER7 = 0x0199           ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1\n.equ EVSYS_ASYNCUSER8 = 0x019A           ; Asynchronous User Ch 8 Input Selection - Event Out 0\n.equ EVSYS_ASYNCUSER9 = 0x019B           ; Asynchronous User Ch 9 Input Selection - Event Out 1\n.equ EVSYS_ASYNCUSER10 = 0x019C          ; Asynchronous User Ch 10 Input Selection - Event Out 2\n.equ EVSYS_ASYNCUSER11 = 0x019D          ; Asynchronous User Ch 11 Input Selection - TCB1\n.equ EVSYS_ASYNCUSER12 = 0x019E          ; Asynchronous User Ch 12 Input Selection - ADC1\n.equ EVSYS_SYNCUSER0 = 0x01A2            ; Synchronous User Ch 0 - TCA0\n.equ EVSYS_SYNCUSER1 = 0x01A3            ; Synchronous User Ch 1 - USART0\n\n;*************************************************************************\n;** FUSE - Fuses\n;*************************************************************************\n\n.equ FUSE_WDTCFG = 0x1280                ; Watchdog Configuration\n.equ FUSE_BODCFG = 0x1281                ; BOD Configuration\n.equ FUSE_OSCCFG = 0x1282                ; Oscillator Configuration\n.equ FUSE_TCD0CFG = 0x1284               ; TCD0 Configuration\n.equ FUSE_SYSCFG0 = 0x1285               ; System Configuration 0\n.equ FUSE_SYSCFG1 = 0x1286               ; System Configuration 1\n.equ FUSE_APPEND = 0x1287                ; Application Code Section End\n.equ FUSE_BOOTEND = 0x1288               ; Boot Section End\n\n;*************************************************************************\n;** GPIO - General Purpose IO\n;*************************************************************************\n\n.equ GPIO_GPIOR0 = 0x001C                ; General Purpose IO Register 0\n.equ GPIO_GPIOR1 = 0x001D                ; General Purpose IO Register 1\n.equ GPIO_GPIOR2 = 0x001E                ; General Purpose IO Register 2\n.equ GPIO_GPIOR3 = 0x001F                ; General Purpose IO Register 3\n\n;*************************************************************************\n;** LOCKBIT - Lockbit\n;*************************************************************************\n\n.equ LOCKBIT_LOCKBIT = 0x128A            ; Lock bits\n\n;*************************************************************************\n;** NVMCTRL - Non-volatile Memory Controller\n;*************************************************************************\n\n.equ NVMCTRL_CTRLA = 0x1000              ; Control A\n.equ NVMCTRL_CTRLB = 0x1001              ; Control B\n.equ NVMCTRL_STATUS = 0x1002             ; Status\n.equ NVMCTRL_INTCTRL = 0x1003            ; Interrupt Control\n.equ NVMCTRL_INTFLAGS = 0x1004           ; Interrupt Flags\n.equ NVMCTRL_DATA = 0x1006               ; Data\n.equ NVMCTRL_DATAL = 0x1006              ; Data low byte\n.equ NVMCTRL_DATAH = 0x1007              ; Data hi byte\n.equ NVMCTRL_ADDR = 0x1008               ; Address\n.equ NVMCTRL_ADDRL = 0x1008              ; Address low byte\n.equ NVMCTRL_ADDRH = 0x1009              ; Address hi byte\n\n;*************************************************************************\n;** PORTA - I/O Ports\n;*************************************************************************\n\n.equ PORTA_DIR = 0x0400                  ; Data Direction\n.equ PORTA_DIRSET = 0x0401               ; Data Direction Set\n.equ PORTA_DIRCLR = 0x0402               ; Data Direction Clear\n.equ PORTA_DIRTGL = 0x0403               ; Data Direction Toggle\n.equ PORTA_OUT = 0x0404                  ; Output Value\n.equ PORTA_OUTSET = 0x0405               ; Output Value Set\n.equ PORTA_OUTCLR = 0x0406               ; Output Value Clear\n.equ PORTA_OUTTGL = 0x0407               ; Output Value Toggle\n.equ PORTA_IN = 0x0408                   ; Input Value\n.equ PORTA_INTFLAGS = 0x0409             ; Interrupt Flags\n.equ PORTA_PIN0CTRL = 0x0410             ; Pin 0 Control\n.equ PORTA_PIN1CTRL = 0x0411             ; Pin 1 Control\n.equ PORTA_PIN2CTRL = 0x0412             ; Pin 2 Control\n.equ PORTA_PIN3CTRL = 0x0413             ; Pin 3 Control\n.equ PORTA_PIN4CTRL = 0x0414             ; Pin 4 Control\n.equ PORTA_PIN5CTRL = 0x0415             ; Pin 5 Control\n.equ PORTA_PIN6CTRL = 0x0416             ; Pin 6 Control\n.equ PORTA_PIN7CTRL = 0x0417             ; Pin 7 Control\n\n;*************************************************************************\n;** PORTB - I/O Ports\n;*************************************************************************\n\n.equ PORTB_DIR = 0x0420                  ; Data Direction\n.equ PORTB_DIRSET = 0x0421               ; Data Direction Set\n.equ PORTB_DIRCLR = 0x0422               ; Data Direction Clear\n.equ PORTB_DIRTGL = 0x0423               ; Data Direction Toggle\n.equ PORTB_OUT = 0x0424                  ; Output Value\n.equ PORTB_OUTSET = 0x0425               ; Output Value Set\n.equ PORTB_OUTCLR = 0x0426               ; Output Value Clear\n.equ PORTB_OUTTGL = 0x0427               ; Output Value Toggle\n.equ PORTB_IN = 0x0428                   ; Input Value\n.equ PORTB_INTFLAGS = 0x0429             ; Interrupt Flags\n.equ PORTB_PIN0CTRL = 0x0430             ; Pin 0 Control\n.equ PORTB_PIN1CTRL = 0x0431             ; Pin 1 Control\n.equ PORTB_PIN2CTRL = 0x0432             ; Pin 2 Control\n.equ PORTB_PIN3CTRL = 0x0433             ; Pin 3 Control\n.equ PORTB_PIN4CTRL = 0x0434             ; Pin 4 Control\n.equ PORTB_PIN5CTRL = 0x0435             ; Pin 5 Control\n.equ PORTB_PIN6CTRL = 0x0436             ; Pin 6 Control\n.equ PORTB_PIN7CTRL = 0x0437             ; Pin 7 Control\n\n;*************************************************************************\n;** PORTMUX - Port Multiplexer\n;*************************************************************************\n\n.equ PORTMUX_CTRLA = 0x0200              ; Port Multiplexer Control A\n.equ PORTMUX_CTRLB = 0x0201              ; Port Multiplexer Control B\n.equ PORTMUX_CTRLC = 0x0202              ; Port Multiplexer Control C\n.equ PORTMUX_CTRLD = 0x0203              ; Port Multiplexer Control D\n\n;*************************************************************************\n;** RSTCTRL - Reset controller\n;*************************************************************************\n\n.equ RSTCTRL_RSTFR = 0x0040              ; Reset Flags\n.equ RSTCTRL_SWRR = 0x0041               ; Software Reset\n\n;*************************************************************************\n;** RTC - Real-Time Counter\n;*************************************************************************\n\n.equ RTC_CTRLA = 0x0140                  ; Control A\n.equ RTC_STATUS = 0x0141                 ; Status\n.equ RTC_INTCTRL = 0x0142                ; Interrupt Control\n.equ RTC_INTFLAGS = 0x0143               ; Interrupt Flags\n.equ RTC_TEMP = 0x0144                   ; Temporary\n.equ RTC_DBGCTRL = 0x0145                ; Debug control\n.equ RTC_CLKSEL = 0x0147                 ; Clock Select\n.equ RTC_CNT = 0x0148                    ; Counter\n.equ RTC_CNTL = 0x0148                   ; Counter low byte\n.equ RTC_CNTH = 0x0149                   ; Counter hi byte\n.equ RTC_PER = 0x014A                    ; Period\n.equ RTC_PERL = 0x014A                   ; Period low byte\n.equ RTC_PERH = 0x014B                   ; Period hi byte\n.equ RTC_CMP = 0x014C                    ; Compare\n.equ RTC_CMPL = 0x014C                   ; Compare low byte\n.equ RTC_CMPH = 0x014D                   ; Compare hi byte\n.equ RTC_PITCTRLA = 0x0150               ; PIT Control A\n.equ RTC_PITSTATUS = 0x0151              ; PIT Status\n.equ RTC_PITINTCTRL = 0x0152             ; PIT Interrupt Control\n.equ RTC_PITINTFLAGS = 0x0153            ; PIT Interrupt Flags\n.equ RTC_PITDBGCTRL = 0x0155             ; PIT Debug control\n\n;*************************************************************************\n;** SIGROW - Signature row\n;*************************************************************************\n\n.equ SIGROW_DEVICEID0 = 0x1100           ; Device ID Byte 0\n.equ SIGROW_DEVICEID1 = 0x1101           ; Device ID Byte 1\n.equ SIGROW_DEVICEID2 = 0x1102           ; Device ID Byte 2\n.equ SIGROW_SERNUM0 = 0x1103             ; Serial Number Byte 0\n.equ SIGROW_SERNUM1 = 0x1104             ; Serial Number Byte 1\n.equ SIGROW_SERNUM2 = 0x1105             ; Serial Number Byte 2\n.equ SIGROW_SERNUM3 = 0x1106             ; Serial Number Byte 3\n.equ SIGROW_SERNUM4 = 0x1107             ; Serial Number Byte 4\n.equ SIGROW_SERNUM5 = 0x1108             ; Serial Number Byte 5\n.equ SIGROW_SERNUM6 = 0x1109             ; Serial Number Byte 6\n.equ SIGROW_SERNUM7 = 0x110A             ; Serial Number Byte 7\n.equ SIGROW_SERNUM8 = 0x110B             ; Serial Number Byte 8\n.equ SIGROW_SERNUM9 = 0x110C             ; Serial Number Byte 9\n.equ SIGROW_TEMPSENSE0 = 0x1120          ; Temperature Sensor Calibration Byte 0\n.equ SIGROW_TEMPSENSE1 = 0x1121          ; Temperature Sensor Calibration Byte 1\n.equ SIGROW_OSC16ERR3V = 0x1122          ; OSC16 error at 3V\n.equ SIGROW_OSC16ERR5V = 0x1123          ; OSC16 error at 5V\n.equ SIGROW_OSC20ERR3V = 0x1124          ; OSC20 error at 3V\n.equ SIGROW_OSC20ERR5V = 0x1125          ; OSC20 error at 5V\n\n;*************************************************************************\n;** SLPCTRL - Sleep Controller\n;*************************************************************************\n\n.equ SLPCTRL_CTRLA = 0x0050              ; Control\n\n;*************************************************************************\n;** SPI0 - Serial Peripheral Interface\n;*************************************************************************\n\n.equ SPI0_CTRLA = 0x0820                 ; Control A\n.equ SPI0_CTRLB = 0x0821                 ; Control B\n.equ SPI0_INTCTRL = 0x0822               ; Interrupt Control\n.equ SPI0_INTFLAGS = 0x0823              ; Interrupt Flags\n.equ SPI0_DATA = 0x0824                  ; Data\n\n;*************************************************************************\n;** SYSCFG - System Configuration Registers\n;*************************************************************************\n\n.equ SYSCFG_REVID = 0x0F01               ; Revision ID\n.equ SYSCFG_EXTBRK = 0x0F02              ; External Break\n\n;*************************************************************************\n;** TCA0 - 16-bit Timer/Counter Type A\n;*************************************************************************\n\n.equ TCA0_SINGLE_CTRLA = 0x0A00          ; SINGLE Control A\n.equ TCA0_SINGLE_CTRLB = 0x0A01          ; SINGLE Control B\n.equ TCA0_SINGLE_CTRLC = 0x0A02          ; SINGLE Control C\n.equ TCA0_SINGLE_CTRLD = 0x0A03          ; SINGLE Control D\n.equ TCA0_SINGLE_CTRLECLR = 0x0A04       ; SINGLE Control E Clear\n.equ TCA0_SINGLE_CTRLESET = 0x0A05       ; SINGLE Control E Set\n.equ TCA0_SINGLE_CTRLFCLR = 0x0A06       ; SINGLE Control F Clear\n.equ TCA0_SINGLE_CTRLFSET = 0x0A07       ; SINGLE Control F Set\n.equ TCA0_SINGLE_EVCTRL = 0x0A09         ; SINGLE Event Control\n.equ TCA0_SINGLE_INTCTRL = 0x0A0A        ; SINGLE Interrupt Control\n.equ TCA0_SINGLE_INTFLAGS = 0x0A0B       ; SINGLE Interrupt Flags\n.equ TCA0_SINGLE_DBGCTRL = 0x0A0E        ; SINGLE Degbug Control\n.equ TCA0_SINGLE_TEMP = 0x0A0F           ; SINGLE Temporary data for 16-bit Access\n.equ TCA0_SINGLE_CNT = 0x0A20            ; SINGLE Count\n.equ TCA0_SINGLE_PER = 0x0A26            ; SINGLE Period\n.equ TCA0_SINGLE_CMP0 = 0x0A28           ; SINGLE Compare 0\n.equ TCA0_SINGLE_CMP1 = 0x0A2A           ; SINGLE Compare 1\n.equ TCA0_SINGLE_CMP2 = 0x0A2C           ; SINGLE Compare 2\n.equ TCA0_SINGLE_PERBUF = 0x0A36         ; SINGLE Period Buffer\n.equ TCA0_SINGLE_CMP0BUF = 0x0A38        ; SINGLE Compare 0 Buffer\n.equ TCA0_SINGLE_CMP1BUF = 0x0A3A        ; SINGLE Compare 1 Buffer\n.equ TCA0_SINGLE_CMP2BUF = 0x0A3C        ; SINGLE Compare 2 Buffer\n.equ TCA0_SPLIT_CTRLA = 0x0A00           ; SPLIT Control A\n.equ TCA0_SPLIT_CTRLB = 0x0A01           ; SPLIT Control B\n.equ TCA0_SPLIT_CTRLC = 0x0A02           ; SPLIT Control C\n.equ TCA0_SPLIT_CTRLD = 0x0A03           ; SPLIT Control D\n.equ TCA0_SPLIT_CTRLECLR = 0x0A04        ; SPLIT Control E Clear\n.equ TCA0_SPLIT_CTRLESET = 0x0A05        ; SPLIT Control E Set\n.equ TCA0_SPLIT_INTCTRL = 0x0A0A         ; SPLIT Interrupt Control\n.equ TCA0_SPLIT_INTFLAGS = 0x0A0B        ; SPLIT Interrupt Flags\n.equ TCA0_SPLIT_DBGCTRL = 0x0A0E         ; SPLIT Degbug Control\n.equ TCA0_SPLIT_LCNT = 0x0A20            ; SPLIT Low Count\n.equ TCA0_SPLIT_HCNT = 0x0A21            ; SPLIT High Count\n.equ TCA0_SPLIT_LPER = 0x0A26            ; SPLIT Low Period\n.equ TCA0_SPLIT_HPER = 0x0A27            ; SPLIT High Period\n.equ TCA0_SPLIT_LCMP0 = 0x0A28           ; SPLIT Low Compare\n.equ TCA0_SPLIT_HCMP0 = 0x0A29           ; SPLIT High Compare\n.equ TCA0_SPLIT_LCMP1 = 0x0A2A           ; SPLIT Low Compare\n.equ TCA0_SPLIT_HCMP1 = 0x0A2B           ; SPLIT High Compare\n.equ TCA0_SPLIT_LCMP2 = 0x0A2C           ; SPLIT Low Compare\n.equ TCA0_SPLIT_HCMP2 = 0x0A2D           ; SPLIT High Compare\n\n;*************************************************************************\n;** TCB0 - 16-bit Timer Type B\n;*************************************************************************\n\n.equ TCB0_CTRLA = 0x0A40                 ; Control A\n.equ TCB0_CTRLB = 0x0A41                 ; Control Register B\n.equ TCB0_EVCTRL = 0x0A44                ; Event Control\n.equ TCB0_INTCTRL = 0x0A45               ; Interrupt Control\n.equ TCB0_INTFLAGS = 0x0A46              ; Interrupt Flags\n.equ TCB0_STATUS = 0x0A47                ; Status\n.equ TCB0_DBGCTRL = 0x0A48               ; Debug Control\n.equ TCB0_TEMP = 0x0A49                  ; Temporary Value\n.equ TCB0_CNT = 0x0A4A                   ; Count\n.equ TCB0_CNTL = 0x0A4A                  ; Count low byte\n.equ TCB0_CNTH = 0x0A4B                  ; Count hi byte\n.equ TCB0_CCMP = 0x0A4C                  ; Compare or Capture\n.equ TCB0_CCMPL = 0x0A4C                 ; Compare or Capture low byte\n.equ TCB0_CCMPH = 0x0A4D                 ; Compare or Capture hi byte\n\n;*************************************************************************\n;** TCB1 - 16-bit Timer Type B\n;*************************************************************************\n\n.equ TCB1_CTRLA = 0x0A50                 ; Control A\n.equ TCB1_CTRLB = 0x0A51                 ; Control Register B\n.equ TCB1_EVCTRL = 0x0A54                ; Event Control\n.equ TCB1_INTCTRL = 0x0A55               ; Interrupt Control\n.equ TCB1_INTFLAGS = 0x0A56              ; Interrupt Flags\n.equ TCB1_STATUS = 0x0A57                ; Status\n.equ TCB1_DBGCTRL = 0x0A58               ; Debug Control\n.equ TCB1_TEMP = 0x0A59                  ; Temporary Value\n.equ TCB1_CNT = 0x0A5A                   ; Count\n.equ TCB1_CNTL = 0x0A5A                  ; Count low byte\n.equ TCB1_CNTH = 0x0A5B                  ; Count hi byte\n.equ TCB1_CCMP = 0x0A5C                  ; Compare or Capture\n.equ TCB1_CCMPL = 0x0A5C                 ; Compare or Capture low byte\n.equ TCB1_CCMPH = 0x0A5D                 ; Compare or Capture hi byte\n\n;*************************************************************************\n;** TCD0 - Timer Counter D\n;*************************************************************************\n\n.equ TCD0_CTRLA = 0x0A80                 ; Control A\n.equ TCD0_CTRLB = 0x0A81                 ; Control B\n.equ TCD0_CTRLC = 0x0A82                 ; Control C\n.equ TCD0_CTRLD = 0x0A83                 ; Control D\n.equ TCD0_CTRLE = 0x0A84                 ; Control E\n.equ TCD0_EVCTRLA = 0x0A88               ; EVCTRLA\n.equ TCD0_EVCTRLB = 0x0A89               ; EVCTRLB\n.equ TCD0_INTCTRL = 0x0A8C               ; Interrupt Control\n.equ TCD0_INTFLAGS = 0x0A8D              ; Interrupt Flags\n.equ TCD0_STATUS = 0x0A8E                ; Status\n.equ TCD0_INPUTCTRLA = 0x0A90            ; Input Control A\n.equ TCD0_INPUTCTRLB = 0x0A91            ; Input Control B\n.equ TCD0_FAULTCTRL = 0x0A92             ; Fault Control\n.equ TCD0_DLYCTRL = 0x0A94               ; Delay Control\n.equ TCD0_DLYVAL = 0x0A95                ; Delay value\n.equ TCD0_DITCTRL = 0x0A98               ; Dither Control A\n.equ TCD0_DITVAL = 0x0A99                ; Dither value\n.equ TCD0_DBGCTRL = 0x0A9E               ; Debug Control\n.equ TCD0_CAPTUREA = 0x0AA2              ; Capture A\n.equ TCD0_CAPTUREAL = 0x0AA2             ; Capture A low byte\n.equ TCD0_CAPTUREAH = 0x0AA3             ; Capture A hi byte\n.equ TCD0_CAPTUREB = 0x0AA4              ; Capture B\n.equ TCD0_CAPTUREBL = 0x0AA4             ; Capture B low byte\n.equ TCD0_CAPTUREBH = 0x0AA5             ; Capture B hi byte\n.equ TCD0_CMPASET = 0x0AA8               ; Compare A Set\n.equ TCD0_CMPASETL = 0x0AA8              ; Compare A Set low byte\n.equ TCD0_CMPASETH = 0x0AA9              ; Compare A Set hi byte\n.equ TCD0_CMPACLR = 0x0AAA               ; Compare A Clear\n.equ TCD0_CMPACLRL = 0x0AAA              ; Compare A Clear low byte\n.equ TCD0_CMPACLRH = 0x0AAB              ; Compare A Clear hi byte\n.equ TCD0_CMPBSET = 0x0AAC               ; Compare B Set\n.equ TCD0_CMPBSETL = 0x0AAC              ; Compare B Set low byte\n.equ TCD0_CMPBSETH = 0x0AAD              ; Compare B Set hi byte\n.equ TCD0_CMPBCLR = 0x0AAE               ; Compare B Clear\n.equ TCD0_CMPBCLRL = 0x0AAE              ; Compare B Clear low byte\n.equ TCD0_CMPBCLRH = 0x0AAF              ; Compare B Clear hi byte\n\n;*************************************************************************\n;** TWI0 - Two-Wire Interface\n;*************************************************************************\n\n.equ TWI0_CTRLA = 0x0810                 ; Control A\n.equ TWI0_DBGCTRL = 0x0812               ; Debug Control Register\n.equ TWI0_MCTRLA = 0x0813                ; Master Control A\n.equ TWI0_MCTRLB = 0x0814                ; Master Control B\n.equ TWI0_MSTATUS = 0x0815               ; Master Status\n.equ TWI0_MBAUD = 0x0816                 ; Master Baurd Rate Control\n.equ TWI0_MADDR = 0x0817                 ; Master Address\n.equ TWI0_MDATA = 0x0818                 ; Master Data\n.equ TWI0_SCTRLA = 0x0819                ; Slave Control A\n.equ TWI0_SCTRLB = 0x081A                ; Slave Control B\n.equ TWI0_SSTATUS = 0x081B               ; Slave Status\n.equ TWI0_SADDR = 0x081C                 ; Slave Address\n.equ TWI0_SDATA = 0x081D                 ; Slave Data\n.equ TWI0_SADDRMASK = 0x081E             ; Slave Address Mask\n\n;*************************************************************************\n;** USART0 - Universal Synchronous and Asynchronous Receiver and Transmitter\n;*************************************************************************\n\n.equ USART0_RXDATAL = 0x0800             ; Receive Data Low Byte\n.equ USART0_RXDATAH = 0x0801             ; Receive Data High Byte\n.equ USART0_TXDATAL = 0x0802             ; Transmit Data Low Byte\n.equ USART0_TXDATAH = 0x0803             ; Transmit Data High Byte\n.equ USART0_STATUS = 0x0804              ; Status\n.equ USART0_CTRLA = 0x0805               ; Control A\n.equ USART0_CTRLB = 0x0806               ; Control B\n.equ USART0_CTRLC = 0x0807               ; Control C\n.equ USART0_BAUD = 0x0808                ; Baud Rate\n.equ USART0_BAUDL = 0x0808               ; Baud Rate low byte\n.equ USART0_BAUDH = 0x0809               ; Baud Rate hi byte\n.equ USART0_DBGCTRL = 0x080B             ; Debug Control\n.equ USART0_EVCTRL = 0x080C              ; Event Control\n.equ USART0_TXPLCTRL = 0x080D            ; IRCOM Transmitter Pulse Length Control\n.equ USART0_RXPLCTRL = 0x080E            ; IRCOM Receiver Pulse Length Control\n\n;*************************************************************************\n;** USERROW - User Row\n;*************************************************************************\n\n.equ USERROW_USERROW0 = 0x1300           ; User Row Byte 0\n.equ USERROW_USERROW1 = 0x1301           ; User Row Byte 1\n.equ USERROW_USERROW2 = 0x1302           ; User Row Byte 2\n.equ USERROW_USERROW3 = 0x1303           ; User Row Byte 3\n.equ USERROW_USERROW4 = 0x1304           ; User Row Byte 4\n.equ USERROW_USERROW5 = 0x1305           ; User Row Byte 5\n.equ USERROW_USERROW6 = 0x1306           ; User Row Byte 6\n.equ USERROW_USERROW7 = 0x1307           ; User Row Byte 7\n.equ USERROW_USERROW8 = 0x1308           ; User Row Byte 8\n.equ USERROW_USERROW9 = 0x1309           ; User Row Byte 9\n.equ USERROW_USERROW10 = 0x130A          ; User Row Byte 10\n.equ USERROW_USERROW11 = 0x130B          ; User Row Byte 11\n.equ USERROW_USERROW12 = 0x130C          ; User Row Byte 12\n.equ USERROW_USERROW13 = 0x130D          ; User Row Byte 13\n.equ USERROW_USERROW14 = 0x130E          ; User Row Byte 14\n.equ USERROW_USERROW15 = 0x130F          ; User Row Byte 15\n.equ USERROW_USERROW16 = 0x1310          ; User Row Byte 16\n.equ USERROW_USERROW17 = 0x1311          ; User Row Byte 17\n.equ USERROW_USERROW18 = 0x1312          ; User Row Byte 18\n.equ USERROW_USERROW19 = 0x1313          ; User Row Byte 19\n.equ USERROW_USERROW20 = 0x1314          ; User Row Byte 20\n.equ USERROW_USERROW21 = 0x1315          ; User Row Byte 21\n.equ USERROW_USERROW22 = 0x1316          ; User Row Byte 22\n.equ USERROW_USERROW23 = 0x1317          ; User Row Byte 23\n.equ USERROW_USERROW24 = 0x1318          ; User Row Byte 24\n.equ USERROW_USERROW25 = 0x1319          ; User Row Byte 25\n.equ USERROW_USERROW26 = 0x131A          ; User Row Byte 26\n.equ USERROW_USERROW27 = 0x131B          ; User Row Byte 27\n.equ USERROW_USERROW28 = 0x131C          ; User Row Byte 28\n.equ USERROW_USERROW29 = 0x131D          ; User Row Byte 29\n.equ USERROW_USERROW30 = 0x131E          ; User Row Byte 30\n.equ USERROW_USERROW31 = 0x131F          ; User Row Byte 31\n\n;*************************************************************************\n;** VPORTA - Virtual Ports\n;*************************************************************************\n\n.equ VPORTA_DIR = 0x0000                 ; Data Direction\n.equ VPORTA_OUT = 0x0001                 ; Output Value\n.equ VPORTA_IN = 0x0002                  ; Input Value\n.equ VPORTA_INTFLAGS = 0x0003            ; Interrupt Flags\n\n;*************************************************************************\n;** VPORTB - Virtual Ports\n;*************************************************************************\n\n.equ VPORTB_DIR = 0x0004                 ; Data Direction\n.equ VPORTB_OUT = 0x0005                 ; Output Value\n.equ VPORTB_IN = 0x0006                  ; Input Value\n.equ VPORTB_INTFLAGS = 0x0007            ; Interrupt Flags\n\n;*************************************************************************\n;** VPORTC - Virtual Ports\n;*************************************************************************\n\n.equ VPORTC_DIR = 0x0008                 ; Data Direction\n.equ VPORTC_OUT = 0x0009                 ; Output Value\n.equ VPORTC_IN = 0x000A                  ; Input Value\n.equ VPORTC_INTFLAGS = 0x000B            ; Interrupt Flags\n\n;*************************************************************************\n;** VREF - Voltage reference\n;*************************************************************************\n\n.equ VREF_CTRLA = 0x00A0                 ; Control A\n.equ VREF_CTRLB = 0x00A1                 ; Control B\n.equ VREF_CTRLC = 0x00A2                 ; Control C\n.equ VREF_CTRLD = 0x00A3                 ; Control D\n\n;*************************************************************************\n;** WDT - Watch-Dog Timer\n;*************************************************************************\n\n.equ WDT_CTRLA = 0x0100                  ; Control A\n.equ WDT_STATUS = 0x0101                 ; Status\n\n\n; ***** ALL MODULE BASE ADRESSES *****************************************\n\n.equ AC0_base = 0x0680                   ; Analog Comparator\n.equ AC1_base = 0x0688                   ; Analog Comparator\n.equ AC2_base = 0x0690                   ; Analog Comparator\n.equ ADC0_base = 0x0600                  ; Analog to Digital Converter\n.equ ADC1_base = 0x0640                  ; Analog to Digital Converter\n.equ BOD_base = 0x0080                   ; Bod interface\n.equ CCL_base = 0x01C0                   ; Configurable Custom Logic\n.equ CLKCTRL_base = 0x0060               ; Clock controller\n.equ CPU_base = 0x0030                   ; CPU\n.equ CPUINT_base = 0x0110                ; Interrupt Controller\n.equ CRCSCAN_base = 0x0120               ; CRCSCAN\n.equ DAC0_base = 0x06A0                  ; Digital to Analog Converter\n.equ DAC1_base = 0x06A8                  ; Digital to Analog Converter\n.equ DAC2_base = 0x06B0                  ; Digital to Analog Converter\n.equ EVSYS_base = 0x0180                 ; Event System\n.equ FUSE_base = 0x1280                  ; Fuses\n.equ GPIO_base = 0x001C                  ; General Purpose IO\n.equ LOCKBIT_base = 0x128A               ; Lockbit\n.equ NVMCTRL_base = 0x1000               ; Non-volatile Memory Controller\n.equ PORTA_base = 0x0400                 ; I/O Ports\n.equ PORTB_base = 0x0420                 ; I/O Ports\n.equ PORTMUX_base = 0x0200               ; Port Multiplexer\n.equ RSTCTRL_base = 0x0040               ; Reset controller\n.equ RTC_base = 0x0140                   ; Real-Time Counter\n.equ SIGROW_base = 0x1100                ; Signature row\n.equ SLPCTRL_base = 0x0050               ; Sleep Controller\n.equ SPI0_base = 0x0820                  ; Serial Peripheral Interface\n.equ SYSCFG_base = 0x0F00                ; System Configuration Registers\n.equ TCA0_base = 0x0A00                  ; 16-bit Timer/Counter Type A\n.equ TCB0_base = 0x0A40                  ; 16-bit Timer Type B\n.equ TCB1_base = 0x0A50                  ; 16-bit Timer Type B\n.equ TCD0_base = 0x0A80                  ; Timer Counter D\n.equ TWI0_base = 0x0810                  ; Two-Wire Interface\n.equ USART0_base = 0x0800                ; Universal Synchronous and Asynchronous Receiver and Transmitter\n.equ USERROW_base = 0x1300               ; User Row\n.equ VPORTA_base = 0x0000                ; Virtual Ports\n.equ VPORTB_base = 0x0004                ; Virtual Ports\n.equ VPORTC_base = 0x0008                ; Virtual Ports\n.equ VREF_base = 0x00A0                  ; Voltage reference\n.equ WDT_base = 0x0100                   ; Watch-Dog Timer\n\n\n; ***** IO REGISTER OFFSETS **********************************************\n\n\n;*************************************************************************\n;** AC - Analog Comparator\n;*************************************************************************\n.equ AC_CTRLA_offset = 0x00              ; Control A\n.equ AC_MUXCTRLA_offset = 0x02           ; Mux Control A\n.equ AC_INTCTRL_offset = 0x06            ; Interrupt Control\n.equ AC_STATUS_offset = 0x07             ; Status\n\n;*************************************************************************\n;** ADC - Analog to Digital Converter\n;*************************************************************************\n.equ ADC_CTRLA_offset = 0x00             ; Control A\n.equ ADC_CTRLB_offset = 0x01             ; Control B\n.equ ADC_CTRLC_offset = 0x02             ; Control C\n.equ ADC_CTRLD_offset = 0x03             ; Control D\n.equ ADC_CTRLE_offset = 0x04             ; Control E\n.equ ADC_SAMPCTRL_offset = 0x05          ; Sample Control\n.equ ADC_MUXPOS_offset = 0x06            ; Positive mux input\n.equ ADC_COMMAND_offset = 0x08           ; Command\n.equ ADC_EVCTRL_offset = 0x09            ; Event Control\n.equ ADC_INTCTRL_offset = 0x0A           ; Interrupt Control\n.equ ADC_INTFLAGS_offset = 0x0B          ; Interrupt Flags\n.equ ADC_DBGCTRL_offset = 0x0C           ; Debug Control\n.equ ADC_TEMP_offset = 0x0D              ; Temporary Data\n.equ ADC_RES_offset = 0x10               ; ADC Accumulator Result\n.equ ADC_WINLT_offset = 0x12             ; Window comparator low threshold\n.equ ADC_WINHT_offset = 0x14             ; Window comparator high threshold\n.equ ADC_CALIB_offset = 0x16             ; Calibration\n\n;*************************************************************************\n;** BOD - Bod interface\n;*************************************************************************\n.equ BOD_CTRLA_offset = 0x00             ; Control A\n.equ BOD_CTRLB_offset = 0x01             ; Control B\n.equ BOD_VLMCTRLA_offset = 0x08          ; Voltage level monitor Control\n.equ BOD_INTCTRL_offset = 0x09           ; Voltage level monitor interrupt Control\n.equ BOD_INTFLAGS_offset = 0x0A          ; Voltage level monitor interrupt Flags\n.equ BOD_STATUS_offset = 0x0B            ; Voltage level monitor status\n\n;*************************************************************************\n;** CCL - Configurable Custom Logic\n;*************************************************************************\n.equ CCL_CTRLA_offset = 0x00             ; Control Register A\n.equ CCL_SEQCTRL0_offset = 0x01          ; Sequential Control 0\n.equ CCL_LUT0CTRLA_offset = 0x05         ; LUT Control 0 A\n.equ CCL_LUT0CTRLB_offset = 0x06         ; LUT Control 0 B\n.equ CCL_LUT0CTRLC_offset = 0x07         ; LUT Control 0 C\n.equ CCL_TRUTH0_offset = 0x08            ; Truth 0\n.equ CCL_LUT1CTRLA_offset = 0x09         ; LUT Control 1 A\n.equ CCL_LUT1CTRLB_offset = 0x0A         ; LUT Control 1 B\n.equ CCL_LUT1CTRLC_offset = 0x0B         ; LUT Control 1 C\n.equ CCL_TRUTH1_offset = 0x0C            ; Truth 1\n\n;*************************************************************************\n;** CLKCTRL - Clock controller\n;*************************************************************************\n.equ CLKCTRL_MCLKCTRLA_offset = 0x00     ; MCLK Control A\n.equ CLKCTRL_MCLKCTRLB_offset = 0x01     ; MCLK Control B\n.equ CLKCTRL_MCLKLOCK_offset = 0x02      ; MCLK Lock\n.equ CLKCTRL_MCLKSTATUS_offset = 0x03    ; MCLK Status\n.equ CLKCTRL_OSC20MCTRLA_offset = 0x10   ; OSC20M Control A\n.equ CLKCTRL_OSC20MCALIBA_offset = 0x11  ; OSC20M Calibration A\n.equ CLKCTRL_OSC20MCALIBB_offset = 0x12  ; OSC20M Calibration B\n.equ CLKCTRL_OSC32KCTRLA_offset = 0x18   ; OSC32K Control A\n.equ CLKCTRL_XOSC32KCTRLA_offset = 0x1C  ; XOSC32K Control A\n\n;*************************************************************************\n;** CPU - CPU\n;*************************************************************************\n.equ CPU_CCP_offset = 0x04               ; Configuration Change Protection\n.equ CPU_SPL_offset = 0x0D               ; Stack Pointer Low\n.equ CPU_SPH_offset = 0x0E               ; Stack Pointer High\n.equ CPU_SREG_offset = 0x0F              ; Status Register\n\n;*************************************************************************\n;** CPUINT - Interrupt Controller\n;*************************************************************************\n.equ CPUINT_CTRLA_offset = 0x00          ; Control A\n.equ CPUINT_STATUS_offset = 0x01         ; Status\n.equ CPUINT_LVL0PRI_offset = 0x02        ; Interrupt Level 0 Priority\n.equ CPUINT_LVL1VEC_offset = 0x03        ; Interrupt Level 1 Priority Vector\n\n;*************************************************************************\n;** CRCSCAN - CRCSCAN\n;*************************************************************************\n.equ CRCSCAN_CTRLA_offset = 0x00         ; Control A\n.equ CRCSCAN_CTRLB_offset = 0x01         ; Control B\n.equ CRCSCAN_STATUS_offset = 0x02        ; Status\n\n;*************************************************************************\n;** DAC - Digital to Analog Converter\n;*************************************************************************\n.equ DAC_CTRLA_offset = 0x00             ; Control Register A\n.equ DAC_DATA_offset = 0x01              ; DATA Register\n\n;*************************************************************************\n;** EVSYS - Event System\n;*************************************************************************\n.equ EVSYS_ASYNCSTROBE_offset = 0x00     ; Asynchronous Channel Strobe\n.equ EVSYS_SYNCSTROBE_offset = 0x01      ; Synchronous Channel Strobe\n.equ EVSYS_ASYNCCH0_offset = 0x02        ; Asynchronous Channel 0 Generator Selection\n.equ EVSYS_ASYNCCH1_offset = 0x03        ; Asynchronous Channel 1 Generator Selection\n.equ EVSYS_ASYNCCH2_offset = 0x04        ; Asynchronous Channel 2 Generator Selection\n.equ EVSYS_ASYNCCH3_offset = 0x05        ; Asynchronous Channel 3 Generator Selection\n.equ EVSYS_SYNCCH0_offset = 0x0A         ; Synchronous Channel 0 Generator Selection\n.equ EVSYS_SYNCCH1_offset = 0x0B         ; Synchronous Channel 1 Generator Selection\n.equ EVSYS_ASYNCUSER0_offset = 0x12      ; Asynchronous User Ch 0 Input Selection - TCB0\n.equ EVSYS_ASYNCUSER1_offset = 0x13      ; Asynchronous User Ch 1 Input Selection - ADC0\n.equ EVSYS_ASYNCUSER2_offset = 0x14      ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0\n.equ EVSYS_ASYNCUSER3_offset = 0x15      ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0\n.equ EVSYS_ASYNCUSER4_offset = 0x16      ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1\n.equ EVSYS_ASYNCUSER5_offset = 0x17      ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1\n.equ EVSYS_ASYNCUSER6_offset = 0x18      ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0\n.equ EVSYS_ASYNCUSER7_offset = 0x19      ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1\n.equ EVSYS_ASYNCUSER8_offset = 0x1A      ; Asynchronous User Ch 8 Input Selection - Event Out 0\n.equ EVSYS_ASYNCUSER9_offset = 0x1B      ; Asynchronous User Ch 9 Input Selection - Event Out 1\n.equ EVSYS_ASYNCUSER10_offset = 0x1C     ; Asynchronous User Ch 10 Input Selection - Event Out 2\n.equ EVSYS_ASYNCUSER11_offset = 0x1D     ; Asynchronous User Ch 11 Input Selection - TCB1\n.equ EVSYS_ASYNCUSER12_offset = 0x1E     ; Asynchronous User Ch 12 Input Selection - ADC1\n.equ EVSYS_SYNCUSER0_offset = 0x22       ; Synchronous User Ch 0 - TCA0\n.equ EVSYS_SYNCUSER1_offset = 0x23       ; Synchronous User Ch 1 - USART0\n\n;*************************************************************************\n;** FUSE - Fuses\n;*************************************************************************\n.equ FUSE_WDTCFG_offset = 0x00           ; Watchdog Configuration\n.equ FUSE_BODCFG_offset = 0x01           ; BOD Configuration\n.equ FUSE_OSCCFG_offset = 0x02           ; Oscillator Configuration\n.equ FUSE_TCD0CFG_offset = 0x04          ; TCD0 Configuration\n.equ FUSE_SYSCFG0_offset = 0x05          ; System Configuration 0\n.equ FUSE_SYSCFG1_offset = 0x06          ; System Configuration 1\n.equ FUSE_APPEND_offset = 0x07           ; Application Code Section End\n.equ FUSE_BOOTEND_offset = 0x08          ; Boot Section End\n\n;*************************************************************************\n;** GPIO - General Purpose IO\n;*************************************************************************\n.equ GPIO_GPIOR0_offset = 0x00           ; General Purpose IO Register 0\n.equ GPIO_GPIOR1_offset = 0x01           ; General Purpose IO Register 1\n.equ GPIO_GPIOR2_offset = 0x02           ; General Purpose IO Register 2\n.equ GPIO_GPIOR3_offset = 0x03           ; General Purpose IO Register 3\n\n;*************************************************************************\n;** LOCKBIT - Lockbit\n;*************************************************************************\n.equ LOCKBIT_LOCKBIT_offset = 0x00       ; Lock bits\n\n;*************************************************************************\n;** NVMCTRL - Non-volatile Memory Controller\n;*************************************************************************\n.equ NVMCTRL_CTRLA_offset = 0x00         ; Control A\n.equ NVMCTRL_CTRLB_offset = 0x01         ; Control B\n.equ NVMCTRL_STATUS_offset = 0x02        ; Status\n.equ NVMCTRL_INTCTRL_offset = 0x03       ; Interrupt Control\n.equ NVMCTRL_INTFLAGS_offset = 0x04      ; Interrupt Flags\n.equ NVMCTRL_DATA_offset = 0x06          ; Data\n.equ NVMCTRL_ADDR_offset = 0x08          ; Address\n\n;*************************************************************************\n;** PORT - I/O Ports\n;*************************************************************************\n.equ PORT_DIR_offset = 0x00              ; Data Direction\n.equ PORT_DIRSET_offset = 0x01           ; Data Direction Set\n.equ PORT_DIRCLR_offset = 0x02           ; Data Direction Clear\n.equ PORT_DIRTGL_offset = 0x03           ; Data Direction Toggle\n.equ PORT_OUT_offset = 0x04              ; Output Value\n.equ PORT_OUTSET_offset = 0x05           ; Output Value Set\n.equ PORT_OUTCLR_offset = 0x06           ; Output Value Clear\n.equ PORT_OUTTGL_offset = 0x07           ; Output Value Toggle\n.equ PORT_IN_offset = 0x08               ; Input Value\n.equ PORT_INTFLAGS_offset = 0x09         ; Interrupt Flags\n.equ PORT_PIN0CTRL_offset = 0x10         ; Pin 0 Control\n.equ PORT_PIN1CTRL_offset = 0x11         ; Pin 1 Control\n.equ PORT_PIN2CTRL_offset = 0x12         ; Pin 2 Control\n.equ PORT_PIN3CTRL_offset = 0x13         ; Pin 3 Control\n.equ PORT_PIN4CTRL_offset = 0x14         ; Pin 4 Control\n.equ PORT_PIN5CTRL_offset = 0x15         ; Pin 5 Control\n.equ PORT_PIN6CTRL_offset = 0x16         ; Pin 6 Control\n.equ PORT_PIN7CTRL_offset = 0x17         ; Pin 7 Control\n\n;*************************************************************************\n;** PORTMUX - Port Multiplexer\n;*************************************************************************\n.equ PORTMUX_CTRLA_offset = 0x00         ; Port Multiplexer Control A\n.equ PORTMUX_CTRLB_offset = 0x01         ; Port Multiplexer Control B\n.equ PORTMUX_CTRLC_offset = 0x02         ; Port Multiplexer Control C\n.equ PORTMUX_CTRLD_offset = 0x03         ; Port Multiplexer Control D\n\n;*************************************************************************\n;** PTC - Peripherial Touch Controller\n;*************************************************************************\n\n;*************************************************************************\n;** RSTCTRL - Reset controller\n;*************************************************************************\n.equ RSTCTRL_RSTFR_offset = 0x00         ; Reset Flags\n.equ RSTCTRL_SWRR_offset = 0x01          ; Software Reset\n\n;*************************************************************************\n;** RTC - Real-Time Counter\n;*************************************************************************\n.equ RTC_CTRLA_offset = 0x00             ; Control A\n.equ RTC_STATUS_offset = 0x01            ; Status\n.equ RTC_INTCTRL_offset = 0x02           ; Interrupt Control\n.equ RTC_INTFLAGS_offset = 0x03          ; Interrupt Flags\n.equ RTC_TEMP_offset = 0x04              ; Temporary\n.equ RTC_DBGCTRL_offset = 0x05           ; Debug control\n.equ RTC_CLKSEL_offset = 0x07            ; Clock Select\n.equ RTC_CNT_offset = 0x08               ; Counter\n.equ RTC_PER_offset = 0x0A               ; Period\n.equ RTC_CMP_offset = 0x0C               ; Compare\n.equ RTC_PITCTRLA_offset = 0x10          ; PIT Control A\n.equ RTC_PITSTATUS_offset = 0x11         ; PIT Status\n.equ RTC_PITINTCTRL_offset = 0x12        ; PIT Interrupt Control\n.equ RTC_PITINTFLAGS_offset = 0x13       ; PIT Interrupt Flags\n.equ RTC_PITDBGCTRL_offset = 0x15        ; PIT Debug control\n\n;*************************************************************************\n;** SIGROW - Signature row\n;*************************************************************************\n.equ SIGROW_DEVICEID0_offset = 0x00      ; Device ID Byte 0\n.equ SIGROW_DEVICEID1_offset = 0x01      ; Device ID Byte 1\n.equ SIGROW_DEVICEID2_offset = 0x02      ; Device ID Byte 2\n.equ SIGROW_SERNUM0_offset = 0x03        ; Serial Number Byte 0\n.equ SIGROW_SERNUM1_offset = 0x04        ; Serial Number Byte 1\n.equ SIGROW_SERNUM2_offset = 0x05        ; Serial Number Byte 2\n.equ SIGROW_SERNUM3_offset = 0x06        ; Serial Number Byte 3\n.equ SIGROW_SERNUM4_offset = 0x07        ; Serial Number Byte 4\n.equ SIGROW_SERNUM5_offset = 0x08        ; Serial Number Byte 5\n.equ SIGROW_SERNUM6_offset = 0x09        ; Serial Number Byte 6\n.equ SIGROW_SERNUM7_offset = 0x0A        ; Serial Number Byte 7\n.equ SIGROW_SERNUM8_offset = 0x0B        ; Serial Number Byte 8\n.equ SIGROW_SERNUM9_offset = 0x0C        ; Serial Number Byte 9\n.equ SIGROW_TEMPSENSE0_offset = 0x20     ; Temperature Sensor Calibration Byte 0\n.equ SIGROW_TEMPSENSE1_offset = 0x21     ; Temperature Sensor Calibration Byte 1\n.equ SIGROW_OSC16ERR3V_offset = 0x22     ; OSC16 error at 3V\n.equ SIGROW_OSC16ERR5V_offset = 0x23     ; OSC16 error at 5V\n.equ SIGROW_OSC20ERR3V_offset = 0x24     ; OSC20 error at 3V\n.equ SIGROW_OSC20ERR5V_offset = 0x25     ; OSC20 error at 5V\n\n;*************************************************************************\n;** SLPCTRL - Sleep Controller\n;*************************************************************************\n.equ SLPCTRL_CTRLA_offset = 0x00         ; Control\n\n;*************************************************************************\n;** SPI - Serial Peripheral Interface\n;*************************************************************************\n.equ SPI_CTRLA_offset = 0x00             ; Control A\n.equ SPI_CTRLB_offset = 0x01             ; Control B\n.equ SPI_INTCTRL_offset = 0x02           ; Interrupt Control\n.equ SPI_INTFLAGS_offset = 0x03          ; Interrupt Flags\n.equ SPI_DATA_offset = 0x04              ; Data\n\n;*************************************************************************\n;** SYSCFG - System Configuration Registers\n;*************************************************************************\n.equ SYSCFG_REVID_offset = 0x01          ; Revision ID\n.equ SYSCFG_EXTBRK_offset = 0x02         ; External Break\n\n;*************************************************************************\n;** TCA - 16-bit Timer/Counter Type A\n;*************************************************************************\n.equ TCA_SINGLE_CTRLA_offset = 0x00      ; Control A\n.equ TCA_SINGLE_CTRLB_offset = 0x01      ; Control B\n.equ TCA_SINGLE_CTRLC_offset = 0x02      ; Control C\n.equ TCA_SINGLE_CTRLD_offset = 0x03      ; Control D\n.equ TCA_SINGLE_CTRLECLR_offset = 0x04   ; Control E Clear\n.equ TCA_SINGLE_CTRLESET_offset = 0x05   ; Control E Set\n.equ TCA_SINGLE_CTRLFCLR_offset = 0x06   ; Control F Clear\n.equ TCA_SINGLE_CTRLFSET_offset = 0x07   ; Control F Set\n.equ TCA_SINGLE_EVCTRL_offset = 0x09     ; Event Control\n.equ TCA_SINGLE_INTCTRL_offset = 0x0A    ; Interrupt Control\n.equ TCA_SINGLE_INTFLAGS_offset = 0x0B   ; Interrupt Flags\n.equ TCA_SINGLE_DBGCTRL_offset = 0x0E    ; Degbug Control\n.equ TCA_SINGLE_TEMP_offset = 0x0F       ; Temporary data for 16-bit Access\n.equ TCA_SINGLE_CNT_offset = 0x20        ; Count\n.equ TCA_SINGLE_PER_offset = 0x26        ; Period\n.equ TCA_SINGLE_CMP0_offset = 0x28       ; Compare 0\n.equ TCA_SINGLE_CMP1_offset = 0x2A       ; Compare 1\n.equ TCA_SINGLE_CMP2_offset = 0x2C       ; Compare 2\n.equ TCA_SINGLE_PERBUF_offset = 0x36     ; Period Buffer\n.equ TCA_SINGLE_CMP0BUF_offset = 0x38    ; Compare 0 Buffer\n.equ TCA_SINGLE_CMP1BUF_offset = 0x3A    ; Compare 1 Buffer\n.equ TCA_SINGLE_CMP2BUF_offset = 0x3C    ; Compare 2 Buffer\n.equ TCA_SPLIT_CTRLA_offset = 0x00       ; Control A\n.equ TCA_SPLIT_CTRLB_offset = 0x01       ; Control B\n.equ TCA_SPLIT_CTRLC_offset = 0x02       ; Control C\n.equ TCA_SPLIT_CTRLD_offset = 0x03       ; Control D\n.equ TCA_SPLIT_CTRLECLR_offset = 0x04    ; Control E Clear\n.equ TCA_SPLIT_CTRLESET_offset = 0x05    ; Control E Set\n.equ TCA_SPLIT_INTCTRL_offset = 0x0A     ; Interrupt Control\n.equ TCA_SPLIT_INTFLAGS_offset = 0x0B    ; Interrupt Flags\n.equ TCA_SPLIT_DBGCTRL_offset = 0x0E     ; Degbug Control\n.equ TCA_SPLIT_LCNT_offset = 0x20        ; Low Count\n.equ TCA_SPLIT_HCNT_offset = 0x21        ; High Count\n.equ TCA_SPLIT_LPER_offset = 0x26        ; Low Period\n.equ TCA_SPLIT_HPER_offset = 0x27        ; High Period\n.equ TCA_SPLIT_LCMP0_offset = 0x28       ; Low Compare\n.equ TCA_SPLIT_HCMP0_offset = 0x29       ; High Compare\n.equ TCA_SPLIT_LCMP1_offset = 0x2A       ; Low Compare\n.equ TCA_SPLIT_HCMP1_offset = 0x2B       ; High Compare\n.equ TCA_SPLIT_LCMP2_offset = 0x2C       ; Low Compare\n.equ TCA_SPLIT_HCMP2_offset = 0x2D       ; High Compare\n.equ TCA_SINGLE_offset = 0x00            ; \n.equ TCA_SPLIT_offset = 0x00             ; \n\n;*************************************************************************\n;** TCB - 16-bit Timer Type B\n;*************************************************************************\n.equ TCB_CTRLA_offset = 0x00             ; Control A\n.equ TCB_CTRLB_offset = 0x01             ; Control Register B\n.equ TCB_EVCTRL_offset = 0x04            ; Event Control\n.equ TCB_INTCTRL_offset = 0x05           ; Interrupt Control\n.equ TCB_INTFLAGS_offset = 0x06          ; Interrupt Flags\n.equ TCB_STATUS_offset = 0x07            ; Status\n.equ TCB_DBGCTRL_offset = 0x08           ; Debug Control\n.equ TCB_TEMP_offset = 0x09              ; Temporary Value\n.equ TCB_CNT_offset = 0x0A               ; Count\n.equ TCB_CCMP_offset = 0x0C              ; Compare or Capture\n\n;*************************************************************************\n;** TCD - Timer Counter D\n;*************************************************************************\n.equ TCD_CTRLA_offset = 0x00             ; Control A\n.equ TCD_CTRLB_offset = 0x01             ; Control B\n.equ TCD_CTRLC_offset = 0x02             ; Control C\n.equ TCD_CTRLD_offset = 0x03             ; Control D\n.equ TCD_CTRLE_offset = 0x04             ; Control E\n.equ TCD_EVCTRLA_offset = 0x08           ; EVCTRLA\n.equ TCD_EVCTRLB_offset = 0x09           ; EVCTRLB\n.equ TCD_INTCTRL_offset = 0x0C           ; Interrupt Control\n.equ TCD_INTFLAGS_offset = 0x0D          ; Interrupt Flags\n.equ TCD_STATUS_offset = 0x0E            ; Status\n.equ TCD_INPUTCTRLA_offset = 0x10        ; Input Control A\n.equ TCD_INPUTCTRLB_offset = 0x11        ; Input Control B\n.equ TCD_FAULTCTRL_offset = 0x12         ; Fault Control\n.equ TCD_DLYCTRL_offset = 0x14           ; Delay Control\n.equ TCD_DLYVAL_offset = 0x15            ; Delay value\n.equ TCD_DITCTRL_offset = 0x18           ; Dither Control A\n.equ TCD_DITVAL_offset = 0x19            ; Dither value\n.equ TCD_DBGCTRL_offset = 0x1E           ; Debug Control\n.equ TCD_CAPTUREA_offset = 0x22          ; Capture A\n.equ TCD_CAPTUREB_offset = 0x24          ; Capture B\n.equ TCD_CMPASET_offset = 0x28           ; Compare A Set\n.equ TCD_CMPACLR_offset = 0x2A           ; Compare A Clear\n.equ TCD_CMPBSET_offset = 0x2C           ; Compare B Set\n.equ TCD_CMPBCLR_offset = 0x2E           ; Compare B Clear\n\n;*************************************************************************\n;** TWI - Two-Wire Interface\n;*************************************************************************\n.equ TWI_CTRLA_offset = 0x00             ; Control A\n.equ TWI_DBGCTRL_offset = 0x02           ; Debug Control Register\n.equ TWI_MCTRLA_offset = 0x03            ; Master Control A\n.equ TWI_MCTRLB_offset = 0x04            ; Master Control B\n.equ TWI_MSTATUS_offset = 0x05           ; Master Status\n.equ TWI_MBAUD_offset = 0x06             ; Master Baurd Rate Control\n.equ TWI_MADDR_offset = 0x07             ; Master Address\n.equ TWI_MDATA_offset = 0x08             ; Master Data\n.equ TWI_SCTRLA_offset = 0x09            ; Slave Control A\n.equ TWI_SCTRLB_offset = 0x0A            ; Slave Control B\n.equ TWI_SSTATUS_offset = 0x0B           ; Slave Status\n.equ TWI_SADDR_offset = 0x0C             ; Slave Address\n.equ TWI_SDATA_offset = 0x0D             ; Slave Data\n.equ TWI_SADDRMASK_offset = 0x0E         ; Slave Address Mask\n\n;*************************************************************************\n;** USART - Universal Synchronous and Asynchronous Receiver and Transmitter\n;*************************************************************************\n.equ USART_RXDATAL_offset = 0x00         ; Receive Data Low Byte\n.equ USART_RXDATAH_offset = 0x01         ; Receive Data High Byte\n.equ USART_TXDATAL_offset = 0x02         ; Transmit Data Low Byte\n.equ USART_TXDATAH_offset = 0x03         ; Transmit Data High Byte\n.equ USART_STATUS_offset = 0x04          ; Status\n.equ USART_CTRLA_offset = 0x05           ; Control A\n.equ USART_CTRLB_offset = 0x06           ; Control B\n.equ USART_CTRLC_offset = 0x07           ; Control C\n.equ USART_BAUD_offset = 0x08            ; Baud Rate\n.equ USART_DBGCTRL_offset = 0x0B         ; Debug Control\n.equ USART_EVCTRL_offset = 0x0C          ; Event Control\n.equ USART_TXPLCTRL_offset = 0x0D        ; IRCOM Transmitter Pulse Length Control\n.equ USART_RXPLCTRL_offset = 0x0E        ; IRCOM Receiver Pulse Length Control\n\n;*************************************************************************\n;** USERROW - User Row\n;*************************************************************************\n.equ USERROW_USERROW0_offset = 0x00      ; User Row Byte 0\n.equ USERROW_USERROW1_offset = 0x01      ; User Row Byte 1\n.equ USERROW_USERROW2_offset = 0x02      ; User Row Byte 2\n.equ USERROW_USERROW3_offset = 0x03      ; User Row Byte 3\n.equ USERROW_USERROW4_offset = 0x04      ; User Row Byte 4\n.equ USERROW_USERROW5_offset = 0x05      ; User Row Byte 5\n.equ USERROW_USERROW6_offset = 0x06      ; User Row Byte 6\n.equ USERROW_USERROW7_offset = 0x07      ; User Row Byte 7\n.equ USERROW_USERROW8_offset = 0x08      ; User Row Byte 8\n.equ USERROW_USERROW9_offset = 0x09      ; User Row Byte 9\n.equ USERROW_USERROW10_offset = 0x0A     ; User Row Byte 10\n.equ USERROW_USERROW11_offset = 0x0B     ; User Row Byte 11\n.equ USERROW_USERROW12_offset = 0x0C     ; User Row Byte 12\n.equ USERROW_USERROW13_offset = 0x0D     ; User Row Byte 13\n.equ USERROW_USERROW14_offset = 0x0E     ; User Row Byte 14\n.equ USERROW_USERROW15_offset = 0x0F     ; User Row Byte 15\n.equ USERROW_USERROW16_offset = 0x10     ; User Row Byte 16\n.equ USERROW_USERROW17_offset = 0x11     ; User Row Byte 17\n.equ USERROW_USERROW18_offset = 0x12     ; User Row Byte 18\n.equ USERROW_USERROW19_offset = 0x13     ; User Row Byte 19\n.equ USERROW_USERROW20_offset = 0x14     ; User Row Byte 20\n.equ USERROW_USERROW21_offset = 0x15     ; User Row Byte 21\n.equ USERROW_USERROW22_offset = 0x16     ; User Row Byte 22\n.equ USERROW_USERROW23_offset = 0x17     ; User Row Byte 23\n.equ USERROW_USERROW24_offset = 0x18     ; User Row Byte 24\n.equ USERROW_USERROW25_offset = 0x19     ; User Row Byte 25\n.equ USERROW_USERROW26_offset = 0x1A     ; User Row Byte 26\n.equ USERROW_USERROW27_offset = 0x1B     ; User Row Byte 27\n.equ USERROW_USERROW28_offset = 0x1C     ; User Row Byte 28\n.equ USERROW_USERROW29_offset = 0x1D     ; User Row Byte 29\n.equ USERROW_USERROW30_offset = 0x1E     ; User Row Byte 30\n.equ USERROW_USERROW31_offset = 0x1F     ; User Row Byte 31\n\n;*************************************************************************\n;** VPORT - Virtual Ports\n;*************************************************************************\n.equ VPORT_DIR_offset = 0x00             ; Data Direction\n.equ VPORT_OUT_offset = 0x01             ; Output Value\n.equ VPORT_IN_offset = 0x02              ; Input Value\n.equ VPORT_INTFLAGS_offset = 0x03        ; Interrupt Flags\n\n;*************************************************************************\n;** VREF - Voltage reference\n;*************************************************************************\n.equ VREF_CTRLA_offset = 0x00            ; Control A\n.equ VREF_CTRLB_offset = 0x01            ; Control B\n.equ VREF_CTRLC_offset = 0x02            ; Control C\n.equ VREF_CTRLD_offset = 0x03            ; Control D\n\n;*************************************************************************\n;** WDT - Watch-Dog Timer\n;*************************************************************************\n.equ WDT_CTRLA_offset = 0x00             ; Control A\n.equ WDT_STATUS_offset = 0x01            ; Status\n\n\n; ***** LOCKBIT REGISTER LOCATIONS ***************************************\n\n\n\n\n; ***** FUSE REGISTER LOCATIONS ******************************************\n\n\n\n\n; ***** BIT AND VALUE DEFINITIONS ****************************************\n\n\n;*************************************************************************\n;** AC - Analog Comparator\n;*************************************************************************\n\n; AC_CTRLA masks\n.equ AC_ENABLE_bm = 0x01                 ; Enable bit mask\n.equ AC_ENABLE_bp = 0                    ; Enable bit position\n.equ AC_HYSMODE_gm = 0x06                ; Hysteresis Mode group mask\n.equ AC_HYSMODE_gp = 1                   ; Hysteresis Mode group position\n.equ AC_HYSMODE0_bm = (1<<1)             ; Hysteresis Mode bit 0 mask\n.equ AC_HYSMODE0_bp = 1                  ; Hysteresis Mode bit 0 position\n.equ AC_HYSMODE1_bm = (1<<2)             ; Hysteresis Mode bit 1 mask\n.equ AC_HYSMODE1_bp = 2                  ; Hysteresis Mode bit 1 position\n.equ AC_INTMODE_gm = 0x30                ; Interrupt Mode group mask\n.equ AC_INTMODE_gp = 4                   ; Interrupt Mode group position\n.equ AC_INTMODE0_bm = (1<<4)             ; Interrupt Mode bit 0 mask\n.equ AC_INTMODE0_bp = 4                  ; Interrupt Mode bit 0 position\n.equ AC_INTMODE1_bm = (1<<5)             ; Interrupt Mode bit 1 mask\n.equ AC_INTMODE1_bp = 5                  ; Interrupt Mode bit 1 position\n.equ AC_LPMODE_bm = 0x08                 ; Low Power Mode bit mask\n.equ AC_LPMODE_bp = 3                    ; Low Power Mode bit position\n.equ AC_OUTEN_bm = 0x40                  ; Output Buffer Enable bit mask\n.equ AC_OUTEN_bp = 6                     ; Output Buffer Enable bit position\n.equ AC_RUNSTDBY_bm = 0x80               ; Run in Standby Mode bit mask\n.equ AC_RUNSTDBY_bp = 7                  ; Run in Standby Mode bit position\n\n; AC_INTCTRL masks\n.equ AC_CMP_bm = 0x01                    ; Analog Comparator 0 Interrupt Enable bit mask\n.equ AC_CMP_bp = 0                       ; Analog Comparator 0 Interrupt Enable bit position\n\n; AC_MUXCTRLA masks\n.equ AC_INVERT_bm = 0x80                 ; Invert AC Output bit mask\n.equ AC_INVERT_bp = 7                    ; Invert AC Output bit position\n.equ AC_MUXNEG_gm = 0x03                 ; Negative Input MUX Selection group mask\n.equ AC_MUXNEG_gp = 0                    ; Negative Input MUX Selection group position\n.equ AC_MUXNEG0_bm = (1<<0)              ; Negative Input MUX Selection bit 0 mask\n.equ AC_MUXNEG0_bp = 0                   ; Negative Input MUX Selection bit 0 position\n.equ AC_MUXNEG1_bm = (1<<1)              ; Negative Input MUX Selection bit 1 mask\n.equ AC_MUXNEG1_bp = 1                   ; Negative Input MUX Selection bit 1 position\n.equ AC_MUXPOS_gm = 0x18                 ; Positive Input MUX Selection group mask\n.equ AC_MUXPOS_gp = 3                    ; Positive Input MUX Selection group position\n.equ AC_MUXPOS0_bm = (1<<3)              ; Positive Input MUX Selection bit 0 mask\n.equ AC_MUXPOS0_bp = 3                   ; Positive Input MUX Selection bit 0 position\n.equ AC_MUXPOS1_bm = (1<<4)              ; Positive Input MUX Selection bit 1 mask\n.equ AC_MUXPOS1_bp = 4                   ; Positive Input MUX Selection bit 1 position\n\n; AC_STATUS masks\n; Masks for AC_CMP already defined\n.equ AC_STATE_bm = 0x10                  ; Analog Comparator State bit mask\n.equ AC_STATE_bp = 4                     ; Analog Comparator State bit position\n\n; Hysteresis Mode select\n.equ AC_HYSMODE_OFF_gc = (0x00<<1)       ; No hysteresis\n.equ AC_HYSMODE_10mV_gc = (0x01<<1)      ; 10mV hysteresis\n.equ AC_HYSMODE_25mV_gc = (0x02<<1)      ; 25mV hysteresis\n.equ AC_HYSMODE_50mV_gc = (0x03<<1)      ; 50mV hysteresis\n\n; Interrupt Mode select\n.equ AC_INTMODE_BOTHEDGE_gc = (0x00<<4)  ; Any Edge\n.equ AC_INTMODE_NEGEDGE_gc = (0x02<<4)   ; Negative Edge\n.equ AC_INTMODE_POSEDGE_gc = (0x03<<4)   ; Positive Edge\n\n; Low Power Mode select\n.equ AC_LPMODE_DIS_gc = (0x00<<3)        ; Low power mode disabled\n.equ AC_LPMODE_EN_gc = (0x01<<3)         ; Low power mode enabled\n\n; Negative Input MUX Selection select\n.equ AC_MUXNEG_PIN0_gc = (0x00<<0)       ; Negative Pin 0\n.equ AC_MUXNEG_PIN1_gc = (0x01<<0)       ; Negative Pin 1\n.equ AC_MUXNEG_VREF_gc = (0x02<<0)       ; Voltage Reference\n.equ AC_MUXNEG_DAC_gc = (0x03<<0)        ; DAC output\n\n; Positive Input MUX Selection select\n.equ AC_MUXPOS_PIN0_gc = (0x00<<3)       ; Positive Pin 0\n.equ AC_MUXPOS_PIN1_gc = (0x01<<3)       ; Positive Pin 1\n.equ AC_MUXPOS_PIN2_gc = (0x02<<3)       ; Positive Pin 2\n.equ AC_MUXPOS_PIN3_gc = (0x03<<3)       ; Positive Pin 3\n\n\n;*************************************************************************\n;** ADC - Analog to Digital Converter\n;*************************************************************************\n\n; ADC_CALIB masks\n.equ ADC_DUTYCYC_bm = 0x01               ; Duty Cycle bit mask\n.equ ADC_DUTYCYC_bp = 0                  ; Duty Cycle bit position\n\n; ADC_COMMAND masks\n.equ ADC_STCONV_bm = 0x01                ; Start Conversion Operation bit mask\n.equ ADC_STCONV_bp = 0                   ; Start Conversion Operation bit position\n\n; ADC_CTRLA masks\n.equ ADC_ENABLE_bm = 0x01                ; ADC Enable bit mask\n.equ ADC_ENABLE_bp = 0                   ; ADC Enable bit position\n.equ ADC_FREERUN_bm = 0x02               ; ADC Freerun mode bit mask\n.equ ADC_FREERUN_bp = 1                  ; ADC Freerun mode bit position\n.equ ADC_RESSEL_bm = 0x04                ; ADC Resolution bit mask\n.equ ADC_RESSEL_bp = 2                   ; ADC Resolution bit position\n.equ ADC_RUNSTBY_bm = 0x80               ; Run standby mode bit mask\n.equ ADC_RUNSTBY_bp = 7                  ; Run standby mode bit position\n\n; ADC_CTRLB masks\n.equ ADC_SAMPNUM_gm = 0x07               ; Accumulation Samples group mask\n.equ ADC_SAMPNUM_gp = 0                  ; Accumulation Samples group position\n.equ ADC_SAMPNUM0_bm = (1<<0)            ; Accumulation Samples bit 0 mask\n.equ ADC_SAMPNUM0_bp = 0                 ; Accumulation Samples bit 0 position\n.equ ADC_SAMPNUM1_bm = (1<<1)            ; Accumulation Samples bit 1 mask\n.equ ADC_SAMPNUM1_bp = 1                 ; Accumulation Samples bit 1 position\n.equ ADC_SAMPNUM2_bm = (1<<2)            ; Accumulation Samples bit 2 mask\n.equ ADC_SAMPNUM2_bp = 2                 ; Accumulation Samples bit 2 position\n\n; ADC_CTRLC masks\n.equ ADC_PRESC_gm = 0x07                 ; Clock Pre-scaler group mask\n.equ ADC_PRESC_gp = 0                    ; Clock Pre-scaler group position\n.equ ADC_PRESC0_bm = (1<<0)              ; Clock Pre-scaler bit 0 mask\n.equ ADC_PRESC0_bp = 0                   ; Clock Pre-scaler bit 0 position\n.equ ADC_PRESC1_bm = (1<<1)              ; Clock Pre-scaler bit 1 mask\n.equ ADC_PRESC1_bp = 1                   ; Clock Pre-scaler bit 1 position\n.equ ADC_PRESC2_bm = (1<<2)              ; Clock Pre-scaler bit 2 mask\n.equ ADC_PRESC2_bp = 2                   ; Clock Pre-scaler bit 2 position\n.equ ADC_REFSEL_gm = 0x30                ; Reference Selection group mask\n.equ ADC_REFSEL_gp = 4                   ; Reference Selection group position\n.equ ADC_REFSEL0_bm = (1<<4)             ; Reference Selection bit 0 mask\n.equ ADC_REFSEL0_bp = 4                  ; Reference Selection bit 0 position\n.equ ADC_REFSEL1_bm = (1<<5)             ; Reference Selection bit 1 mask\n.equ ADC_REFSEL1_bp = 5                  ; Reference Selection bit 1 position\n.equ ADC_SAMPCAP_bm = 0x40               ; Sample Capacitance Selection bit mask\n.equ ADC_SAMPCAP_bp = 6                  ; Sample Capacitance Selection bit position\n\n; ADC_CTRLD masks\n.equ ADC_ASDV_bm = 0x10                  ; Automatic Sampling Delay Variation bit mask\n.equ ADC_ASDV_bp = 4                     ; Automatic Sampling Delay Variation bit position\n.equ ADC_INITDLY_gm = 0xE0               ; Initial Delay Selection group mask\n.equ ADC_INITDLY_gp = 5                  ; Initial Delay Selection group position\n.equ ADC_INITDLY0_bm = (1<<5)            ; Initial Delay Selection bit 0 mask\n.equ ADC_INITDLY0_bp = 5                 ; Initial Delay Selection bit 0 position\n.equ ADC_INITDLY1_bm = (1<<6)            ; Initial Delay Selection bit 1 mask\n.equ ADC_INITDLY1_bp = 6                 ; Initial Delay Selection bit 1 position\n.equ ADC_INITDLY2_bm = (1<<7)            ; Initial Delay Selection bit 2 mask\n.equ ADC_INITDLY2_bp = 7                 ; Initial Delay Selection bit 2 position\n.equ ADC_SAMPDLY_gm = 0x0F               ; Sampling Delay Selection group mask\n.equ ADC_SAMPDLY_gp = 0                  ; Sampling Delay Selection group position\n.equ ADC_SAMPDLY0_bm = (1<<0)            ; Sampling Delay Selection bit 0 mask\n.equ ADC_SAMPDLY0_bp = 0                 ; Sampling Delay Selection bit 0 position\n.equ ADC_SAMPDLY1_bm = (1<<1)            ; Sampling Delay Selection bit 1 mask\n.equ ADC_SAMPDLY1_bp = 1                 ; Sampling Delay Selection bit 1 position\n.equ ADC_SAMPDLY2_bm = (1<<2)            ; Sampling Delay Selection bit 2 mask\n.equ ADC_SAMPDLY2_bp = 2                 ; Sampling Delay Selection bit 2 position\n.equ ADC_SAMPDLY3_bm = (1<<3)            ; Sampling Delay Selection bit 3 mask\n.equ ADC_SAMPDLY3_bp = 3                 ; Sampling Delay Selection bit 3 position\n\n; ADC_CTRLE masks\n.equ ADC_WINCM_gm = 0x07                 ; Window Comparator Mode group mask\n.equ ADC_WINCM_gp = 0                    ; Window Comparator Mode group position\n.equ ADC_WINCM0_bm = (1<<0)              ; Window Comparator Mode bit 0 mask\n.equ ADC_WINCM0_bp = 0                   ; Window Comparator Mode bit 0 position\n.equ ADC_WINCM1_bm = (1<<1)              ; Window Comparator Mode bit 1 mask\n.equ ADC_WINCM1_bp = 1                   ; Window Comparator Mode bit 1 position\n.equ ADC_WINCM2_bm = (1<<2)              ; Window Comparator Mode bit 2 mask\n.equ ADC_WINCM2_bp = 2                   ; Window Comparator Mode bit 2 position\n\n; ADC_DBGCTRL masks\n.equ ADC_DBGRUN_bm = 0x01                ; Debug run bit mask\n.equ ADC_DBGRUN_bp = 0                   ; Debug run bit position\n\n; ADC_EVCTRL masks\n.equ ADC_STARTEI_bm = 0x01               ; Start Event Input Enable bit mask\n.equ ADC_STARTEI_bp = 0                  ; Start Event Input Enable bit position\n\n; ADC_INTCTRL masks\n.equ ADC_RESRDY_bm = 0x01                ; Result Ready Interrupt Enable bit mask\n.equ ADC_RESRDY_bp = 0                   ; Result Ready Interrupt Enable bit position\n.equ ADC_WCMP_bm = 0x02                  ; Window Comparator Interrupt Enable bit mask\n.equ ADC_WCMP_bp = 1                     ; Window Comparator Interrupt Enable bit position\n\n; ADC_INTFLAGS masks\n; Masks for ADC_RESRDY already defined\n; Masks for ADC_WCMP already defined\n\n; ADC_MUXPOS masks\n.equ ADC_MUXPOS_gm = 0x1F                ; Analog Channel Selection Bits group mask\n.equ ADC_MUXPOS_gp = 0                   ; Analog Channel Selection Bits group position\n.equ ADC_MUXPOS0_bm = (1<<0)             ; Analog Channel Selection Bits bit 0 mask\n.equ ADC_MUXPOS0_bp = 0                  ; Analog Channel Selection Bits bit 0 position\n.equ ADC_MUXPOS1_bm = (1<<1)             ; Analog Channel Selection Bits bit 1 mask\n.equ ADC_MUXPOS1_bp = 1                  ; Analog Channel Selection Bits bit 1 position\n.equ ADC_MUXPOS2_bm = (1<<2)             ; Analog Channel Selection Bits bit 2 mask\n.equ ADC_MUXPOS2_bp = 2                  ; Analog Channel Selection Bits bit 2 position\n.equ ADC_MUXPOS3_bm = (1<<3)             ; Analog Channel Selection Bits bit 3 mask\n.equ ADC_MUXPOS3_bp = 3                  ; Analog Channel Selection Bits bit 3 position\n.equ ADC_MUXPOS4_bm = (1<<4)             ; Analog Channel Selection Bits bit 4 mask\n.equ ADC_MUXPOS4_bp = 4                  ; Analog Channel Selection Bits bit 4 position\n\n; ADC_SAMPCTRL masks\n.equ ADC_SAMPLEN_gm = 0x1F               ; Sample lenght group mask\n.equ ADC_SAMPLEN_gp = 0                  ; Sample lenght group position\n.equ ADC_SAMPLEN0_bm = (1<<0)            ; Sample lenght bit 0 mask\n.equ ADC_SAMPLEN0_bp = 0                 ; Sample lenght bit 0 position\n.equ ADC_SAMPLEN1_bm = (1<<1)            ; Sample lenght bit 1 mask\n.equ ADC_SAMPLEN1_bp = 1                 ; Sample lenght bit 1 position\n.equ ADC_SAMPLEN2_bm = (1<<2)            ; Sample lenght bit 2 mask\n.equ ADC_SAMPLEN2_bp = 2                 ; Sample lenght bit 2 position\n.equ ADC_SAMPLEN3_bm = (1<<3)            ; Sample lenght bit 3 mask\n.equ ADC_SAMPLEN3_bp = 3                 ; Sample lenght bit 3 position\n.equ ADC_SAMPLEN4_bm = (1<<4)            ; Sample lenght bit 4 mask\n.equ ADC_SAMPLEN4_bp = 4                 ; Sample lenght bit 4 position\n\n; ADC_TEMP masks\n.equ ADC_TEMP_gm = 0xFF                  ; Temporary group mask\n.equ ADC_TEMP_gp = 0                     ; Temporary group position\n.equ ADC_TEMP0_bm = (1<<0)               ; Temporary bit 0 mask\n.equ ADC_TEMP0_bp = 0                    ; Temporary bit 0 position\n.equ ADC_TEMP1_bm = (1<<1)               ; Temporary bit 1 mask\n.equ ADC_TEMP1_bp = 1                    ; Temporary bit 1 position\n.equ ADC_TEMP2_bm = (1<<2)               ; Temporary bit 2 mask\n.equ ADC_TEMP2_bp = 2                    ; Temporary bit 2 position\n.equ ADC_TEMP3_bm = (1<<3)               ; Temporary bit 3 mask\n.equ ADC_TEMP3_bp = 3                    ; Temporary bit 3 position\n.equ ADC_TEMP4_bm = (1<<4)               ; Temporary bit 4 mask\n.equ ADC_TEMP4_bp = 4                    ; Temporary bit 4 position\n.equ ADC_TEMP5_bm = (1<<5)               ; Temporary bit 5 mask\n.equ ADC_TEMP5_bp = 5                    ; Temporary bit 5 position\n.equ ADC_TEMP6_bm = (1<<6)               ; Temporary bit 6 mask\n.equ ADC_TEMP6_bp = 6                    ; Temporary bit 6 position\n.equ ADC_TEMP7_bm = (1<<7)               ; Temporary bit 7 mask\n.equ ADC_TEMP7_bp = 7                    ; Temporary bit 7 position\n\n; Duty Cycle select\n.equ ADC_DUTYCYC_DUTY50_gc = (0x00<<0)   ; 50% Duty cycle\n.equ ADC_DUTYCYC_DUTY25_gc = (0x01<<0)   ; 25% Duty cycle\n\n; ADC Resolution select\n.equ ADC_RESSEL_10BIT_gc = (0x00<<2)     ; 10-bit mode\n.equ ADC_RESSEL_8BIT_gc = (0x01<<2)      ; 8-bit mode\n\n; Accumulation Samples select\n.equ ADC_SAMPNUM_ACC1_gc = (0x00<<0)     ; 1 ADC sample\n.equ ADC_SAMPNUM_ACC2_gc = (0x01<<0)     ; Accumulate 2 samples\n.equ ADC_SAMPNUM_ACC4_gc = (0x02<<0)     ; Accumulate 4 samples\n.equ ADC_SAMPNUM_ACC8_gc = (0x03<<0)     ; Accumulate 8 samples\n.equ ADC_SAMPNUM_ACC16_gc = (0x04<<0)    ; Accumulate 16 samples\n.equ ADC_SAMPNUM_ACC32_gc = (0x05<<0)    ; Accumulate 32 samples\n.equ ADC_SAMPNUM_ACC64_gc = (0x06<<0)    ; Accumulate 64 samples\n\n; Clock Pre-scaler select\n.equ ADC_PRESC_DIV2_gc = (0x00<<0)       ; CLK_PER divided by 2\n.equ ADC_PRESC_DIV4_gc = (0x01<<0)       ; CLK_PER divided by 4\n.equ ADC_PRESC_DIV8_gc = (0x02<<0)       ; CLK_PER divided by 8\n.equ ADC_PRESC_DIV16_gc = (0x03<<0)      ; CLK_PER divided by 16\n.equ ADC_PRESC_DIV32_gc = (0x04<<0)      ; CLK_PER divided by 32\n.equ ADC_PRESC_DIV64_gc = (0x05<<0)      ; CLK_PER divided by 64\n.equ ADC_PRESC_DIV128_gc = (0x06<<0)     ; CLK_PER divided by 128\n.equ ADC_PRESC_DIV256_gc = (0x07<<0)     ; CLK_PER divided by 256\n\n; Reference Selection select\n.equ ADC_REFSEL_INTREF_gc = (0x00<<4)    ; Internal reference\n.equ ADC_REFSEL_VDDREF_gc = (0x01<<4)    ; VDD\n.equ ADC_REFSEL_VREFA_gc = (0x02<<4)     ; External reference\n\n; Automatic Sampling Delay Variation select\n.equ ADC_ASDV_ASVOFF_gc = (0x00<<4)      ; The Automatic Sampling Delay Variation is disabled\n.equ ADC_ASDV_ASVON_gc = (0x01<<4)       ; The Automatic Sampling Delay Variation is enabled\n\n; Initial Delay Selection select\n.equ ADC_INITDLY_DLY0_gc = (0x00<<5)     ; Delay 0 CLK_ADC cycles\n.equ ADC_INITDLY_DLY16_gc = (0x01<<5)    ; Delay 16 CLK_ADC cycles\n.equ ADC_INITDLY_DLY32_gc = (0x02<<5)    ; Delay 32 CLK_ADC cycles\n.equ ADC_INITDLY_DLY64_gc = (0x03<<5)    ; Delay 64 CLK_ADC cycles\n.equ ADC_INITDLY_DLY128_gc = (0x04<<5)   ; Delay 128 CLK_ADC cycles\n.equ ADC_INITDLY_DLY256_gc = (0x05<<5)   ; Delay 256 CLK_ADC cycles\n\n; Window Comparator Mode select\n.equ ADC_WINCM_NONE_gc = (0x00<<0)       ; No Window Comparison\n.equ ADC_WINCM_BELOW_gc = (0x01<<0)      ; Below Window\n.equ ADC_WINCM_ABOVE_gc = (0x02<<0)      ; Above Window\n.equ ADC_WINCM_INSIDE_gc = (0x03<<0)     ; Inside Window\n.equ ADC_WINCM_OUTSIDE_gc = (0x04<<0)    ; Outside Window\n\n; Analog Channel Selection Bits select\n.equ ADC_MUXPOS_AIN0_gc = (0x00<<0)      ; ADC input pin 0\n.equ ADC_MUXPOS_AIN1_gc = (0x01<<0)      ; ADC input pin 1\n.equ ADC_MUXPOS_AIN2_gc = (0x02<<0)      ; ADC input pin 2\n.equ ADC_MUXPOS_AIN3_gc = (0x03<<0)      ; ADC input pin 3\n.equ ADC_MUXPOS_AIN4_gc = (0x04<<0)      ; ADC input pin 4\n.equ ADC_MUXPOS_AIN5_gc = (0x05<<0)      ; ADC input pin 5\n.equ ADC_MUXPOS_AIN6_gc = (0x06<<0)      ; ADC input pin 6\n.equ ADC_MUXPOS_AIN7_gc = (0x07<<0)      ; ADC input pin 7\n.equ ADC_MUXPOS_AIN8_gc = (0x08<<0)      ; ADC input pin 8\n.equ ADC_MUXPOS_AIN9_gc = (0x09<<0)      ; ADC input pin 9\n.equ ADC_MUXPOS_AIN10_gc = (0x0A<<0)     ; ADC input pin 10\n.equ ADC_MUXPOS_AIN11_gc = (0x0B<<0)     ; ADC input pin 11\n.equ ADC_MUXPOS_PTC_gc = (0x1B<<0)       ; PTC/DAC2\n.equ ADC_MUXPOS_DAC0_gc = (0x1C<<0)      ; DAC0/DAC0\n.equ ADC_MUXPOS_INTREF_gc = (0x1D<<0)    ; Internal Ref\n.equ ADC_MUXPOS_TEMPSENSE_gc = (0x1E<<0) ; Temp sensor/DAC1\n.equ ADC_MUXPOS_GND_gc = (0x1F<<0)       ; GND\n\n\n;*************************************************************************\n;** BOD - Bod interface\n;*************************************************************************\n\n; BOD_CTRLA masks\n.equ BOD_ACTIVE_gm = 0x0C                ; Operation in active mode group mask\n.equ BOD_ACTIVE_gp = 2                   ; Operation in active mode group position\n.equ BOD_ACTIVE0_bm = (1<<2)             ; Operation in active mode bit 0 mask\n.equ BOD_ACTIVE0_bp = 2                  ; Operation in active mode bit 0 position\n.equ BOD_ACTIVE1_bm = (1<<3)             ; Operation in active mode bit 1 mask\n.equ BOD_ACTIVE1_bp = 3                  ; Operation in active mode bit 1 position\n.equ BOD_SAMPFREQ_bm = 0x10              ; Sample frequency bit mask\n.equ BOD_SAMPFREQ_bp = 4                 ; Sample frequency bit position\n.equ BOD_SLEEP_gm = 0x03                 ; Operation in sleep mode group mask\n.equ BOD_SLEEP_gp = 0                    ; Operation in sleep mode group position\n.equ BOD_SLEEP0_bm = (1<<0)              ; Operation in sleep mode bit 0 mask\n.equ BOD_SLEEP0_bp = 0                   ; Operation in sleep mode bit 0 position\n.equ BOD_SLEEP1_bm = (1<<1)              ; Operation in sleep mode bit 1 mask\n.equ BOD_SLEEP1_bp = 1                   ; Operation in sleep mode bit 1 position\n\n; BOD_CTRLB masks\n.equ BOD_LVL_gm = 0x07                   ; Bod level group mask\n.equ BOD_LVL_gp = 0                      ; Bod level group position\n.equ BOD_LVL0_bm = (1<<0)                ; Bod level bit 0 mask\n.equ BOD_LVL0_bp = 0                     ; Bod level bit 0 position\n.equ BOD_LVL1_bm = (1<<1)                ; Bod level bit 1 mask\n.equ BOD_LVL1_bp = 1                     ; Bod level bit 1 position\n.equ BOD_LVL2_bm = (1<<2)                ; Bod level bit 2 mask\n.equ BOD_LVL2_bp = 2                     ; Bod level bit 2 position\n\n; BOD_INTCTRL masks\n.equ BOD_VLMCFG_gm = 0x06                ; Configuration group mask\n.equ BOD_VLMCFG_gp = 1                   ; Configuration group position\n.equ BOD_VLMCFG0_bm = (1<<1)             ; Configuration bit 0 mask\n.equ BOD_VLMCFG0_bp = 1                  ; Configuration bit 0 position\n.equ BOD_VLMCFG1_bm = (1<<2)             ; Configuration bit 1 mask\n.equ BOD_VLMCFG1_bp = 2                  ; Configuration bit 1 position\n.equ BOD_VLMIE_bm = 0x01                 ; voltage level monitor interrrupt enable bit mask\n.equ BOD_VLMIE_bp = 0                    ; voltage level monitor interrrupt enable bit position\n\n; BOD_INTFLAGS masks\n.equ BOD_VLMIF_bm = 0x01                 ; Voltage level monitor interrupt flag bit mask\n.equ BOD_VLMIF_bp = 0                    ; Voltage level monitor interrupt flag bit position\n\n; BOD_STATUS masks\n.equ BOD_VLMS_bm = 0x01                  ; Voltage level monitor status bit mask\n.equ BOD_VLMS_bp = 0                     ; Voltage level monitor status bit position\n\n; BOD_VLMCTRLA masks\n.equ BOD_VLMLVL_gm = 0x03                ; voltage level monitor level group mask\n.equ BOD_VLMLVL_gp = 0                   ; voltage level monitor level group position\n.equ BOD_VLMLVL0_bm = (1<<0)             ; voltage level monitor level bit 0 mask\n.equ BOD_VLMLVL0_bp = 0                  ; voltage level monitor level bit 0 position\n.equ BOD_VLMLVL1_bm = (1<<1)             ; voltage level monitor level bit 1 mask\n.equ BOD_VLMLVL1_bp = 1                  ; voltage level monitor level bit 1 position\n\n; Operation in active mode select\n.equ BOD_ACTIVE_DIS_gc = (0x00<<2)       ; Disabled\n.equ BOD_ACTIVE_ENABLED_gc = (0x01<<2)   ; Enabled\n.equ BOD_ACTIVE_SAMPLED_gc = (0x02<<2)   ; Sampled\n.equ BOD_ACTIVE_ENWAKE_gc = (0x03<<2)    ; Enabled with wake-up halted until BOD is ready\n\n; Sample frequency select\n.equ BOD_SAMPFREQ_1KHZ_gc = (0x00<<4)    ; 1kHz sampling frequency\n.equ BOD_SAMPFREQ_125HZ_gc = (0x01<<4)   ; 125Hz sampling frequency\n\n; Operation in sleep mode select\n.equ BOD_SLEEP_DIS_gc = (0x00<<0)        ; Disabled\n.equ BOD_SLEEP_ENABLED_gc = (0x01<<0)    ; Enabled\n.equ BOD_SLEEP_SAMPLED_gc = (0x02<<0)    ; Sampled\n\n; Bod level select\n.equ BOD_LVL_BODLEVEL0_gc = (0x00<<0)    ; 1.8 V\n.equ BOD_LVL_BODLEVEL2_gc = (0x02<<0)    ; 2.6 V\n.equ BOD_LVL_BODLEVEL7_gc = (0x07<<0)    ; 4.2 V\n\n; Configuration select\n.equ BOD_VLMCFG_BELOW_gc = (0x00<<1)     ; Interrupt when supply goes below VLM level\n.equ BOD_VLMCFG_ABOVE_gc = (0x01<<1)     ; Interrupt when supply goes above VLM level\n.equ BOD_VLMCFG_CROSS_gc = (0x02<<1)     ; Interrupt when supply crosses VLM level\n\n; voltage level monitor level select\n.equ BOD_VLMLVL_5ABOVE_gc = (0x00<<0)    ; VLM threshold 5% above BOD level\n.equ BOD_VLMLVL_15ABOVE_gc = (0x01<<0)   ; VLM threshold 15% above BOD level\n.equ BOD_VLMLVL_25ABOVE_gc = (0x02<<0)   ; VLM threshold 25% above BOD level\n\n\n;*************************************************************************\n;** CCL - Configurable Custom Logic\n;*************************************************************************\n\n; CCL_CTRLA masks\n.equ CCL_ENABLE_bm = 0x01                ; Enable bit mask\n.equ CCL_ENABLE_bp = 0                   ; Enable bit position\n.equ CCL_RUNSTDBY_bm = 0x40              ; Run in Standby bit mask\n.equ CCL_RUNSTDBY_bp = 6                 ; Run in Standby bit position\n\n; CCL_LUT0CTRLA masks\n.equ CCL_CLKSRC_bm = 0x40                ; Clock Source Selection bit mask\n.equ CCL_CLKSRC_bp = 6                   ; Clock Source Selection bit position\n.equ CCL_EDGEDET_bm = 0x80               ; Edge Detection Enable bit mask\n.equ CCL_EDGEDET_bp = 7                  ; Edge Detection Enable bit position\n; Masks for CCL_ENABLE already defined\n.equ CCL_FILTSEL_gm = 0x30               ; Filter Selection group mask\n.equ CCL_FILTSEL_gp = 4                  ; Filter Selection group position\n.equ CCL_FILTSEL0_bm = (1<<4)            ; Filter Selection bit 0 mask\n.equ CCL_FILTSEL0_bp = 4                 ; Filter Selection bit 0 position\n.equ CCL_FILTSEL1_bm = (1<<5)            ; Filter Selection bit 1 mask\n.equ CCL_FILTSEL1_bp = 5                 ; Filter Selection bit 1 position\n.equ CCL_OUTEN_bm = 0x08                 ; Output Enable bit mask\n.equ CCL_OUTEN_bp = 3                    ; Output Enable bit position\n\n; CCL_LUT0CTRLB masks\n.equ CCL_INSEL0_gm = 0x0F                ; LUT Input 0 Source Selection group mask\n.equ CCL_INSEL0_gp = 0                   ; LUT Input 0 Source Selection group position\n.equ CCL_INSEL00_bm = (1<<0)             ; LUT Input 0 Source Selection bit 0 mask\n.equ CCL_INSEL00_bp = 0                  ; LUT Input 0 Source Selection bit 0 position\n.equ CCL_INSEL01_bm = (1<<1)             ; LUT Input 0 Source Selection bit 1 mask\n.equ CCL_INSEL01_bp = 1                  ; LUT Input 0 Source Selection bit 1 position\n.equ CCL_INSEL02_bm = (1<<2)             ; LUT Input 0 Source Selection bit 2 mask\n.equ CCL_INSEL02_bp = 2                  ; LUT Input 0 Source Selection bit 2 position\n.equ CCL_INSEL03_bm = (1<<3)             ; LUT Input 0 Source Selection bit 3 mask\n.equ CCL_INSEL03_bp = 3                  ; LUT Input 0 Source Selection bit 3 position\n.equ CCL_INSEL1_gm = 0xF0                ; LUT Input 1 Source Selection group mask\n.equ CCL_INSEL1_gp = 4                   ; LUT Input 1 Source Selection group position\n.equ CCL_INSEL10_bm = (1<<4)             ; LUT Input 1 Source Selection bit 0 mask\n.equ CCL_INSEL10_bp = 4                  ; LUT Input 1 Source Selection bit 0 position\n.equ CCL_INSEL11_bm = (1<<5)             ; LUT Input 1 Source Selection bit 1 mask\n.equ CCL_INSEL11_bp = 5                  ; LUT Input 1 Source Selection bit 1 position\n.equ CCL_INSEL12_bm = (1<<6)             ; LUT Input 1 Source Selection bit 2 mask\n.equ CCL_INSEL12_bp = 6                  ; LUT Input 1 Source Selection bit 2 position\n.equ CCL_INSEL13_bm = (1<<7)             ; LUT Input 1 Source Selection bit 3 mask\n.equ CCL_INSEL13_bp = 7                  ; LUT Input 1 Source Selection bit 3 position\n\n; CCL_LUT0CTRLC masks\n.equ CCL_INSEL2_gm = 0x0F                ; LUT Input 2 Source Selection group mask\n.equ CCL_INSEL2_gp = 0                   ; LUT Input 2 Source Selection group position\n.equ CCL_INSEL20_bm = (1<<0)             ; LUT Input 2 Source Selection bit 0 mask\n.equ CCL_INSEL20_bp = 0                  ; LUT Input 2 Source Selection bit 0 position\n.equ CCL_INSEL21_bm = (1<<1)             ; LUT Input 2 Source Selection bit 1 mask\n.equ CCL_INSEL21_bp = 1                  ; LUT Input 2 Source Selection bit 1 position\n.equ CCL_INSEL22_bm = (1<<2)             ; LUT Input 2 Source Selection bit 2 mask\n.equ CCL_INSEL22_bp = 2                  ; LUT Input 2 Source Selection bit 2 position\n.equ CCL_INSEL23_bm = (1<<3)             ; LUT Input 2 Source Selection bit 3 mask\n.equ CCL_INSEL23_bp = 3                  ; LUT Input 2 Source Selection bit 3 position\n\n; CCL_LUT1CTRLA masks\n; Masks for CCL_CLKSRC already defined\n; Masks for CCL_EDGEDET already defined\n; Masks for CCL_ENABLE already defined\n; Masks for CCL_FILTSEL already defined\n; Masks for CCL_OUTEN already defined\n\n; CCL_LUT1CTRLB masks\n; Masks for CCL_INSEL0 already defined\n; Masks for CCL_INSEL1 already defined\n\n; CCL_LUT1CTRLC masks\n; Masks for CCL_INSEL2 already defined\n\n; CCL_SEQCTRL0 masks\n.equ CCL_SEQSEL_gm = 0x07                ; Sequential Selection group mask\n.equ CCL_SEQSEL_gp = 0                   ; Sequential Selection group position\n.equ CCL_SEQSEL0_bm = (1<<0)             ; Sequential Selection bit 0 mask\n.equ CCL_SEQSEL0_bp = 0                  ; Sequential Selection bit 0 position\n.equ CCL_SEQSEL1_bm = (1<<1)             ; Sequential Selection bit 1 mask\n.equ CCL_SEQSEL1_bp = 1                  ; Sequential Selection bit 1 position\n.equ CCL_SEQSEL2_bm = (1<<2)             ; Sequential Selection bit 2 mask\n.equ CCL_SEQSEL2_bp = 2                  ; Sequential Selection bit 2 position\n\n; Edge Detection Enable select\n.equ CCL_EDGEDET_DIS_gc = (0x00<<7)      ; Edge detector is disabled\n.equ CCL_EDGEDET_EN_gc = (0x01<<7)       ; Edge detector is enabled\n\n; Filter Selection select\n.equ CCL_FILTSEL_DISABLE_gc = (0x00<<4)  ; Filter disabled\n.equ CCL_FILTSEL_SYNCH_gc = (0x01<<4)    ; Synchronizer enabled\n.equ CCL_FILTSEL_FILTER_gc = (0x02<<4)   ; Filter enabled\n\n; LUT Input 0 Source Selection select\n.equ CCL_INSEL0_MASK_gc = (0x00<<0)      ; Masked input\n.equ CCL_INSEL0_FEEDBACK_gc = (0x01<<0)  ; Feedback input source\n.equ CCL_INSEL0_LINK_gc = (0x02<<0)      ; Linked LUT input source\n.equ CCL_INSEL0_EVENT0_gc = (0x03<<0)    ; Event input source 0\n.equ CCL_INSEL0_EVENT1_gc = (0x04<<0)    ; Event input source 1\n.equ CCL_INSEL0_IO_gc = (0x05<<0)        ; IO pin LUTn-IN0 input source\n.equ CCL_INSEL0_AC0_gc = (0x06<<0)       ; AC0 OUT input source\n.equ CCL_INSEL0_TCB0_gc = (0x07<<0)      ; TCB0 WO input source\n.equ CCL_INSEL0_TCA0_gc = (0x08<<0)      ; TCA0 WO0 input source\n.equ CCL_INSEL0_TCD0_gc = (0x09<<0)      ; TCD0 WOA input source\n.equ CCL_INSEL0_USART0_gc = (0x0A<<0)    ; USART0 XCK input source\n.equ CCL_INSEL0_SPI0_gc = (0x0B<<0)      ; SPI0 SCK source\n.equ CCL_INSEL0_AC1_gc = (0x0C<<0)       ; AC1 OUT input source\n.equ CCL_INSEL0_TCB1_gc = (0x0D<<0)      ; TCB1 WO input source\n.equ CCL_INSEL0_AC2_gc = (0x0E<<0)       ; AC2 OUT input source\n\n; LUT Input 1 Source Selection select\n.equ CCL_INSEL1_MASK_gc = (0x00<<4)      ; Masked input\n.equ CCL_INSEL1_FEEDBACK_gc = (0x01<<4)  ; Feedback input source\n.equ CCL_INSEL1_LINK_gc = (0x02<<4)      ; Linked LUT input source\n.equ CCL_INSEL1_EVENT0_gc = (0x03<<4)    ; Event input source 0\n.equ CCL_INSEL1_EVENT1_gc = (0x04<<4)    ; Event input source 1\n.equ CCL_INSEL1_IO_gc = (0x05<<4)        ; IO pin LUTn-N1 input source\n.equ CCL_INSEL1_AC0_gc = (0x06<<4)       ; AC0 OUT input source\n.equ CCL_INSEL1_TCB0_gc = (0x07<<4)      ; TCB0 WO input source\n.equ CCL_INSEL1_TCA0_gc = (0x08<<4)      ; TCA0 WO1 input source\n.equ CCL_INSEL1_TCD0_gc = (0x09<<4)      ; TCD0 WOB input source\n.equ CCL_INSEL1_USART0_gc = (0x0A<<4)    ; USART0 TXD input source\n.equ CCL_INSEL1_SPI0_gc = (0x0B<<4)      ; SPI0 MOSI input source\n.equ CCL_INSEL1_AC1_gc = (0x0C<<4)       ; AC1 OUT input source\n.equ CCL_INSEL1_TCB1_gc = (0x0D<<4)      ; TCB1WO input source\n.equ CCL_INSEL1_AC2_gc = (0x0E<<4)       ; AC2 OUT input source\n\n; LUT Input 2 Source Selection select\n.equ CCL_INSEL2_MASK_gc = (0x00<<0)      ; Masked input\n.equ CCL_INSEL2_FEEDBACK_gc = (0x01<<0)  ; Feedback input source\n.equ CCL_INSEL2_LINK_gc = (0x02<<0)      ; Linked LUT input source\n.equ CCL_INSEL2_EVENT0_gc = (0x03<<0)    ; Event input source 0\n.equ CCL_INSEL2_EVENT1_gc = (0x04<<0)    ; Event input source 1\n.equ CCL_INSEL2_IO_gc = (0x05<<0)        ; IO pin LUTn-IN2 input source\n.equ CCL_INSEL2_AC0_gc = (0x06<<0)       ; AC0 OUT input source\n.equ CCL_INSEL2_TCB0_gc = (0x07<<0)      ; TCB0 WO input source\n.equ CCL_INSEL2_TCA0_gc = (0x08<<0)      ; TCA0 WO2 input source\n.equ CCL_INSEL2_TCD0_gc = (0x09<<0)      ; TCD0 WOA input source\n.equ CCL_INSEL2_SPI0_gc = (0x0B<<0)      ; SPI0 MISO source\n.equ CCL_INSEL2_AC1_gc = (0x0C<<0)       ; AC1 OUT input source\n.equ CCL_INSEL2_TCB1_gc = (0x0D<<0)      ; TCB1 WO input source\n.equ CCL_INSEL2_AC2_gc = (0x0E<<0)       ; AC2 OUT input source\n\n; Sequential Selection select\n.equ CCL_SEQSEL_DISABLE_gc = (0x00<<0)   ; Sequential logic disabled\n.equ CCL_SEQSEL_DFF_gc = (0x01<<0)       ; D FlipFlop\n.equ CCL_SEQSEL_JK_gc = (0x02<<0)        ; JK FlipFlop\n.equ CCL_SEQSEL_LATCH_gc = (0x03<<0)     ; D Latch\n.equ CCL_SEQSEL_RS_gc = (0x04<<0)        ; RS Latch\n\n\n;*************************************************************************\n;** CLKCTRL - Clock controller\n;*************************************************************************\n\n; CLKCTRL_MCLKCTRLA masks\n.equ CLKCTRL_CLKOUT_bm = 0x80            ; System clock out bit mask\n.equ CLKCTRL_CLKOUT_bp = 7               ; System clock out bit position\n.equ CLKCTRL_CLKSEL_gm = 0x03            ; clock select group mask\n.equ CLKCTRL_CLKSEL_gp = 0               ; clock select group position\n.equ CLKCTRL_CLKSEL0_bm = (1<<0)         ; clock select bit 0 mask\n.equ CLKCTRL_CLKSEL0_bp = 0              ; clock select bit 0 position\n.equ CLKCTRL_CLKSEL1_bm = (1<<1)         ; clock select bit 1 mask\n.equ CLKCTRL_CLKSEL1_bp = 1              ; clock select bit 1 position\n\n; CLKCTRL_MCLKCTRLB masks\n.equ CLKCTRL_PDIV_gm = 0x1E              ; Prescaler division group mask\n.equ CLKCTRL_PDIV_gp = 1                 ; Prescaler division group position\n.equ CLKCTRL_PDIV0_bm = (1<<1)           ; Prescaler division bit 0 mask\n.equ CLKCTRL_PDIV0_bp = 1                ; Prescaler division bit 0 position\n.equ CLKCTRL_PDIV1_bm = (1<<2)           ; Prescaler division bit 1 mask\n.equ CLKCTRL_PDIV1_bp = 2                ; Prescaler division bit 1 position\n.equ CLKCTRL_PDIV2_bm = (1<<3)           ; Prescaler division bit 2 mask\n.equ CLKCTRL_PDIV2_bp = 3                ; Prescaler division bit 2 position\n.equ CLKCTRL_PDIV3_bm = (1<<4)           ; Prescaler division bit 3 mask\n.equ CLKCTRL_PDIV3_bp = 4                ; Prescaler division bit 3 position\n.equ CLKCTRL_PEN_bm = 0x01               ; Prescaler enable bit mask\n.equ CLKCTRL_PEN_bp = 0                  ; Prescaler enable bit position\n\n; CLKCTRL_MCLKLOCK masks\n.equ CLKCTRL_LOCKEN_bm = 0x01            ; lock ebable bit mask\n.equ CLKCTRL_LOCKEN_bp = 0               ; lock ebable bit position\n\n; CLKCTRL_MCLKSTATUS masks\n.equ CLKCTRL_EXTS_bm = 0x80              ; External Clock status bit mask\n.equ CLKCTRL_EXTS_bp = 7                 ; External Clock status bit position\n.equ CLKCTRL_OSC20MS_bm = 0x10           ; 20MHz oscillator status bit mask\n.equ CLKCTRL_OSC20MS_bp = 4              ; 20MHz oscillator status bit position\n.equ CLKCTRL_OSC32KS_bm = 0x20           ; 32KHz oscillator status bit mask\n.equ CLKCTRL_OSC32KS_bp = 5              ; 32KHz oscillator status bit position\n.equ CLKCTRL_SOSC_bm = 0x01              ; System Oscillator changing bit mask\n.equ CLKCTRL_SOSC_bp = 0                 ; System Oscillator changing bit position\n.equ CLKCTRL_XOSC32KS_bm = 0x40          ; 32.768 kHz Crystal Oscillator status bit mask\n.equ CLKCTRL_XOSC32KS_bp = 6             ; 32.768 kHz Crystal Oscillator status bit position\n\n; CLKCTRL_OSC20MCALIBA masks\n.equ CLKCTRL_CAL20M_gm = 0x3F            ; Calibration group mask\n.equ CLKCTRL_CAL20M_gp = 0               ; Calibration group position\n.equ CLKCTRL_CAL20M0_bm = (1<<0)         ; Calibration bit 0 mask\n.equ CLKCTRL_CAL20M0_bp = 0              ; Calibration bit 0 position\n.equ CLKCTRL_CAL20M1_bm = (1<<1)         ; Calibration bit 1 mask\n.equ CLKCTRL_CAL20M1_bp = 1              ; Calibration bit 1 position\n.equ CLKCTRL_CAL20M2_bm = (1<<2)         ; Calibration bit 2 mask\n.equ CLKCTRL_CAL20M2_bp = 2              ; Calibration bit 2 position\n.equ CLKCTRL_CAL20M3_bm = (1<<3)         ; Calibration bit 3 mask\n.equ CLKCTRL_CAL20M3_bp = 3              ; Calibration bit 3 position\n.equ CLKCTRL_CAL20M4_bm = (1<<4)         ; Calibration bit 4 mask\n.equ CLKCTRL_CAL20M4_bp = 4              ; Calibration bit 4 position\n.equ CLKCTRL_CAL20M5_bm = (1<<5)         ; Calibration bit 5 mask\n.equ CLKCTRL_CAL20M5_bp = 5              ; Calibration bit 5 position\n\n; CLKCTRL_OSC20MCALIBB masks\n.equ CLKCTRL_LOCK_bm = 0x80              ; Lock bit mask\n.equ CLKCTRL_LOCK_bp = 7                 ; Lock bit position\n.equ CLKCTRL_TEMPCAL20M_gm = 0x0F        ; Oscillator temperature coefficient group mask\n.equ CLKCTRL_TEMPCAL20M_gp = 0           ; Oscillator temperature coefficient group position\n.equ CLKCTRL_TEMPCAL20M0_bm = (1<<0)     ; Oscillator temperature coefficient bit 0 mask\n.equ CLKCTRL_TEMPCAL20M0_bp = 0          ; Oscillator temperature coefficient bit 0 position\n.equ CLKCTRL_TEMPCAL20M1_bm = (1<<1)     ; Oscillator temperature coefficient bit 1 mask\n.equ CLKCTRL_TEMPCAL20M1_bp = 1          ; Oscillator temperature coefficient bit 1 position\n.equ CLKCTRL_TEMPCAL20M2_bm = (1<<2)     ; Oscillator temperature coefficient bit 2 mask\n.equ CLKCTRL_TEMPCAL20M2_bp = 2          ; Oscillator temperature coefficient bit 2 position\n.equ CLKCTRL_TEMPCAL20M3_bm = (1<<3)     ; Oscillator temperature coefficient bit 3 mask\n.equ CLKCTRL_TEMPCAL20M3_bp = 3          ; Oscillator temperature coefficient bit 3 position\n\n; CLKCTRL_OSC20MCTRLA masks\n.equ CLKCTRL_RUNSTDBY_bm = 0x02          ; Run standby bit mask\n.equ CLKCTRL_RUNSTDBY_bp = 1             ; Run standby bit position\n\n; CLKCTRL_OSC32KCTRLA masks\n; Masks for CLKCTRL_RUNSTDBY already defined\n\n; CLKCTRL_XOSC32KCTRLA masks\n.equ CLKCTRL_CSUT_gm = 0x30              ; Crystal startup time group mask\n.equ CLKCTRL_CSUT_gp = 4                 ; Crystal startup time group position\n.equ CLKCTRL_CSUT0_bm = (1<<4)           ; Crystal startup time bit 0 mask\n.equ CLKCTRL_CSUT0_bp = 4                ; Crystal startup time bit 0 position\n.equ CLKCTRL_CSUT1_bm = (1<<5)           ; Crystal startup time bit 1 mask\n.equ CLKCTRL_CSUT1_bp = 5                ; Crystal startup time bit 1 position\n.equ CLKCTRL_ENABLE_bm = 0x01            ; Enable bit mask\n.equ CLKCTRL_ENABLE_bp = 0               ; Enable bit position\n; Masks for CLKCTRL_RUNSTDBY already defined\n.equ CLKCTRL_SEL_bm = 0x04               ; Select bit mask\n.equ CLKCTRL_SEL_bp = 2                  ; Select bit position\n\n; clock select select\n.equ CLKCTRL_CLKSEL_OSC20M_gc = (0x00<<0) ; 20MHz internal oscillator\n.equ CLKCTRL_CLKSEL_OSCULP32K_gc = (0x01<<0) ; 32KHz internal Ultra Low Power oscillator\n.equ CLKCTRL_CLKSEL_XOSC32K_gc = (0x02<<0) ; 32.768kHz external crystal oscillator\n.equ CLKCTRL_CLKSEL_EXTCLK_gc = (0x03<<0) ; External clock\n\n; Prescaler division select\n.equ CLKCTRL_PDIV_2X_gc = (0x00<<1)      ; 2X\n.equ CLKCTRL_PDIV_4X_gc = (0x01<<1)      ; 4X\n.equ CLKCTRL_PDIV_8X_gc = (0x02<<1)      ; 8X\n.equ CLKCTRL_PDIV_16X_gc = (0x03<<1)     ; 16X\n.equ CLKCTRL_PDIV_32X_gc = (0x04<<1)     ; 32X\n.equ CLKCTRL_PDIV_64X_gc = (0x05<<1)     ; 64X\n.equ CLKCTRL_PDIV_6X_gc = (0x08<<1)      ; 6X\n.equ CLKCTRL_PDIV_10X_gc = (0x09<<1)     ; 10X\n.equ CLKCTRL_PDIV_12X_gc = (0x0A<<1)     ; 12X\n.equ CLKCTRL_PDIV_24X_gc = (0x0B<<1)     ; 24X\n.equ CLKCTRL_PDIV_48X_gc = (0x0C<<1)     ; 48X\n\n; Crystal startup time select\n.equ CLKCTRL_CSUT_1K_gc = (0x00<<4)      ; 1K cycles\n.equ CLKCTRL_CSUT_16K_gc = (0x01<<4)     ; 16K cycles\n.equ CLKCTRL_CSUT_32K_gc = (0x02<<4)     ; 32K cycles\n.equ CLKCTRL_CSUT_64K_gc = (0x03<<4)     ; 64K cycles\n\n\n;*************************************************************************\n;** CPU - CPU\n;*************************************************************************\n\n; CPU_CCP masks\n.equ CPU_CCP_gm = 0xFF                   ; CCP signature group mask\n.equ CPU_CCP_gp = 0                      ; CCP signature group position\n.equ CPU_CCP0_bm = (1<<0)                ; CCP signature bit 0 mask\n.equ CPU_CCP0_bp = 0                     ; CCP signature bit 0 position\n.equ CPU_CCP1_bm = (1<<1)                ; CCP signature bit 1 mask\n.equ CPU_CCP1_bp = 1                     ; CCP signature bit 1 position\n.equ CPU_CCP2_bm = (1<<2)                ; CCP signature bit 2 mask\n.equ CPU_CCP2_bp = 2                     ; CCP signature bit 2 position\n.equ CPU_CCP3_bm = (1<<3)                ; CCP signature bit 3 mask\n.equ CPU_CCP3_bp = 3                     ; CCP signature bit 3 position\n.equ CPU_CCP4_bm = (1<<4)                ; CCP signature bit 4 mask\n.equ CPU_CCP4_bp = 4                     ; CCP signature bit 4 position\n.equ CPU_CCP5_bm = (1<<5)                ; CCP signature bit 5 mask\n.equ CPU_CCP5_bp = 5                     ; CCP signature bit 5 position\n.equ CPU_CCP6_bm = (1<<6)                ; CCP signature bit 6 mask\n.equ CPU_CCP6_bp = 6                     ; CCP signature bit 6 position\n.equ CPU_CCP7_bm = (1<<7)                ; CCP signature bit 7 mask\n.equ CPU_CCP7_bp = 7                     ; CCP signature bit 7 position\n\n; CPU_SREG masks\n.equ CPU_C_bm = 0x01                     ; Carry Flag bit mask\n.equ CPU_C_bp = 0                        ; Carry Flag bit position\n.equ CPU_H_bm = 0x20                     ; Half Carry Flag bit mask\n.equ CPU_H_bp = 5                        ; Half Carry Flag bit position\n.equ CPU_I_bm = 0x80                     ; Global Interrupt Enable Flag bit mask\n.equ CPU_I_bp = 7                        ; Global Interrupt Enable Flag bit position\n.equ CPU_N_bm = 0x04                     ; Negative Flag bit mask\n.equ CPU_N_bp = 2                        ; Negative Flag bit position\n.equ CPU_S_bm = 0x10                     ; N Exclusive Or V Flag bit mask\n.equ CPU_S_bp = 4                        ; N Exclusive Or V Flag bit position\n.equ CPU_T_bm = 0x40                     ; Transfer Bit bit mask\n.equ CPU_T_bp = 6                        ; Transfer Bit bit position\n.equ CPU_V_bm = 0x08                     ; Two's Complement Overflow Flag bit mask\n.equ CPU_V_bp = 3                        ; Two's Complement Overflow Flag bit position\n.equ CPU_Z_bm = 0x02                     ; Zero Flag bit mask\n.equ CPU_Z_bp = 1                        ; Zero Flag bit position\n\n; CCP signature select\n.equ CPU_CCP_SPM_gc = (0x9D<<0)          ; SPM Instruction Protection\n.equ CPU_CCP_IOREG_gc = (0xD8<<0)        ; IO Register Protection\n\n\n;*************************************************************************\n;** CPUINT - Interrupt Controller\n;*************************************************************************\n\n; CPUINT_CTRLA masks\n.equ CPUINT_CVT_bm = 0x20                ; Compact Vector Table bit mask\n.equ CPUINT_CVT_bp = 5                   ; Compact Vector Table bit position\n.equ CPUINT_IVSEL_bm = 0x40              ; Interrupt Vector Select bit mask\n.equ CPUINT_IVSEL_bp = 6                 ; Interrupt Vector Select bit position\n.equ CPUINT_LVL0RR_bm = 0x01             ; Round-robin Scheduling Enable bit mask\n.equ CPUINT_LVL0RR_bp = 0                ; Round-robin Scheduling Enable bit position\n\n; CPUINT_LVL0PRI masks\n.equ CPUINT_LVL0PRI_gm = 0xFF            ; Interrupt Level Priority group mask\n.equ CPUINT_LVL0PRI_gp = 0               ; Interrupt Level Priority group position\n.equ CPUINT_LVL0PRI0_bm = (1<<0)         ; Interrupt Level Priority bit 0 mask\n.equ CPUINT_LVL0PRI0_bp = 0              ; Interrupt Level Priority bit 0 position\n.equ CPUINT_LVL0PRI1_bm = (1<<1)         ; Interrupt Level Priority bit 1 mask\n.equ CPUINT_LVL0PRI1_bp = 1              ; Interrupt Level Priority bit 1 position\n.equ CPUINT_LVL0PRI2_bm = (1<<2)         ; Interrupt Level Priority bit 2 mask\n.equ CPUINT_LVL0PRI2_bp = 2              ; Interrupt Level Priority bit 2 position\n.equ CPUINT_LVL0PRI3_bm = (1<<3)         ; Interrupt Level Priority bit 3 mask\n.equ CPUINT_LVL0PRI3_bp = 3              ; Interrupt Level Priority bit 3 position\n.equ CPUINT_LVL0PRI4_bm = (1<<4)         ; Interrupt Level Priority bit 4 mask\n.equ CPUINT_LVL0PRI4_bp = 4              ; Interrupt Level Priority bit 4 position\n.equ CPUINT_LVL0PRI5_bm = (1<<5)         ; Interrupt Level Priority bit 5 mask\n.equ CPUINT_LVL0PRI5_bp = 5              ; Interrupt Level Priority bit 5 position\n.equ CPUINT_LVL0PRI6_bm = (1<<6)         ; Interrupt Level Priority bit 6 mask\n.equ CPUINT_LVL0PRI6_bp = 6              ; Interrupt Level Priority bit 6 position\n.equ CPUINT_LVL0PRI7_bm = (1<<7)         ; Interrupt Level Priority bit 7 mask\n.equ CPUINT_LVL0PRI7_bp = 7              ; Interrupt Level Priority bit 7 position\n\n; CPUINT_LVL1VEC masks\n.equ CPUINT_LVL1VEC_gm = 0xFF            ; Interrupt Vector with High Priority group mask\n.equ CPUINT_LVL1VEC_gp = 0               ; Interrupt Vector with High Priority group position\n.equ CPUINT_LVL1VEC0_bm = (1<<0)         ; Interrupt Vector with High Priority bit 0 mask\n.equ CPUINT_LVL1VEC0_bp = 0              ; Interrupt Vector with High Priority bit 0 position\n.equ CPUINT_LVL1VEC1_bm = (1<<1)         ; Interrupt Vector with High Priority bit 1 mask\n.equ CPUINT_LVL1VEC1_bp = 1              ; Interrupt Vector with High Priority bit 1 position\n.equ CPUINT_LVL1VEC2_bm = (1<<2)         ; Interrupt Vector with High Priority bit 2 mask\n.equ CPUINT_LVL1VEC2_bp = 2              ; Interrupt Vector with High Priority bit 2 position\n.equ CPUINT_LVL1VEC3_bm = (1<<3)         ; Interrupt Vector with High Priority bit 3 mask\n.equ CPUINT_LVL1VEC3_bp = 3              ; Interrupt Vector with High Priority bit 3 position\n.equ CPUINT_LVL1VEC4_bm = (1<<4)         ; Interrupt Vector with High Priority bit 4 mask\n.equ CPUINT_LVL1VEC4_bp = 4              ; Interrupt Vector with High Priority bit 4 position\n.equ CPUINT_LVL1VEC5_bm = (1<<5)         ; Interrupt Vector with High Priority bit 5 mask\n.equ CPUINT_LVL1VEC5_bp = 5              ; Interrupt Vector with High Priority bit 5 position\n.equ CPUINT_LVL1VEC6_bm = (1<<6)         ; Interrupt Vector with High Priority bit 6 mask\n.equ CPUINT_LVL1VEC6_bp = 6              ; Interrupt Vector with High Priority bit 6 position\n.equ CPUINT_LVL1VEC7_bm = (1<<7)         ; Interrupt Vector with High Priority bit 7 mask\n.equ CPUINT_LVL1VEC7_bp = 7              ; Interrupt Vector with High Priority bit 7 position\n\n; CPUINT_STATUS masks\n.equ CPUINT_LVL0EX_bm = 0x01             ; Level 0 Interrupt Executing bit mask\n.equ CPUINT_LVL0EX_bp = 0                ; Level 0 Interrupt Executing bit position\n.equ CPUINT_LVL1EX_bm = 0x02             ; Level 1 Interrupt Executing bit mask\n.equ CPUINT_LVL1EX_bp = 1                ; Level 1 Interrupt Executing bit position\n.equ CPUINT_NMIEX_bm = 0x80              ; Non-maskable Interrupt Executing bit mask\n.equ CPUINT_NMIEX_bp = 7                 ; Non-maskable Interrupt Executing bit position\n\n\n;*************************************************************************\n;** CRCSCAN - CRCSCAN\n;*************************************************************************\n\n; CRCSCAN_CTRLA masks\n.equ CRCSCAN_ENABLE_bm = 0x01            ; Enable CRC scan bit mask\n.equ CRCSCAN_ENABLE_bp = 0               ; Enable CRC scan bit position\n.equ CRCSCAN_NMIEN_bm = 0x02             ; Enable NMI Trigger bit mask\n.equ CRCSCAN_NMIEN_bp = 1                ; Enable NMI Trigger bit position\n.equ CRCSCAN_RESET_bm = 0x80             ; Reset CRC scan bit mask\n.equ CRCSCAN_RESET_bp = 7                ; Reset CRC scan bit position\n\n; CRCSCAN_CTRLB masks\n.equ CRCSCAN_MODE_gm = 0x30              ; CRC Flash Access Mode group mask\n.equ CRCSCAN_MODE_gp = 4                 ; CRC Flash Access Mode group position\n.equ CRCSCAN_MODE0_bm = (1<<4)           ; CRC Flash Access Mode bit 0 mask\n.equ CRCSCAN_MODE0_bp = 4                ; CRC Flash Access Mode bit 0 position\n.equ CRCSCAN_MODE1_bm = (1<<5)           ; CRC Flash Access Mode bit 1 mask\n.equ CRCSCAN_MODE1_bp = 5                ; CRC Flash Access Mode bit 1 position\n.equ CRCSCAN_SRC_gm = 0x03               ; CRC Source group mask\n.equ CRCSCAN_SRC_gp = 0                  ; CRC Source group position\n.equ CRCSCAN_SRC0_bm = (1<<0)            ; CRC Source bit 0 mask\n.equ CRCSCAN_SRC0_bp = 0                 ; CRC Source bit 0 position\n.equ CRCSCAN_SRC1_bm = (1<<1)            ; CRC Source bit 1 mask\n.equ CRCSCAN_SRC1_bp = 1                 ; CRC Source bit 1 position\n\n; CRCSCAN_STATUS masks\n.equ CRCSCAN_BUSY_bm = 0x01              ; CRC Busy bit mask\n.equ CRCSCAN_BUSY_bp = 0                 ; CRC Busy bit position\n.equ CRCSCAN_OK_bm = 0x02                ; CRC Ok bit mask\n.equ CRCSCAN_OK_bp = 1                   ; CRC Ok bit position\n\n; CRC Flash Access Mode select\n.equ CRCSCAN_MODE_PRIORITY_gc = (0x00<<4) ; Priority to flash\n.equ CRCSCAN_MODE_RESERVED_gc = (0x01<<4) ; Reserved\n.equ CRCSCAN_MODE_BACKGROUND_gc = (0x02<<4) ; Lowest priority to flash\n.equ CRCSCAN_MODE_CONTINUOUS_gc = (0x03<<4) ; Continuous checks in background\n\n; CRC Source select\n.equ CRCSCAN_SRC_FLASH_gc = (0x00<<0)    ; CRC on entire flash\n.equ CRCSCAN_SRC_APPLICATION_gc = (0x01<<0) ; CRC on boot and appl section of flash\n.equ CRCSCAN_SRC_BOOT_gc = (0x02<<0)     ; CRC on boot section of flash\n\n\n;*************************************************************************\n;** DAC - Digital to Analog Converter\n;*************************************************************************\n\n; DAC_CTRLA masks\n.equ DAC_ENABLE_bm = 0x01                ; DAC Enable bit mask\n.equ DAC_ENABLE_bp = 0                   ; DAC Enable bit position\n.equ DAC_OUTEN_bm = 0x40                 ; Output Buffer Enable bit mask\n.equ DAC_OUTEN_bp = 6                    ; Output Buffer Enable bit position\n.equ DAC_RUNSTDBY_bm = 0x80              ; Run in Standby Mode bit mask\n.equ DAC_RUNSTDBY_bp = 7                 ; Run in Standby Mode bit position\n\n\n;*************************************************************************\n;** EVSYS - Event System\n;*************************************************************************\n\n; EVSYS_ASYNCCH0 masks\n.equ EVSYS_ASYNCCH0_gm = 0xFF            ; Asynchronous Channel 0 Generator Selection group mask\n.equ EVSYS_ASYNCCH0_gp = 0               ; Asynchronous Channel 0 Generator Selection group position\n.equ EVSYS_ASYNCCH00_bm = (1<<0)         ; Asynchronous Channel 0 Generator Selection bit 0 mask\n.equ EVSYS_ASYNCCH00_bp = 0              ; Asynchronous Channel 0 Generator Selection bit 0 position\n.equ EVSYS_ASYNCCH01_bm = (1<<1)         ; Asynchronous Channel 0 Generator Selection bit 1 mask\n.equ EVSYS_ASYNCCH01_bp = 1              ; Asynchronous Channel 0 Generator Selection bit 1 position\n.equ EVSYS_ASYNCCH02_bm = (1<<2)         ; Asynchronous Channel 0 Generator Selection bit 2 mask\n.equ EVSYS_ASYNCCH02_bp = 2              ; Asynchronous Channel 0 Generator Selection bit 2 position\n.equ EVSYS_ASYNCCH03_bm = (1<<3)         ; Asynchronous Channel 0 Generator Selection bit 3 mask\n.equ EVSYS_ASYNCCH03_bp = 3              ; Asynchronous Channel 0 Generator Selection bit 3 position\n.equ EVSYS_ASYNCCH04_bm = (1<<4)         ; Asynchronous Channel 0 Generator Selection bit 4 mask\n.equ EVSYS_ASYNCCH04_bp = 4              ; Asynchronous Channel 0 Generator Selection bit 4 position\n.equ EVSYS_ASYNCCH05_bm = (1<<5)         ; Asynchronous Channel 0 Generator Selection bit 5 mask\n.equ EVSYS_ASYNCCH05_bp = 5              ; Asynchronous Channel 0 Generator Selection bit 5 position\n.equ EVSYS_ASYNCCH06_bm = (1<<6)         ; Asynchronous Channel 0 Generator Selection bit 6 mask\n.equ EVSYS_ASYNCCH06_bp = 6              ; Asynchronous Channel 0 Generator Selection bit 6 position\n.equ EVSYS_ASYNCCH07_bm = (1<<7)         ; Asynchronous Channel 0 Generator Selection bit 7 mask\n.equ EVSYS_ASYNCCH07_bp = 7              ; Asynchronous Channel 0 Generator Selection bit 7 position\n\n; EVSYS_ASYNCCH1 masks\n.equ EVSYS_ASYNCCH1_gm = 0xFF            ; Asynchronous Channel 1 Generator Selection group mask\n.equ EVSYS_ASYNCCH1_gp = 0               ; Asynchronous Channel 1 Generator Selection group position\n.equ EVSYS_ASYNCCH10_bm = (1<<0)         ; Asynchronous Channel 1 Generator Selection bit 0 mask\n.equ EVSYS_ASYNCCH10_bp = 0              ; Asynchronous Channel 1 Generator Selection bit 0 position\n.equ EVSYS_ASYNCCH11_bm = (1<<1)         ; Asynchronous Channel 1 Generator Selection bit 1 mask\n.equ EVSYS_ASYNCCH11_bp = 1              ; Asynchronous Channel 1 Generator Selection bit 1 position\n.equ EVSYS_ASYNCCH12_bm = (1<<2)         ; Asynchronous Channel 1 Generator Selection bit 2 mask\n.equ EVSYS_ASYNCCH12_bp = 2              ; Asynchronous Channel 1 Generator Selection bit 2 position\n.equ EVSYS_ASYNCCH13_bm = (1<<3)         ; Asynchronous Channel 1 Generator Selection bit 3 mask\n.equ EVSYS_ASYNCCH13_bp = 3              ; Asynchronous Channel 1 Generator Selection bit 3 position\n.equ EVSYS_ASYNCCH14_bm = (1<<4)         ; Asynchronous Channel 1 Generator Selection bit 4 mask\n.equ EVSYS_ASYNCCH14_bp = 4              ; Asynchronous Channel 1 Generator Selection bit 4 position\n.equ EVSYS_ASYNCCH15_bm = (1<<5)         ; Asynchronous Channel 1 Generator Selection bit 5 mask\n.equ EVSYS_ASYNCCH15_bp = 5              ; Asynchronous Channel 1 Generator Selection bit 5 position\n.equ EVSYS_ASYNCCH16_bm = (1<<6)         ; Asynchronous Channel 1 Generator Selection bit 6 mask\n.equ EVSYS_ASYNCCH16_bp = 6              ; Asynchronous Channel 1 Generator Selection bit 6 position\n.equ EVSYS_ASYNCCH17_bm = (1<<7)         ; Asynchronous Channel 1 Generator Selection bit 7 mask\n.equ EVSYS_ASYNCCH17_bp = 7              ; Asynchronous Channel 1 Generator Selection bit 7 position\n\n; EVSYS_ASYNCCH2 masks\n.equ EVSYS_ASYNCCH2_gm = 0xFF            ; Asynchronous Channel 2 Generator Selection group mask\n.equ EVSYS_ASYNCCH2_gp = 0               ; Asynchronous Channel 2 Generator Selection group position\n.equ EVSYS_ASYNCCH20_bm = (1<<0)         ; Asynchronous Channel 2 Generator Selection bit 0 mask\n.equ EVSYS_ASYNCCH20_bp = 0              ; Asynchronous Channel 2 Generator Selection bit 0 position\n.equ EVSYS_ASYNCCH21_bm = (1<<1)         ; Asynchronous Channel 2 Generator Selection bit 1 mask\n.equ EVSYS_ASYNCCH21_bp = 1              ; Asynchronous Channel 2 Generator Selection bit 1 position\n.equ EVSYS_ASYNCCH22_bm = (1<<2)         ; Asynchronous Channel 2 Generator Selection bit 2 mask\n.equ EVSYS_ASYNCCH22_bp = 2              ; Asynchronous Channel 2 Generator Selection bit 2 position\n.equ EVSYS_ASYNCCH23_bm = (1<<3)         ; Asynchronous Channel 2 Generator Selection bit 3 mask\n.equ EVSYS_ASYNCCH23_bp = 3              ; Asynchronous Channel 2 Generator Selection bit 3 position\n.equ EVSYS_ASYNCCH24_bm = (1<<4)         ; Asynchronous Channel 2 Generator Selection bit 4 mask\n.equ EVSYS_ASYNCCH24_bp = 4              ; Asynchronous Channel 2 Generator Selection bit 4 position\n.equ EVSYS_ASYNCCH25_bm = (1<<5)         ; Asynchronous Channel 2 Generator Selection bit 5 mask\n.equ EVSYS_ASYNCCH25_bp = 5              ; Asynchronous Channel 2 Generator Selection bit 5 position\n.equ EVSYS_ASYNCCH26_bm = (1<<6)         ; Asynchronous Channel 2 Generator Selection bit 6 mask\n.equ EVSYS_ASYNCCH26_bp = 6              ; Asynchronous Channel 2 Generator Selection bit 6 position\n.equ EVSYS_ASYNCCH27_bm = (1<<7)         ; Asynchronous Channel 2 Generator Selection bit 7 mask\n.equ EVSYS_ASYNCCH27_bp = 7              ; Asynchronous Channel 2 Generator Selection bit 7 position\n\n; EVSYS_ASYNCCH3 masks\n.equ EVSYS_ASYNCCH3_gm = 0xFF            ; Asynchronous Channel 3 Generator Selection group mask\n.equ EVSYS_ASYNCCH3_gp = 0               ; Asynchronous Channel 3 Generator Selection group position\n.equ EVSYS_ASYNCCH30_bm = (1<<0)         ; Asynchronous Channel 3 Generator Selection bit 0 mask\n.equ EVSYS_ASYNCCH30_bp = 0              ; Asynchronous Channel 3 Generator Selection bit 0 position\n.equ EVSYS_ASYNCCH31_bm = (1<<1)         ; Asynchronous Channel 3 Generator Selection bit 1 mask\n.equ EVSYS_ASYNCCH31_bp = 1              ; Asynchronous Channel 3 Generator Selection bit 1 position\n.equ EVSYS_ASYNCCH32_bm = (1<<2)         ; Asynchronous Channel 3 Generator Selection bit 2 mask\n.equ EVSYS_ASYNCCH32_bp = 2              ; Asynchronous Channel 3 Generator Selection bit 2 position\n.equ EVSYS_ASYNCCH33_bm = (1<<3)         ; Asynchronous Channel 3 Generator Selection bit 3 mask\n.equ EVSYS_ASYNCCH33_bp = 3              ; Asynchronous Channel 3 Generator Selection bit 3 position\n.equ EVSYS_ASYNCCH34_bm = (1<<4)         ; Asynchronous Channel 3 Generator Selection bit 4 mask\n.equ EVSYS_ASYNCCH34_bp = 4              ; Asynchronous Channel 3 Generator Selection bit 4 position\n.equ EVSYS_ASYNCCH35_bm = (1<<5)         ; Asynchronous Channel 3 Generator Selection bit 5 mask\n.equ EVSYS_ASYNCCH35_bp = 5              ; Asynchronous Channel 3 Generator Selection bit 5 position\n.equ EVSYS_ASYNCCH36_bm = (1<<6)         ; Asynchronous Channel 3 Generator Selection bit 6 mask\n.equ EVSYS_ASYNCCH36_bp = 6              ; Asynchronous Channel 3 Generator Selection bit 6 position\n.equ EVSYS_ASYNCCH37_bm = (1<<7)         ; Asynchronous Channel 3 Generator Selection bit 7 mask\n.equ EVSYS_ASYNCCH37_bp = 7              ; Asynchronous Channel 3 Generator Selection bit 7 position\n\n; EVSYS_ASYNCUSER0 masks\n.equ EVSYS_ASYNCUSER0_gm = 0xFF          ; Asynchronous User Ch 0 Input Selection - TCB0 group mask\n.equ EVSYS_ASYNCUSER0_gp = 0             ; Asynchronous User Ch 0 Input Selection - TCB0 group position\n.equ EVSYS_ASYNCUSER00_bm = (1<<0)       ; Asynchronous User Ch 0 Input Selection - TCB0 bit 0 mask\n.equ EVSYS_ASYNCUSER00_bp = 0            ; Asynchronous User Ch 0 Input Selection - TCB0 bit 0 position\n.equ EVSYS_ASYNCUSER01_bm = (1<<1)       ; Asynchronous User Ch 0 Input Selection - TCB0 bit 1 mask\n.equ EVSYS_ASYNCUSER01_bp = 1            ; Asynchronous User Ch 0 Input Selection - TCB0 bit 1 position\n.equ EVSYS_ASYNCUSER02_bm = (1<<2)       ; Asynchronous User Ch 0 Input Selection - TCB0 bit 2 mask\n.equ EVSYS_ASYNCUSER02_bp = 2            ; Asynchronous User Ch 0 Input Selection - TCB0 bit 2 position\n.equ EVSYS_ASYNCUSER03_bm = (1<<3)       ; Asynchronous User Ch 0 Input Selection - TCB0 bit 3 mask\n.equ EVSYS_ASYNCUSER03_bp = 3            ; Asynchronous User Ch 0 Input Selection - TCB0 bit 3 position\n.equ EVSYS_ASYNCUSER04_bm = (1<<4)       ; Asynchronous User Ch 0 Input Selection - TCB0 bit 4 mask\n.equ EVSYS_ASYNCUSER04_bp = 4            ; Asynchronous User Ch 0 Input Selection - TCB0 bit 4 position\n.equ EVSYS_ASYNCUSER05_bm = (1<<5)       ; Asynchronous User Ch 0 Input Selection - TCB0 bit 5 mask\n.equ EVSYS_ASYNCUSER05_bp = 5            ; Asynchronous User Ch 0 Input Selection - TCB0 bit 5 position\n.equ EVSYS_ASYNCUSER06_bm = (1<<6)       ; Asynchronous User Ch 0 Input Selection - TCB0 bit 6 mask\n.equ EVSYS_ASYNCUSER06_bp = 6            ; Asynchronous User Ch 0 Input Selection - TCB0 bit 6 position\n.equ EVSYS_ASYNCUSER07_bm = (1<<7)       ; Asynchronous User Ch 0 Input Selection - TCB0 bit 7 mask\n.equ EVSYS_ASYNCUSER07_bp = 7            ; Asynchronous User Ch 0 Input Selection - TCB0 bit 7 position\n\n; EVSYS_ASYNCUSER1 masks\n.equ EVSYS_ASYNCUSER1_gm = 0xFF          ; Asynchronous User Ch 1 Input Selection - ADC0 group mask\n.equ EVSYS_ASYNCUSER1_gp = 0             ; Asynchronous User Ch 1 Input Selection - ADC0 group position\n.equ EVSYS_ASYNCUSER10_bm = (1<<0)       ; Asynchronous User Ch 1 Input Selection - ADC0 bit 0 mask\n.equ EVSYS_ASYNCUSER10_bp = 0            ; Asynchronous User Ch 1 Input Selection - ADC0 bit 0 position\n.equ EVSYS_ASYNCUSER11_bm = (1<<1)       ; Asynchronous User Ch 1 Input Selection - ADC0 bit 1 mask\n.equ EVSYS_ASYNCUSER11_bp = 1            ; Asynchronous User Ch 1 Input Selection - ADC0 bit 1 position\n.equ EVSYS_ASYNCUSER12_bm = (1<<2)       ; Asynchronous User Ch 1 Input Selection - ADC0 bit 2 mask\n.equ EVSYS_ASYNCUSER12_bp = 2            ; Asynchronous User Ch 1 Input Selection - ADC0 bit 2 position\n.equ EVSYS_ASYNCUSER13_bm = (1<<3)       ; Asynchronous User Ch 1 Input Selection - ADC0 bit 3 mask\n.equ EVSYS_ASYNCUSER13_bp = 3            ; Asynchronous User Ch 1 Input Selection - ADC0 bit 3 position\n.equ EVSYS_ASYNCUSER14_bm = (1<<4)       ; Asynchronous User Ch 1 Input Selection - ADC0 bit 4 mask\n.equ EVSYS_ASYNCUSER14_bp = 4            ; Asynchronous User Ch 1 Input Selection - ADC0 bit 4 position\n.equ EVSYS_ASYNCUSER15_bm = (1<<5)       ; Asynchronous User Ch 1 Input Selection - ADC0 bit 5 mask\n.equ EVSYS_ASYNCUSER15_bp = 5            ; Asynchronous User Ch 1 Input Selection - ADC0 bit 5 position\n.equ EVSYS_ASYNCUSER16_bm = (1<<6)       ; Asynchronous User Ch 1 Input Selection - ADC0 bit 6 mask\n.equ EVSYS_ASYNCUSER16_bp = 6            ; Asynchronous User Ch 1 Input Selection - ADC0 bit 6 position\n.equ EVSYS_ASYNCUSER17_bm = (1<<7)       ; Asynchronous User Ch 1 Input Selection - ADC0 bit 7 mask\n.equ EVSYS_ASYNCUSER17_bp = 7            ; Asynchronous User Ch 1 Input Selection - ADC0 bit 7 position\n\n; EVSYS_ASYNCUSER2 masks\n.equ EVSYS_ASYNCUSER2_gm = 0xFF          ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 group mask\n.equ EVSYS_ASYNCUSER2_gp = 0             ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 group position\n.equ EVSYS_ASYNCUSER20_bm = (1<<0)       ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 0 mask\n.equ EVSYS_ASYNCUSER20_bp = 0            ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 0 position\n.equ EVSYS_ASYNCUSER21_bm = (1<<1)       ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 1 mask\n.equ EVSYS_ASYNCUSER21_bp = 1            ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 1 position\n.equ EVSYS_ASYNCUSER22_bm = (1<<2)       ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 2 mask\n.equ EVSYS_ASYNCUSER22_bp = 2            ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 2 position\n.equ EVSYS_ASYNCUSER23_bm = (1<<3)       ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 3 mask\n.equ EVSYS_ASYNCUSER23_bp = 3            ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 3 position\n.equ EVSYS_ASYNCUSER24_bm = (1<<4)       ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 4 mask\n.equ EVSYS_ASYNCUSER24_bp = 4            ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 4 position\n.equ EVSYS_ASYNCUSER25_bm = (1<<5)       ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 5 mask\n.equ EVSYS_ASYNCUSER25_bp = 5            ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 5 position\n.equ EVSYS_ASYNCUSER26_bm = (1<<6)       ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 6 mask\n.equ EVSYS_ASYNCUSER26_bp = 6            ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 6 position\n.equ EVSYS_ASYNCUSER27_bm = (1<<7)       ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 7 mask\n.equ EVSYS_ASYNCUSER27_bp = 7            ; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 bit 7 position\n\n; EVSYS_ASYNCUSER3 masks\n.equ EVSYS_ASYNCUSER3_gm = 0xFF          ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 group mask\n.equ EVSYS_ASYNCUSER3_gp = 0             ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 group position\n.equ EVSYS_ASYNCUSER30_bm = (1<<0)       ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 0 mask\n.equ EVSYS_ASYNCUSER30_bp = 0            ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 0 position\n.equ EVSYS_ASYNCUSER31_bm = (1<<1)       ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 1 mask\n.equ EVSYS_ASYNCUSER31_bp = 1            ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 1 position\n.equ EVSYS_ASYNCUSER32_bm = (1<<2)       ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 2 mask\n.equ EVSYS_ASYNCUSER32_bp = 2            ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 2 position\n.equ EVSYS_ASYNCUSER33_bm = (1<<3)       ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 3 mask\n.equ EVSYS_ASYNCUSER33_bp = 3            ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 3 position\n.equ EVSYS_ASYNCUSER34_bm = (1<<4)       ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 4 mask\n.equ EVSYS_ASYNCUSER34_bp = 4            ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 4 position\n.equ EVSYS_ASYNCUSER35_bm = (1<<5)       ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 5 mask\n.equ EVSYS_ASYNCUSER35_bp = 5            ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 5 position\n.equ EVSYS_ASYNCUSER36_bm = (1<<6)       ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 6 mask\n.equ EVSYS_ASYNCUSER36_bp = 6            ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 6 position\n.equ EVSYS_ASYNCUSER37_bm = (1<<7)       ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 7 mask\n.equ EVSYS_ASYNCUSER37_bp = 7            ; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 bit 7 position\n\n; EVSYS_ASYNCUSER4 masks\n.equ EVSYS_ASYNCUSER4_gm = 0xFF          ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 group mask\n.equ EVSYS_ASYNCUSER4_gp = 0             ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 group position\n.equ EVSYS_ASYNCUSER40_bm = (1<<0)       ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 0 mask\n.equ EVSYS_ASYNCUSER40_bp = 0            ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 0 position\n.equ EVSYS_ASYNCUSER41_bm = (1<<1)       ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 1 mask\n.equ EVSYS_ASYNCUSER41_bp = 1            ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 1 position\n.equ EVSYS_ASYNCUSER42_bm = (1<<2)       ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 2 mask\n.equ EVSYS_ASYNCUSER42_bp = 2            ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 2 position\n.equ EVSYS_ASYNCUSER43_bm = (1<<3)       ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 3 mask\n.equ EVSYS_ASYNCUSER43_bp = 3            ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 3 position\n.equ EVSYS_ASYNCUSER44_bm = (1<<4)       ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 4 mask\n.equ EVSYS_ASYNCUSER44_bp = 4            ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 4 position\n.equ EVSYS_ASYNCUSER45_bm = (1<<5)       ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 5 mask\n.equ EVSYS_ASYNCUSER45_bp = 5            ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 5 position\n.equ EVSYS_ASYNCUSER46_bm = (1<<6)       ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 6 mask\n.equ EVSYS_ASYNCUSER46_bp = 6            ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 6 position\n.equ EVSYS_ASYNCUSER47_bm = (1<<7)       ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 7 mask\n.equ EVSYS_ASYNCUSER47_bp = 7            ; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 bit 7 position\n\n; EVSYS_ASYNCUSER5 masks\n.equ EVSYS_ASYNCUSER5_gm = 0xFF          ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 group mask\n.equ EVSYS_ASYNCUSER5_gp = 0             ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 group position\n.equ EVSYS_ASYNCUSER50_bm = (1<<0)       ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 0 mask\n.equ EVSYS_ASYNCUSER50_bp = 0            ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 0 position\n.equ EVSYS_ASYNCUSER51_bm = (1<<1)       ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 1 mask\n.equ EVSYS_ASYNCUSER51_bp = 1            ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 1 position\n.equ EVSYS_ASYNCUSER52_bm = (1<<2)       ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 2 mask\n.equ EVSYS_ASYNCUSER52_bp = 2            ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 2 position\n.equ EVSYS_ASYNCUSER53_bm = (1<<3)       ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 3 mask\n.equ EVSYS_ASYNCUSER53_bp = 3            ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 3 position\n.equ EVSYS_ASYNCUSER54_bm = (1<<4)       ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 4 mask\n.equ EVSYS_ASYNCUSER54_bp = 4            ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 4 position\n.equ EVSYS_ASYNCUSER55_bm = (1<<5)       ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 5 mask\n.equ EVSYS_ASYNCUSER55_bp = 5            ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 5 position\n.equ EVSYS_ASYNCUSER56_bm = (1<<6)       ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 6 mask\n.equ EVSYS_ASYNCUSER56_bp = 6            ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 6 position\n.equ EVSYS_ASYNCUSER57_bm = (1<<7)       ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 7 mask\n.equ EVSYS_ASYNCUSER57_bp = 7            ; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 bit 7 position\n\n; EVSYS_ASYNCUSER6 masks\n.equ EVSYS_ASYNCUSER6_gm = 0xFF          ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 group mask\n.equ EVSYS_ASYNCUSER6_gp = 0             ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 group position\n.equ EVSYS_ASYNCUSER60_bm = (1<<0)       ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 0 mask\n.equ EVSYS_ASYNCUSER60_bp = 0            ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 0 position\n.equ EVSYS_ASYNCUSER61_bm = (1<<1)       ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 1 mask\n.equ EVSYS_ASYNCUSER61_bp = 1            ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 1 position\n.equ EVSYS_ASYNCUSER62_bm = (1<<2)       ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 2 mask\n.equ EVSYS_ASYNCUSER62_bp = 2            ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 2 position\n.equ EVSYS_ASYNCUSER63_bm = (1<<3)       ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 3 mask\n.equ EVSYS_ASYNCUSER63_bp = 3            ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 3 position\n.equ EVSYS_ASYNCUSER64_bm = (1<<4)       ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 4 mask\n.equ EVSYS_ASYNCUSER64_bp = 4            ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 4 position\n.equ EVSYS_ASYNCUSER65_bm = (1<<5)       ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 5 mask\n.equ EVSYS_ASYNCUSER65_bp = 5            ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 5 position\n.equ EVSYS_ASYNCUSER66_bm = (1<<6)       ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 6 mask\n.equ EVSYS_ASYNCUSER66_bp = 6            ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 6 position\n.equ EVSYS_ASYNCUSER67_bm = (1<<7)       ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 7 mask\n.equ EVSYS_ASYNCUSER67_bp = 7            ; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 bit 7 position\n\n; EVSYS_ASYNCUSER7 masks\n.equ EVSYS_ASYNCUSER7_gm = 0xFF          ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 group mask\n.equ EVSYS_ASYNCUSER7_gp = 0             ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 group position\n.equ EVSYS_ASYNCUSER70_bm = (1<<0)       ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 0 mask\n.equ EVSYS_ASYNCUSER70_bp = 0            ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 0 position\n.equ EVSYS_ASYNCUSER71_bm = (1<<1)       ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 1 mask\n.equ EVSYS_ASYNCUSER71_bp = 1            ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 1 position\n.equ EVSYS_ASYNCUSER72_bm = (1<<2)       ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 2 mask\n.equ EVSYS_ASYNCUSER72_bp = 2            ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 2 position\n.equ EVSYS_ASYNCUSER73_bm = (1<<3)       ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 3 mask\n.equ EVSYS_ASYNCUSER73_bp = 3            ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 3 position\n.equ EVSYS_ASYNCUSER74_bm = (1<<4)       ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 4 mask\n.equ EVSYS_ASYNCUSER74_bp = 4            ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 4 position\n.equ EVSYS_ASYNCUSER75_bm = (1<<5)       ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 5 mask\n.equ EVSYS_ASYNCUSER75_bp = 5            ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 5 position\n.equ EVSYS_ASYNCUSER76_bm = (1<<6)       ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 6 mask\n.equ EVSYS_ASYNCUSER76_bp = 6            ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 6 position\n.equ EVSYS_ASYNCUSER77_bm = (1<<7)       ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 7 mask\n.equ EVSYS_ASYNCUSER77_bp = 7            ; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 bit 7 position\n\n; EVSYS_ASYNCUSER8 masks\n.equ EVSYS_ASYNCUSER8_gm = 0xFF          ; Asynchronous User Ch 8 Input Selection - Event Out 0 group mask\n.equ EVSYS_ASYNCUSER8_gp = 0             ; Asynchronous User Ch 8 Input Selection - Event Out 0 group position\n.equ EVSYS_ASYNCUSER80_bm = (1<<0)       ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 0 mask\n.equ EVSYS_ASYNCUSER80_bp = 0            ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 0 position\n.equ EVSYS_ASYNCUSER81_bm = (1<<1)       ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 1 mask\n.equ EVSYS_ASYNCUSER81_bp = 1            ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 1 position\n.equ EVSYS_ASYNCUSER82_bm = (1<<2)       ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 2 mask\n.equ EVSYS_ASYNCUSER82_bp = 2            ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 2 position\n.equ EVSYS_ASYNCUSER83_bm = (1<<3)       ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 3 mask\n.equ EVSYS_ASYNCUSER83_bp = 3            ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 3 position\n.equ EVSYS_ASYNCUSER84_bm = (1<<4)       ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 4 mask\n.equ EVSYS_ASYNCUSER84_bp = 4            ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 4 position\n.equ EVSYS_ASYNCUSER85_bm = (1<<5)       ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 5 mask\n.equ EVSYS_ASYNCUSER85_bp = 5            ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 5 position\n.equ EVSYS_ASYNCUSER86_bm = (1<<6)       ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 6 mask\n.equ EVSYS_ASYNCUSER86_bp = 6            ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 6 position\n.equ EVSYS_ASYNCUSER87_bm = (1<<7)       ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 7 mask\n.equ EVSYS_ASYNCUSER87_bp = 7            ; Asynchronous User Ch 8 Input Selection - Event Out 0 bit 7 position\n\n; EVSYS_ASYNCUSER9 masks\n.equ EVSYS_ASYNCUSER9_gm = 0xFF          ; Asynchronous User Ch 9 Input Selection - Event Out 1 group mask\n.equ EVSYS_ASYNCUSER9_gp = 0             ; Asynchronous User Ch 9 Input Selection - Event Out 1 group position\n.equ EVSYS_ASYNCUSER90_bm = (1<<0)       ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 0 mask\n.equ EVSYS_ASYNCUSER90_bp = 0            ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 0 position\n.equ EVSYS_ASYNCUSER91_bm = (1<<1)       ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 1 mask\n.equ EVSYS_ASYNCUSER91_bp = 1            ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 1 position\n.equ EVSYS_ASYNCUSER92_bm = (1<<2)       ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 2 mask\n.equ EVSYS_ASYNCUSER92_bp = 2            ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 2 position\n.equ EVSYS_ASYNCUSER93_bm = (1<<3)       ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 3 mask\n.equ EVSYS_ASYNCUSER93_bp = 3            ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 3 position\n.equ EVSYS_ASYNCUSER94_bm = (1<<4)       ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 4 mask\n.equ EVSYS_ASYNCUSER94_bp = 4            ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 4 position\n.equ EVSYS_ASYNCUSER95_bm = (1<<5)       ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 5 mask\n.equ EVSYS_ASYNCUSER95_bp = 5            ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 5 position\n.equ EVSYS_ASYNCUSER96_bm = (1<<6)       ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 6 mask\n.equ EVSYS_ASYNCUSER96_bp = 6            ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 6 position\n.equ EVSYS_ASYNCUSER97_bm = (1<<7)       ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 7 mask\n.equ EVSYS_ASYNCUSER97_bp = 7            ; Asynchronous User Ch 9 Input Selection - Event Out 1 bit 7 position\n\n; EVSYS_ASYNCUSER10 masks\n.equ EVSYS_ASYNCUSER10_gm = 0xFF         ; Asynchronous User Ch 10 Input Selection - Event Out 2 group mask\n.equ EVSYS_ASYNCUSER10_gp = 0            ; Asynchronous User Ch 10 Input Selection - Event Out 2 group position\n.equ EVSYS_ASYNCUSER100_bm = (1<<0)      ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 0 mask\n.equ EVSYS_ASYNCUSER100_bp = 0           ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 0 position\n.equ EVSYS_ASYNCUSER101_bm = (1<<1)      ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 1 mask\n.equ EVSYS_ASYNCUSER101_bp = 1           ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 1 position\n.equ EVSYS_ASYNCUSER102_bm = (1<<2)      ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 2 mask\n.equ EVSYS_ASYNCUSER102_bp = 2           ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 2 position\n.equ EVSYS_ASYNCUSER103_bm = (1<<3)      ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 3 mask\n.equ EVSYS_ASYNCUSER103_bp = 3           ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 3 position\n.equ EVSYS_ASYNCUSER104_bm = (1<<4)      ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 4 mask\n.equ EVSYS_ASYNCUSER104_bp = 4           ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 4 position\n.equ EVSYS_ASYNCUSER105_bm = (1<<5)      ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 5 mask\n.equ EVSYS_ASYNCUSER105_bp = 5           ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 5 position\n.equ EVSYS_ASYNCUSER106_bm = (1<<6)      ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 6 mask\n.equ EVSYS_ASYNCUSER106_bp = 6           ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 6 position\n.equ EVSYS_ASYNCUSER107_bm = (1<<7)      ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 7 mask\n.equ EVSYS_ASYNCUSER107_bp = 7           ; Asynchronous User Ch 10 Input Selection - Event Out 2 bit 7 position\n\n; EVSYS_ASYNCUSER11 masks\n.equ EVSYS_ASYNCUSER11_gm = 0xFF         ; Asynchronous User Ch 11 Input Selection - TCB1 group mask\n.equ EVSYS_ASYNCUSER11_gp = 0            ; Asynchronous User Ch 11 Input Selection - TCB1 group position\n.equ EVSYS_ASYNCUSER110_bm = (1<<0)      ; Asynchronous User Ch 11 Input Selection - TCB1 bit 0 mask\n.equ EVSYS_ASYNCUSER110_bp = 0           ; Asynchronous User Ch 11 Input Selection - TCB1 bit 0 position\n.equ EVSYS_ASYNCUSER111_bm = (1<<1)      ; Asynchronous User Ch 11 Input Selection - TCB1 bit 1 mask\n.equ EVSYS_ASYNCUSER111_bp = 1           ; Asynchronous User Ch 11 Input Selection - TCB1 bit 1 position\n.equ EVSYS_ASYNCUSER112_bm = (1<<2)      ; Asynchronous User Ch 11 Input Selection - TCB1 bit 2 mask\n.equ EVSYS_ASYNCUSER112_bp = 2           ; Asynchronous User Ch 11 Input Selection - TCB1 bit 2 position\n.equ EVSYS_ASYNCUSER113_bm = (1<<3)      ; Asynchronous User Ch 11 Input Selection - TCB1 bit 3 mask\n.equ EVSYS_ASYNCUSER113_bp = 3           ; Asynchronous User Ch 11 Input Selection - TCB1 bit 3 position\n.equ EVSYS_ASYNCUSER114_bm = (1<<4)      ; Asynchronous User Ch 11 Input Selection - TCB1 bit 4 mask\n.equ EVSYS_ASYNCUSER114_bp = 4           ; Asynchronous User Ch 11 Input Selection - TCB1 bit 4 position\n.equ EVSYS_ASYNCUSER115_bm = (1<<5)      ; Asynchronous User Ch 11 Input Selection - TCB1 bit 5 mask\n.equ EVSYS_ASYNCUSER115_bp = 5           ; Asynchronous User Ch 11 Input Selection - TCB1 bit 5 position\n.equ EVSYS_ASYNCUSER116_bm = (1<<6)      ; Asynchronous User Ch 11 Input Selection - TCB1 bit 6 mask\n.equ EVSYS_ASYNCUSER116_bp = 6           ; Asynchronous User Ch 11 Input Selection - TCB1 bit 6 position\n.equ EVSYS_ASYNCUSER117_bm = (1<<7)      ; Asynchronous User Ch 11 Input Selection - TCB1 bit 7 mask\n.equ EVSYS_ASYNCUSER117_bp = 7           ; Asynchronous User Ch 11 Input Selection - TCB1 bit 7 position\n\n; EVSYS_ASYNCUSER12 masks\n.equ EVSYS_ASYNCUSER12_gm = 0xFF         ; Asynchronous User Ch 12 Input Selection - ADC0 group mask\n.equ EVSYS_ASYNCUSER12_gp = 0            ; Asynchronous User Ch 12 Input Selection - ADC0 group position\n.equ EVSYS_ASYNCUSER120_bm = (1<<0)      ; Asynchronous User Ch 12 Input Selection - ADC0 bit 0 mask\n.equ EVSYS_ASYNCUSER120_bp = 0           ; Asynchronous User Ch 12 Input Selection - ADC0 bit 0 position\n.equ EVSYS_ASYNCUSER121_bm = (1<<1)      ; Asynchronous User Ch 12 Input Selection - ADC0 bit 1 mask\n.equ EVSYS_ASYNCUSER121_bp = 1           ; Asynchronous User Ch 12 Input Selection - ADC0 bit 1 position\n.equ EVSYS_ASYNCUSER122_bm = (1<<2)      ; Asynchronous User Ch 12 Input Selection - ADC0 bit 2 mask\n.equ EVSYS_ASYNCUSER122_bp = 2           ; Asynchronous User Ch 12 Input Selection - ADC0 bit 2 position\n.equ EVSYS_ASYNCUSER123_bm = (1<<3)      ; Asynchronous User Ch 12 Input Selection - ADC0 bit 3 mask\n.equ EVSYS_ASYNCUSER123_bp = 3           ; Asynchronous User Ch 12 Input Selection - ADC0 bit 3 position\n.equ EVSYS_ASYNCUSER124_bm = (1<<4)      ; Asynchronous User Ch 12 Input Selection - ADC0 bit 4 mask\n.equ EVSYS_ASYNCUSER124_bp = 4           ; Asynchronous User Ch 12 Input Selection - ADC0 bit 4 position\n.equ EVSYS_ASYNCUSER125_bm = (1<<5)      ; Asynchronous User Ch 12 Input Selection - ADC0 bit 5 mask\n.equ EVSYS_ASYNCUSER125_bp = 5           ; Asynchronous User Ch 12 Input Selection - ADC0 bit 5 position\n.equ EVSYS_ASYNCUSER126_bm = (1<<6)      ; Asynchronous User Ch 12 Input Selection - ADC0 bit 6 mask\n.equ EVSYS_ASYNCUSER126_bp = 6           ; Asynchronous User Ch 12 Input Selection - ADC0 bit 6 position\n.equ EVSYS_ASYNCUSER127_bm = (1<<7)      ; Asynchronous User Ch 12 Input Selection - ADC0 bit 7 mask\n.equ EVSYS_ASYNCUSER127_bp = 7           ; Asynchronous User Ch 12 Input Selection - ADC0 bit 7 position\n\n; EVSYS_SYNCCH0 masks\n.equ EVSYS_SYNCCH0_gm = 0xFF             ; Synchronous Channel 0 Generator Selection group mask\n.equ EVSYS_SYNCCH0_gp = 0                ; Synchronous Channel 0 Generator Selection group position\n.equ EVSYS_SYNCCH00_bm = (1<<0)          ; Synchronous Channel 0 Generator Selection bit 0 mask\n.equ EVSYS_SYNCCH00_bp = 0               ; Synchronous Channel 0 Generator Selection bit 0 position\n.equ EVSYS_SYNCCH01_bm = (1<<1)          ; Synchronous Channel 0 Generator Selection bit 1 mask\n.equ EVSYS_SYNCCH01_bp = 1               ; Synchronous Channel 0 Generator Selection bit 1 position\n.equ EVSYS_SYNCCH02_bm = (1<<2)          ; Synchronous Channel 0 Generator Selection bit 2 mask\n.equ EVSYS_SYNCCH02_bp = 2               ; Synchronous Channel 0 Generator Selection bit 2 position\n.equ EVSYS_SYNCCH03_bm = (1<<3)          ; Synchronous Channel 0 Generator Selection bit 3 mask\n.equ EVSYS_SYNCCH03_bp = 3               ; Synchronous Channel 0 Generator Selection bit 3 position\n.equ EVSYS_SYNCCH04_bm = (1<<4)          ; Synchronous Channel 0 Generator Selection bit 4 mask\n.equ EVSYS_SYNCCH04_bp = 4               ; Synchronous Channel 0 Generator Selection bit 4 position\n.equ EVSYS_SYNCCH05_bm = (1<<5)          ; Synchronous Channel 0 Generator Selection bit 5 mask\n.equ EVSYS_SYNCCH05_bp = 5               ; Synchronous Channel 0 Generator Selection bit 5 position\n.equ EVSYS_SYNCCH06_bm = (1<<6)          ; Synchronous Channel 0 Generator Selection bit 6 mask\n.equ EVSYS_SYNCCH06_bp = 6               ; Synchronous Channel 0 Generator Selection bit 6 position\n.equ EVSYS_SYNCCH07_bm = (1<<7)          ; Synchronous Channel 0 Generator Selection bit 7 mask\n.equ EVSYS_SYNCCH07_bp = 7               ; Synchronous Channel 0 Generator Selection bit 7 position\n\n; EVSYS_SYNCCH1 masks\n.equ EVSYS_SYNCCH1_gm = 0xFF             ; Synchronous Channel 1 Generator Selection group mask\n.equ EVSYS_SYNCCH1_gp = 0                ; Synchronous Channel 1 Generator Selection group position\n.equ EVSYS_SYNCCH10_bm = (1<<0)          ; Synchronous Channel 1 Generator Selection bit 0 mask\n.equ EVSYS_SYNCCH10_bp = 0               ; Synchronous Channel 1 Generator Selection bit 0 position\n.equ EVSYS_SYNCCH11_bm = (1<<1)          ; Synchronous Channel 1 Generator Selection bit 1 mask\n.equ EVSYS_SYNCCH11_bp = 1               ; Synchronous Channel 1 Generator Selection bit 1 position\n.equ EVSYS_SYNCCH12_bm = (1<<2)          ; Synchronous Channel 1 Generator Selection bit 2 mask\n.equ EVSYS_SYNCCH12_bp = 2               ; Synchronous Channel 1 Generator Selection bit 2 position\n.equ EVSYS_SYNCCH13_bm = (1<<3)          ; Synchronous Channel 1 Generator Selection bit 3 mask\n.equ EVSYS_SYNCCH13_bp = 3               ; Synchronous Channel 1 Generator Selection bit 3 position\n.equ EVSYS_SYNCCH14_bm = (1<<4)          ; Synchronous Channel 1 Generator Selection bit 4 mask\n.equ EVSYS_SYNCCH14_bp = 4               ; Synchronous Channel 1 Generator Selection bit 4 position\n.equ EVSYS_SYNCCH15_bm = (1<<5)          ; Synchronous Channel 1 Generator Selection bit 5 mask\n.equ EVSYS_SYNCCH15_bp = 5               ; Synchronous Channel 1 Generator Selection bit 5 position\n.equ EVSYS_SYNCCH16_bm = (1<<6)          ; Synchronous Channel 1 Generator Selection bit 6 mask\n.equ EVSYS_SYNCCH16_bp = 6               ; Synchronous Channel 1 Generator Selection bit 6 position\n.equ EVSYS_SYNCCH17_bm = (1<<7)          ; Synchronous Channel 1 Generator Selection bit 7 mask\n.equ EVSYS_SYNCCH17_bp = 7               ; Synchronous Channel 1 Generator Selection bit 7 position\n\n; EVSYS_SYNCUSER0 masks\n.equ EVSYS_SYNCUSER0_gm = 0xFF           ; Synchronous User Ch 0 - TCA0 group mask\n.equ EVSYS_SYNCUSER0_gp = 0              ; Synchronous User Ch 0 - TCA0 group position\n.equ EVSYS_SYNCUSER00_bm = (1<<0)        ; Synchronous User Ch 0 - TCA0 bit 0 mask\n.equ EVSYS_SYNCUSER00_bp = 0             ; Synchronous User Ch 0 - TCA0 bit 0 position\n.equ EVSYS_SYNCUSER01_bm = (1<<1)        ; Synchronous User Ch 0 - TCA0 bit 1 mask\n.equ EVSYS_SYNCUSER01_bp = 1             ; Synchronous User Ch 0 - TCA0 bit 1 position\n.equ EVSYS_SYNCUSER02_bm = (1<<2)        ; Synchronous User Ch 0 - TCA0 bit 2 mask\n.equ EVSYS_SYNCUSER02_bp = 2             ; Synchronous User Ch 0 - TCA0 bit 2 position\n.equ EVSYS_SYNCUSER03_bm = (1<<3)        ; Synchronous User Ch 0 - TCA0 bit 3 mask\n.equ EVSYS_SYNCUSER03_bp = 3             ; Synchronous User Ch 0 - TCA0 bit 3 position\n.equ EVSYS_SYNCUSER04_bm = (1<<4)        ; Synchronous User Ch 0 - TCA0 bit 4 mask\n.equ EVSYS_SYNCUSER04_bp = 4             ; Synchronous User Ch 0 - TCA0 bit 4 position\n.equ EVSYS_SYNCUSER05_bm = (1<<5)        ; Synchronous User Ch 0 - TCA0 bit 5 mask\n.equ EVSYS_SYNCUSER05_bp = 5             ; Synchronous User Ch 0 - TCA0 bit 5 position\n.equ EVSYS_SYNCUSER06_bm = (1<<6)        ; Synchronous User Ch 0 - TCA0 bit 6 mask\n.equ EVSYS_SYNCUSER06_bp = 6             ; Synchronous User Ch 0 - TCA0 bit 6 position\n.equ EVSYS_SYNCUSER07_bm = (1<<7)        ; Synchronous User Ch 0 - TCA0 bit 7 mask\n.equ EVSYS_SYNCUSER07_bp = 7             ; Synchronous User Ch 0 - TCA0 bit 7 position\n\n; EVSYS_SYNCUSER1 masks\n.equ EVSYS_SYNCUSER1_gm = 0xFF           ; Synchronous User Ch 1 - USART0 group mask\n.equ EVSYS_SYNCUSER1_gp = 0              ; Synchronous User Ch 1 - USART0 group position\n.equ EVSYS_SYNCUSER10_bm = (1<<0)        ; Synchronous User Ch 1 - USART0 bit 0 mask\n.equ EVSYS_SYNCUSER10_bp = 0             ; Synchronous User Ch 1 - USART0 bit 0 position\n.equ EVSYS_SYNCUSER11_bm = (1<<1)        ; Synchronous User Ch 1 - USART0 bit 1 mask\n.equ EVSYS_SYNCUSER11_bp = 1             ; Synchronous User Ch 1 - USART0 bit 1 position\n.equ EVSYS_SYNCUSER12_bm = (1<<2)        ; Synchronous User Ch 1 - USART0 bit 2 mask\n.equ EVSYS_SYNCUSER12_bp = 2             ; Synchronous User Ch 1 - USART0 bit 2 position\n.equ EVSYS_SYNCUSER13_bm = (1<<3)        ; Synchronous User Ch 1 - USART0 bit 3 mask\n.equ EVSYS_SYNCUSER13_bp = 3             ; Synchronous User Ch 1 - USART0 bit 3 position\n.equ EVSYS_SYNCUSER14_bm = (1<<4)        ; Synchronous User Ch 1 - USART0 bit 4 mask\n.equ EVSYS_SYNCUSER14_bp = 4             ; Synchronous User Ch 1 - USART0 bit 4 position\n.equ EVSYS_SYNCUSER15_bm = (1<<5)        ; Synchronous User Ch 1 - USART0 bit 5 mask\n.equ EVSYS_SYNCUSER15_bp = 5             ; Synchronous User Ch 1 - USART0 bit 5 position\n.equ EVSYS_SYNCUSER16_bm = (1<<6)        ; Synchronous User Ch 1 - USART0 bit 6 mask\n.equ EVSYS_SYNCUSER16_bp = 6             ; Synchronous User Ch 1 - USART0 bit 6 position\n.equ EVSYS_SYNCUSER17_bm = (1<<7)        ; Synchronous User Ch 1 - USART0 bit 7 mask\n.equ EVSYS_SYNCUSER17_bp = 7             ; Synchronous User Ch 1 - USART0 bit 7 position\n\n; Asynchronous Channel 0 Generator Selection select\n.equ EVSYS_ASYNCCH0_OFF_gc = (0x00<<0)   ; Off\n.equ EVSYS_ASYNCCH0_CCL_LUT0_gc = (0x01<<0) ; Configurable Custom Logic LUT0\n.equ EVSYS_ASYNCCH0_CCL_LUT1_gc = (0x02<<0) ; Configurable Custom Logic LUT1\n.equ EVSYS_ASYNCCH0_AC0_OUT_gc = (0x03<<0) ; Analog Comparator 0 out\n.equ EVSYS_ASYNCCH0_TCD0_CMPBCLR_gc = (0x04<<0) ; Timer/Counter D0 compare B clear\n.equ EVSYS_ASYNCCH0_TCD0_CMPASET_gc = (0x05<<0) ; Timer/Counter D0 compare A set\n.equ EVSYS_ASYNCCH0_TCD0_CMPBSET_gc = (0x06<<0) ; Timer/Counter D0 compare B set\n.equ EVSYS_ASYNCCH0_TCD0_PROGEV_gc = (0x07<<0) ; Timer/Counter D0 program event\n.equ EVSYS_ASYNCCH0_RTC_OVF_gc = (0x08<<0) ; Real Time Counter overflow\n.equ EVSYS_ASYNCCH0_RTC_CMP_gc = (0x09<<0) ; Real Time Counter compare\n.equ EVSYS_ASYNCCH0_PORTA_PIN0_gc = (0x0A<<0) ; Asynchronous Event from Pin PA0\n.equ EVSYS_ASYNCCH0_PORTA_PIN1_gc = (0x0B<<0) ; Asynchronous Event from Pin PA1\n.equ EVSYS_ASYNCCH0_PORTA_PIN2_gc = (0x0C<<0) ; Asynchronous Event from Pin PA2\n.equ EVSYS_ASYNCCH0_PORTA_PIN3_gc = (0x0D<<0) ; Asynchronous Event from Pin PA3\n.equ EVSYS_ASYNCCH0_PORTA_PIN4_gc = (0x0E<<0) ; Asynchronous Event from Pin PA4\n.equ EVSYS_ASYNCCH0_PORTA_PIN5_gc = (0x0F<<0) ; Asynchronous Event from Pin PA5\n.equ EVSYS_ASYNCCH0_PORTA_PIN6_gc = (0x10<<0) ; Asynchronous Event from Pin PA6\n.equ EVSYS_ASYNCCH0_PORTA_PIN7_gc = (0x11<<0) ; Asynchronous Event from Pin PA7\n.equ EVSYS_ASYNCCH0_UPDI_gc = (0x12<<0)  ; Unified Program and debug interface\n.equ EVSYS_ASYNCCH0_AC1_OUT_gc = (0x13<<0) ; Analog Comparator 1 out\n.equ EVSYS_ASYNCCH0_AC2_OUT_gc = (0x14<<0) ; Analog Comparator 2 out\n\n; Asynchronous Channel 1 Generator Selection select\n.equ EVSYS_ASYNCCH1_OFF_gc = (0x00<<0)   ; Off\n.equ EVSYS_ASYNCCH1_CCL_LUT0_gc = (0x01<<0) ; Configurable custom logic LUT0\n.equ EVSYS_ASYNCCH1_CCL_LUT1_gc = (0x02<<0) ; Configurable custom logic LUT1\n.equ EVSYS_ASYNCCH1_AC0_OUT_gc = (0x03<<0) ; Analog Comparator 0 out\n.equ EVSYS_ASYNCCH1_TCD0_CMPBCLR_gc = (0x04<<0) ; Timer/Counter D0 compare B clear\n.equ EVSYS_ASYNCCH1_TCD0_CMPASET_gc = (0x05<<0) ; Timer/Counter D0 compare A set\n.equ EVSYS_ASYNCCH1_TCD0_CMPBSET_gc = (0x06<<0) ; Timer/Counter D0 compare B set\n.equ EVSYS_ASYNCCH1_TCD0_PROGEV_gc = (0x07<<0) ; Timer/Counter D0 program event\n.equ EVSYS_ASYNCCH1_RTC_OVF_gc = (0x08<<0) ; Real Time Counter overflow\n.equ EVSYS_ASYNCCH1_RTC_CMP_gc = (0x09<<0) ; Real Time Counter compare\n.equ EVSYS_ASYNCCH1_PORTB_PIN0_gc = (0x0A<<0) ; Asynchronous Event from Pin PB0\n.equ EVSYS_ASYNCCH1_PORTB_PIN1_gc = (0x0B<<0) ; Asynchronous Event from Pin PB1\n.equ EVSYS_ASYNCCH1_PORTB_PIN2_gc = (0x0C<<0) ; Asynchronous Event from Pin PB2\n.equ EVSYS_ASYNCCH1_PORTB_PIN3_gc = (0x0D<<0) ; Asynchronous Event from Pin PB3\n.equ EVSYS_ASYNCCH1_PORTB_PIN4_gc = (0x0E<<0) ; Asynchronous Event from Pin PB4\n.equ EVSYS_ASYNCCH1_PORTB_PIN5_gc = (0x0F<<0) ; Asynchronous Event from Pin PB5\n.equ EVSYS_ASYNCCH1_PORTB_PIN6_gc = (0x10<<0) ; Asynchronous Event from Pin PB6\n.equ EVSYS_ASYNCCH1_PORTB_PIN7_gc = (0x11<<0) ; Asynchronous Event from Pin PB7\n.equ EVSYS_ASYNCCH1_AC1_OUT_gc = (0x12<<0) ; Analog Comparator 1 out\n.equ EVSYS_ASYNCCH1_AC2_OUT_gc = (0x13<<0) ; Analog Comparator 2 out\n\n; Asynchronous Channel 2 Generator Selection select\n.equ EVSYS_ASYNCCH2_OFF_gc = (0x00<<0)   ; Off\n.equ EVSYS_ASYNCCH2_CCL_LUT0_gc = (0x01<<0) ; Configurable Custom Logic LUT0\n.equ EVSYS_ASYNCCH2_CCL_LUT1_gc = (0x02<<0) ; Configurable Custom Logic LUT1\n.equ EVSYS_ASYNCCH2_AC0_OUT_gc = (0x03<<0) ; Analog Comparator 0 out\n.equ EVSYS_ASYNCCH2_TCD0_CMPBCLR_gc = (0x04<<0) ; Timer/Counter D0 compare B clear\n.equ EVSYS_ASYNCCH2_TCD0_CMPASET_gc = (0x05<<0) ; Timer/Counter D0 compare A set\n.equ EVSYS_ASYNCCH2_TCD0_CMPBSET_gc = (0x06<<0) ; Timer/Counter D0 compare B set\n.equ EVSYS_ASYNCCH2_TCD0_PROGEV_gc = (0x07<<0) ; Timer/Counter D0 program event\n.equ EVSYS_ASYNCCH2_RTC_OVF_gc = (0x08<<0) ; Real Time Counter overflow\n.equ EVSYS_ASYNCCH2_RTC_CMP_gc = (0x09<<0) ; Real Time Counter compare\n.equ EVSYS_ASYNCCH2_PORTC_PIN0_gc = (0x0A<<0) ; Asynchronous Event from Pin PC0\n.equ EVSYS_ASYNCCH2_PORTC_PIN1_gc = (0x0B<<0) ; Asynchronous Event from Pin PC1\n.equ EVSYS_ASYNCCH2_PORTC_PIN2_gc = (0x0C<<0) ; Asynchronous Event from Pin PC2\n.equ EVSYS_ASYNCCH2_PORTC_PIN3_gc = (0x0D<<0) ; Asynchronous Event from Pin PC3\n.equ EVSYS_ASYNCCH2_PORTC_PIN4_gc = (0x0E<<0) ; Asynchronous Event from Pin PC4\n.equ EVSYS_ASYNCCH2_PORTC_PIN5_gc = (0x0F<<0) ; Asynchronous Event from Pin PC5\n.equ EVSYS_ASYNCCH2_AC1_OUT_gc = (0x10<<0) ; Analog Comparator 1 out\n.equ EVSYS_ASYNCCH2_AC2_OUT_gc = (0x11<<0) ; Analog Comparator 2 out\n\n; Asynchronous Channel 3 Generator Selection select\n.equ EVSYS_ASYNCCH3_OFF_gc = (0x00<<0)   ; Off\n.equ EVSYS_ASYNCCH3_CCL_LUT0_gc = (0x01<<0) ; Configurable custom logic LUT0\n.equ EVSYS_ASYNCCH3_CCL_LUT1_gc = (0x02<<0) ; Configurable custom logic LUT1\n.equ EVSYS_ASYNCCH3_AC0_OUT_gc = (0x03<<0) ; Analog Comparator 0 out\n.equ EVSYS_ASYNCCH3_TCD0_CMPBCLR_gc = (0x04<<0) ; Timer/Counter type D compare B clear\n.equ EVSYS_ASYNCCH3_TCD0_CMPASET_gc = (0x05<<0) ; Timer/Counter type D compare A set\n.equ EVSYS_ASYNCCH3_TCD0_CMPBSET_gc = (0x06<<0) ; Timer/Counter type D compare B set\n.equ EVSYS_ASYNCCH3_TCD0_PROGEV_gc = (0x07<<0) ; Timer/Counter type D program event\n.equ EVSYS_ASYNCCH3_RTC_OVF_gc = (0x08<<0) ; Real Time Counter overflow\n.equ EVSYS_ASYNCCH3_RTC_CMP_gc = (0x09<<0) ; Real Time Counter compare\n.equ EVSYS_ASYNCCH3_PIT_DIV8192_gc = (0x0A<<0) ; Periodic Interrupt CLK_RTC div 8192\n.equ EVSYS_ASYNCCH3_PIT_DIV4096_gc = (0x0B<<0) ; Periodic Interrupt CLK_RTC div 4096\n.equ EVSYS_ASYNCCH3_PIT_DIV2048_gc = (0x0C<<0) ; Periodic Interrupt CLK_RTC div 2048\n.equ EVSYS_ASYNCCH3_PIT_DIV1024_gc = (0x0D<<0) ; Periodic Interrupt CLK_RTC div 1024\n.equ EVSYS_ASYNCCH3_PIT_DIV512_gc = (0x0E<<0) ; Periodic Interrupt CLK_RTC div 512\n.equ EVSYS_ASYNCCH3_PIT_DIV256_gc = (0x0F<<0) ; Periodic Interrupt CLK_RTC div 256\n.equ EVSYS_ASYNCCH3_PIT_DIV128_gc = (0x10<<0) ; Periodic Interrupt CLK_RTC div 128\n.equ EVSYS_ASYNCCH3_PIT_DIV64_gc = (0x11<<0) ; Periodic Interrupt CLK_RTC div 64\n.equ EVSYS_ASYNCCH3_AC1_OUT_gc = (0x12<<0) ; Analog Comparator 1 out\n.equ EVSYS_ASYNCCH3_AC2_OUT_gc = (0x13<<0) ; Analog Comparator 2 out\n\n; Asynchronous User Ch 0 Input Selection - TCB0 select\n.equ EVSYS_ASYNCUSER0_OFF_gc = (0x00<<0) ; Off\n.equ EVSYS_ASYNCUSER0_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_ASYNCUSER0_SYNCCH1_gc = (0x02<<0) ; Synchronous Event Channel 1\n.equ EVSYS_ASYNCUSER0_ASYNCCH0_gc = (0x03<<0) ; Asynchronous Event Channel 0\n.equ EVSYS_ASYNCUSER0_ASYNCCH1_gc = (0x04<<0) ; Asynchronous Event Channel 1\n.equ EVSYS_ASYNCUSER0_ASYNCCH2_gc = (0x05<<0) ; Asynchronous Event Channel 2\n.equ EVSYS_ASYNCUSER0_ASYNCCH3_gc = (0x06<<0) ; Asynchronous Event Channel 3\n\n; Asynchronous User Ch 1 Input Selection - ADC0 select\n.equ EVSYS_ASYNCUSER1_OFF_gc = (0x00<<0) ; Off\n.equ EVSYS_ASYNCUSER1_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_ASYNCUSER1_SYNCCH1_gc = (0x02<<0) ; Synchronous Event Channel 1\n.equ EVSYS_ASYNCUSER1_ASYNCCH0_gc = (0x03<<0) ; Asynchronous Event Channel 0\n.equ EVSYS_ASYNCUSER1_ASYNCCH1_gc = (0x04<<0) ; Asynchronous Event Channel 1\n.equ EVSYS_ASYNCUSER1_ASYNCCH2_gc = (0x05<<0) ; Asynchronous Event Channel 2\n.equ EVSYS_ASYNCUSER1_ASYNCCH3_gc = (0x06<<0) ; Asynchronous Event Channel 3\n\n; Asynchronous User Ch 2 Input Selection - CCL LUT0 Event 0 select\n.equ EVSYS_ASYNCUSER2_OFF_gc = (0x00<<0) ; Off\n.equ EVSYS_ASYNCUSER2_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_ASYNCUSER2_SYNCCH1_gc = (0x02<<0) ; Synchronous Event Channel 1\n.equ EVSYS_ASYNCUSER2_ASYNCCH0_gc = (0x03<<0) ; Asynchronous Event Channel 0\n.equ EVSYS_ASYNCUSER2_ASYNCCH1_gc = (0x04<<0) ; Asynchronous Event Channel 1\n.equ EVSYS_ASYNCUSER2_ASYNCCH2_gc = (0x05<<0) ; Asynchronous Event Channel 2\n.equ EVSYS_ASYNCUSER2_ASYNCCH3_gc = (0x06<<0) ; Asynchronous Event Channel 3\n\n; Asynchronous User Ch 3 Input Selection - CCL LUT1 Event 0 select\n.equ EVSYS_ASYNCUSER3_OFF_gc = (0x00<<0) ; Off\n.equ EVSYS_ASYNCUSER3_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_ASYNCUSER3_SYNCCH1_gc = (0x02<<0) ; Synchronous Event Channel 1\n.equ EVSYS_ASYNCUSER3_ASYNCCH0_gc = (0x03<<0) ; Asynchronous Event Channel 0\n.equ EVSYS_ASYNCUSER3_ASYNCCH1_gc = (0x04<<0) ; Asynchronous Event Channel 1\n.equ EVSYS_ASYNCUSER3_ASYNCCH2_gc = (0x05<<0) ; Asynchronous Event Channel 2\n.equ EVSYS_ASYNCUSER3_ASYNCCH3_gc = (0x06<<0) ; Asynchronous Event Channel 3\n\n; Asynchronous User Ch 4 Input Selection - CCL LUT0 Event 1 select\n.equ EVSYS_ASYNCUSER4_OFF_gc = (0x00<<0) ; Off\n.equ EVSYS_ASYNCUSER4_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_ASYNCUSER4_SYNCCH1_gc = (0x02<<0) ; Synchronous Event Channel 1\n.equ EVSYS_ASYNCUSER4_ASYNCCH0_gc = (0x03<<0) ; Asynchronous Event Channel 0\n.equ EVSYS_ASYNCUSER4_ASYNCCH1_gc = (0x04<<0) ; Asynchronous Event Channel 1\n.equ EVSYS_ASYNCUSER4_ASYNCCH2_gc = (0x05<<0) ; Asynchronous Event Channel 2\n.equ EVSYS_ASYNCUSER4_ASYNCCH3_gc = (0x06<<0) ; Asynchronous Event Channel 3\n\n; Asynchronous User Ch 5 Input Selection - CCL LUT1 Event 1 select\n.equ EVSYS_ASYNCUSER5_OFF_gc = (0x00<<0) ; Off\n.equ EVSYS_ASYNCUSER5_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_ASYNCUSER5_SYNCCH1_gc = (0x02<<0) ; Synchronous Event Channel 1\n.equ EVSYS_ASYNCUSER5_ASYNCCH0_gc = (0x03<<0) ; Asynchronous Event Channel 0\n.equ EVSYS_ASYNCUSER5_ASYNCCH1_gc = (0x04<<0) ; Asynchronous Event Channel 1\n.equ EVSYS_ASYNCUSER5_ASYNCCH2_gc = (0x05<<0) ; Asynchronous Event Channel 2\n.equ EVSYS_ASYNCUSER5_ASYNCCH3_gc = (0x06<<0) ; Asynchronous Event Channel 3\n\n; Asynchronous User Ch 6 Input Selection - TCD0 Event 0 select\n.equ EVSYS_ASYNCUSER6_OFF_gc = (0x00<<0) ; Off\n.equ EVSYS_ASYNCUSER6_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_ASYNCUSER6_SYNCCH1_gc = (0x02<<0) ; Synchronous Event Channel 1\n.equ EVSYS_ASYNCUSER6_ASYNCCH0_gc = (0x03<<0) ; Asynchronous Event Channel 0\n.equ EVSYS_ASYNCUSER6_ASYNCCH1_gc = (0x04<<0) ; Asynchronous Event Channel 1\n.equ EVSYS_ASYNCUSER6_ASYNCCH2_gc = (0x05<<0) ; Asynchronous Event Channel 2\n.equ EVSYS_ASYNCUSER6_ASYNCCH3_gc = (0x06<<0) ; Asynchronous Event Channel 3\n\n; Asynchronous User Ch 7 Input Selection - TCD0 Event 1 select\n.equ EVSYS_ASYNCUSER7_OFF_gc = (0x00<<0) ; Off\n.equ EVSYS_ASYNCUSER7_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_ASYNCUSER7_SYNCCH1_gc = (0x02<<0) ; Synchronous Event Channel 1\n.equ EVSYS_ASYNCUSER7_ASYNCCH0_gc = (0x03<<0) ; Asynchronous Event Channel 0\n.equ EVSYS_ASYNCUSER7_ASYNCCH1_gc = (0x04<<0) ; Asynchronous Event Channel 1\n.equ EVSYS_ASYNCUSER7_ASYNCCH2_gc = (0x05<<0) ; Asynchronous Event Channel 2\n.equ EVSYS_ASYNCUSER7_ASYNCCH3_gc = (0x06<<0) ; Asynchronous Event Channel 3\n\n; Asynchronous User Ch 8 Input Selection - Event Out 0 select\n.equ EVSYS_ASYNCUSER8_OFF_gc = (0x00<<0) ; Off\n.equ EVSYS_ASYNCUSER8_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_ASYNCUSER8_SYNCCH1_gc = (0x02<<0) ; Synchronous Event Channel 1\n.equ EVSYS_ASYNCUSER8_ASYNCCH0_gc = (0x03<<0) ; Asynchronous Event Channel 0\n.equ EVSYS_ASYNCUSER8_ASYNCCH1_gc = (0x04<<0) ; Asynchronous Event Channel 1\n.equ EVSYS_ASYNCUSER8_ASYNCCH2_gc = (0x05<<0) ; Asynchronous Event Channel 2\n.equ EVSYS_ASYNCUSER8_ASYNCCH3_gc = (0x06<<0) ; Asynchronous Event Channel 3\n\n; Asynchronous User Ch 9 Input Selection - Event Out 1 select\n.equ EVSYS_ASYNCUSER9_OFF_gc = (0x00<<0) ; Off\n.equ EVSYS_ASYNCUSER9_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_ASYNCUSER9_SYNCCH1_gc = (0x02<<0) ; Synchronous Event Channel 1\n.equ EVSYS_ASYNCUSER9_ASYNCCH0_gc = (0x03<<0) ; Asynchronous Event Channel 0\n.equ EVSYS_ASYNCUSER9_ASYNCCH1_gc = (0x04<<0) ; Asynchronous Event Channel 1\n.equ EVSYS_ASYNCUSER9_ASYNCCH2_gc = (0x05<<0) ; Asynchronous Event Channel 2\n.equ EVSYS_ASYNCUSER9_ASYNCCH3_gc = (0x06<<0) ; Asynchronous Event Channel 3\n\n; Asynchronous User Ch 10 Input Selection - Event Out 2 select\n.equ EVSYS_ASYNCUSER10_OFF_gc = (0x00<<0) ; Off\n.equ EVSYS_ASYNCUSER10_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_ASYNCUSER10_SYNCCH1_gc = (0x02<<0) ; Synchronous Event Channel 1\n.equ EVSYS_ASYNCUSER10_ASYNCCH0_gc = (0x03<<0) ; Asynchronous Event Channel 0\n.equ EVSYS_ASYNCUSER10_ASYNCCH1_gc = (0x04<<0) ; Asynchronous Event Channel 1\n.equ EVSYS_ASYNCUSER10_ASYNCCH2_gc = (0x05<<0) ; Asynchronous Event Channel 2\n.equ EVSYS_ASYNCUSER10_ASYNCCH3_gc = (0x06<<0) ; Asynchronous Event Channel 3\n\n; Asynchronous User Ch 11 Input Selection - TCB1 select\n.equ EVSYS_ASYNCUSER11_OFF_gc = (0x00<<0) ; Off\n.equ EVSYS_ASYNCUSER11_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_ASYNCUSER11_SYNCCH1_gc = (0x02<<0) ; Synchronous Event Channel 1\n.equ EVSYS_ASYNCUSER11_ASYNCCH0_gc = (0x03<<0) ; Asynchronous Event Channel 0\n.equ EVSYS_ASYNCUSER11_ASYNCCH1_gc = (0x04<<0) ; Asynchronous Event Channel 1\n.equ EVSYS_ASYNCUSER11_ASYNCCH2_gc = (0x05<<0) ; Asynchronous Event Channel 2\n.equ EVSYS_ASYNCUSER11_ASYNCCH3_gc = (0x06<<0) ; Asynchronous Event Channel 3\n\n; Asynchronous User Ch 12 Input Selection - ADC0 select\n.equ EVSYS_ASYNCUSER12_OFF_gc = (0x00<<0) ; Off\n.equ EVSYS_ASYNCUSER12_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_ASYNCUSER12_SYNCCH1_gc = (0x02<<0) ; Synchronous Event Channel 1\n.equ EVSYS_ASYNCUSER12_ASYNCCH0_gc = (0x03<<0) ; Asynchronous Event Channel 0\n.equ EVSYS_ASYNCUSER12_ASYNCCH1_gc = (0x04<<0) ; Asynchronous Event Channel 1\n.equ EVSYS_ASYNCUSER12_ASYNCCH2_gc = (0x05<<0) ; Asynchronous Event Channel 2\n.equ EVSYS_ASYNCUSER12_ASYNCCH3_gc = (0x06<<0) ; Asynchronous Event Channel 3\n\n; Synchronous Channel 0 Generator Selection select\n.equ EVSYS_SYNCCH0_OFF_gc = (0x00<<0)    ; Off\n.equ EVSYS_SYNCCH0_TCB0_gc = (0x01<<0)   ; Timer/Counter B0\n.equ EVSYS_SYNCCH0_TCA0_OVF_LUNF_gc = (0x02<<0) ; Timer/Counter A0 overflow\n.equ EVSYS_SYNCCH0_TCA0_HUNF_gc = (0x03<<0) ; Timer/Counter A0 underflow high byte (split mode)\n.equ EVSYS_SYNCCH0_TCA0_CMP0_gc = (0x04<<0) ; Timer/Counter A0 compare 0\n.equ EVSYS_SYNCCH0_TCA0_CMP1_gc = (0x05<<0) ; Timer/Counter A0 compare 1\n.equ EVSYS_SYNCCH0_TCA0_CMP2_gc = (0x06<<0) ; Timer/Counter A0 compare 2\n.equ EVSYS_SYNCCH0_PORTC_PIN0_gc = (0x07<<0) ; Synchronous Event from Pin PC0\n.equ EVSYS_SYNCCH0_PORTC_PIN1_gc = (0x08<<0) ; Synchronous Event from Pin PC1\n.equ EVSYS_SYNCCH0_PORTC_PIN2_gc = (0x09<<0) ; Synchronous Event from Pin PC2\n.equ EVSYS_SYNCCH0_PORTC_PIN3_gc = (0x0A<<0) ; Synchronous Event from Pin PC3\n.equ EVSYS_SYNCCH0_PORTC_PIN4_gc = (0x0B<<0) ; Synchronous Event from Pin PC4\n.equ EVSYS_SYNCCH0_PORTC_PIN5_gc = (0x0C<<0) ; Synchronous Event from Pin PC5\n.equ EVSYS_SYNCCH0_PORTA_PIN0_gc = (0x0D<<0) ; Synchronous Event from Pin PA0\n.equ EVSYS_SYNCCH0_PORTA_PIN1_gc = (0x0E<<0) ; Synchronous Event from Pin PA1\n.equ EVSYS_SYNCCH0_PORTA_PIN2_gc = (0x0F<<0) ; Synchronous Event from Pin PA2\n.equ EVSYS_SYNCCH0_PORTA_PIN3_gc = (0x10<<0) ; Synchronous Event from Pin PA3\n.equ EVSYS_SYNCCH0_PORTA_PIN4_gc = (0x11<<0) ; Synchronous Event from Pin PA4\n.equ EVSYS_SYNCCH0_PORTA_PIN5_gc = (0x12<<0) ; Synchronous Event from Pin PA5\n.equ EVSYS_SYNCCH0_PORTA_PIN6_gc = (0x13<<0) ; Synchronous Event from Pin PA6\n.equ EVSYS_SYNCCH0_PORTA_PIN7_gc = (0x14<<0) ; Synchronous Event from Pin PA7\n.equ EVSYS_SYNCCH0_TCB1_gc = (0x15<<0)   ; Timer/Counter B1\n\n; Synchronous Channel 1 Generator Selection select\n.equ EVSYS_SYNCCH1_OFF_gc = (0x00<<0)    ; Off\n.equ EVSYS_SYNCCH1_TCB0_gc = (0x01<<0)   ; Timer/Counter B0\n.equ EVSYS_SYNCCH1_TCA0_OVF_LUNF_gc = (0x02<<0) ; Timer/Counter A0 overflow\n.equ EVSYS_SYNCCH1_TCA0_HUNF_gc = (0x03<<0) ; Timer/Counter A0 underflow high byte (split mode)\n.equ EVSYS_SYNCCH1_TCA0_CMP0_gc = (0x04<<0) ; Timer/Counter A0 compare 0\n.equ EVSYS_SYNCCH1_TCA0_CMP1_gc = (0x05<<0) ; Timer/Counter A0 compare 1\n.equ EVSYS_SYNCCH1_TCA0_CMP2_gc = (0x06<<0) ; Timer/Counter A0 compare 2\n.equ EVSYS_SYNCCH1_PORTB_PIN0_gc = (0x08<<0) ; Synchronous Event from Pin PB0\n.equ EVSYS_SYNCCH1_PORTB_PIN1_gc = (0x09<<0) ; Synchronous Event from Pin PB1\n.equ EVSYS_SYNCCH1_PORTB_PIN2_gc = (0x0A<<0) ; Synchronous Event from Pin PB2\n.equ EVSYS_SYNCCH1_PORTB_PIN3_gc = (0x0B<<0) ; Synchronous Event from Pin PB3\n.equ EVSYS_SYNCCH1_PORTB_PIN4_gc = (0x0C<<0) ; Synchronous Event from Pin PB4\n.equ EVSYS_SYNCCH1_PORTB_PIN5_gc = (0x0D<<0) ; Synchronous Event from Pin PB5\n.equ EVSYS_SYNCCH1_PORTB_PIN6_gc = (0x0E<<0) ; Synchronous Event from Pin PB6\n.equ EVSYS_SYNCCH1_PORTB_PIN7_gc = (0x0F<<0) ; Synchronous Event from Pin PB7\n.equ EVSYS_SYNCCH1_TCB1_gc = (0x10<<0)   ; Timer/Counter B1\n\n; Synchronous User Ch 0 - TCA0 select\n.equ EVSYS_SYNCUSER0_OFF_gc = (0x00<<0)  ; Off\n.equ EVSYS_SYNCUSER0_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_SYNCUSER0_SYNCCH1_gc = (0x02<<0) ; Synchronous Event Channel 1\n\n; Synchronous User Ch 1 - USART0 select\n.equ EVSYS_SYNCUSER1_OFF_gc = (0x00<<0)  ; Off\n.equ EVSYS_SYNCUSER1_SYNCCH0_gc = (0x01<<0) ; Synchronous Event Channel 0\n.equ EVSYS_SYNCUSER1_SYNCCH1_gc = (0x02<<0) ; Synchronous Event Channel 1\n\n\n;*************************************************************************\n;** FUSE - Fuses\n;*************************************************************************\n\n; FUSE_BODCFG masks\n.equ FUSE_ACTIVE_gm = 0x0C               ; BOD Operation in Active Mode group mask\n.equ FUSE_ACTIVE_gp = 2                  ; BOD Operation in Active Mode group position\n.equ FUSE_ACTIVE0_bm = (1<<2)            ; BOD Operation in Active Mode bit 0 mask\n.equ FUSE_ACTIVE0_bp = 2                 ; BOD Operation in Active Mode bit 0 position\n.equ FUSE_ACTIVE1_bm = (1<<3)            ; BOD Operation in Active Mode bit 1 mask\n.equ FUSE_ACTIVE1_bp = 3                 ; BOD Operation in Active Mode bit 1 position\n.equ FUSE_LVL_gm = 0xE0                  ; BOD Level group mask\n.equ FUSE_LVL_gp = 5                     ; BOD Level group position\n.equ FUSE_LVL0_bm = (1<<5)               ; BOD Level bit 0 mask\n.equ FUSE_LVL0_bp = 5                    ; BOD Level bit 0 position\n.equ FUSE_LVL1_bm = (1<<6)               ; BOD Level bit 1 mask\n.equ FUSE_LVL1_bp = 6                    ; BOD Level bit 1 position\n.equ FUSE_LVL2_bm = (1<<7)               ; BOD Level bit 2 mask\n.equ FUSE_LVL2_bp = 7                    ; BOD Level bit 2 position\n.equ FUSE_SAMPFREQ_bm = 0x10             ; BOD Sample Frequency bit mask\n.equ FUSE_SAMPFREQ_bp = 4                ; BOD Sample Frequency bit position\n.equ FUSE_SLEEP_gm = 0x03                ; BOD Operation in Sleep Mode group mask\n.equ FUSE_SLEEP_gp = 0                   ; BOD Operation in Sleep Mode group position\n.equ FUSE_SLEEP0_bm = (1<<0)             ; BOD Operation in Sleep Mode bit 0 mask\n.equ FUSE_SLEEP0_bp = 0                  ; BOD Operation in Sleep Mode bit 0 position\n.equ FUSE_SLEEP1_bm = (1<<1)             ; BOD Operation in Sleep Mode bit 1 mask\n.equ FUSE_SLEEP1_bp = 1                  ; BOD Operation in Sleep Mode bit 1 position\n\n; FUSE_OSCCFG masks\n.equ FUSE_FREQSEL_gm = 0x03              ; Frequency Select group mask\n.equ FUSE_FREQSEL_gp = 0                 ; Frequency Select group position\n.equ FUSE_FREQSEL0_bm = (1<<0)           ; Frequency Select bit 0 mask\n.equ FUSE_FREQSEL0_bp = 0                ; Frequency Select bit 0 position\n.equ FUSE_FREQSEL1_bm = (1<<1)           ; Frequency Select bit 1 mask\n.equ FUSE_FREQSEL1_bp = 1                ; Frequency Select bit 1 position\n.equ FUSE_OSCLOCK_bm = 0x80              ; Oscillator Lock bit mask\n.equ FUSE_OSCLOCK_bp = 7                 ; Oscillator Lock bit position\n\n; FUSE_SYSCFG0 masks\n.equ FUSE_CRCSRC_gm = 0xC0               ; CRC Source group mask\n.equ FUSE_CRCSRC_gp = 6                  ; CRC Source group position\n.equ FUSE_CRCSRC0_bm = (1<<6)            ; CRC Source bit 0 mask\n.equ FUSE_CRCSRC0_bp = 6                 ; CRC Source bit 0 position\n.equ FUSE_CRCSRC1_bm = (1<<7)            ; CRC Source bit 1 mask\n.equ FUSE_CRCSRC1_bp = 7                 ; CRC Source bit 1 position\n.equ FUSE_EESAVE_bm = 0x01               ; EEPROM Save bit mask\n.equ FUSE_EESAVE_bp = 0                  ; EEPROM Save bit position\n.equ FUSE_RSTPINCFG_gm = 0x0C            ; Reset Pin Configuration group mask\n.equ FUSE_RSTPINCFG_gp = 2               ; Reset Pin Configuration group position\n.equ FUSE_RSTPINCFG0_bm = (1<<2)         ; Reset Pin Configuration bit 0 mask\n.equ FUSE_RSTPINCFG0_bp = 2              ; Reset Pin Configuration bit 0 position\n.equ FUSE_RSTPINCFG1_bm = (1<<3)         ; Reset Pin Configuration bit 1 mask\n.equ FUSE_RSTPINCFG1_bp = 3              ; Reset Pin Configuration bit 1 position\n\n; FUSE_SYSCFG1 masks\n.equ FUSE_SUT_gm = 0x07                  ; Startup Time group mask\n.equ FUSE_SUT_gp = 0                     ; Startup Time group position\n.equ FUSE_SUT0_bm = (1<<0)               ; Startup Time bit 0 mask\n.equ FUSE_SUT0_bp = 0                    ; Startup Time bit 0 position\n.equ FUSE_SUT1_bm = (1<<1)               ; Startup Time bit 1 mask\n.equ FUSE_SUT1_bp = 1                    ; Startup Time bit 1 position\n.equ FUSE_SUT2_bm = (1<<2)               ; Startup Time bit 2 mask\n.equ FUSE_SUT2_bp = 2                    ; Startup Time bit 2 position\n\n; FUSE_TCD0CFG masks\n.equ FUSE_CMPA_bm = 0x01                 ; Compare A Default Output Value bit mask\n.equ FUSE_CMPA_bp = 0                    ; Compare A Default Output Value bit position\n.equ FUSE_CMPAEN_bm = 0x10               ; Compare A Output Enable bit mask\n.equ FUSE_CMPAEN_bp = 4                  ; Compare A Output Enable bit position\n.equ FUSE_CMPB_bm = 0x02                 ; Compare B Default Output Value bit mask\n.equ FUSE_CMPB_bp = 1                    ; Compare B Default Output Value bit position\n.equ FUSE_CMPBEN_bm = 0x20               ; Compare B Output Enable bit mask\n.equ FUSE_CMPBEN_bp = 5                  ; Compare B Output Enable bit position\n.equ FUSE_CMPC_bm = 0x04                 ; Compare C Default Output Value bit mask\n.equ FUSE_CMPC_bp = 2                    ; Compare C Default Output Value bit position\n.equ FUSE_CMPCEN_bm = 0x40               ; Compare C Output Enable bit mask\n.equ FUSE_CMPCEN_bp = 6                  ; Compare C Output Enable bit position\n.equ FUSE_CMPD_bm = 0x08                 ; Compare D Default Output Value bit mask\n.equ FUSE_CMPD_bp = 3                    ; Compare D Default Output Value bit position\n.equ FUSE_CMPDEN_bm = 0x80               ; Compare D Output Enable bit mask\n.equ FUSE_CMPDEN_bp = 7                  ; Compare D Output Enable bit position\n\n; FUSE_WDTCFG masks\n.equ FUSE_PERIOD_gm = 0x0F               ; Watchdog Timeout Period group mask\n.equ FUSE_PERIOD_gp = 0                  ; Watchdog Timeout Period group position\n.equ FUSE_PERIOD0_bm = (1<<0)            ; Watchdog Timeout Period bit 0 mask\n.equ FUSE_PERIOD0_bp = 0                 ; Watchdog Timeout Period bit 0 position\n.equ FUSE_PERIOD1_bm = (1<<1)            ; Watchdog Timeout Period bit 1 mask\n.equ FUSE_PERIOD1_bp = 1                 ; Watchdog Timeout Period bit 1 position\n.equ FUSE_PERIOD2_bm = (1<<2)            ; Watchdog Timeout Period bit 2 mask\n.equ FUSE_PERIOD2_bp = 2                 ; Watchdog Timeout Period bit 2 position\n.equ FUSE_PERIOD3_bm = (1<<3)            ; Watchdog Timeout Period bit 3 mask\n.equ FUSE_PERIOD3_bp = 3                 ; Watchdog Timeout Period bit 3 position\n.equ FUSE_WINDOW_gm = 0xF0               ; Watchdog Window Timeout Period group mask\n.equ FUSE_WINDOW_gp = 4                  ; Watchdog Window Timeout Period group position\n.equ FUSE_WINDOW0_bm = (1<<4)            ; Watchdog Window Timeout Period bit 0 mask\n.equ FUSE_WINDOW0_bp = 4                 ; Watchdog Window Timeout Period bit 0 position\n.equ FUSE_WINDOW1_bm = (1<<5)            ; Watchdog Window Timeout Period bit 1 mask\n.equ FUSE_WINDOW1_bp = 5                 ; Watchdog Window Timeout Period bit 1 position\n.equ FUSE_WINDOW2_bm = (1<<6)            ; Watchdog Window Timeout Period bit 2 mask\n.equ FUSE_WINDOW2_bp = 6                 ; Watchdog Window Timeout Period bit 2 position\n.equ FUSE_WINDOW3_bm = (1<<7)            ; Watchdog Window Timeout Period bit 3 mask\n.equ FUSE_WINDOW3_bp = 7                 ; Watchdog Window Timeout Period bit 3 position\n\n; BOD Operation in Active Mode select\n.equ FUSE_ACTIVE_DIS_gc = (0x00<<2)      ; Disabled\n.equ FUSE_ACTIVE_ENABLED_gc = (0x01<<2)  ; Enabled\n.equ FUSE_ACTIVE_SAMPLED_gc = (0x02<<2)  ; Sampled\n.equ FUSE_ACTIVE_ENWAKE_gc = (0x03<<2)   ; Enabled with wake-up halted until BOD is ready\n\n; BOD Level select\n.equ FUSE_LVL_BODLEVEL0_gc = (0x00<<5)   ; 1.8 V\n.equ FUSE_LVL_BODLEVEL2_gc = (0x02<<5)   ; 2.6 V\n.equ FUSE_LVL_BODLEVEL7_gc = (0x07<<5)   ; 4.2 V\n\n; BOD Sample Frequency select\n.equ FUSE_SAMPFREQ_1KHZ_gc = (0x00<<4)   ; 1kHz sampling frequency\n.equ FUSE_SAMPFREQ_125HZ_gc = (0x01<<4)  ; 125Hz sampling frequency\n\n; BOD Operation in Sleep Mode select\n.equ FUSE_SLEEP_DIS_gc = (0x00<<0)       ; Disabled\n.equ FUSE_SLEEP_ENABLED_gc = (0x01<<0)   ; Enabled\n.equ FUSE_SLEEP_SAMPLED_gc = (0x02<<0)   ; Sampled\n\n; Frequency Select select\n.equ FUSE_FREQSEL_16MHZ_gc = (0x01<<0)   ; 16 MHz\n.equ FUSE_FREQSEL_20MHZ_gc = (0x02<<0)   ; 20 MHz\n\n; CRC Source select\n.equ FUSE_CRCSRC_FLASH_gc = (0x00<<6)    ; The CRC is performed on the entire Flash (boot, application code and application data section).\n.equ FUSE_CRCSRC_BOOT_gc = (0x01<<6)     ; The CRC is performed on the boot section of Flash\n.equ FUSE_CRCSRC_BOOTAPP_gc = (0x02<<6)  ; The CRC is performed on the boot and application code section of Flash\n.equ FUSE_CRCSRC_NOCRC_gc = (0x03<<6)    ; Disable CRC.\n\n; Reset Pin Configuration select\n.equ FUSE_RSTPINCFG_GPIO_gc = (0x00<<2)  ; GPIO mode\n.equ FUSE_RSTPINCFG_UPDI_gc = (0x01<<2)  ; UPDI mode\n.equ FUSE_RSTPINCFG_RST_gc = (0x02<<2)   ; Reset mode\n\n; Startup Time select\n.equ FUSE_SUT_0MS_gc = (0x00<<0)         ; 0 ms\n.equ FUSE_SUT_1MS_gc = (0x01<<0)         ; 1 ms\n.equ FUSE_SUT_2MS_gc = (0x02<<0)         ; 2 ms\n.equ FUSE_SUT_4MS_gc = (0x03<<0)         ; 4 ms\n.equ FUSE_SUT_8MS_gc = (0x04<<0)         ; 8 ms\n.equ FUSE_SUT_16MS_gc = (0x05<<0)        ; 16 ms\n.equ FUSE_SUT_32MS_gc = (0x06<<0)        ; 32 ms\n.equ FUSE_SUT_64MS_gc = (0x07<<0)        ; 64 ms\n\n; Watchdog Timeout Period select\n.equ FUSE_PERIOD_OFF_gc = (0x00<<0)      ; Off\n.equ FUSE_PERIOD_8CLK_gc = (0x01<<0)     ; 8 cycles (8ms)\n.equ FUSE_PERIOD_16CLK_gc = (0x02<<0)    ; 16 cycles (16ms)\n.equ FUSE_PERIOD_32CLK_gc = (0x03<<0)    ; 32 cycles (32ms)\n.equ FUSE_PERIOD_64CLK_gc = (0x04<<0)    ; 64 cycles (64ms)\n.equ FUSE_PERIOD_128CLK_gc = (0x05<<0)   ; 128 cycles (0.128s)\n.equ FUSE_PERIOD_256CLK_gc = (0x06<<0)   ; 256 cycles (0.256s)\n.equ FUSE_PERIOD_512CLK_gc = (0x07<<0)   ; 512 cycles (0.512s)\n.equ FUSE_PERIOD_1KCLK_gc = (0x08<<0)    ; 1K cycles (1.0s)\n.equ FUSE_PERIOD_2KCLK_gc = (0x09<<0)    ; 2K cycles (2.0s)\n.equ FUSE_PERIOD_4KCLK_gc = (0x0A<<0)    ; 4K cycles (4.1s)\n.equ FUSE_PERIOD_8KCLK_gc = (0x0B<<0)    ; 8K cycles (8.2s)\n\n; Watchdog Window Timeout Period select\n.equ FUSE_WINDOW_OFF_gc = (0x00<<4)      ; Off\n.equ FUSE_WINDOW_8CLK_gc = (0x01<<4)     ; 8 cycles (8ms)\n.equ FUSE_WINDOW_16CLK_gc = (0x02<<4)    ; 16 cycles (16ms)\n.equ FUSE_WINDOW_32CLK_gc = (0x03<<4)    ; 32 cycles (32ms)\n.equ FUSE_WINDOW_64CLK_gc = (0x04<<4)    ; 64 cycles (64ms)\n.equ FUSE_WINDOW_128CLK_gc = (0x05<<4)   ; 128 cycles (0.128s)\n.equ FUSE_WINDOW_256CLK_gc = (0x06<<4)   ; 256 cycles (0.256s)\n.equ FUSE_WINDOW_512CLK_gc = (0x07<<4)   ; 512 cycles (0.512s)\n.equ FUSE_WINDOW_1KCLK_gc = (0x08<<4)    ; 1K cycles (1.0s)\n.equ FUSE_WINDOW_2KCLK_gc = (0x09<<4)    ; 2K cycles (2.0s)\n.equ FUSE_WINDOW_4KCLK_gc = (0x0A<<4)    ; 4K cycles (4.1s)\n.equ FUSE_WINDOW_8KCLK_gc = (0x0B<<4)    ; 8K cycles (8.2s)\n\n\n;*************************************************************************\n;** GPIO - General Purpose IO\n;*************************************************************************\n\n\n;*************************************************************************\n;** LOCKBIT - Lockbit\n;*************************************************************************\n\n; LOCKBIT_LOCKBIT masks\n.equ LOCKBIT_LB_gm = 0xFF                ; Lock Bits group mask\n.equ LOCKBIT_LB_gp = 0                   ; Lock Bits group position\n.equ LOCKBIT_LB0_bm = (1<<0)             ; Lock Bits bit 0 mask\n.equ LOCKBIT_LB0_bp = 0                  ; Lock Bits bit 0 position\n.equ LOCKBIT_LB1_bm = (1<<1)             ; Lock Bits bit 1 mask\n.equ LOCKBIT_LB1_bp = 1                  ; Lock Bits bit 1 position\n.equ LOCKBIT_LB2_bm = (1<<2)             ; Lock Bits bit 2 mask\n.equ LOCKBIT_LB2_bp = 2                  ; Lock Bits bit 2 position\n.equ LOCKBIT_LB3_bm = (1<<3)             ; Lock Bits bit 3 mask\n.equ LOCKBIT_LB3_bp = 3                  ; Lock Bits bit 3 position\n.equ LOCKBIT_LB4_bm = (1<<4)             ; Lock Bits bit 4 mask\n.equ LOCKBIT_LB4_bp = 4                  ; Lock Bits bit 4 position\n.equ LOCKBIT_LB5_bm = (1<<5)             ; Lock Bits bit 5 mask\n.equ LOCKBIT_LB5_bp = 5                  ; Lock Bits bit 5 position\n.equ LOCKBIT_LB6_bm = (1<<6)             ; Lock Bits bit 6 mask\n.equ LOCKBIT_LB6_bp = 6                  ; Lock Bits bit 6 position\n.equ LOCKBIT_LB7_bm = (1<<7)             ; Lock Bits bit 7 mask\n.equ LOCKBIT_LB7_bp = 7                  ; Lock Bits bit 7 position\n\n; Lock Bits select\n.equ LOCKBIT_LB_RWLOCK_gc = (0x3A<<0)    ; Read and write lock\n.equ LOCKBIT_LB_NOLOCK_gc = (0xC5<<0)    ; No locks\n\n\n;*************************************************************************\n;** NVMCTRL - Non-volatile Memory Controller\n;*************************************************************************\n\n; NVMCTRL_CTRLA masks\n.equ NVMCTRL_CMD_gm = 0x07               ; Command group mask\n.equ NVMCTRL_CMD_gp = 0                  ; Command group position\n.equ NVMCTRL_CMD0_bm = (1<<0)            ; Command bit 0 mask\n.equ NVMCTRL_CMD0_bp = 0                 ; Command bit 0 position\n.equ NVMCTRL_CMD1_bm = (1<<1)            ; Command bit 1 mask\n.equ NVMCTRL_CMD1_bp = 1                 ; Command bit 1 position\n.equ NVMCTRL_CMD2_bm = (1<<2)            ; Command bit 2 mask\n.equ NVMCTRL_CMD2_bp = 2                 ; Command bit 2 position\n\n; NVMCTRL_CTRLB masks\n.equ NVMCTRL_APCWP_bm = 0x01             ; Application code write protect bit mask\n.equ NVMCTRL_APCWP_bp = 0                ; Application code write protect bit position\n.equ NVMCTRL_BOOTLOCK_bm = 0x02          ; Boot Lock bit mask\n.equ NVMCTRL_BOOTLOCK_bp = 1             ; Boot Lock bit position\n\n; NVMCTRL_INTCTRL masks\n.equ NVMCTRL_EEREADY_bm = 0x01           ; EEPROM Ready bit mask\n.equ NVMCTRL_EEREADY_bp = 0              ; EEPROM Ready bit position\n\n; NVMCTRL_INTFLAGS masks\n; Masks for NVMCTRL_EEREADY already defined\n\n; NVMCTRL_STATUS masks\n.equ NVMCTRL_EEBUSY_bm = 0x02            ; EEPROM busy bit mask\n.equ NVMCTRL_EEBUSY_bp = 1               ; EEPROM busy bit position\n.equ NVMCTRL_FBUSY_bm = 0x01             ; Flash busy bit mask\n.equ NVMCTRL_FBUSY_bp = 0                ; Flash busy bit position\n.equ NVMCTRL_WRERROR_bm = 0x04           ; Write error bit mask\n.equ NVMCTRL_WRERROR_bp = 2              ; Write error bit position\n\n; Command select\n.equ NVMCTRL_CMD_NONE_gc = (0x00<<0)     ; No Command\n.equ NVMCTRL_CMD_PAGEWRITE_gc = (0x01<<0) ; Write page\n.equ NVMCTRL_CMD_PAGEERASE_gc = (0x02<<0) ; Erase page\n.equ NVMCTRL_CMD_PAGEERASEWRITE_gc = (0x03<<0) ; Erase and write page\n.equ NVMCTRL_CMD_PAGEBUFCLR_gc = (0x04<<0) ; Page buffer clear\n.equ NVMCTRL_CMD_CHIPERASE_gc = (0x05<<0) ; Chip erase\n.equ NVMCTRL_CMD_EEERASE_gc = (0x06<<0)  ; EEPROM erase\n.equ NVMCTRL_CMD_FUSEWRITE_gc = (0x07<<0) ; Write fuse (PDI only)\n\n\n;*************************************************************************\n;** PORT - I/O Ports\n;*************************************************************************\n\n; PORT_INTFLAGS masks\n.equ PORT_INT_gm = 0xFF                  ; Pin Interrupt group mask\n.equ PORT_INT_gp = 0                     ; Pin Interrupt group position\n.equ PORT_INT0_bm = (1<<0)               ; Pin Interrupt bit 0 mask\n.equ PORT_INT0_bp = 0                    ; Pin Interrupt bit 0 position\n.equ PORT_INT1_bm = (1<<1)               ; Pin Interrupt bit 1 mask\n.equ PORT_INT1_bp = 1                    ; Pin Interrupt bit 1 position\n.equ PORT_INT2_bm = (1<<2)               ; Pin Interrupt bit 2 mask\n.equ PORT_INT2_bp = 2                    ; Pin Interrupt bit 2 position\n.equ PORT_INT3_bm = (1<<3)               ; Pin Interrupt bit 3 mask\n.equ PORT_INT3_bp = 3                    ; Pin Interrupt bit 3 position\n.equ PORT_INT4_bm = (1<<4)               ; Pin Interrupt bit 4 mask\n.equ PORT_INT4_bp = 4                    ; Pin Interrupt bit 4 position\n.equ PORT_INT5_bm = (1<<5)               ; Pin Interrupt bit 5 mask\n.equ PORT_INT5_bp = 5                    ; Pin Interrupt bit 5 position\n.equ PORT_INT6_bm = (1<<6)               ; Pin Interrupt bit 6 mask\n.equ PORT_INT6_bp = 6                    ; Pin Interrupt bit 6 position\n.equ PORT_INT7_bm = (1<<7)               ; Pin Interrupt bit 7 mask\n.equ PORT_INT7_bp = 7                    ; Pin Interrupt bit 7 position\n\n; PORT_PIN0CTRL masks\n.equ PORT_INVEN_bm = 0x80                ; Inverted I/O Enable bit mask\n.equ PORT_INVEN_bp = 7                   ; Inverted I/O Enable bit position\n.equ PORT_ISC_gm = 0x07                  ; Input/Sense Configuration group mask\n.equ PORT_ISC_gp = 0                     ; Input/Sense Configuration group position\n.equ PORT_ISC0_bm = (1<<0)               ; Input/Sense Configuration bit 0 mask\n.equ PORT_ISC0_bp = 0                    ; Input/Sense Configuration bit 0 position\n.equ PORT_ISC1_bm = (1<<1)               ; Input/Sense Configuration bit 1 mask\n.equ PORT_ISC1_bp = 1                    ; Input/Sense Configuration bit 1 position\n.equ PORT_ISC2_bm = (1<<2)               ; Input/Sense Configuration bit 2 mask\n.equ PORT_ISC2_bp = 2                    ; Input/Sense Configuration bit 2 position\n.equ PORT_PULLUPEN_bm = 0x08             ; Pullup enable bit mask\n.equ PORT_PULLUPEN_bp = 3                ; Pullup enable bit position\n\n; PORT_PIN1CTRL masks\n; Masks for PORT_INVEN already defined\n; Masks for PORT_ISC already defined\n; Masks for PORT_PULLUPEN already defined\n\n; PORT_PIN2CTRL masks\n; Masks for PORT_INVEN already defined\n; Masks for PORT_ISC already defined\n; Masks for PORT_PULLUPEN already defined\n\n; PORT_PIN3CTRL masks\n; Masks for PORT_INVEN already defined\n; Masks for PORT_ISC already defined\n; Masks for PORT_PULLUPEN already defined\n\n; PORT_PIN4CTRL masks\n; Masks for PORT_INVEN already defined\n; Masks for PORT_ISC already defined\n; Masks for PORT_PULLUPEN already defined\n\n; PORT_PIN5CTRL masks\n; Masks for PORT_INVEN already defined\n; Masks for PORT_ISC already defined\n; Masks for PORT_PULLUPEN already defined\n\n; PORT_PIN6CTRL masks\n; Masks for PORT_INVEN already defined\n; Masks for PORT_ISC already defined\n; Masks for PORT_PULLUPEN already defined\n\n; PORT_PIN7CTRL masks\n; Masks for PORT_INVEN already defined\n; Masks for PORT_ISC already defined\n; Masks for PORT_PULLUPEN already defined\n\n; Input/Sense Configuration select\n.equ PORT_ISC_INTDISABLE_gc = (0x00<<0)  ; Interrupt disabled but input buffer enabled\n.equ PORT_ISC_BOTHEDGES_gc = (0x01<<0)   ; Sense Both Edges\n.equ PORT_ISC_RISING_gc = (0x02<<0)      ; Sense Rising Edge\n.equ PORT_ISC_FALLING_gc = (0x03<<0)     ; Sense Falling Edge\n.equ PORT_ISC_INPUT_DISABLE_gc = (0x04<<0) ; Digital Input Buffer disabled\n.equ PORT_ISC_LEVEL_gc = (0x05<<0)       ; Sense low Level\n\n\n;*************************************************************************\n;** PORTMUX - Port Multiplexer\n;*************************************************************************\n\n; PORTMUX_CTRLA masks\n.equ PORTMUX_EVOUT0_bm = 0x01            ; Event Output 0 bit mask\n.equ PORTMUX_EVOUT0_bp = 0               ; Event Output 0 bit position\n.equ PORTMUX_EVOUT1_bm = 0x02            ; Event Output 1 bit mask\n.equ PORTMUX_EVOUT1_bp = 1               ; Event Output 1 bit position\n.equ PORTMUX_EVOUT2_bm = 0x04            ; Event Output 2 bit mask\n.equ PORTMUX_EVOUT2_bp = 2               ; Event Output 2 bit position\n.equ PORTMUX_LUT0_bm = 0x10              ; Configurable Custom Logic LUT0 bit mask\n.equ PORTMUX_LUT0_bp = 4                 ; Configurable Custom Logic LUT0 bit position\n.equ PORTMUX_LUT1_bm = 0x20              ; Configurable Custom Logic LUT1 bit mask\n.equ PORTMUX_LUT1_bp = 5                 ; Configurable Custom Logic LUT1 bit position\n\n; PORTMUX_CTRLB masks\n.equ PORTMUX_SPI0_bm = 0x04              ; Port Multiplexer SPI0 bit mask\n.equ PORTMUX_SPI0_bp = 2                 ; Port Multiplexer SPI0 bit position\n.equ PORTMUX_TWI0_bm = 0x10              ; Port Multiplexer TWI0 bit mask\n.equ PORTMUX_TWI0_bp = 4                 ; Port Multiplexer TWI0 bit position\n.equ PORTMUX_USART0_bm = 0x01            ; Port Multiplexer USART0 bit mask\n.equ PORTMUX_USART0_bp = 0               ; Port Multiplexer USART0 bit position\n\n; PORTMUX_CTRLC masks\n.equ PORTMUX_TCA00_bm = 0x01             ; Port Multiplexer TCA0 Output 0 bit mask\n.equ PORTMUX_TCA00_bp = 0                ; Port Multiplexer TCA0 Output 0 bit position\n.equ PORTMUX_TCA01_bm = 0x02             ; Port Multiplexer TCA0 Output 1 bit mask\n.equ PORTMUX_TCA01_bp = 1                ; Port Multiplexer TCA0 Output 1 bit position\n.equ PORTMUX_TCA02_bm = 0x04             ; Port Multiplexer TCA0 Output 2 bit mask\n.equ PORTMUX_TCA02_bp = 2                ; Port Multiplexer TCA0 Output 2 bit position\n.equ PORTMUX_TCA03_bm = 0x08             ; Port Multiplexer TCA0 Output 3 bit mask\n.equ PORTMUX_TCA03_bp = 3                ; Port Multiplexer TCA0 Output 3 bit position\n.equ PORTMUX_TCA04_bm = 0x10             ; Port Multiplexer TCA0 Output 4 bit mask\n.equ PORTMUX_TCA04_bp = 4                ; Port Multiplexer TCA0 Output 4 bit position\n.equ PORTMUX_TCA05_bm = 0x20             ; Port Multiplexer TCA0 Output 5 bit mask\n.equ PORTMUX_TCA05_bp = 5                ; Port Multiplexer TCA0 Output 5 bit position\n\n; PORTMUX_CTRLD masks\n.equ PORTMUX_TCB0_bm = 0x01              ; Port Multiplexer TCB0 bit mask\n.equ PORTMUX_TCB0_bp = 0                 ; Port Multiplexer TCB0 bit position\n.equ PORTMUX_TCB1_bm = 0x02              ; Port Multiplexer TCB1 bit mask\n.equ PORTMUX_TCB1_bp = 1                 ; Port Multiplexer TCB1 bit position\n\n; Configurable Custom Logic LUT0 select\n.equ PORTMUX_LUT0_DEFAULT_gc = (0x00<<4) ; Default pin\n.equ PORTMUX_LUT0_ALTERNATE_gc = (0x01<<4) ; Alternate pin\n\n; Configurable Custom Logic LUT1 select\n.equ PORTMUX_LUT1_DEFAULT_gc = (0x00<<5) ; Default pin\n.equ PORTMUX_LUT1_ALTERNATE_gc = (0x01<<5) ; Alternate pin\n\n; Port Multiplexer SPI0 select\n.equ PORTMUX_SPI0_DEFAULT_gc = (0x00<<2) ; Default pins\n.equ PORTMUX_SPI0_ALTERNATE_gc = (0x01<<2) ; Alternate pins\n\n; Port Multiplexer TWI0 select\n.equ PORTMUX_TWI0_DEFAULT_gc = (0x00<<4) ; Default pins\n.equ PORTMUX_TWI0_ALTERNATE_gc = (0x01<<4) ; Alternate pins\n\n; Port Multiplexer USART0 select\n.equ PORTMUX_USART0_DEFAULT_gc = (0x00<<0) ; Default pins\n.equ PORTMUX_USART0_ALTERNATE_gc = (0x01<<0) ; Alternate pins\n\n; Port Multiplexer TCA0 Output 0 select\n.equ PORTMUX_TCA00_DEFAULT_gc = (0x00<<0) ; Default pin\n.equ PORTMUX_TCA00_ALTERNATE_gc = (0x01<<0) ; Alternate pin\n\n; Port Multiplexer TCA0 Output 1 select\n.equ PORTMUX_TCA01_DEFAULT_gc = (0x00<<1) ; Default pin\n.equ PORTMUX_TCA01_ALTERNATE_gc = (0x01<<1) ; Alternate pin\n\n; Port Multiplexer TCA0 Output 2 select\n.equ PORTMUX_TCA02_DEFAULT_gc = (0x00<<2) ; Default pin\n.equ PORTMUX_TCA02_ALTERNATE_gc = (0x01<<2) ; Alternate pin\n\n; Port Multiplexer TCA0 Output 3 select\n.equ PORTMUX_TCA03_DEFAULT_gc = (0x00<<3) ; Default pin\n.equ PORTMUX_TCA03_ALTERNATE_gc = (0x01<<3) ; Alternate pin\n\n; Port Multiplexer TCA0 Output 4 select\n.equ PORTMUX_TCA04_DEFAULT_gc = (0x00<<4) ; Default pin\n.equ PORTMUX_TCA04_ALTERNATE_gc = (0x01<<4) ; Alternate pin\n\n; Port Multiplexer TCA0 Output 5 select\n.equ PORTMUX_TCA05_DEFAULT_gc = (0x00<<5) ; Default pin\n.equ PORTMUX_TCA05_ALTERNATE_gc = (0x01<<5) ; Alternate pin\n\n; Port Multiplexer TCB0 select\n.equ PORTMUX_TCB0_DEFAULT_gc = (0x00<<0) ; Default pin\n.equ PORTMUX_TCB0_ALTERNATE_gc = (0x01<<0) ; Alternate pin\n\n; Port Multiplexer TCB1 select\n.equ PORTMUX_TCB1_DEFAULT_gc = (0x00<<1) ; Default pin\n.equ PORTMUX_TCB1_ALTERNATE_gc = (0x01<<1) ; Alternate pin\n\n\n;*************************************************************************\n;** PTC - Peripherial Touch Controller\n;*************************************************************************\n\n\n;*************************************************************************\n;** RSTCTRL - Reset controller\n;*************************************************************************\n\n; RSTCTRL_RSTFR masks\n.equ RSTCTRL_BORF_bm = 0x02              ; Brown out detector Reset flag bit mask\n.equ RSTCTRL_BORF_bp = 1                 ; Brown out detector Reset flag bit position\n.equ RSTCTRL_EXTRF_bm = 0x04             ; External Reset flag bit mask\n.equ RSTCTRL_EXTRF_bp = 2                ; External Reset flag bit position\n.equ RSTCTRL_PORF_bm = 0x01              ; Power on Reset flag bit mask\n.equ RSTCTRL_PORF_bp = 0                 ; Power on Reset flag bit position\n.equ RSTCTRL_SWRF_bm = 0x10              ; Software Reset flag bit mask\n.equ RSTCTRL_SWRF_bp = 4                 ; Software Reset flag bit position\n.equ RSTCTRL_UPDIRF_bm = 0x20            ; UPDI Reset flag bit mask\n.equ RSTCTRL_UPDIRF_bp = 5               ; UPDI Reset flag bit position\n.equ RSTCTRL_WDRF_bm = 0x08              ; Watch dog Reset flag bit mask\n.equ RSTCTRL_WDRF_bp = 3                 ; Watch dog Reset flag bit position\n\n; RSTCTRL_SWRR masks\n.equ RSTCTRL_SWRE_bm = 0x01              ; Software reset enable bit mask\n.equ RSTCTRL_SWRE_bp = 0                 ; Software reset enable bit position\n\n\n;*************************************************************************\n;** RTC - Real-Time Counter\n;*************************************************************************\n\n; RTC_CLKSEL masks\n.equ RTC_CLKSEL_gm = 0x03                ; Clock Select group mask\n.equ RTC_CLKSEL_gp = 0                   ; Clock Select group position\n.equ RTC_CLKSEL0_bm = (1<<0)             ; Clock Select bit 0 mask\n.equ RTC_CLKSEL0_bp = 0                  ; Clock Select bit 0 position\n.equ RTC_CLKSEL1_bm = (1<<1)             ; Clock Select bit 1 mask\n.equ RTC_CLKSEL1_bp = 1                  ; Clock Select bit 1 position\n\n; RTC_CTRLA masks\n.equ RTC_PRESCALER_gm = 0x78             ; Prescaling Factor group mask\n.equ RTC_PRESCALER_gp = 3                ; Prescaling Factor group position\n.equ RTC_PRESCALER0_bm = (1<<3)          ; Prescaling Factor bit 0 mask\n.equ RTC_PRESCALER0_bp = 3               ; Prescaling Factor bit 0 position\n.equ RTC_PRESCALER1_bm = (1<<4)          ; Prescaling Factor bit 1 mask\n.equ RTC_PRESCALER1_bp = 4               ; Prescaling Factor bit 1 position\n.equ RTC_PRESCALER2_bm = (1<<5)          ; Prescaling Factor bit 2 mask\n.equ RTC_PRESCALER2_bp = 5               ; Prescaling Factor bit 2 position\n.equ RTC_PRESCALER3_bm = (1<<6)          ; Prescaling Factor bit 3 mask\n.equ RTC_PRESCALER3_bp = 6               ; Prescaling Factor bit 3 position\n.equ RTC_RTCEN_bm = 0x01                 ; Enable bit mask\n.equ RTC_RTCEN_bp = 0                    ; Enable bit position\n.equ RTC_RUNSTDBY_bm = 0x80              ; Run In Standby bit mask\n.equ RTC_RUNSTDBY_bp = 7                 ; Run In Standby bit position\n\n; RTC_DBGCTRL masks\n.equ RTC_DBGRUN_bm = 0x01                ; Run in debug bit mask\n.equ RTC_DBGRUN_bp = 0                   ; Run in debug bit position\n\n; RTC_INTCTRL masks\n.equ RTC_CMP_bm = 0x02                   ; Compare Match Interrupt enable bit mask\n.equ RTC_CMP_bp = 1                      ; Compare Match Interrupt enable bit position\n.equ RTC_OVF_bm = 0x01                   ; Overflow Interrupt enable bit mask\n.equ RTC_OVF_bp = 0                      ; Overflow Interrupt enable bit position\n\n; RTC_INTFLAGS masks\n; Masks for RTC_CMP already defined\n; Masks for RTC_OVF already defined\n\n; RTC_PITCTRLA masks\n.equ RTC_PERIOD_gm = 0x78                ; Period group mask\n.equ RTC_PERIOD_gp = 3                   ; Period group position\n.equ RTC_PERIOD0_bm = (1<<3)             ; Period bit 0 mask\n.equ RTC_PERIOD0_bp = 3                  ; Period bit 0 position\n.equ RTC_PERIOD1_bm = (1<<4)             ; Period bit 1 mask\n.equ RTC_PERIOD1_bp = 4                  ; Period bit 1 position\n.equ RTC_PERIOD2_bm = (1<<5)             ; Period bit 2 mask\n.equ RTC_PERIOD2_bp = 5                  ; Period bit 2 position\n.equ RTC_PERIOD3_bm = (1<<6)             ; Period bit 3 mask\n.equ RTC_PERIOD3_bp = 6                  ; Period bit 3 position\n.equ RTC_PITEN_bm = 0x01                 ; Enable bit mask\n.equ RTC_PITEN_bp = 0                    ; Enable bit position\n\n; RTC_PITDBGCTRL masks\n; Masks for RTC_DBGRUN already defined\n\n; RTC_PITINTCTRL masks\n.equ RTC_PI_bm = 0x01                    ; Periodic Interrupt bit mask\n.equ RTC_PI_bp = 0                       ; Periodic Interrupt bit position\n\n; RTC_PITINTFLAGS masks\n; Masks for RTC_PI already defined\n\n; RTC_PITSTATUS masks\n.equ RTC_CTRLBUSY_bm = 0x01              ; CTRLA Synchronization Busy Flag bit mask\n.equ RTC_CTRLBUSY_bp = 0                 ; CTRLA Synchronization Busy Flag bit position\n\n; RTC_STATUS masks\n.equ RTC_CMPBUSY_bm = 0x08               ; Comparator Synchronization Busy Flag bit mask\n.equ RTC_CMPBUSY_bp = 3                  ; Comparator Synchronization Busy Flag bit position\n.equ RTC_CNTBUSY_bm = 0x02               ; Count Synchronization Busy Flag bit mask\n.equ RTC_CNTBUSY_bp = 1                  ; Count Synchronization Busy Flag bit position\n.equ RTC_CTRLABUSY_bm = 0x01             ; CTRLA Synchronization Busy Flag bit mask\n.equ RTC_CTRLABUSY_bp = 0                ; CTRLA Synchronization Busy Flag bit position\n.equ RTC_PERBUSY_bm = 0x04               ; Period Synchronization Busy Flag bit mask\n.equ RTC_PERBUSY_bp = 2                  ; Period Synchronization Busy Flag bit position\n\n; Clock Select select\n.equ RTC_CLKSEL_INT32K_gc = (0x00<<0)    ; Internal 32kHz OSC\n.equ RTC_CLKSEL_INT1K_gc = (0x01<<0)     ; Internal 1kHz OSC\n.equ RTC_CLKSEL_TOSC32K_gc = (0x02<<0)   ; 32KHz Crystal OSC\n.equ RTC_CLKSEL_EXTCLK_gc = (0x03<<0)    ; External Clock\n\n; Prescaling Factor select\n.equ RTC_PRESCALER_DIV1_gc = (0x00<<3)   ; RTC Clock / 1\n.equ RTC_PRESCALER_DIV2_gc = (0x01<<3)   ; RTC Clock / 2\n.equ RTC_PRESCALER_DIV4_gc = (0x02<<3)   ; RTC Clock / 4\n.equ RTC_PRESCALER_DIV8_gc = (0x03<<3)   ; RTC Clock / 8\n.equ RTC_PRESCALER_DIV16_gc = (0x04<<3)  ; RTC Clock / 16\n.equ RTC_PRESCALER_DIV32_gc = (0x05<<3)  ; RTC Clock / 32\n.equ RTC_PRESCALER_DIV64_gc = (0x06<<3)  ; RTC Clock / 64\n.equ RTC_PRESCALER_DIV128_gc = (0x07<<3) ; RTC Clock / 128\n.equ RTC_PRESCALER_DIV256_gc = (0x08<<3) ; RTC Clock / 256\n.equ RTC_PRESCALER_DIV512_gc = (0x09<<3) ; RTC Clock / 512\n.equ RTC_PRESCALER_DIV1024_gc = (0x0A<<3) ; RTC Clock / 1024\n.equ RTC_PRESCALER_DIV2048_gc = (0x0B<<3) ; RTC Clock / 2048\n.equ RTC_PRESCALER_DIV4096_gc = (0x0C<<3) ; RTC Clock / 4096\n.equ RTC_PRESCALER_DIV8192_gc = (0x0D<<3) ; RTC Clock / 8192\n.equ RTC_PRESCALER_DIV16384_gc = (0x0E<<3) ; RTC Clock / 16384\n.equ RTC_PRESCALER_DIV32768_gc = (0x0F<<3) ; RTC Clock / 32768\n\n; Period select\n.equ RTC_PERIOD_OFF_gc = (0x00<<3)       ; Off\n.equ RTC_PERIOD_CYC4_gc = (0x01<<3)      ; RTC Clock Cycles 4\n.equ RTC_PERIOD_CYC8_gc = (0x02<<3)      ; RTC Clock Cycles 8\n.equ RTC_PERIOD_CYC16_gc = (0x03<<3)     ; RTC Clock Cycles 16\n.equ RTC_PERIOD_CYC32_gc = (0x04<<3)     ; RTC Clock Cycles 32\n.equ RTC_PERIOD_CYC64_gc = (0x05<<3)     ; RTC Clock Cycles 64\n.equ RTC_PERIOD_CYC128_gc = (0x06<<3)    ; RTC Clock Cycles 128\n.equ RTC_PERIOD_CYC256_gc = (0x07<<3)    ; RTC Clock Cycles 256\n.equ RTC_PERIOD_CYC512_gc = (0x08<<3)    ; RTC Clock Cycles 512\n.equ RTC_PERIOD_CYC1024_gc = (0x09<<3)   ; RTC Clock Cycles 1024\n.equ RTC_PERIOD_CYC2048_gc = (0x0A<<3)   ; RTC Clock Cycles 2048\n.equ RTC_PERIOD_CYC4096_gc = (0x0B<<3)   ; RTC Clock Cycles 4096\n.equ RTC_PERIOD_CYC8192_gc = (0x0C<<3)   ; RTC Clock Cycles 8192\n.equ RTC_PERIOD_CYC16384_gc = (0x0D<<3)  ; RTC Clock Cycles 16384\n.equ RTC_PERIOD_CYC32768_gc = (0x0E<<3)  ; RTC Clock Cycles 32768\n\n\n;*************************************************************************\n;** SIGROW - Signature row\n;*************************************************************************\n\n\n;*************************************************************************\n;** SLPCTRL - Sleep Controller\n;*************************************************************************\n\n; SLPCTRL_CTRLA masks\n.equ SLPCTRL_SEN_bm = 0x01               ; Sleep enable bit mask\n.equ SLPCTRL_SEN_bp = 0                  ; Sleep enable bit position\n.equ SLPCTRL_SMODE_gm = 0x06             ; Sleep mode group mask\n.equ SLPCTRL_SMODE_gp = 1                ; Sleep mode group position\n.equ SLPCTRL_SMODE0_bm = (1<<1)          ; Sleep mode bit 0 mask\n.equ SLPCTRL_SMODE0_bp = 1               ; Sleep mode bit 0 position\n.equ SLPCTRL_SMODE1_bm = (1<<2)          ; Sleep mode bit 1 mask\n.equ SLPCTRL_SMODE1_bp = 2               ; Sleep mode bit 1 position\n\n; Sleep mode select\n.equ SLPCTRL_SMODE_IDLE_gc = (0x00<<1)   ; Idle mode\n.equ SLPCTRL_SMODE_STDBY_gc = (0x01<<1)  ; Standby Mode\n.equ SLPCTRL_SMODE_PDOWN_gc = (0x02<<1)  ; Power-down Mode\n\n\n;*************************************************************************\n;** SPI - Serial Peripheral Interface\n;*************************************************************************\n\n; SPI_CTRLA masks\n.equ SPI_CLK2X_bm = 0x10                 ; Enable Double Speed bit mask\n.equ SPI_CLK2X_bp = 4                    ; Enable Double Speed bit position\n.equ SPI_DORD_bm = 0x40                  ; Data Order Setting bit mask\n.equ SPI_DORD_bp = 6                     ; Data Order Setting bit position\n.equ SPI_ENABLE_bm = 0x01                ; Enable Module bit mask\n.equ SPI_ENABLE_bp = 0                   ; Enable Module bit position\n.equ SPI_MASTER_bm = 0x20                ; Master Operation Enable bit mask\n.equ SPI_MASTER_bp = 5                   ; Master Operation Enable bit position\n.equ SPI_PRESC_gm = 0x06                 ; Prescaler group mask\n.equ SPI_PRESC_gp = 1                    ; Prescaler group position\n.equ SPI_PRESC0_bm = (1<<1)              ; Prescaler bit 0 mask\n.equ SPI_PRESC0_bp = 1                   ; Prescaler bit 0 position\n.equ SPI_PRESC1_bm = (1<<2)              ; Prescaler bit 1 mask\n.equ SPI_PRESC1_bp = 2                   ; Prescaler bit 1 position\n\n; SPI_CTRLB masks\n.equ SPI_BUFEN_bm = 0x80                 ; Buffer Mode Enable bit mask\n.equ SPI_BUFEN_bp = 7                    ; Buffer Mode Enable bit position\n.equ SPI_BUFWR_bm = 0x40                 ; Buffer Write Mode bit mask\n.equ SPI_BUFWR_bp = 6                    ; Buffer Write Mode bit position\n.equ SPI_MODE_gm = 0x03                  ; SPI Mode group mask\n.equ SPI_MODE_gp = 0                     ; SPI Mode group position\n.equ SPI_MODE0_bm = (1<<0)               ; SPI Mode bit 0 mask\n.equ SPI_MODE0_bp = 0                    ; SPI Mode bit 0 position\n.equ SPI_MODE1_bm = (1<<1)               ; SPI Mode bit 1 mask\n.equ SPI_MODE1_bp = 1                    ; SPI Mode bit 1 position\n.equ SPI_SSD_bm = 0x04                   ; Slave Select Disable bit mask\n.equ SPI_SSD_bp = 2                      ; Slave Select Disable bit position\n\n; SPI_INTCTRL masks\n.equ SPI_DREIE_bm = 0x20                 ; Data Register Empty Interrupt Enable bit mask\n.equ SPI_DREIE_bp = 5                    ; Data Register Empty Interrupt Enable bit position\n.equ SPI_IE_bm = 0x01                    ; Interrupt Enable bit mask\n.equ SPI_IE_bp = 0                       ; Interrupt Enable bit position\n.equ SPI_RXCIE_bm = 0x80                 ; Receive Complete Interrupt Enable bit mask\n.equ SPI_RXCIE_bp = 7                    ; Receive Complete Interrupt Enable bit position\n.equ SPI_SSIE_bm = 0x10                  ; Slave Select Trigger Interrupt Enable bit mask\n.equ SPI_SSIE_bp = 4                     ; Slave Select Trigger Interrupt Enable bit position\n.equ SPI_TXCIE_bm = 0x40                 ; Transfer Complete Interrupt Enable bit mask\n.equ SPI_TXCIE_bp = 6                    ; Transfer Complete Interrupt Enable bit position\n\n; SPI_INTFLAGS masks\n.equ SPI_BUFOVF_bm = 0x01                ; Buffer Overflow bit mask\n.equ SPI_BUFOVF_bp = 0                   ; Buffer Overflow bit position\n.equ SPI_DREIF_bm = 0x20                 ; Data Register Empty Interrupt Flag bit mask\n.equ SPI_DREIF_bp = 5                    ; Data Register Empty Interrupt Flag bit position\n.equ SPI_RXCIF_bm = 0x80                 ; Receive Complete Interrupt Flag bit mask\n.equ SPI_RXCIF_bp = 7                    ; Receive Complete Interrupt Flag bit position\n.equ SPI_SSIF_bm = 0x10                  ; Slave Select Trigger Interrupt Flag bit mask\n.equ SPI_SSIF_bp = 4                     ; Slave Select Trigger Interrupt Flag bit position\n.equ SPI_TXCIF_bm = 0x40                 ; Transfer Complete Interrupt Flag bit mask\n.equ SPI_TXCIF_bp = 6                    ; Transfer Complete Interrupt Flag bit position\n.equ SPI_IF_bm = 0x80                    ; Interrupt Flag bit mask\n.equ SPI_IF_bp = 7                       ; Interrupt Flag bit position\n.equ SPI_WRCOL_bm = 0x40                 ; Write Collision bit mask\n.equ SPI_WRCOL_bp = 6                    ; Write Collision bit position\n\n; Prescaler select\n.equ SPI_PRESC_DIV4_gc = (0x00<<1)       ; System Clock / 4\n.equ SPI_PRESC_DIV16_gc = (0x01<<1)      ; System Clock / 16\n.equ SPI_PRESC_DIV64_gc = (0x02<<1)      ; System Clock / 64\n.equ SPI_PRESC_DIV128_gc = (0x03<<1)     ; System Clock / 128\n\n; SPI Mode select\n.equ SPI_MODE_0_gc = (0x00<<0)           ; SPI Mode 0\n.equ SPI_MODE_1_gc = (0x01<<0)           ; SPI Mode 1\n.equ SPI_MODE_2_gc = (0x02<<0)           ; SPI Mode 2\n.equ SPI_MODE_3_gc = (0x03<<0)           ; SPI Mode 3\n\n\n;*************************************************************************\n;** SYSCFG - System Configuration Registers\n;*************************************************************************\n\n; SYSCFG_EXTBRK masks\n.equ SYSCFG_ENEXTBRK_bm = 0x01           ; External break enable bit mask\n.equ SYSCFG_ENEXTBRK_bp = 0              ; External break enable bit position\n\n\n;*************************************************************************\n;** TCA - 16-bit Timer/Counter Type A\n;*************************************************************************\n\n; TCA_SINGLE_CTRLA masks\n.equ TCA_SINGLE_CLKSEL_gm = 0x0E         ; Clock Selection group mask\n.equ TCA_SINGLE_CLKSEL_gp = 1            ; Clock Selection group position\n.equ TCA_SINGLE_CLKSEL0_bm = (1<<1)      ; Clock Selection bit 0 mask\n.equ TCA_SINGLE_CLKSEL0_bp = 1           ; Clock Selection bit 0 position\n.equ TCA_SINGLE_CLKSEL1_bm = (1<<2)      ; Clock Selection bit 1 mask\n.equ TCA_SINGLE_CLKSEL1_bp = 2           ; Clock Selection bit 1 position\n.equ TCA_SINGLE_CLKSEL2_bm = (1<<3)      ; Clock Selection bit 2 mask\n.equ TCA_SINGLE_CLKSEL2_bp = 3           ; Clock Selection bit 2 position\n.equ TCA_SINGLE_ENABLE_bm = 0x01         ; Module Enable bit mask\n.equ TCA_SINGLE_ENABLE_bp = 0            ; Module Enable bit position\n\n; TCA_SINGLE_CTRLB masks\n.equ TCA_SINGLE_ALUPD_bm = 0x08          ; Auto Lock Update bit mask\n.equ TCA_SINGLE_ALUPD_bp = 3             ; Auto Lock Update bit position\n.equ TCA_SINGLE_CMP0EN_bm = 0x10         ; Compare 0 Enable bit mask\n.equ TCA_SINGLE_CMP0EN_bp = 4            ; Compare 0 Enable bit position\n.equ TCA_SINGLE_CMP1EN_bm = 0x20         ; Compare 1 Enable bit mask\n.equ TCA_SINGLE_CMP1EN_bp = 5            ; Compare 1 Enable bit position\n.equ TCA_SINGLE_CMP2EN_bm = 0x40         ; Compare 2 Enable bit mask\n.equ TCA_SINGLE_CMP2EN_bp = 6            ; Compare 2 Enable bit position\n.equ TCA_SINGLE_WGMODE_gm = 0x07         ; Waveform generation mode group mask\n.equ TCA_SINGLE_WGMODE_gp = 0            ; Waveform generation mode group position\n.equ TCA_SINGLE_WGMODE0_bm = (1<<0)      ; Waveform generation mode bit 0 mask\n.equ TCA_SINGLE_WGMODE0_bp = 0           ; Waveform generation mode bit 0 position\n.equ TCA_SINGLE_WGMODE1_bm = (1<<1)      ; Waveform generation mode bit 1 mask\n.equ TCA_SINGLE_WGMODE1_bp = 1           ; Waveform generation mode bit 1 position\n.equ TCA_SINGLE_WGMODE2_bm = (1<<2)      ; Waveform generation mode bit 2 mask\n.equ TCA_SINGLE_WGMODE2_bp = 2           ; Waveform generation mode bit 2 position\n\n; TCA_SINGLE_CTRLC masks\n.equ TCA_SINGLE_CMP0OV_bm = 0x01         ; Compare 0 Waveform Output Value bit mask\n.equ TCA_SINGLE_CMP0OV_bp = 0            ; Compare 0 Waveform Output Value bit position\n.equ TCA_SINGLE_CMP1OV_bm = 0x02         ; Compare 1 Waveform Output Value bit mask\n.equ TCA_SINGLE_CMP1OV_bp = 1            ; Compare 1 Waveform Output Value bit position\n.equ TCA_SINGLE_CMP2OV_bm = 0x04         ; Compare 2 Waveform Output Value bit mask\n.equ TCA_SINGLE_CMP2OV_bp = 2            ; Compare 2 Waveform Output Value bit position\n\n; TCA_SINGLE_CTRLD masks\n.equ TCA_SINGLE_SPLITM_bm = 0x01         ; Split Mode Enable bit mask\n.equ TCA_SINGLE_SPLITM_bp = 0            ; Split Mode Enable bit position\n\n; TCA_SINGLE_CTRLECLR masks\n.equ TCA_SINGLE_CMD_gm = 0x0C            ; Command group mask\n.equ TCA_SINGLE_CMD_gp = 2               ; Command group position\n.equ TCA_SINGLE_CMD0_bm = (1<<2)         ; Command bit 0 mask\n.equ TCA_SINGLE_CMD0_bp = 2              ; Command bit 0 position\n.equ TCA_SINGLE_CMD1_bm = (1<<3)         ; Command bit 1 mask\n.equ TCA_SINGLE_CMD1_bp = 3              ; Command bit 1 position\n.equ TCA_SINGLE_DIR_bm = 0x01            ; Direction bit mask\n.equ TCA_SINGLE_DIR_bp = 0               ; Direction bit position\n.equ TCA_SINGLE_LUPD_bm = 0x02           ; Lock Update bit mask\n.equ TCA_SINGLE_LUPD_bp = 1              ; Lock Update bit position\n\n; TCA_SINGLE_CTRLESET masks\n; Masks for TCA_SINGLE_CMD already defined\n; Masks for TCA_SINGLE_DIR already defined\n; Masks for TCA_SINGLE_LUPD already defined\n\n; TCA_SINGLE_CTRLFCLR masks\n.equ TCA_SINGLE_CMP0BV_bm = 0x02         ; Compare 0 Buffer Valid bit mask\n.equ TCA_SINGLE_CMP0BV_bp = 1            ; Compare 0 Buffer Valid bit position\n.equ TCA_SINGLE_CMP1BV_bm = 0x04         ; Compare 1 Buffer Valid bit mask\n.equ TCA_SINGLE_CMP1BV_bp = 2            ; Compare 1 Buffer Valid bit position\n.equ TCA_SINGLE_CMP2BV_bm = 0x08         ; Compare 2 Buffer Valid bit mask\n.equ TCA_SINGLE_CMP2BV_bp = 3            ; Compare 2 Buffer Valid bit position\n.equ TCA_SINGLE_PERBV_bm = 0x01          ; Period Buffer Valid bit mask\n.equ TCA_SINGLE_PERBV_bp = 0             ; Period Buffer Valid bit position\n\n; TCA_SINGLE_CTRLFSET masks\n; Masks for TCA_SINGLE_CMP0BV already defined\n; Masks for TCA_SINGLE_CMP1BV already defined\n; Masks for TCA_SINGLE_CMP2BV already defined\n; Masks for TCA_SINGLE_PERBV already defined\n\n; TCA_SINGLE_DBGCTRL masks\n.equ TCA_SINGLE_DBGRUN_bm = 0x01         ; Debug Run bit mask\n.equ TCA_SINGLE_DBGRUN_bp = 0            ; Debug Run bit position\n\n; TCA_SINGLE_EVCTRL masks\n.equ TCA_SINGLE_CNTEI_bm = 0x01          ; Count on Event Input bit mask\n.equ TCA_SINGLE_CNTEI_bp = 0             ; Count on Event Input bit position\n.equ TCA_SINGLE_EVACT_gm = 0x06          ; Event Action group mask\n.equ TCA_SINGLE_EVACT_gp = 1             ; Event Action group position\n.equ TCA_SINGLE_EVACT0_bm = (1<<1)       ; Event Action bit 0 mask\n.equ TCA_SINGLE_EVACT0_bp = 1            ; Event Action bit 0 position\n.equ TCA_SINGLE_EVACT1_bm = (1<<2)       ; Event Action bit 1 mask\n.equ TCA_SINGLE_EVACT1_bp = 2            ; Event Action bit 1 position\n\n; TCA_SINGLE_INTCTRL masks\n.equ TCA_SINGLE_CMP0_bm = 0x10           ; Compare 0 Interrupt bit mask\n.equ TCA_SINGLE_CMP0_bp = 4              ; Compare 0 Interrupt bit position\n.equ TCA_SINGLE_CMP1_bm = 0x20           ; Compare 1 Interrupt bit mask\n.equ TCA_SINGLE_CMP1_bp = 5              ; Compare 1 Interrupt bit position\n.equ TCA_SINGLE_CMP2_bm = 0x40           ; Compare 2 Interrupt bit mask\n.equ TCA_SINGLE_CMP2_bp = 6              ; Compare 2 Interrupt bit position\n.equ TCA_SINGLE_OVF_bm = 0x01            ; Overflow Interrupt bit mask\n.equ TCA_SINGLE_OVF_bp = 0               ; Overflow Interrupt bit position\n\n; TCA_SINGLE_INTFLAGS masks\n; Masks for TCA_SINGLE_CMP0 already defined\n; Masks for TCA_SINGLE_CMP1 already defined\n; Masks for TCA_SINGLE_CMP2 already defined\n; Masks for TCA_SINGLE_OVF already defined\n\n; TCA_SPLIT_CTRLA masks\n.equ TCA_SPLIT_CLKSEL_gm = 0x0E          ; Clock Selection group mask\n.equ TCA_SPLIT_CLKSEL_gp = 1             ; Clock Selection group position\n.equ TCA_SPLIT_CLKSEL0_bm = (1<<1)       ; Clock Selection bit 0 mask\n.equ TCA_SPLIT_CLKSEL0_bp = 1            ; Clock Selection bit 0 position\n.equ TCA_SPLIT_CLKSEL1_bm = (1<<2)       ; Clock Selection bit 1 mask\n.equ TCA_SPLIT_CLKSEL1_bp = 2            ; Clock Selection bit 1 position\n.equ TCA_SPLIT_CLKSEL2_bm = (1<<3)       ; Clock Selection bit 2 mask\n.equ TCA_SPLIT_CLKSEL2_bp = 3            ; Clock Selection bit 2 position\n.equ TCA_SPLIT_ENABLE_bm = 0x01          ; Module Enable bit mask\n.equ TCA_SPLIT_ENABLE_bp = 0             ; Module Enable bit position\n\n; TCA_SPLIT_CTRLB masks\n.equ TCA_SPLIT_HCMP0EN_bm = 0x10         ; High Compare 0 Enable bit mask\n.equ TCA_SPLIT_HCMP0EN_bp = 4            ; High Compare 0 Enable bit position\n.equ TCA_SPLIT_HCMP1EN_bm = 0x20         ; High Compare 1 Enable bit mask\n.equ TCA_SPLIT_HCMP1EN_bp = 5            ; High Compare 1 Enable bit position\n.equ TCA_SPLIT_HCMP2EN_bm = 0x40         ; High Compare 2 Enable bit mask\n.equ TCA_SPLIT_HCMP2EN_bp = 6            ; High Compare 2 Enable bit position\n.equ TCA_SPLIT_LCMP0EN_bm = 0x01         ; Low Compare 0 Enable bit mask\n.equ TCA_SPLIT_LCMP0EN_bp = 0            ; Low Compare 0 Enable bit position\n.equ TCA_SPLIT_LCMP1EN_bm = 0x02         ; Low Compare 1 Enable bit mask\n.equ TCA_SPLIT_LCMP1EN_bp = 1            ; Low Compare 1 Enable bit position\n.equ TCA_SPLIT_LCMP2EN_bm = 0x04         ; Low Compare 2 Enable bit mask\n.equ TCA_SPLIT_LCMP2EN_bp = 2            ; Low Compare 2 Enable bit position\n\n; TCA_SPLIT_CTRLC masks\n.equ TCA_SPLIT_HCMP0OV_bm = 0x10         ; High Compare 0 Output Value bit mask\n.equ TCA_SPLIT_HCMP0OV_bp = 4            ; High Compare 0 Output Value bit position\n.equ TCA_SPLIT_HCMP1OV_bm = 0x20         ; High Compare 1 Output Value bit mask\n.equ TCA_SPLIT_HCMP1OV_bp = 5            ; High Compare 1 Output Value bit position\n.equ TCA_SPLIT_HCMP2OV_bm = 0x40         ; High Compare 2 Output Value bit mask\n.equ TCA_SPLIT_HCMP2OV_bp = 6            ; High Compare 2 Output Value bit position\n.equ TCA_SPLIT_LCMP0OV_bm = 0x01         ; Low Compare 0 Output Value bit mask\n.equ TCA_SPLIT_LCMP0OV_bp = 0            ; Low Compare 0 Output Value bit position\n.equ TCA_SPLIT_LCMP1OV_bm = 0x02         ; Low Compare 1 Output Value bit mask\n.equ TCA_SPLIT_LCMP1OV_bp = 1            ; Low Compare 1 Output Value bit position\n.equ TCA_SPLIT_LCMP2OV_bm = 0x04         ; Low Compare 2 Output Value bit mask\n.equ TCA_SPLIT_LCMP2OV_bp = 2            ; Low Compare 2 Output Value bit position\n\n; TCA_SPLIT_CTRLD masks\n.equ TCA_SPLIT_SPLITM_bm = 0x01          ; Split Mode Enable bit mask\n.equ TCA_SPLIT_SPLITM_bp = 0             ; Split Mode Enable bit position\n\n; TCA_SPLIT_CTRLECLR masks\n.equ TCA_SPLIT_CMD_gm = 0x0C             ; Command group mask\n.equ TCA_SPLIT_CMD_gp = 2                ; Command group position\n.equ TCA_SPLIT_CMD0_bm = (1<<2)          ; Command bit 0 mask\n.equ TCA_SPLIT_CMD0_bp = 2               ; Command bit 0 position\n.equ TCA_SPLIT_CMD1_bm = (1<<3)          ; Command bit 1 mask\n.equ TCA_SPLIT_CMD1_bp = 3               ; Command bit 1 position\n\n; TCA_SPLIT_CTRLESET masks\n; Masks for TCA_SPLIT_CMD already defined\n\n; TCA_SPLIT_DBGCTRL masks\n.equ TCA_SPLIT_DBGRUN_bm = 0x01          ; Debug Run bit mask\n.equ TCA_SPLIT_DBGRUN_bp = 0             ; Debug Run bit position\n\n; TCA_SPLIT_INTCTRL masks\n.equ TCA_SPLIT_HUNF_bm = 0x02            ; High Underflow Interrupt Enable bit mask\n.equ TCA_SPLIT_HUNF_bp = 1               ; High Underflow Interrupt Enable bit position\n.equ TCA_SPLIT_LCMP0_bm = 0x10           ; Low Compare 0 Interrupt Enable bit mask\n.equ TCA_SPLIT_LCMP0_bp = 4              ; Low Compare 0 Interrupt Enable bit position\n.equ TCA_SPLIT_LCMP1_bm = 0x20           ; Low Compare 1 Interrupt Enable bit mask\n.equ TCA_SPLIT_LCMP1_bp = 5              ; Low Compare 1 Interrupt Enable bit position\n.equ TCA_SPLIT_LCMP2_bm = 0x40           ; Low Compare 2 Interrupt Enable bit mask\n.equ TCA_SPLIT_LCMP2_bp = 6              ; Low Compare 2 Interrupt Enable bit position\n.equ TCA_SPLIT_LUNF_bm = 0x01            ; Low Underflow Interrupt Enable bit mask\n.equ TCA_SPLIT_LUNF_bp = 0               ; Low Underflow Interrupt Enable bit position\n\n; TCA_SPLIT_INTFLAGS masks\n; Masks for TCA_SPLIT_HUNF already defined\n; Masks for TCA_SPLIT_LCMP0 already defined\n; Masks for TCA_SPLIT_LCMP1 already defined\n; Masks for TCA_SPLIT_LCMP2 already defined\n; Masks for TCA_SPLIT_LUNF already defined\n\n; Clock Selection select\n.equ TCA_SINGLE_CLKSEL_DIV1_gc = (0x00<<1) ; System Clock\n.equ TCA_SINGLE_CLKSEL_DIV2_gc = (0x01<<1) ; System Clock / 2\n.equ TCA_SINGLE_CLKSEL_DIV4_gc = (0x02<<1) ; System Clock / 4\n.equ TCA_SINGLE_CLKSEL_DIV8_gc = (0x03<<1) ; System Clock / 8\n.equ TCA_SINGLE_CLKSEL_DIV16_gc = (0x04<<1) ; System Clock / 16\n.equ TCA_SINGLE_CLKSEL_DIV64_gc = (0x05<<1) ; System Clock / 64\n.equ TCA_SINGLE_CLKSEL_DIV256_gc = (0x06<<1) ; System Clock / 256\n.equ TCA_SINGLE_CLKSEL_DIV1024_gc = (0x07<<1) ; System Clock / 1024\n\n; Waveform generation mode select\n.equ TCA_SINGLE_WGMODE_NORMAL_gc = (0x00<<0) ; Normal Mode\n.equ TCA_SINGLE_WGMODE_FRQ_gc = (0x01<<0) ; Frequency Generation Mode\n.equ TCA_SINGLE_WGMODE_SINGLESLOPE_gc = (0x03<<0) ; Single Slope PWM\n.equ TCA_SINGLE_WGMODE_DSTOP_gc = (0x05<<0) ; Dual Slope PWM, overflow on TOP\n.equ TCA_SINGLE_WGMODE_DSBOTH_gc = (0x06<<0) ; Dual Slope PWM, overflow on TOP and BOTTOM\n.equ TCA_SINGLE_WGMODE_DSBOTTOM_gc = (0x07<<0) ; Dual Slope PWM, overflow on BOTTOM\n\n; Command select\n.equ TCA_SINGLE_CMD_NONE_gc = (0x00<<2)  ; No Command\n.equ TCA_SINGLE_CMD_UPDATE_gc = (0x01<<2) ; Force Update\n.equ TCA_SINGLE_CMD_RESTART_gc = (0x02<<2) ; Force Restart\n.equ TCA_SINGLE_CMD_RESET_gc = (0x03<<2) ; Force Hard Reset\n\n; Direction select\n.equ TCA_SINGLE_DIR_UP_gc = (0x00<<0)    ; Count up\n.equ TCA_SINGLE_DIR_DOWN_gc = (0x01<<0)  ; Count down\n\n; Event Action select\n.equ TCA_SINGLE_EVACT_POSEDGE_gc = (0x00<<1) ; Count on positive edge event\n.equ TCA_SINGLE_EVACT_ANYEDGE_gc = (0x01<<1) ; Count on any edge event\n.equ TCA_SINGLE_EVACT_HIGHLVL_gc = (0x02<<1) ; Count on prescaled clock while event line is 1.\n.equ TCA_SINGLE_EVACT_UPDOWN_gc = (0x03<<1) ; Count on prescaled clock. Event controls count direction. Up-count when event line is 0, down-count when event line is 1.\n\n; Clock Selection select\n.equ TCA_SPLIT_CLKSEL_DIV1_gc = (0x00<<1) ; System Clock\n.equ TCA_SPLIT_CLKSEL_DIV2_gc = (0x01<<1) ; System Clock / 2\n.equ TCA_SPLIT_CLKSEL_DIV4_gc = (0x02<<1) ; System Clock / 4\n.equ TCA_SPLIT_CLKSEL_DIV8_gc = (0x03<<1) ; System Clock / 8\n.equ TCA_SPLIT_CLKSEL_DIV16_gc = (0x04<<1) ; System Clock / 16\n.equ TCA_SPLIT_CLKSEL_DIV64_gc = (0x05<<1) ; System Clock / 64\n.equ TCA_SPLIT_CLKSEL_DIV256_gc = (0x06<<1) ; System Clock / 256\n.equ TCA_SPLIT_CLKSEL_DIV1024_gc = (0x07<<1) ; System Clock / 1024\n\n; Command select\n.equ TCA_SPLIT_CMD_NONE_gc = (0x00<<2)   ; No Command\n.equ TCA_SPLIT_CMD_UPDATE_gc = (0x01<<2) ; Force Update\n.equ TCA_SPLIT_CMD_RESTART_gc = (0x02<<2) ; Force Restart\n.equ TCA_SPLIT_CMD_RESET_gc = (0x03<<2)  ; Force Hard Reset\n\n\n;*************************************************************************\n;** TCB - 16-bit Timer Type B\n;*************************************************************************\n\n; TCB_CTRLA masks\n.equ TCB_CLKSEL_gm = 0x06                ; Clock Select group mask\n.equ TCB_CLKSEL_gp = 1                   ; Clock Select group position\n.equ TCB_CLKSEL0_bm = (1<<1)             ; Clock Select bit 0 mask\n.equ TCB_CLKSEL0_bp = 1                  ; Clock Select bit 0 position\n.equ TCB_CLKSEL1_bm = (1<<2)             ; Clock Select bit 1 mask\n.equ TCB_CLKSEL1_bp = 2                  ; Clock Select bit 1 position\n.equ TCB_ENABLE_bm = 0x01                ; Enable bit mask\n.equ TCB_ENABLE_bp = 0                   ; Enable bit position\n.equ TCB_RUNSTDBY_bm = 0x40              ; Run Standby bit mask\n.equ TCB_RUNSTDBY_bp = 6                 ; Run Standby bit position\n.equ TCB_SYNCUPD_bm = 0x10               ; Synchronize Update bit mask\n.equ TCB_SYNCUPD_bp = 4                  ; Synchronize Update bit position\n\n; TCB_CTRLB masks\n.equ TCB_ASYNC_bm = 0x40                 ; Asynchronous Enable bit mask\n.equ TCB_ASYNC_bp = 6                    ; Asynchronous Enable bit position\n.equ TCB_CCMPEN_bm = 0x10                ; Pin Output Enable bit mask\n.equ TCB_CCMPEN_bp = 4                   ; Pin Output Enable bit position\n.equ TCB_CCMPINIT_bm = 0x20              ; Pin Initial State bit mask\n.equ TCB_CCMPINIT_bp = 5                 ; Pin Initial State bit position\n.equ TCB_CNTMODE_gm = 0x07               ; Timer Mode group mask\n.equ TCB_CNTMODE_gp = 0                  ; Timer Mode group position\n.equ TCB_CNTMODE0_bm = (1<<0)            ; Timer Mode bit 0 mask\n.equ TCB_CNTMODE0_bp = 0                 ; Timer Mode bit 0 position\n.equ TCB_CNTMODE1_bm = (1<<1)            ; Timer Mode bit 1 mask\n.equ TCB_CNTMODE1_bp = 1                 ; Timer Mode bit 1 position\n.equ TCB_CNTMODE2_bm = (1<<2)            ; Timer Mode bit 2 mask\n.equ TCB_CNTMODE2_bp = 2                 ; Timer Mode bit 2 position\n\n; TCB_DBGCTRL masks\n.equ TCB_DBGRUN_bm = 0x01                ; Debug Run bit mask\n.equ TCB_DBGRUN_bp = 0                   ; Debug Run bit position\n\n; TCB_EVCTRL masks\n.equ TCB_CAPTEI_bm = 0x01                ; Event Input Enable bit mask\n.equ TCB_CAPTEI_bp = 0                   ; Event Input Enable bit position\n.equ TCB_EDGE_bm = 0x10                  ; Event Edge bit mask\n.equ TCB_EDGE_bp = 4                     ; Event Edge bit position\n.equ TCB_FILTER_bm = 0x40                ; Input Capture Noise Cancellation Filter bit mask\n.equ TCB_FILTER_bp = 6                   ; Input Capture Noise Cancellation Filter bit position\n\n; TCB_INTCTRL masks\n.equ TCB_CAPT_bm = 0x01                  ; Capture or Timeout bit mask\n.equ TCB_CAPT_bp = 0                     ; Capture or Timeout bit position\n\n; TCB_INTFLAGS masks\n; Masks for TCB_CAPT already defined\n\n; TCB_STATUS masks\n.equ TCB_RUN_bm = 0x01                   ; Run bit mask\n.equ TCB_RUN_bp = 0                      ; Run bit position\n\n; Clock Select select\n.equ TCB_CLKSEL_CLKDIV1_gc = (0x00<<1)   ; CLK_PER (No Prescaling)\n.equ TCB_CLKSEL_CLKDIV2_gc = (0x01<<1)   ; CLK_PER/2 (From Prescaler)\n.equ TCB_CLKSEL_CLKTCA_gc = (0x02<<1)    ; Use Clock from TCA\n\n; Timer Mode select\n.equ TCB_CNTMODE_INT_gc = (0x00<<0)      ; Periodic Interrupt\n.equ TCB_CNTMODE_TIMEOUT_gc = (0x01<<0)  ; Periodic Timeout\n.equ TCB_CNTMODE_CAPT_gc = (0x02<<0)     ; Input Capture Event\n.equ TCB_CNTMODE_FRQ_gc = (0x03<<0)      ; Input Capture Frequency measurement\n.equ TCB_CNTMODE_PW_gc = (0x04<<0)       ; Input Capture Pulse-Width measurement\n.equ TCB_CNTMODE_FRQPW_gc = (0x05<<0)    ; Input Capture Frequency and Pulse-Width measurement\n.equ TCB_CNTMODE_SINGLE_gc = (0x06<<0)   ; Single Shot\n.equ TCB_CNTMODE_PWM8_gc = (0x07<<0)     ; 8-bit PWM\n\n\n;*************************************************************************\n;** TCD - Timer Counter D\n;*************************************************************************\n\n; TCD_CTRLA masks\n.equ TCD_CLKSEL_gm = 0x60                ; clock select group mask\n.equ TCD_CLKSEL_gp = 5                   ; clock select group position\n.equ TCD_CLKSEL0_bm = (1<<5)             ; clock select bit 0 mask\n.equ TCD_CLKSEL0_bp = 5                  ; clock select bit 0 position\n.equ TCD_CLKSEL1_bm = (1<<6)             ; clock select bit 1 mask\n.equ TCD_CLKSEL1_bp = 6                  ; clock select bit 1 position\n.equ TCD_CNTPRES_gm = 0x18               ; counter prescaler group mask\n.equ TCD_CNTPRES_gp = 3                  ; counter prescaler group position\n.equ TCD_CNTPRES0_bm = (1<<3)            ; counter prescaler bit 0 mask\n.equ TCD_CNTPRES0_bp = 3                 ; counter prescaler bit 0 position\n.equ TCD_CNTPRES1_bm = (1<<4)            ; counter prescaler bit 1 mask\n.equ TCD_CNTPRES1_bp = 4                 ; counter prescaler bit 1 position\n.equ TCD_ENABLE_bm = 0x01                ; Enable bit mask\n.equ TCD_ENABLE_bp = 0                   ; Enable bit position\n.equ TCD_SYNCPRES_gm = 0x06              ; Syncronization prescaler group mask\n.equ TCD_SYNCPRES_gp = 1                 ; Syncronization prescaler group position\n.equ TCD_SYNCPRES0_bm = (1<<1)           ; Syncronization prescaler bit 0 mask\n.equ TCD_SYNCPRES0_bp = 1                ; Syncronization prescaler bit 0 position\n.equ TCD_SYNCPRES1_bm = (1<<2)           ; Syncronization prescaler bit 1 mask\n.equ TCD_SYNCPRES1_bp = 2                ; Syncronization prescaler bit 1 position\n\n; TCD_CTRLB masks\n.equ TCD_WGMODE_gm = 0x03                ; Waveform generation mode group mask\n.equ TCD_WGMODE_gp = 0                   ; Waveform generation mode group position\n.equ TCD_WGMODE0_bm = (1<<0)             ; Waveform generation mode bit 0 mask\n.equ TCD_WGMODE0_bp = 0                  ; Waveform generation mode bit 0 position\n.equ TCD_WGMODE1_bm = (1<<1)             ; Waveform generation mode bit 1 mask\n.equ TCD_WGMODE1_bp = 1                  ; Waveform generation mode bit 1 position\n\n; TCD_CTRLC masks\n.equ TCD_AUPDATE_bm = 0x02               ; Auto update bit mask\n.equ TCD_AUPDATE_bp = 1                  ; Auto update bit position\n.equ TCD_CMPCSEL_bm = 0x40               ; Compare C output select bit mask\n.equ TCD_CMPCSEL_bp = 6                  ; Compare C output select bit position\n.equ TCD_CMPDSEL_bm = 0x80               ; Compare D output select bit mask\n.equ TCD_CMPDSEL_bp = 7                  ; Compare D output select bit position\n.equ TCD_CMPOVR_bm = 0x01                ; Compare output value override bit mask\n.equ TCD_CMPOVR_bp = 0                   ; Compare output value override bit position\n.equ TCD_FIFTY_bm = 0x08                 ; Fifty percent waveform bit mask\n.equ TCD_FIFTY_bp = 3                    ; Fifty percent waveform bit position\n\n; TCD_CTRLD masks\n.equ TCD_CMPAVAL_gm = 0x0F               ; Compare A value group mask\n.equ TCD_CMPAVAL_gp = 0                  ; Compare A value group position\n.equ TCD_CMPAVAL0_bm = (1<<0)            ; Compare A value bit 0 mask\n.equ TCD_CMPAVAL0_bp = 0                 ; Compare A value bit 0 position\n.equ TCD_CMPAVAL1_bm = (1<<1)            ; Compare A value bit 1 mask\n.equ TCD_CMPAVAL1_bp = 1                 ; Compare A value bit 1 position\n.equ TCD_CMPAVAL2_bm = (1<<2)            ; Compare A value bit 2 mask\n.equ TCD_CMPAVAL2_bp = 2                 ; Compare A value bit 2 position\n.equ TCD_CMPAVAL3_bm = (1<<3)            ; Compare A value bit 3 mask\n.equ TCD_CMPAVAL3_bp = 3                 ; Compare A value bit 3 position\n.equ TCD_CMPBVAL_gm = 0xF0               ; Compare B value group mask\n.equ TCD_CMPBVAL_gp = 4                  ; Compare B value group position\n.equ TCD_CMPBVAL0_bm = (1<<4)            ; Compare B value bit 0 mask\n.equ TCD_CMPBVAL0_bp = 4                 ; Compare B value bit 0 position\n.equ TCD_CMPBVAL1_bm = (1<<5)            ; Compare B value bit 1 mask\n.equ TCD_CMPBVAL1_bp = 5                 ; Compare B value bit 1 position\n.equ TCD_CMPBVAL2_bm = (1<<6)            ; Compare B value bit 2 mask\n.equ TCD_CMPBVAL2_bp = 6                 ; Compare B value bit 2 position\n.equ TCD_CMPBVAL3_bm = (1<<7)            ; Compare B value bit 3 mask\n.equ TCD_CMPBVAL3_bp = 7                 ; Compare B value bit 3 position\n\n; TCD_CTRLE masks\n.equ TCD_DISEOC_bm = 0x80                ; Disable at end of cycle bit mask\n.equ TCD_DISEOC_bp = 7                   ; Disable at end of cycle bit position\n.equ TCD_RESTART_bm = 0x04               ; Restart strobe bit mask\n.equ TCD_RESTART_bp = 2                  ; Restart strobe bit position\n.equ TCD_SCAPTUREA_bm = 0x08             ; Software Capture A Strobe bit mask\n.equ TCD_SCAPTUREA_bp = 3                ; Software Capture A Strobe bit position\n.equ TCD_SCAPTUREB_bm = 0x10             ; Software Capture B Strobe bit mask\n.equ TCD_SCAPTUREB_bp = 4                ; Software Capture B Strobe bit position\n.equ TCD_SYNC_bm = 0x02                  ; synchronize strobe bit mask\n.equ TCD_SYNC_bp = 1                     ; synchronize strobe bit position\n.equ TCD_SYNCEOC_bm = 0x01               ; synchronize end of cycle strobe bit mask\n.equ TCD_SYNCEOC_bp = 0                  ; synchronize end of cycle strobe bit position\n\n; TCD_DBGCTRL masks\n.equ TCD_DBGRUN_bm = 0x01                ; Debug run bit mask\n.equ TCD_DBGRUN_bp = 0                   ; Debug run bit position\n.equ TCD_FAULTDET_bm = 0x04              ; Fault detection bit mask\n.equ TCD_FAULTDET_bp = 2                 ; Fault detection bit position\n\n; TCD_DITCTRL masks\n.equ TCD_DITHERSEL_gm = 0x03             ; dither select group mask\n.equ TCD_DITHERSEL_gp = 0                ; dither select group position\n.equ TCD_DITHERSEL0_bm = (1<<0)          ; dither select bit 0 mask\n.equ TCD_DITHERSEL0_bp = 0               ; dither select bit 0 position\n.equ TCD_DITHERSEL1_bm = (1<<1)          ; dither select bit 1 mask\n.equ TCD_DITHERSEL1_bp = 1               ; dither select bit 1 position\n\n; TCD_DITVAL masks\n.equ TCD_DITHER_gm = 0x0F                ; Dither value group mask\n.equ TCD_DITHER_gp = 0                   ; Dither value group position\n.equ TCD_DITHER0_bm = (1<<0)             ; Dither value bit 0 mask\n.equ TCD_DITHER0_bp = 0                  ; Dither value bit 0 position\n.equ TCD_DITHER1_bm = (1<<1)             ; Dither value bit 1 mask\n.equ TCD_DITHER1_bp = 1                  ; Dither value bit 1 position\n.equ TCD_DITHER2_bm = (1<<2)             ; Dither value bit 2 mask\n.equ TCD_DITHER2_bp = 2                  ; Dither value bit 2 position\n.equ TCD_DITHER3_bm = (1<<3)             ; Dither value bit 3 mask\n.equ TCD_DITHER3_bp = 3                  ; Dither value bit 3 position\n\n; TCD_DLYCTRL masks\n.equ TCD_DLYPRESC_gm = 0x30              ; Delay prescaler group mask\n.equ TCD_DLYPRESC_gp = 4                 ; Delay prescaler group position\n.equ TCD_DLYPRESC0_bm = (1<<4)           ; Delay prescaler bit 0 mask\n.equ TCD_DLYPRESC0_bp = 4                ; Delay prescaler bit 0 position\n.equ TCD_DLYPRESC1_bm = (1<<5)           ; Delay prescaler bit 1 mask\n.equ TCD_DLYPRESC1_bp = 5                ; Delay prescaler bit 1 position\n.equ TCD_DLYSEL_gm = 0x03                ; Delay select group mask\n.equ TCD_DLYSEL_gp = 0                   ; Delay select group position\n.equ TCD_DLYSEL0_bm = (1<<0)             ; Delay select bit 0 mask\n.equ TCD_DLYSEL0_bp = 0                  ; Delay select bit 0 position\n.equ TCD_DLYSEL1_bm = (1<<1)             ; Delay select bit 1 mask\n.equ TCD_DLYSEL1_bp = 1                  ; Delay select bit 1 position\n.equ TCD_DLYTRIG_gm = 0x0C               ; Delay trigger group mask\n.equ TCD_DLYTRIG_gp = 2                  ; Delay trigger group position\n.equ TCD_DLYTRIG0_bm = (1<<2)            ; Delay trigger bit 0 mask\n.equ TCD_DLYTRIG0_bp = 2                 ; Delay trigger bit 0 position\n.equ TCD_DLYTRIG1_bm = (1<<3)            ; Delay trigger bit 1 mask\n.equ TCD_DLYTRIG1_bp = 3                 ; Delay trigger bit 1 position\n\n; TCD_DLYVAL masks\n.equ TCD_DLYVAL_gm = 0xFF                ; Delay value group mask\n.equ TCD_DLYVAL_gp = 0                   ; Delay value group position\n.equ TCD_DLYVAL0_bm = (1<<0)             ; Delay value bit 0 mask\n.equ TCD_DLYVAL0_bp = 0                  ; Delay value bit 0 position\n.equ TCD_DLYVAL1_bm = (1<<1)             ; Delay value bit 1 mask\n.equ TCD_DLYVAL1_bp = 1                  ; Delay value bit 1 position\n.equ TCD_DLYVAL2_bm = (1<<2)             ; Delay value bit 2 mask\n.equ TCD_DLYVAL2_bp = 2                  ; Delay value bit 2 position\n.equ TCD_DLYVAL3_bm = (1<<3)             ; Delay value bit 3 mask\n.equ TCD_DLYVAL3_bp = 3                  ; Delay value bit 3 position\n.equ TCD_DLYVAL4_bm = (1<<4)             ; Delay value bit 4 mask\n.equ TCD_DLYVAL4_bp = 4                  ; Delay value bit 4 position\n.equ TCD_DLYVAL5_bm = (1<<5)             ; Delay value bit 5 mask\n.equ TCD_DLYVAL5_bp = 5                  ; Delay value bit 5 position\n.equ TCD_DLYVAL6_bm = (1<<6)             ; Delay value bit 6 mask\n.equ TCD_DLYVAL6_bp = 6                  ; Delay value bit 6 position\n.equ TCD_DLYVAL7_bm = (1<<7)             ; Delay value bit 7 mask\n.equ TCD_DLYVAL7_bp = 7                  ; Delay value bit 7 position\n\n; TCD_EVCTRLA masks\n.equ TCD_ACTION_bm = 0x04                ; event action bit mask\n.equ TCD_ACTION_bp = 2                   ; event action bit position\n.equ TCD_CFG_gm = 0xC0                   ; event config group mask\n.equ TCD_CFG_gp = 6                      ; event config group position\n.equ TCD_CFG0_bm = (1<<6)                ; event config bit 0 mask\n.equ TCD_CFG0_bp = 6                     ; event config bit 0 position\n.equ TCD_CFG1_bm = (1<<7)                ; event config bit 1 mask\n.equ TCD_CFG1_bp = 7                     ; event config bit 1 position\n.equ TCD_EDGE_bm = 0x10                  ; edge select bit mask\n.equ TCD_EDGE_bp = 4                     ; edge select bit position\n.equ TCD_TRIGEI_bm = 0x01                ; Trigger event enable bit mask\n.equ TCD_TRIGEI_bp = 0                   ; Trigger event enable bit position\n\n; TCD_EVCTRLB masks\n; Masks for TCD_ACTION already defined\n; Masks for TCD_CFG already defined\n; Masks for TCD_EDGE already defined\n; Masks for TCD_TRIGEI already defined\n\n; TCD_FAULTCTRL masks\n.equ TCD_CMPA_bm = 0x01                  ; Compare A value bit mask\n.equ TCD_CMPA_bp = 0                     ; Compare A value bit position\n.equ TCD_CMPAEN_bm = 0x10                ; Compare A enable bit mask\n.equ TCD_CMPAEN_bp = 4                   ; Compare A enable bit position\n.equ TCD_CMPB_bm = 0x02                  ; Compare B value bit mask\n.equ TCD_CMPB_bp = 1                     ; Compare B value bit position\n.equ TCD_CMPBEN_bm = 0x20                ; Compare B enable bit mask\n.equ TCD_CMPBEN_bp = 5                   ; Compare B enable bit position\n.equ TCD_CMPC_bm = 0x04                  ; Compare C value bit mask\n.equ TCD_CMPC_bp = 2                     ; Compare C value bit position\n.equ TCD_CMPCEN_bm = 0x40                ; Compare C enable bit mask\n.equ TCD_CMPCEN_bp = 6                   ; Compare C enable bit position\n.equ TCD_CMPD_bm = 0x08                  ; Compare D vaule bit mask\n.equ TCD_CMPD_bp = 3                     ; Compare D vaule bit position\n.equ TCD_CMPDEN_bm = 0x80                ; Compare D enable bit mask\n.equ TCD_CMPDEN_bp = 7                   ; Compare D enable bit position\n\n; TCD_INPUTCTRLA masks\n.equ TCD_INPUTMODE_gm = 0x0F             ; Input mode group mask\n.equ TCD_INPUTMODE_gp = 0                ; Input mode group position\n.equ TCD_INPUTMODE0_bm = (1<<0)          ; Input mode bit 0 mask\n.equ TCD_INPUTMODE0_bp = 0               ; Input mode bit 0 position\n.equ TCD_INPUTMODE1_bm = (1<<1)          ; Input mode bit 1 mask\n.equ TCD_INPUTMODE1_bp = 1               ; Input mode bit 1 position\n.equ TCD_INPUTMODE2_bm = (1<<2)          ; Input mode bit 2 mask\n.equ TCD_INPUTMODE2_bp = 2               ; Input mode bit 2 position\n.equ TCD_INPUTMODE3_bm = (1<<3)          ; Input mode bit 3 mask\n.equ TCD_INPUTMODE3_bp = 3               ; Input mode bit 3 position\n\n; TCD_INPUTCTRLB masks\n; Masks for TCD_INPUTMODE already defined\n\n; TCD_INTCTRL masks\n.equ TCD_OVF_bm = 0x01                   ; Overflow interrupt enable bit mask\n.equ TCD_OVF_bp = 0                      ; Overflow interrupt enable bit position\n.equ TCD_TRIGA_bm = 0x04                 ; Trigger A interrupt enable bit mask\n.equ TCD_TRIGA_bp = 2                    ; Trigger A interrupt enable bit position\n.equ TCD_TRIGB_bm = 0x08                 ; Trigger B interrupt enable bit mask\n.equ TCD_TRIGB_bp = 3                    ; Trigger B interrupt enable bit position\n\n; TCD_INTFLAGS masks\n; Masks for TCD_OVF already defined\n; Masks for TCD_TRIGA already defined\n; Masks for TCD_TRIGB already defined\n\n; TCD_STATUS masks\n.equ TCD_CMDRDY_bm = 0x02                ; Command ready bit mask\n.equ TCD_CMDRDY_bp = 1                   ; Command ready bit position\n.equ TCD_ENRDY_bm = 0x01                 ; Enable ready bit mask\n.equ TCD_ENRDY_bp = 0                    ; Enable ready bit position\n.equ TCD_PWMACTA_bm = 0x40               ; PWM activity on A bit mask\n.equ TCD_PWMACTA_bp = 6                  ; PWM activity on A bit position\n.equ TCD_PWMACTB_bm = 0x80               ; PWM activity on B bit mask\n.equ TCD_PWMACTB_bp = 7                  ; PWM activity on B bit position\n\n; clock select select\n.equ TCD_CLKSEL_20MHZ_gc = (0x00<<5)     ; 20 MHz oscillator\n.equ TCD_CLKSEL_EXTCLK_gc = (0x02<<5)    ; External clock\n.equ TCD_CLKSEL_SYSCLK_gc = (0x03<<5)    ; System clock\n\n; counter prescaler select\n.equ TCD_CNTPRES_DIV1_gc = (0x00<<3)     ; Sync clock divided by 1\n.equ TCD_CNTPRES_DIV4_gc = (0x01<<3)     ; Sync clock divided by 4\n.equ TCD_CNTPRES_DIV32_gc = (0x02<<3)    ; Sync clock divided by 32\n\n; Syncronization prescaler select\n.equ TCD_SYNCPRES_DIV1_gc = (0x00<<1)    ; Selevted clock source divided by 1\n.equ TCD_SYNCPRES_DIV2_gc = (0x01<<1)    ; Selevted clock source divided by 2\n.equ TCD_SYNCPRES_DIV4_gc = (0x02<<1)    ; Selevted clock source divided by 4\n.equ TCD_SYNCPRES_DIV8_gc = (0x03<<1)    ; Selevted clock source divided by 8\n\n; Waveform generation mode select\n.equ TCD_WGMODE_ONERAMP_gc = (0x00<<0)   ; One ramp mode\n.equ TCD_WGMODE_TWORAMP_gc = (0x01<<0)   ; Two ramp mode\n.equ TCD_WGMODE_FOURRAMP_gc = (0x02<<0)  ; Four ramp mode\n.equ TCD_WGMODE_DS_gc = (0x03<<0)        ; Dual slope mode\n\n; Compare C output select select\n.equ TCD_CMPCSEL_PWMA_gc = (0x00<<6)     ; PWM A output\n.equ TCD_CMPCSEL_PWMB_gc = (0x01<<6)     ; PWM B output\n\n; Compare D output select select\n.equ TCD_CMPDSEL_PWMA_gc = (0x00<<7)     ; PWM A output\n.equ TCD_CMPDSEL_PWMB_gc = (0x01<<7)     ; PWM B output\n\n; dither select select\n.equ TCD_DITHERSEL_ONTIMEB_gc = (0x00<<0) ; On-time ramp B\n.equ TCD_DITHERSEL_ONTIMEAB_gc = (0x01<<0) ; On-time ramp A and B\n.equ TCD_DITHERSEL_DEADTIMEB_gc = (0x02<<0) ; Dead-time rampB\n.equ TCD_DITHERSEL_DEADTIMEAB_gc = (0x03<<0) ; Dead-time ramp A and B\n\n; Delay prescaler select\n.equ TCD_DLYPRESC_DIV1_gc = (0x00<<4)    ; No prescaling\n.equ TCD_DLYPRESC_DIV2_gc = (0x01<<4)    ; Prescale with 2\n.equ TCD_DLYPRESC_DIV4_gc = (0x02<<4)    ; Prescale with 4\n.equ TCD_DLYPRESC_DIV8_gc = (0x03<<4)    ; Prescale with 8\n\n; Delay select select\n.equ TCD_DLYSEL_OFF_gc = (0x00<<0)       ; No delay\n.equ TCD_DLYSEL_INBLANK_gc = (0x01<<0)   ; Input blanking enabled\n.equ TCD_DLYSEL_EVENT_gc = (0x02<<0)     ; Event delay enabled\n\n; Delay trigger select\n.equ TCD_DLYTRIG_CMPASET_gc = (0x00<<2)  ; Compare A set\n.equ TCD_DLYTRIG_CMPACLR_gc = (0x01<<2)  ; Compare A clear\n.equ TCD_DLYTRIG_CMPBSET_gc = (0x02<<2)  ; Compare B set\n.equ TCD_DLYTRIG_CMPBCLR_gc = (0x03<<2)  ; Compare B clear\n\n; event action select\n.equ TCD_ACTION_FAULT_gc = (0x00<<2)     ; Event trigger a fault\n.equ TCD_ACTION_CAPTURE_gc = (0x01<<2)   ; Event trigger a fault and capture\n\n; event config select\n.equ TCD_CFG_NEITHER_gc = (0x00<<6)      ; Neither Filter nor Asynchronous Event is enabled\n.equ TCD_CFG_FILTER_gc = (0x01<<6)       ; Input Capture Noise Cancellation Filter enabled\n.equ TCD_CFG_ASYNC_gc = (0x02<<6)        ; Asynchronous Event output qualification enabled\n\n; edge select select\n.equ TCD_EDGE_FALL_LOW_gc = (0x00<<4)    ; The falling edge or low level of event generates retrigger or fault action\n.equ TCD_EDGE_RISE_HIGH_gc = (0x01<<4)   ; The rising edge or high level of event generates retrigger or fault action\n\n; Input mode select\n.equ TCD_INPUTMODE_NONE_gc = (0x00<<0)   ; Input has no actions\n.equ TCD_INPUTMODE_JMPWAIT_gc = (0x01<<0) ; Stop output, jump to opposite compare cycle and wait\n.equ TCD_INPUTMODE_EXECWAIT_gc = (0x02<<0) ; Stop output, execute opposite compare cycle and wait\n.equ TCD_INPUTMODE_EXECFAULT_gc = (0x03<<0) ; stop output, execute opposite compare cycle while fault active\n.equ TCD_INPUTMODE_FREQ_gc = (0x04<<0)   ; Stop all outputs, maintain frequency\n.equ TCD_INPUTMODE_EXECDT_gc = (0x05<<0) ; Stop all outputs, execute dead time while fault active\n.equ TCD_INPUTMODE_WAIT_gc = (0x06<<0)   ; Stop all outputs, jump to next compare cycle and wait\n.equ TCD_INPUTMODE_WAITSW_gc = (0x07<<0) ; Stop all outputs, wait for software action\n.equ TCD_INPUTMODE_EDGETRIG_gc = (0x08<<0) ; Stop output on edge, jump to next compare cycle\n.equ TCD_INPUTMODE_EDGETRIGFREQ_gc = (0x09<<0) ; Stop output on edge, maintain frequency\n.equ TCD_INPUTMODE_LVLTRIGFREQ_gc = (0x0A<<0) ; Stop output at level, maintain frequency\n\n\n;*************************************************************************\n;** TWI - Two-Wire Interface\n;*************************************************************************\n\n; TWI_CTRLA masks\n.equ TWI_FMPEN_bm = 0x02                 ; FM Plus Enable bit mask\n.equ TWI_FMPEN_bp = 1                    ; FM Plus Enable bit position\n.equ TWI_SDAHOLD_gm = 0x0C               ; SDA Hold Time group mask\n.equ TWI_SDAHOLD_gp = 2                  ; SDA Hold Time group position\n.equ TWI_SDAHOLD0_bm = (1<<2)            ; SDA Hold Time bit 0 mask\n.equ TWI_SDAHOLD0_bp = 2                 ; SDA Hold Time bit 0 position\n.equ TWI_SDAHOLD1_bm = (1<<3)            ; SDA Hold Time bit 1 mask\n.equ TWI_SDAHOLD1_bp = 3                 ; SDA Hold Time bit 1 position\n.equ TWI_SDASETUP_bm = 0x10              ; SDA Setup Time bit mask\n.equ TWI_SDASETUP_bp = 4                 ; SDA Setup Time bit position\n\n; TWI_DBGCTRL masks\n.equ TWI_DBGRUN_bm = 0x01                ; Debug Run bit mask\n.equ TWI_DBGRUN_bp = 0                   ; Debug Run bit position\n\n; TWI_MCTRLA masks\n.equ TWI_ENABLE_bm = 0x01                ; Enable TWI Master bit mask\n.equ TWI_ENABLE_bp = 0                   ; Enable TWI Master bit position\n.equ TWI_QCEN_bm = 0x10                  ; Quick Command Enable bit mask\n.equ TWI_QCEN_bp = 4                     ; Quick Command Enable bit position\n.equ TWI_RIEN_bm = 0x80                  ; Read Interrupt Enable bit mask\n.equ TWI_RIEN_bp = 7                     ; Read Interrupt Enable bit position\n.equ TWI_SMEN_bm = 0x02                  ; Smart Mode Enable bit mask\n.equ TWI_SMEN_bp = 1                     ; Smart Mode Enable bit position\n.equ TWI_TIMEOUT_gm = 0x0C               ; Inactive Bus Timeout group mask\n.equ TWI_TIMEOUT_gp = 2                  ; Inactive Bus Timeout group position\n.equ TWI_TIMEOUT0_bm = (1<<2)            ; Inactive Bus Timeout bit 0 mask\n.equ TWI_TIMEOUT0_bp = 2                 ; Inactive Bus Timeout bit 0 position\n.equ TWI_TIMEOUT1_bm = (1<<3)            ; Inactive Bus Timeout bit 1 mask\n.equ TWI_TIMEOUT1_bp = 3                 ; Inactive Bus Timeout bit 1 position\n.equ TWI_WIEN_bm = 0x40                  ; Write Interrupt Enable bit mask\n.equ TWI_WIEN_bp = 6                     ; Write Interrupt Enable bit position\n\n; TWI_MCTRLB masks\n.equ TWI_ACKACT_bm = 0x04                ; Acknowledge Action bit mask\n.equ TWI_ACKACT_bp = 2                   ; Acknowledge Action bit position\n.equ TWI_FLUSH_bm = 0x08                 ; Flush bit mask\n.equ TWI_FLUSH_bp = 3                    ; Flush bit position\n.equ TWI_MCMD_gm = 0x03                  ; Command group mask\n.equ TWI_MCMD_gp = 0                     ; Command group position\n.equ TWI_MCMD0_bm = (1<<0)               ; Command bit 0 mask\n.equ TWI_MCMD0_bp = 0                    ; Command bit 0 position\n.equ TWI_MCMD1_bm = (1<<1)               ; Command bit 1 mask\n.equ TWI_MCMD1_bp = 1                    ; Command bit 1 position\n\n; TWI_MSTATUS masks\n.equ TWI_ARBLOST_bm = 0x08               ; Arbitration Lost bit mask\n.equ TWI_ARBLOST_bp = 3                  ; Arbitration Lost bit position\n.equ TWI_BUSERR_bm = 0x04                ; Bus Error bit mask\n.equ TWI_BUSERR_bp = 2                   ; Bus Error bit position\n.equ TWI_BUSSTATE_gm = 0x03              ; Bus State group mask\n.equ TWI_BUSSTATE_gp = 0                 ; Bus State group position\n.equ TWI_BUSSTATE0_bm = (1<<0)           ; Bus State bit 0 mask\n.equ TWI_BUSSTATE0_bp = 0                ; Bus State bit 0 position\n.equ TWI_BUSSTATE1_bm = (1<<1)           ; Bus State bit 1 mask\n.equ TWI_BUSSTATE1_bp = 1                ; Bus State bit 1 position\n.equ TWI_CLKHOLD_bm = 0x20               ; Clock Hold bit mask\n.equ TWI_CLKHOLD_bp = 5                  ; Clock Hold bit position\n.equ TWI_RIF_bm = 0x80                   ; Read Interrupt Flag bit mask\n.equ TWI_RIF_bp = 7                      ; Read Interrupt Flag bit position\n.equ TWI_RXACK_bm = 0x10                 ; Received Acknowledge bit mask\n.equ TWI_RXACK_bp = 4                    ; Received Acknowledge bit position\n.equ TWI_WIF_bm = 0x40                   ; Write Interrupt Flag bit mask\n.equ TWI_WIF_bp = 6                      ; Write Interrupt Flag bit position\n\n; TWI_SADDRMASK masks\n.equ TWI_ADDREN_bm = 0x01                ; Address Enable bit mask\n.equ TWI_ADDREN_bp = 0                   ; Address Enable bit position\n.equ TWI_ADDRMASK_gm = 0xFE              ; Address Mask group mask\n.equ TWI_ADDRMASK_gp = 1                 ; Address Mask group position\n.equ TWI_ADDRMASK0_bm = (1<<1)           ; Address Mask bit 0 mask\n.equ TWI_ADDRMASK0_bp = 1                ; Address Mask bit 0 position\n.equ TWI_ADDRMASK1_bm = (1<<2)           ; Address Mask bit 1 mask\n.equ TWI_ADDRMASK1_bp = 2                ; Address Mask bit 1 position\n.equ TWI_ADDRMASK2_bm = (1<<3)           ; Address Mask bit 2 mask\n.equ TWI_ADDRMASK2_bp = 3                ; Address Mask bit 2 position\n.equ TWI_ADDRMASK3_bm = (1<<4)           ; Address Mask bit 3 mask\n.equ TWI_ADDRMASK3_bp = 4                ; Address Mask bit 3 position\n.equ TWI_ADDRMASK4_bm = (1<<5)           ; Address Mask bit 4 mask\n.equ TWI_ADDRMASK4_bp = 5                ; Address Mask bit 4 position\n.equ TWI_ADDRMASK5_bm = (1<<6)           ; Address Mask bit 5 mask\n.equ TWI_ADDRMASK5_bp = 6                ; Address Mask bit 5 position\n.equ TWI_ADDRMASK6_bm = (1<<7)           ; Address Mask bit 6 mask\n.equ TWI_ADDRMASK6_bp = 7                ; Address Mask bit 6 position\n\n; TWI_SCTRLA masks\n.equ TWI_APIEN_bm = 0x40                 ; Address/Stop Interrupt Enable bit mask\n.equ TWI_APIEN_bp = 6                    ; Address/Stop Interrupt Enable bit position\n.equ TWI_DIEN_bm = 0x80                  ; Data Interrupt Enable bit mask\n.equ TWI_DIEN_bp = 7                     ; Data Interrupt Enable bit position\n; Masks for TWI_ENABLE already defined\n.equ TWI_PIEN_bm = 0x20                  ; Stop Interrupt Enable bit mask\n.equ TWI_PIEN_bp = 5                     ; Stop Interrupt Enable bit position\n.equ TWI_PMEN_bm = 0x04                  ; Promiscuous Mode Enable bit mask\n.equ TWI_PMEN_bp = 2                     ; Promiscuous Mode Enable bit position\n; Masks for TWI_SMEN already defined\n\n; TWI_SCTRLB masks\n; Masks for TWI_ACKACT already defined\n.equ TWI_SCMD_gm = 0x03                  ; Command group mask\n.equ TWI_SCMD_gp = 0                     ; Command group position\n.equ TWI_SCMD0_bm = (1<<0)               ; Command bit 0 mask\n.equ TWI_SCMD0_bp = 0                    ; Command bit 0 position\n.equ TWI_SCMD1_bm = (1<<1)               ; Command bit 1 mask\n.equ TWI_SCMD1_bp = 1                    ; Command bit 1 position\n\n; TWI_SSTATUS masks\n.equ TWI_AP_bm = 0x01                    ; Slave Address or Stop bit mask\n.equ TWI_AP_bp = 0                       ; Slave Address or Stop bit position\n.equ TWI_APIF_bm = 0x40                  ; Address/Stop Interrupt Flag bit mask\n.equ TWI_APIF_bp = 6                     ; Address/Stop Interrupt Flag bit position\n; Masks for TWI_BUSERR already defined\n; Masks for TWI_CLKHOLD already defined\n.equ TWI_COLL_bm = 0x08                  ; Collision bit mask\n.equ TWI_COLL_bp = 3                     ; Collision bit position\n.equ TWI_DIF_bm = 0x80                   ; Data Interrupt Flag bit mask\n.equ TWI_DIF_bp = 7                      ; Data Interrupt Flag bit position\n.equ TWI_DIR_bm = 0x02                   ; Read/Write Direction bit mask\n.equ TWI_DIR_bp = 1                      ; Read/Write Direction bit position\n; Masks for TWI_RXACK already defined\n\n; SDA Hold Time select\n.equ TWI_DEFAULT_SDAHOLD_OFF_gc = (0x00<<2) ; SDA hold time off\n.equ TWI_DEFAULT_SDAHOLD_50NS_gc = (0x01<<2) ; Typical 50ns hold time\n.equ TWI_DEFAULT_SDAHOLD_300NS_gc = (0x02<<2) ; Typical 300ns hold time\n.equ TWI_DEFAULT_SDAHOLD_500NS_gc = (0x03<<2) ; Typical 500ns hold time\n\n; SDA Setup Time select\n.equ TWI_DEFAULT_SDASETUP_4CYC_gc = (0x00<<4) ; SDA setup time is 4 clock cycles\n.equ TWI_DEFAULT_SDASETUP_8CYC_gc = (0x01<<4) ; SDA setup time is 8 clock cycles\n\n; Inactive Bus Timeout select\n.equ TWI_TIMEOUT_DISABLED_gc = (0x00<<2) ; Bus Timeout Disabled\n.equ TWI_TIMEOUT_50US_gc = (0x01<<2)     ; 50 Microseconds\n.equ TWI_TIMEOUT_100US_gc = (0x02<<2)    ; 100 Microseconds\n.equ TWI_TIMEOUT_200US_gc = (0x03<<2)    ; 200 Microseconds\n\n; Acknowledge Action select\n.equ TWI_ACKACT_ACK_gc = (0x00<<2)       ; Send ACK\n.equ TWI_ACKACT_NACK_gc = (0x01<<2)      ; Send NACK\n\n; Command select\n.equ TWI_MCMD_NOACT_gc = (0x00<<0)       ; No Action\n.equ TWI_MCMD_REPSTART_gc = (0x01<<0)    ; Issue Repeated Start Condition\n.equ TWI_MCMD_RECVTRANS_gc = (0x02<<0)   ; Receive or Transmit Data, depending on DIR\n.equ TWI_MCMD_STOP_gc = (0x03<<0)        ; Issue Stop Condition\n\n; Bus State select\n.equ TWI_BUSSTATE_UNKNOWN_gc = (0x00<<0) ; Unknown Bus State\n.equ TWI_BUSSTATE_IDLE_gc = (0x01<<0)    ; Bus is Idle\n.equ TWI_BUSSTATE_OWNER_gc = (0x02<<0)   ; This Module Controls The Bus\n.equ TWI_BUSSTATE_BUSY_gc = (0x03<<0)    ; The Bus is Busy\n\n; Command select\n.equ TWI_SCMD_NOACT_gc = (0x00<<0)       ; No Action\n.equ TWI_SCMD_COMPTRANS_gc = (0x02<<0)   ; Used To Complete a Transaction\n.equ TWI_SCMD_RESPONSE_gc = (0x03<<0)    ; Used in Response to Address/Data Interrupt\n\n; Slave Address or Stop select\n.equ TWI_AP_STOP_gc = (0x00<<0)          ; Stop condition generated APIF\n.equ TWI_AP_ADR_gc = (0x01<<0)           ; Address detection generated APIF\n\n\n;*************************************************************************\n;** USART - Universal Synchronous and Asynchronous Receiver and Transmitter\n;*************************************************************************\n\n; USART_CTRLA masks\n.equ USART_ABEIE_bm = 0x04               ; Auto-baud Error Interrupt Enable bit mask\n.equ USART_ABEIE_bp = 2                  ; Auto-baud Error Interrupt Enable bit position\n.equ USART_DREIE_bm = 0x20               ; Data Register Empty Interrupt Enable bit mask\n.equ USART_DREIE_bp = 5                  ; Data Register Empty Interrupt Enable bit position\n.equ USART_LBME_bm = 0x08                ; Loop-back Mode Enable bit mask\n.equ USART_LBME_bp = 3                   ; Loop-back Mode Enable bit position\n.equ USART_RS485_gm = 0x03               ; RS485 Mode internal transmitter group mask\n.equ USART_RS485_gp = 0                  ; RS485 Mode internal transmitter group position\n.equ USART_RS4850_bm = (1<<0)            ; RS485 Mode internal transmitter bit 0 mask\n.equ USART_RS4850_bp = 0                 ; RS485 Mode internal transmitter bit 0 position\n.equ USART_RS4851_bm = (1<<1)            ; RS485 Mode internal transmitter bit 1 mask\n.equ USART_RS4851_bp = 1                 ; RS485 Mode internal transmitter bit 1 position\n.equ USART_RXCIE_bm = 0x80               ; Receive Complete Interrupt Enable bit mask\n.equ USART_RXCIE_bp = 7                  ; Receive Complete Interrupt Enable bit position\n.equ USART_RXSIE_bm = 0x10               ; Receiver Start Frame Interrupt Enable bit mask\n.equ USART_RXSIE_bp = 4                  ; Receiver Start Frame Interrupt Enable bit position\n.equ USART_TXCIE_bm = 0x40               ; Transmit Complete Interrupt Enable bit mask\n.equ USART_TXCIE_bp = 6                  ; Transmit Complete Interrupt Enable bit position\n\n; USART_CTRLB masks\n.equ USART_MPCM_bm = 0x01                ; Multi-processor Communication Mode bit mask\n.equ USART_MPCM_bp = 0                   ; Multi-processor Communication Mode bit position\n.equ USART_ODME_bm = 0x08                ; Open Drain Mode Enable bit mask\n.equ USART_ODME_bp = 3                   ; Open Drain Mode Enable bit position\n.equ USART_RXEN_bm = 0x80                ; Reciever enable bit mask\n.equ USART_RXEN_bp = 7                   ; Reciever enable bit position\n.equ USART_RXMODE_gm = 0x06              ; Receiver Mode group mask\n.equ USART_RXMODE_gp = 1                 ; Receiver Mode group position\n.equ USART_RXMODE0_bm = (1<<1)           ; Receiver Mode bit 0 mask\n.equ USART_RXMODE0_bp = 1                ; Receiver Mode bit 0 position\n.equ USART_RXMODE1_bm = (1<<2)           ; Receiver Mode bit 1 mask\n.equ USART_RXMODE1_bp = 2                ; Receiver Mode bit 1 position\n.equ USART_SFDEN_bm = 0x10               ; Start Frame Detection Enable bit mask\n.equ USART_SFDEN_bp = 4                  ; Start Frame Detection Enable bit position\n.equ USART_TXEN_bm = 0x40                ; Transmitter Enable bit mask\n.equ USART_TXEN_bp = 6                   ; Transmitter Enable bit position\n\n; USART_CTRLC masks\n.equ USART_CMODE_gm = 0xC0               ; Communication Mode group mask\n.equ USART_CMODE_gp = 6                  ; Communication Mode group position\n.equ USART_CMODE0_bm = (1<<6)            ; Communication Mode bit 0 mask\n.equ USART_CMODE0_bp = 6                 ; Communication Mode bit 0 position\n.equ USART_CMODE1_bm = (1<<7)            ; Communication Mode bit 1 mask\n.equ USART_CMODE1_bp = 7                 ; Communication Mode bit 1 position\n.equ USART_UCPHA_bm = 0x02               ; SPI Master Mode, Clock Phase bit mask\n.equ USART_UCPHA_bp = 1                  ; SPI Master Mode, Clock Phase bit position\n.equ USART_UDORD_bm = 0x04               ; SPI Master Mode, Data Order bit mask\n.equ USART_UDORD_bp = 2                  ; SPI Master Mode, Data Order bit position\n.equ USART_CHSIZE_gm = 0x07              ; Character Size group mask\n.equ USART_CHSIZE_gp = 0                 ; Character Size group position\n.equ USART_CHSIZE0_bm = (1<<0)           ; Character Size bit 0 mask\n.equ USART_CHSIZE0_bp = 0                ; Character Size bit 0 position\n.equ USART_CHSIZE1_bm = (1<<1)           ; Character Size bit 1 mask\n.equ USART_CHSIZE1_bp = 1                ; Character Size bit 1 position\n.equ USART_CHSIZE2_bm = (1<<2)           ; Character Size bit 2 mask\n.equ USART_CHSIZE2_bp = 2                ; Character Size bit 2 position\n; Masks for USART_CMODE already defined\n.equ USART_PMODE_gm = 0x30               ; Parity Mode group mask\n.equ USART_PMODE_gp = 4                  ; Parity Mode group position\n.equ USART_PMODE0_bm = (1<<4)            ; Parity Mode bit 0 mask\n.equ USART_PMODE0_bp = 4                 ; Parity Mode bit 0 position\n.equ USART_PMODE1_bm = (1<<5)            ; Parity Mode bit 1 mask\n.equ USART_PMODE1_bp = 5                 ; Parity Mode bit 1 position\n.equ USART_SBMODE_bm = 0x08              ; Stop Bit Mode bit mask\n.equ USART_SBMODE_bp = 3                 ; Stop Bit Mode bit position\n\n; USART_DBGCTRL masks\n.equ USART_DBGRUN_bm = 0x01              ; Debug Run bit mask\n.equ USART_DBGRUN_bp = 0                 ; Debug Run bit position\n\n; USART_EVCTRL masks\n.equ USART_IREI_bm = 0x01                ; IrDA Event Input Enable bit mask\n.equ USART_IREI_bp = 0                   ; IrDA Event Input Enable bit position\n\n; USART_RXDATAH masks\n.equ USART_BUFOVF_bm = 0x40              ; Buffer Overflow bit mask\n.equ USART_BUFOVF_bp = 6                 ; Buffer Overflow bit position\n.equ USART_DATA8_bm = 0x01               ; Receiver Data Register bit mask\n.equ USART_DATA8_bp = 0                  ; Receiver Data Register bit position\n.equ USART_FERR_bm = 0x04                ; Frame Error bit mask\n.equ USART_FERR_bp = 2                   ; Frame Error bit position\n.equ USART_PERR_bm = 0x02                ; Parity Error bit mask\n.equ USART_PERR_bp = 1                   ; Parity Error bit position\n.equ USART_RXCIF_bm = 0x80               ; Receive Complete Interrupt Flag bit mask\n.equ USART_RXCIF_bp = 7                  ; Receive Complete Interrupt Flag bit position\n\n; USART_RXDATAL masks\n.equ USART_DATA_gm = 0xFF                ; RX Data group mask\n.equ USART_DATA_gp = 0                   ; RX Data group position\n.equ USART_DATA0_bm = (1<<0)             ; RX Data bit 0 mask\n.equ USART_DATA0_bp = 0                  ; RX Data bit 0 position\n.equ USART_DATA1_bm = (1<<1)             ; RX Data bit 1 mask\n.equ USART_DATA1_bp = 1                  ; RX Data bit 1 position\n.equ USART_DATA2_bm = (1<<2)             ; RX Data bit 2 mask\n.equ USART_DATA2_bp = 2                  ; RX Data bit 2 position\n.equ USART_DATA3_bm = (1<<3)             ; RX Data bit 3 mask\n.equ USART_DATA3_bp = 3                  ; RX Data bit 3 position\n.equ USART_DATA4_bm = (1<<4)             ; RX Data bit 4 mask\n.equ USART_DATA4_bp = 4                  ; RX Data bit 4 position\n.equ USART_DATA5_bm = (1<<5)             ; RX Data bit 5 mask\n.equ USART_DATA5_bp = 5                  ; RX Data bit 5 position\n.equ USART_DATA6_bm = (1<<6)             ; RX Data bit 6 mask\n.equ USART_DATA6_bp = 6                  ; RX Data bit 6 position\n.equ USART_DATA7_bm = (1<<7)             ; RX Data bit 7 mask\n.equ USART_DATA7_bp = 7                  ; RX Data bit 7 position\n\n; USART_RXPLCTRL masks\n.equ USART_RXPL_gm = 0x7F                ; Receiver Pulse Lenght group mask\n.equ USART_RXPL_gp = 0                   ; Receiver Pulse Lenght group position\n.equ USART_RXPL0_bm = (1<<0)             ; Receiver Pulse Lenght bit 0 mask\n.equ USART_RXPL0_bp = 0                  ; Receiver Pulse Lenght bit 0 position\n.equ USART_RXPL1_bm = (1<<1)             ; Receiver Pulse Lenght bit 1 mask\n.equ USART_RXPL1_bp = 1                  ; Receiver Pulse Lenght bit 1 position\n.equ USART_RXPL2_bm = (1<<2)             ; Receiver Pulse Lenght bit 2 mask\n.equ USART_RXPL2_bp = 2                  ; Receiver Pulse Lenght bit 2 position\n.equ USART_RXPL3_bm = (1<<3)             ; Receiver Pulse Lenght bit 3 mask\n.equ USART_RXPL3_bp = 3                  ; Receiver Pulse Lenght bit 3 position\n.equ USART_RXPL4_bm = (1<<4)             ; Receiver Pulse Lenght bit 4 mask\n.equ USART_RXPL4_bp = 4                  ; Receiver Pulse Lenght bit 4 position\n.equ USART_RXPL5_bm = (1<<5)             ; Receiver Pulse Lenght bit 5 mask\n.equ USART_RXPL5_bp = 5                  ; Receiver Pulse Lenght bit 5 position\n.equ USART_RXPL6_bm = (1<<6)             ; Receiver Pulse Lenght bit 6 mask\n.equ USART_RXPL6_bp = 6                  ; Receiver Pulse Lenght bit 6 position\n\n; USART_STATUS masks\n.equ USART_BDF_bm = 0x02                 ; Break Detected Flag bit mask\n.equ USART_BDF_bp = 1                    ; Break Detected Flag bit position\n.equ USART_DREIF_bm = 0x20               ; Data Register Empty Flag bit mask\n.equ USART_DREIF_bp = 5                  ; Data Register Empty Flag bit position\n.equ USART_ISFIF_bm = 0x08               ; Inconsistent Sync Field Interrupt Flag bit mask\n.equ USART_ISFIF_bp = 3                  ; Inconsistent Sync Field Interrupt Flag bit position\n; Masks for USART_RXCIF already defined\n.equ USART_RXSIF_bm = 0x10               ; Receive Start Interrupt bit mask\n.equ USART_RXSIF_bp = 4                  ; Receive Start Interrupt bit position\n.equ USART_TXCIF_bm = 0x40               ; Transmit Interrupt Flag bit mask\n.equ USART_TXCIF_bp = 6                  ; Transmit Interrupt Flag bit position\n.equ USART_WFB_bm = 0x01                 ; Wait For Break bit mask\n.equ USART_WFB_bp = 0                    ; Wait For Break bit position\n\n; USART_TXDATAH masks\n; Masks for USART_DATA8 already defined\n\n; USART_TXDATAL masks\n; Masks for USART_DATA already defined\n\n; USART_TXPLCTRL masks\n.equ USART_TXPL_gm = 0xFF                ; Transmit pulse length group mask\n.equ USART_TXPL_gp = 0                   ; Transmit pulse length group position\n.equ USART_TXPL0_bm = (1<<0)             ; Transmit pulse length bit 0 mask\n.equ USART_TXPL0_bp = 0                  ; Transmit pulse length bit 0 position\n.equ USART_TXPL1_bm = (1<<1)             ; Transmit pulse length bit 1 mask\n.equ USART_TXPL1_bp = 1                  ; Transmit pulse length bit 1 position\n.equ USART_TXPL2_bm = (1<<2)             ; Transmit pulse length bit 2 mask\n.equ USART_TXPL2_bp = 2                  ; Transmit pulse length bit 2 position\n.equ USART_TXPL3_bm = (1<<3)             ; Transmit pulse length bit 3 mask\n.equ USART_TXPL3_bp = 3                  ; Transmit pulse length bit 3 position\n.equ USART_TXPL4_bm = (1<<4)             ; Transmit pulse length bit 4 mask\n.equ USART_TXPL4_bp = 4                  ; Transmit pulse length bit 4 position\n.equ USART_TXPL5_bm = (1<<5)             ; Transmit pulse length bit 5 mask\n.equ USART_TXPL5_bp = 5                  ; Transmit pulse length bit 5 position\n.equ USART_TXPL6_bm = (1<<6)             ; Transmit pulse length bit 6 mask\n.equ USART_TXPL6_bp = 6                  ; Transmit pulse length bit 6 position\n.equ USART_TXPL7_bm = (1<<7)             ; Transmit pulse length bit 7 mask\n.equ USART_TXPL7_bp = 7                  ; Transmit pulse length bit 7 position\n\n; RS485 Mode internal transmitter select\n.equ USART_RS485_OFF_gc = (0x00<<0)      ; RS485 Mode disabled\n.equ USART_RS485_EXT_gc = (0x01<<0)      ; RS485 Mode External drive\n.equ USART_RS485_INT_gc = (0x02<<0)      ; RS485 Mode Internal drive\n\n; Receiver Mode select\n.equ USART_RXMODE_NORMAL_gc = (0x00<<1)  ; Normal mode\n.equ USART_RXMODE_CLK2X_gc = (0x01<<1)   ; CLK2x mode\n.equ USART_RXMODE_GENAUTO_gc = (0x02<<1) ; Generic autobaud mode\n.equ USART_RXMODE_LINAUTO_gc = (0x03<<1) ; LIN constrained autobaud mode\n\n; Communication Mode select\n.equ USART_MSPI_CMODE_ASYNCHRONOUS_gc = (0x00<<6) ; Asynchronous Mode\n.equ USART_MSPI_CMODE_SYNCHRONOUS_gc = (0x01<<6) ; Synchronous Mode\n.equ USART_MSPI_CMODE_IRCOM_gc = (0x02<<6) ; Infrared Communication\n.equ USART_MSPI_CMODE_MSPI_gc = (0x03<<6) ; Master SPI Mode\n\n; Character Size select\n.equ USART_NORMAL_CHSIZE_5BIT_gc = (0x00<<0) ; Character size: 5 bit\n.equ USART_NORMAL_CHSIZE_6BIT_gc = (0x01<<0) ; Character size: 6 bit\n.equ USART_NORMAL_CHSIZE_7BIT_gc = (0x02<<0) ; Character size: 7 bit\n.equ USART_NORMAL_CHSIZE_8BIT_gc = (0x03<<0) ; Character size: 8 bit\n.equ USART_NORMAL_CHSIZE_9BITL_gc = (0x06<<0) ; Character size: 9 bit read low byte first\n.equ USART_NORMAL_CHSIZE_9BITH_gc = (0x07<<0) ; Character size: 9 bit read high byte first\n\n; Communication Mode select\n.equ USART_NORMAL_CMODE_ASYNCHRONOUS_gc = (0x00<<6) ; Asynchronous Mode\n.equ USART_NORMAL_CMODE_SYNCHRONOUS_gc = (0x01<<6) ; Synchronous Mode\n.equ USART_NORMAL_CMODE_IRCOM_gc = (0x02<<6) ; Infrared Communication\n.equ USART_NORMAL_CMODE_MSPI_gc = (0x03<<6) ; Master SPI Mode\n\n; Parity Mode select\n.equ USART_NORMAL_PMODE_DISABLED_gc = (0x00<<4) ; No Parity\n.equ USART_NORMAL_PMODE_EVEN_gc = (0x02<<4) ; Even Parity\n.equ USART_NORMAL_PMODE_ODD_gc = (0x03<<4) ; Odd Parity\n\n; Stop Bit Mode select\n.equ USART_NORMAL_SBMODE_1BIT_gc = (0x00<<3) ; 1 stop bit\n.equ USART_NORMAL_SBMODE_2BIT_gc = (0x01<<3) ; 2 stop bits\n\n\n;*************************************************************************\n;** USERROW - User Row\n;*************************************************************************\n\n\n;*************************************************************************\n;** VPORT - Virtual Ports\n;*************************************************************************\n\n; VPORT_INTFLAGS masks\n.equ VPORT_INT_gm = 0xFF                 ; Pin Interrupt group mask\n.equ VPORT_INT_gp = 0                    ; Pin Interrupt group position\n.equ VPORT_INT0_bm = (1<<0)              ; Pin Interrupt bit 0 mask\n.equ VPORT_INT0_bp = 0                   ; Pin Interrupt bit 0 position\n.equ VPORT_INT1_bm = (1<<1)              ; Pin Interrupt bit 1 mask\n.equ VPORT_INT1_bp = 1                   ; Pin Interrupt bit 1 position\n.equ VPORT_INT2_bm = (1<<2)              ; Pin Interrupt bit 2 mask\n.equ VPORT_INT2_bp = 2                   ; Pin Interrupt bit 2 position\n.equ VPORT_INT3_bm = (1<<3)              ; Pin Interrupt bit 3 mask\n.equ VPORT_INT3_bp = 3                   ; Pin Interrupt bit 3 position\n.equ VPORT_INT4_bm = (1<<4)              ; Pin Interrupt bit 4 mask\n.equ VPORT_INT4_bp = 4                   ; Pin Interrupt bit 4 position\n.equ VPORT_INT5_bm = (1<<5)              ; Pin Interrupt bit 5 mask\n.equ VPORT_INT5_bp = 5                   ; Pin Interrupt bit 5 position\n.equ VPORT_INT6_bm = (1<<6)              ; Pin Interrupt bit 6 mask\n.equ VPORT_INT6_bp = 6                   ; Pin Interrupt bit 6 position\n.equ VPORT_INT7_bm = (1<<7)              ; Pin Interrupt bit 7 mask\n.equ VPORT_INT7_bp = 7                   ; Pin Interrupt bit 7 position\n\n\n;*************************************************************************\n;** VREF - Voltage reference\n;*************************************************************************\n\n; VREF_CTRLA masks\n.equ VREF_ADC0REFSEL_gm = 0x70           ; ADC0 reference select group mask\n.equ VREF_ADC0REFSEL_gp = 4              ; ADC0 reference select group position\n.equ VREF_ADC0REFSEL0_bm = (1<<4)        ; ADC0 reference select bit 0 mask\n.equ VREF_ADC0REFSEL0_bp = 4             ; ADC0 reference select bit 0 position\n.equ VREF_ADC0REFSEL1_bm = (1<<5)        ; ADC0 reference select bit 1 mask\n.equ VREF_ADC0REFSEL1_bp = 5             ; ADC0 reference select bit 1 position\n.equ VREF_ADC0REFSEL2_bm = (1<<6)        ; ADC0 reference select bit 2 mask\n.equ VREF_ADC0REFSEL2_bp = 6             ; ADC0 reference select bit 2 position\n.equ VREF_DAC0REFSEL_gm = 0x07           ; DAC0/AC0 reference select group mask\n.equ VREF_DAC0REFSEL_gp = 0              ; DAC0/AC0 reference select group position\n.equ VREF_DAC0REFSEL0_bm = (1<<0)        ; DAC0/AC0 reference select bit 0 mask\n.equ VREF_DAC0REFSEL0_bp = 0             ; DAC0/AC0 reference select bit 0 position\n.equ VREF_DAC0REFSEL1_bm = (1<<1)        ; DAC0/AC0 reference select bit 1 mask\n.equ VREF_DAC0REFSEL1_bp = 1             ; DAC0/AC0 reference select bit 1 position\n.equ VREF_DAC0REFSEL2_bm = (1<<2)        ; DAC0/AC0 reference select bit 2 mask\n.equ VREF_DAC0REFSEL2_bp = 2             ; DAC0/AC0 reference select bit 2 position\n\n; VREF_CTRLB masks\n.equ VREF_ADC0REFEN_bm = 0x02            ; ADC0 reference enable bit mask\n.equ VREF_ADC0REFEN_bp = 1               ; ADC0 reference enable bit position\n.equ VREF_ADC1REFEN_bm = 0x10            ; ADC1 reference enable bit mask\n.equ VREF_ADC1REFEN_bp = 4               ; ADC1 reference enable bit position\n.equ VREF_DAC0REFEN_bm = 0x01            ; DAC0/AC0 reference enable bit mask\n.equ VREF_DAC0REFEN_bp = 0               ; DAC0/AC0 reference enable bit position\n.equ VREF_DAC1REFEN_bm = 0x08            ; DAC1/AC1 reference enable bit mask\n.equ VREF_DAC1REFEN_bp = 3               ; DAC1/AC1 reference enable bit position\n.equ VREF_DAC2REFEN_bm = 0x20            ; DAC2/AC2 reference enable bit mask\n.equ VREF_DAC2REFEN_bp = 5               ; DAC2/AC2 reference enable bit position\n\n; VREF_CTRLC masks\n.equ VREF_ADC1REFSEL_gm = 0x70           ; ADC1 reference select group mask\n.equ VREF_ADC1REFSEL_gp = 4              ; ADC1 reference select group position\n.equ VREF_ADC1REFSEL0_bm = (1<<4)        ; ADC1 reference select bit 0 mask\n.equ VREF_ADC1REFSEL0_bp = 4             ; ADC1 reference select bit 0 position\n.equ VREF_ADC1REFSEL1_bm = (1<<5)        ; ADC1 reference select bit 1 mask\n.equ VREF_ADC1REFSEL1_bp = 5             ; ADC1 reference select bit 1 position\n.equ VREF_ADC1REFSEL2_bm = (1<<6)        ; ADC1 reference select bit 2 mask\n.equ VREF_ADC1REFSEL2_bp = 6             ; ADC1 reference select bit 2 position\n.equ VREF_DAC1REFSEL_gm = 0x07           ; DAC1/AC1 reference select group mask\n.equ VREF_DAC1REFSEL_gp = 0              ; DAC1/AC1 reference select group position\n.equ VREF_DAC1REFSEL0_bm = (1<<0)        ; DAC1/AC1 reference select bit 0 mask\n.equ VREF_DAC1REFSEL0_bp = 0             ; DAC1/AC1 reference select bit 0 position\n.equ VREF_DAC1REFSEL1_bm = (1<<1)        ; DAC1/AC1 reference select bit 1 mask\n.equ VREF_DAC1REFSEL1_bp = 1             ; DAC1/AC1 reference select bit 1 position\n.equ VREF_DAC1REFSEL2_bm = (1<<2)        ; DAC1/AC1 reference select bit 2 mask\n.equ VREF_DAC1REFSEL2_bp = 2             ; DAC1/AC1 reference select bit 2 position\n\n; VREF_CTRLD masks\n.equ VREF_DAC2REFSEL_gm = 0x07           ; DAC2/AC2 reference select group mask\n.equ VREF_DAC2REFSEL_gp = 0              ; DAC2/AC2 reference select group position\n.equ VREF_DAC2REFSEL0_bm = (1<<0)        ; DAC2/AC2 reference select bit 0 mask\n.equ VREF_DAC2REFSEL0_bp = 0             ; DAC2/AC2 reference select bit 0 position\n.equ VREF_DAC2REFSEL1_bm = (1<<1)        ; DAC2/AC2 reference select bit 1 mask\n.equ VREF_DAC2REFSEL1_bp = 1             ; DAC2/AC2 reference select bit 1 position\n.equ VREF_DAC2REFSEL2_bm = (1<<2)        ; DAC2/AC2 reference select bit 2 mask\n.equ VREF_DAC2REFSEL2_bp = 2             ; DAC2/AC2 reference select bit 2 position\n\n; ADC0 reference select select\n.equ VREF_ADC0REFSEL_0V55_gc = (0x00<<4) ; Voltage reference at 0.55V\n.equ VREF_ADC0REFSEL_1V1_gc = (0x01<<4)  ; Voltage reference at 1.1V\n.equ VREF_ADC0REFSEL_2V5_gc = (0x02<<4)  ; Voltage reference at 2.5V\n.equ VREF_ADC0REFSEL_4V34_gc = (0x03<<4) ; Voltage reference at 4.34V\n.equ VREF_ADC0REFSEL_1V5_gc = (0x04<<4)  ; Voltage reference at 1.5V\n\n; DAC0/AC0 reference select select\n.equ VREF_DAC0REFSEL_0V55_gc = (0x00<<0) ; Voltage reference at 0.55V\n.equ VREF_DAC0REFSEL_1V1_gc = (0x01<<0)  ; Voltage reference at 1.1V\n.equ VREF_DAC0REFSEL_2V5_gc = (0x02<<0)  ; Voltage reference at 2.5V\n.equ VREF_DAC0REFSEL_4V34_gc = (0x03<<0) ; Voltage reference at 4.34V\n.equ VREF_DAC0REFSEL_1V5_gc = (0x04<<0)  ; Voltage reference at 1.5V\n\n; ADC1 reference select select\n.equ VREF_ADC1REFSEL_0V55_gc = (0x00<<4) ; Voltage reference at 0.55V\n.equ VREF_ADC1REFSEL_1V1_gc = (0x01<<4)  ; Voltage reference at 1.1V\n.equ VREF_ADC1REFSEL_2V5_gc = (0x02<<4)  ; Voltage reference at 2.5V\n.equ VREF_ADC1REFSEL_4V34_gc = (0x03<<4) ; Voltage reference at 4.34V\n.equ VREF_ADC1REFSEL_1V5_gc = (0x04<<4)  ; Voltage reference at 1.5V\n\n; DAC1/AC1 reference select select\n.equ VREF_DAC1REFSEL_0V55_gc = (0x00<<0) ; Voltage reference at 0.55V\n.equ VREF_DAC1REFSEL_1V1_gc = (0x01<<0)  ; Voltage reference at 1.1V\n.equ VREF_DAC1REFSEL_2V5_gc = (0x02<<0)  ; Voltage reference at 2.5V\n.equ VREF_DAC1REFSEL_4V34_gc = (0x03<<0) ; Voltage reference at 4.34V\n.equ VREF_DAC1REFSEL_1V5_gc = (0x04<<0)  ; Voltage reference at 1.5V\n\n; DAC2/AC2 reference select select\n.equ VREF_DAC2REFSEL_0V55_gc = (0x00<<0) ; Voltage reference at 0.55V\n.equ VREF_DAC2REFSEL_1V1_gc = (0x01<<0)  ; Voltage reference at 1.1V\n.equ VREF_DAC2REFSEL_2V5_gc = (0x02<<0)  ; Voltage reference at 2.5V\n.equ VREF_DAC2REFSEL_4V34_gc = (0x03<<0) ; Voltage reference at 4.34V\n.equ VREF_DAC2REFSEL_1V5_gc = (0x04<<0)  ; Voltage reference at 1.5V\n\n\n;*************************************************************************\n;** WDT - Watch-Dog Timer\n;*************************************************************************\n\n; WDT_CTRLA masks\n.equ WDT_PERIOD_gm = 0x0F                ; Period group mask\n.equ WDT_PERIOD_gp = 0                   ; Period group position\n.equ WDT_PERIOD0_bm = (1<<0)             ; Period bit 0 mask\n.equ WDT_PERIOD0_bp = 0                  ; Period bit 0 position\n.equ WDT_PERIOD1_bm = (1<<1)             ; Period bit 1 mask\n.equ WDT_PERIOD1_bp = 1                  ; Period bit 1 position\n.equ WDT_PERIOD2_bm = (1<<2)             ; Period bit 2 mask\n.equ WDT_PERIOD2_bp = 2                  ; Period bit 2 position\n.equ WDT_PERIOD3_bm = (1<<3)             ; Period bit 3 mask\n.equ WDT_PERIOD3_bp = 3                  ; Period bit 3 position\n.equ WDT_WINDOW_gm = 0xF0                ; Window group mask\n.equ WDT_WINDOW_gp = 4                   ; Window group position\n.equ WDT_WINDOW0_bm = (1<<4)             ; Window bit 0 mask\n.equ WDT_WINDOW0_bp = 4                  ; Window bit 0 position\n.equ WDT_WINDOW1_bm = (1<<5)             ; Window bit 1 mask\n.equ WDT_WINDOW1_bp = 5                  ; Window bit 1 position\n.equ WDT_WINDOW2_bm = (1<<6)             ; Window bit 2 mask\n.equ WDT_WINDOW2_bp = 6                  ; Window bit 2 position\n.equ WDT_WINDOW3_bm = (1<<7)             ; Window bit 3 mask\n.equ WDT_WINDOW3_bp = 7                  ; Window bit 3 position\n\n; WDT_STATUS masks\n.equ WDT_LOCK_bm = 0x80                  ; Lock enable bit mask\n.equ WDT_LOCK_bp = 7                     ; Lock enable bit position\n.equ WDT_SYNCBUSY_bm = 0x01              ; Syncronization busy bit mask\n.equ WDT_SYNCBUSY_bp = 0                 ; Syncronization busy bit position\n\n; Period select\n.equ WDT_PERIOD_OFF_gc = (0x00<<0)       ; Off\n.equ WDT_PERIOD_8CLK_gc = (0x01<<0)      ; 8 cycles (8ms)\n.equ WDT_PERIOD_16CLK_gc = (0x02<<0)     ; 16 cycles (16ms)\n.equ WDT_PERIOD_32CLK_gc = (0x03<<0)     ; 32 cycles (32ms)\n.equ WDT_PERIOD_64CLK_gc = (0x04<<0)     ; 64 cycles (64ms)\n.equ WDT_PERIOD_128CLK_gc = (0x05<<0)    ; 128 cycles (0.128s)\n.equ WDT_PERIOD_256CLK_gc = (0x06<<0)    ; 256 cycles (0.256s)\n.equ WDT_PERIOD_512CLK_gc = (0x07<<0)    ; 512 cycles (0.512s)\n.equ WDT_PERIOD_1KCLK_gc = (0x08<<0)     ; 1K cycles (1.0s)\n.equ WDT_PERIOD_2KCLK_gc = (0x09<<0)     ; 2K cycles (2.0s)\n.equ WDT_PERIOD_4KCLK_gc = (0x0A<<0)     ; 4K cycles (4.1s)\n.equ WDT_PERIOD_8KCLK_gc = (0x0B<<0)     ; 8K cycles (8.2s)\n\n; Window select\n.equ WDT_WINDOW_OFF_gc = (0x00<<4)       ; Off\n.equ WDT_WINDOW_8CLK_gc = (0x01<<4)      ; 8 cycles (8ms)\n.equ WDT_WINDOW_16CLK_gc = (0x02<<4)     ; 16 cycles (16ms)\n.equ WDT_WINDOW_32CLK_gc = (0x03<<4)     ; 32 cycles (32ms)\n.equ WDT_WINDOW_64CLK_gc = (0x04<<4)     ; 64 cycles (64ms)\n.equ WDT_WINDOW_128CLK_gc = (0x05<<4)    ; 128 cycles (0.128s)\n.equ WDT_WINDOW_256CLK_gc = (0x06<<4)    ; 256 cycles (0.256s)\n.equ WDT_WINDOW_512CLK_gc = (0x07<<4)    ; 512 cycles (0.512s)\n.equ WDT_WINDOW_1KCLK_gc = (0x08<<4)     ; 1K cycles (1.0s)\n.equ WDT_WINDOW_2KCLK_gc = (0x09<<4)     ; 2K cycles (2.0s)\n.equ WDT_WINDOW_4KCLK_gc = (0x0A<<4)     ; 4K cycles (4.1s)\n.equ WDT_WINDOW_8KCLK_gc = (0x0B<<4)     ; 8K cycles (8.2s)\n\n\n\n\n; ***** CPU REGISTER DEFINITIONS *****************************************\n.def\tXH\t= r27\n.def\tXL\t= r26\n.def\tYH\t= r29\n.def\tYL\t= r28\n.def\tZH\t= r31\n.def\tZL\t= r30\n\n\n; ***** DATA MEMORY DECLARATIONS *****************************************\n\n\n#define DATAMEM_START 0x0000\n#define DATAMEM_SIZE 0xC000\n#define DATAMEM_END (0x0000 + 0xC000 - 1)\n\n#define EEPROM_START 0x1400\n#define EEPROM_SIZE 0x0100\n#define EEPROM_END (0x1400 + 0x0100 - 1)\n#define EEPROM_PAGE_SIZE 0x20\n\n#define FUSES_START 0x1280\n#define FUSES_SIZE 0x000A\n#define FUSES_END (0x1280 + 0x000A - 1)\n#define FUSES_PAGE_SIZE 0x20\n\n#define INTERNAL_SRAM_START 0x3800\n#define INTERNAL_SRAM_SIZE 0x0800\n#define INTERNAL_SRAM_END (0x3800 + 0x0800 - 1)\n\n#define IO_START 0x0000\n#define IO_SIZE 0x1100\n#define IO_END (0x0000 + 0x1100 - 1)\n\n#define LOCKBITS_START 0x128A\n#define LOCKBITS_SIZE 0x0001\n#define LOCKBITS_END (0x128A + 0x0001 - 1)\n#define LOCKBITS_PAGE_SIZE 0x20\n\n#define MAPPED_PROGMEM_START 0x8000\n#define MAPPED_PROGMEM_SIZE 0x4000\n#define MAPPED_PROGMEM_END (0x8000 + 0x4000 - 1)\n#define MAPPED_PROGMEM_PAGE_SIZE 0x40\n\n#define PROD_SIGNATURES_START 0x1103\n#define PROD_SIGNATURES_SIZE 0x003D\n#define PROD_SIGNATURES_END (0x1103 + 0x003D - 1)\n#define PROD_SIGNATURES_PAGE_SIZE 0x40\n\n#define SIGNATURES_START 0x1100\n#define SIGNATURES_SIZE 0x0003\n#define SIGNATURES_END (0x1100 + 0x0003 - 1)\n#define SIGNATURES_PAGE_SIZE 0x40\n\n#define USER_SIGNATURES_START 0x1300\n#define USER_SIGNATURES_SIZE 0x0020\n#define USER_SIGNATURES_END (0x1300 + 0x0020 - 1)\n#define USER_SIGNATURES_PAGE_SIZE 0x20\n\n#define PROGMEM_START 0x0000\n#define PROGMEM_SIZE 0x4000\n#define PROGMEM_END (0x0000 + 0x4000 - 1)\n#define PROGMEM_PAGE_SIZE 0x40\n\n\n; Legacy definitions\n.equ    FLASHSTART    = (PROGMEM_START / 2) ; Note: Word address\n.equ    FLASHEND      = (PROGMEM_END / 2) ; Note: Word address\n.equ    IOEND         = IO_END\n.equ    SRAM_START    = INTERNAL_SRAM_START\n.equ    SRAM_SIZE     = INTERNAL_SRAM_SIZE\n.equ    RAMEND        = INTERNAL_SRAM_END\n.equ    E2END         = EEPROM_END\n.equ    EEPROMEND     = EEPROM_END\n\n\n; Definitions used by the assembler\n#pragma AVRPART MEMORY PROG_FLASH 0x4000\n#pragma AVRPART MEMORY EEPROM 0x0100\n#pragma AVRPART MEMORY INT_SRAM SIZE 0x0800\n#pragma AVRPART MEMORY INT_SRAM START_ADDR 0x3800\n\n; ***** INTERRUPT VECTORS, ABSOLUTE ADDRESSES ****************************\n\n; CRCSCAN interrupt vectors\n.equ CRCSCAN_NMI_vect = 0x0002           ; \n\n; BOD interrupt vectors\n.equ BOD_VLM_vect = 0x0004               ; \n\n; PORTA interrupt vectors\n.equ PORTA_PORT_vect = 0x0006            ; \n\n; PORTB interrupt vectors\n.equ PORTB_PORT_vect = 0x0008            ; \n\n; RTC interrupt vectors\n.equ RTC_CNT_vect = 0x000C               ; \n.equ RTC_PIT_vect = 0x000E               ; \n\n; TCA0 interrupt vectors\n.equ TCA0_LUNF_vect = 0x0010             ; \n.equ TCA0_OVF_vect = 0x0010              ; \n.equ TCA0_HUNF_vect = 0x0012             ; \n.equ TCA0_CMP0_vect = 0x0014             ; \n.equ TCA0_LCMP0_vect = 0x0014            ; \n.equ TCA0_CMP1_vect = 0x0016             ; \n.equ TCA0_LCMP1_vect = 0x0016            ; \n.equ TCA0_CMP2_vect = 0x0018             ; \n.equ TCA0_LCMP2_vect = 0x0018            ; \n\n; TCB0 interrupt vectors\n.equ TCB0_INT_vect = 0x001A              ; \n\n; TCB1 interrupt vectors\n.equ TCB1_INT_vect = 0x001C              ; \n\n; TCD0 interrupt vectors\n.equ TCD0_OVF_vect = 0x001E              ; \n.equ TCD0_TRIG_vect = 0x0020             ; \n\n; AC0 interrupt vectors\n.equ AC0_AC_vect = 0x0022                ; \n\n; AC1 interrupt vectors\n.equ AC1_AC_vect = 0x0024                ; \n\n; AC2 interrupt vectors\n.equ AC2_AC_vect = 0x0026                ; \n\n; ADC0 interrupt vectors\n.equ ADC0_RESRDY_vect = 0x0028           ; \n.equ ADC0_WCOMP_vect = 0x002A            ; \n\n; ADC1 interrupt vectors\n.equ ADC1_RESRDY_vect = 0x002C           ; \n.equ ADC1_WCOMP_vect = 0x002E            ; \n\n; TWI0 interrupt vectors\n.equ TWI0_TWIS_vect = 0x0030             ; \n.equ TWI0_TWIM_vect = 0x0032             ; \n\n; SPI0 interrupt vectors\n.equ SPI0_INT_vect = 0x0034              ; \n\n; USART0 interrupt vectors\n.equ USART0_RXC_vect = 0x0036            ; \n.equ USART0_DRE_vect = 0x0038            ; \n.equ USART0_TXC_vect = 0x003A            ; \n\n; NVMCTRL interrupt vectors\n.equ NVMCTRL_EE_vect = 0x003C            ; \n\n\n\n; ***** INTERRUPT VECTORS, MODULE BASES **********************************\n\n.equ CRCSCAN_vbase = 0x0002\n.equ BOD_vbase = 0x0004\n.equ PORTA_vbase = 0x0006\n.equ PORTB_vbase = 0x0008\n.equ RTC_vbase = 0x000C\n.equ TCA0_vbase = 0x0010\n.equ TCB0_vbase = 0x001A\n.equ TCB1_vbase = 0x001C\n.equ TCD0_vbase = 0x001E\n.equ AC0_vbase = 0x0022\n.equ AC1_vbase = 0x0024\n.equ AC2_vbase = 0x0026\n.equ ADC0_vbase = 0x0028\n.equ ADC1_vbase = 0x002C\n.equ TWI0_vbase = 0x0030\n.equ SPI0_vbase = 0x0034\n.equ USART0_vbase = 0x0036\n.equ NVMCTRL_vbase = 0x003C\n\n\n; ***** INTERRUPT VECTORS, VECTOR OFFSETS ********************************\n\n; CRCSCAN interrupt vector offsets\n\n.equ CRCSCAN_NMI_voffset = 0\n\n; BOD interrupt vector offsets\n\n.equ BOD_VLM_voffset = 0\n\n; PORTA interrupt vector offsets\n\n.equ PORTA_PORT_voffset = 0\n\n; PORTB interrupt vector offsets\n\n.equ PORTB_PORT_voffset = 0\n\n; RTC interrupt vector offsets\n\n.equ RTC_CNT_voffset = 0\n.equ RTC_PIT_voffset = 2\n\n; TCA0 interrupt vector offsets\n\n.equ TCA0_LUNF_voffset = 0\n.equ TCA0_OVF_voffset = 0\n.equ TCA0_HUNF_voffset = 2\n.equ TCA0_CMP0_voffset = 4\n.equ TCA0_LCMP0_voffset = 4\n.equ TCA0_CMP1_voffset = 6\n.equ TCA0_LCMP1_voffset = 6\n.equ TCA0_CMP2_voffset = 8\n.equ TCA0_LCMP2_voffset = 8\n\n; TCB0 interrupt vector offsets\n\n.equ TCB0_INT_voffset = 0\n\n; TCB1 interrupt vector offsets\n\n.equ TCB1_INT_voffset = 0\n\n; TCD0 interrupt vector offsets\n\n.equ TCD0_OVF_voffset = 0\n.equ TCD0_TRIG_voffset = 2\n\n; AC0 interrupt vector offsets\n\n.equ AC0_AC_voffset = 0\n\n; AC1 interrupt vector offsets\n\n.equ AC1_AC_voffset = 0\n\n; AC2 interrupt vector offsets\n\n.equ AC2_AC_voffset = 0\n\n; ADC0 interrupt vector offsets\n\n.equ ADC0_RESRDY_voffset = 0\n.equ ADC0_WCOMP_voffset = 2\n\n; ADC1 interrupt vector offsets\n\n.equ ADC1_RESRDY_voffset = 0\n.equ ADC1_WCOMP_voffset = 2\n\n; TWI0 interrupt vector offsets\n\n.equ TWI0_TWIS_voffset = 0\n.equ TWI0_TWIM_voffset = 2\n\n; SPI0 interrupt vector offsets\n\n.equ SPI0_INT_voffset = 0\n\n; USART0 interrupt vector offsets\n\n.equ USART0_RXC_voffset = 0\n.equ USART0_DRE_voffset = 2\n.equ USART0_TXC_voffset = 4\n\n; NVMCTRL interrupt vector offsets\n\n.equ NVMCTRL_EE_voffset = 0\n\n\n\n.equ INT_VECTORS_SIZE = 62 ; size in words\n\n\n#endif /* _TN1614DEF_INC_ */\n\n; ***** END OF FILE ******************************************************\n\n\n\n"}
